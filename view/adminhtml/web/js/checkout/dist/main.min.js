(() => {
  function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const onRE = /^on[^a-z]/;
  const isOn = (key) => onRE.test(key);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend$1 = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
  const isArray$2 = Array.isArray;
  const isMap = (val) => toTypeString$1(val) === "[object Map]";
  const isSet = (val) => toTypeString$1(val) === "[object Set]";
  const isDate$2 = (val) => toTypeString$1(val) === "[object Date]";
  const isFunction$2 = (val) => typeof val === "function";
  const isString$3 = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject$4 = (val) => val !== null && typeof val === "object";
  const isPromise$1 = (val) => {
    return isObject$4(val) && isFunction$2(val.then) && isFunction$2(val.catch);
  };
  const objectToString$2 = Object.prototype.toString;
  const toTypeString$1 = (value) => objectToString$2.call(value);
  const toRawType = (value) => {
    return toTypeString$1(value).slice(8, -1);
  };
  const isPlainObject$3 = (val) => toTypeString$1(val) === "[object Object]";
  const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
  const cacheStringFunction = (fn) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache2[str];
      return hit || (cache2[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  const capitalize$1 = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize$1(str)}` : ``);
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](arg);
    }
  };
  const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  const toNumber$1 = (val) => {
    const n = isString$3(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  let _globalThis$1;
  const getGlobalThis$1 = () => {
    return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray$2(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString$3(value)) {
      return value;
    } else if (isObject$4(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$3(value)) {
      res = value;
    } else if (isArray$2(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$4(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  function looseCompareArrays(a, b) {
    if (a.length !== b.length)
      return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
      equal = looseEqual(a[i], b[i]);
    }
    return equal;
  }
  function looseEqual(a, b) {
    if (a === b)
      return true;
    let aValidType = isDate$2(a);
    let bValidType = isDate$2(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isSymbol$1(a);
    bValidType = isSymbol$1(b);
    if (aValidType || bValidType) {
      return a === b;
    }
    aValidType = isArray$2(a);
    bValidType = isArray$2(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject$4(a);
    bValidType = isObject$4(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a).length;
      const bKeysCount = Object.keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a) {
        const aHasKey = a.hasOwnProperty(key);
        const bHasKey = b.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
          return false;
        }
      }
    }
    return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  const toDisplayString$1 = (val) => {
    return isString$3(val) ? val : val == null ? "" : isArray$2(val) || isObject$4(val) && (val.toString === objectToString$2 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (val && val.__v_isRef) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
          entries[`${key} =>`] = val2;
          return entries;
        }, {})
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()]
      };
    } else if (isObject$4(val) && !isArray$2(val) && !isPlainObject$3(val)) {
      return String(val);
    }
    return val;
  };
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
      }
    }
    get active() {
      return this._active;
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    on() {
      activeEffectScope = this;
    }
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
      scope.effects.push(effect);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  const createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
  };
  const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
  const newTracked = (dep) => (dep.n & trackOpBit) > 0;
  const initDepMarkers = ({ deps }) => {
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].w |= trackOpBit;
      }
    }
  };
  const finalizeDepMarkers = (effect) => {
    const { deps } = effect;
    if (deps.length) {
      let ptr = 0;
      for (let i = 0; i < deps.length; i++) {
        const dep = deps[i];
        if (wasTracked(dep) && !newTracked(dep)) {
          dep.delete(effect);
        } else {
          deps[ptr++] = dep;
        }
        dep.w &= ~trackOpBit;
        dep.n &= ~trackOpBit;
      }
      deps.length = ptr;
    }
  };
  const targetMap = /* @__PURE__ */ new WeakMap();
  let effectTrackDepth = 0;
  let trackOpBit = 1;
  const maxMarkerBits = 30;
  let activeEffect;
  const ITERATE_KEY = Symbol("");
  const MAP_KEY_ITERATE_KEY = Symbol("");
  class ReactiveEffect {
    constructor(fn, scheduler = null, scope) {
      this.fn = fn;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      this.parent = void 0;
      recordEffectScope(this, scope);
    }
    run() {
      if (!this.active) {
        return this.fn();
      }
      let parent = activeEffect;
      let lastShouldTrack = shouldTrack;
      while (parent) {
        if (parent === this) {
          return;
        }
        parent = parent.parent;
      }
      try {
        this.parent = activeEffect;
        activeEffect = this;
        shouldTrack = true;
        trackOpBit = 1 << ++effectTrackDepth;
        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this);
        } else {
          cleanupEffect(this);
        }
        return this.fn();
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this);
        }
        trackOpBit = 1 << --effectTrackDepth;
        activeEffect = this.parent;
        shouldTrack = lastShouldTrack;
        this.parent = void 0;
        if (this.deferStop) {
          this.stop();
        }
      }
    }
    stop() {
      if (activeEffect === this) {
        this.deferStop = true;
      } else if (this.active) {
        cleanupEffect(this);
        if (this.onStop) {
          this.onStop();
        }
        this.active = false;
      }
    }
  }
  function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect2);
      }
      deps.length = 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (shouldTrack && activeEffect) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = createDep());
      }
      trackEffects(dep);
    }
  }
  function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
      if (!newTracked(dep)) {
        dep.n |= trackOpBit;
        shouldTrack2 = !wasTracked(dep);
      }
    } else {
      shouldTrack2 = !dep.has(activeEffect);
    }
    if (shouldTrack2) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray$2(target)) {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newLength) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    if (deps.length === 1) {
      if (deps[0]) {
        {
          triggerEffects(deps[0]);
        }
      }
    } else {
      const effects = [];
      for (const dep of deps) {
        if (dep) {
          effects.push(...dep);
        }
      }
      {
        triggerEffects(createDep(effects));
      }
    }
  }
  function triggerEffects(dep, debuggerEventExtraInfo) {
    const effects = isArray$2(dep) ? dep : [...dep];
    for (const effect2 of effects) {
      if (effect2.computed) {
        triggerEffect(effect2);
      }
    }
    for (const effect2 of effects) {
      if (!effect2.computed) {
        triggerEffect(effect2);
      }
    }
  }
  function triggerEffect(effect2, debuggerEventExtraInfo) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
      if (effect2.scheduler) {
        effect2.scheduler();
      } else {
        effect2.run();
      }
    }
  }
  function getDepFromReactive(object, key) {
    var _a;
    return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1));
  const get$1 = /* @__PURE__ */ createGetter();
  const shallowGet = /* @__PURE__ */ createGetter(false, true);
  const readonlyGet = /* @__PURE__ */ createGetter(true);
  const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function hasOwnProperty$1(key) {
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  function createGetter(isReadonly2 = false, shallow = false) {
    return function get2(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return shallow;
      } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray$2(target);
      if (!isReadonly2) {
        if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty$1;
        }
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$4(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    };
  }
  const set$1 = /* @__PURE__ */ createSetter();
  const shallowSet = /* @__PURE__ */ createSetter(true);
  function createSetter(shallow = false) {
    return function set2(target, key, value, receiver) {
      let oldValue = target[key];
      if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
        return false;
      }
      if (!shallow) {
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  function has$1(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  const mutableHandlers = {
    get: get$1,
    set: set$1,
    deleteProperty,
    has: has$1,
    ownKeys
  };
  const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      return true;
    },
    deleteProperty(target, key) {
      return true;
    }
  };
  const shallowReactiveHandlers = /* @__PURE__ */ extend$1({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
  });
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function get(target, key, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (key !== rawKey) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (key !== rawKey) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach3(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get(this, key);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  const [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn$1(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$4(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    def(value, "__v_skip", true);
    return value;
  }
  const toReactive = (value) => isObject$4(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
  function trackRefValue(ref2) {
    if (shouldTrack && activeEffect) {
      ref2 = toRaw(ref2);
      {
        trackEffects(ref2.dep || (ref2.dep = createDep()));
      }
    }
  }
  function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) {
      {
        triggerEffects(dep);
      }
    }
  }
  function isRef(r) {
    return !!(r && r.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, __v_isShallow) {
      this.__v_isShallow = __v_isShallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = __v_isShallow ? value : toRaw(value);
      this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
      newVal = useDirectValue ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = useDirectValue ? newVal : toReactive(newVal);
        triggerRefValue(this);
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    const ret = isArray$2(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this.__v_isRef = true;
    }
    get value() {
      const val = this._object[this._key];
      return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  function propertyToRef(source2, key, defaultValue) {
    const val = source2[key];
    return isRef(val) ? val : new ObjectRefImpl(source2, key, defaultValue);
  }
  class ComputedRefImpl {
    constructor(getter, _setter, isReadonly2, isSSR) {
      this._setter = _setter;
      this.dep = void 0;
      this.__v_isRef = true;
      this["__v_isReadonly"] = false;
      this._dirty = true;
      this.effect = new ReactiveEffect(getter, () => {
        if (!this._dirty) {
          this._dirty = true;
          triggerRefValue(this);
        }
      });
      this.effect.computed = this;
      this.effect.active = this._cacheable = !isSSR;
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw(this);
      trackRefValue(self2);
      if (self2._dirty || !self2._cacheable) {
        self2._dirty = false;
        self2._value = self2.effect.run();
      }
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction$2(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    return cRef;
  }
  function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
      res = args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
    return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction$2(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise$1(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = type;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
    {
      console.error(err);
    }
  }
  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJobId = getId(queue[middle]);
      middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
  }
  function queueJob(job) {
    if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
      queue.splice(i, 1);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$2(cb)) {
      if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
        pendingPostFlushCbs.push(cb);
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.pre) {
        queue.splice(i, 1);
        i--;
        cb();
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)];
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? Infinity : job.id;
  const comparator = (a, b) => {
    const diff = getId(a) - getId(b);
    if (diff === 0) {
      if (a.pre && !b.pre)
        return -1;
      if (b.pre && !a.pre)
        return 1;
    }
    return diff;
  };
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    queue.sort(comparator);
    const check = NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (false)
            ;
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs();
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
      return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modelArg = isModelListener2 && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
      if (trim2) {
        args = rawArgs.map((a) => isString$3(a) ? a.trim() : a);
      }
      if (number2) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(handler, instance, 6, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.emitsCache;
    const cached = cache2.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$2(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend$1(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$4(comp)) {
        cache2.set(comp, null);
      }
      return null;
    }
    if (isArray$2(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend$1(normalized, raw);
    }
    if (isObject$4(comp)) {
      cache2.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      props,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render,
      renderCache,
      data: data2,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data2, ctx));
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component;
        if (false)
          ;
        result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
          get attrs() {
            markAttrsAccessed();
            return attrs;
          },
          slots,
          emit: emit2
        } : { attrs, slots, emit: emit2 }) : render2(props, null));
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root2 = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root2;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
          }
          root2 = cloneVNode(root2, fallthroughAttrs);
        }
      }
    }
    if (vnode.dirs) {
      root2 = cloneVNode(root2);
      root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      root2.transition = vnode.transition;
    }
    {
      result = root2;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent && parent.subTree === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    }
  }
  const isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$2(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const INITIAL_WATCHER_VALUE = {};
  function watch(source2, cb, options) {
    return doWatch(source2, cb, options);
  }
  function doWatch(source2, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
    var _a;
    const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source2)) {
      getter = () => source2.value;
      forceTrigger = isShallow(source2);
    } else if (isReactive(source2)) {
      getter = () => source2;
      deep = true;
    } else if (isArray$2(source2)) {
      isMultiSource = true;
      forceTrigger = source2.some((s) => isReactive(s) || isShallow(s));
      getter = () => source2.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return traverse(s);
        } else if (isFunction$2(s)) {
          return callWithErrorHandling(s, instance, 2);
        } else
          ;
      });
    } else if (isFunction$2(source2)) {
      if (cb) {
        getter = () => callWithErrorHandling(source2, instance, 2);
      } else {
        getter = () => {
          if (instance && instance.isUnmounted) {
            return;
          }
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(source2, instance, 3, [onCleanup]);
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
      cleanup = effect.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
      };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else {
        return NOOP;
      }
    }
    let oldValue = isMultiSource ? new Array(source2.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect.active) {
        return;
      }
      if (cb) {
        const newValue = effect.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      job.pre = true;
      if (instance)
        job.id = instance.uid;
      scheduler = () => queueJob(job);
    }
    const effect = new ReactiveEffect(getter, scheduler);
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    } else {
      effect.run();
    }
    const unwatch = () => {
      effect.stop();
      if (instance && instance.scope) {
        remove(instance.scope.effects, effect);
      }
    };
    if (ssrCleanup)
      ssrCleanup.push(unwatch);
    return unwatch;
  }
  function instanceWatch(source2, value, options) {
    const publicThis = this.proxy;
    const getter = isString$3(source2) ? source2.includes(".") ? createPathGetter(publicThis, source2) : () => publicThis[source2] : source2.bind(publicThis, publicThis);
    let cb;
    if (isFunction$2(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
      setCurrentInstance(cur);
    } else {
      unsetCurrentInstance();
    }
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse(value, seen) {
    if (!isObject$4(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    if (isRef(value)) {
      traverse(value.value, seen);
    } else if (isArray$2(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, seen);
      });
    } else if (isPlainObject$3(value)) {
      for (const key in value) {
        traverse(value[key], seen);
      }
    }
    return value;
  }
  function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
      return vnode;
    }
    const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction$2(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevTransitionKey;
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        let child = children[0];
        if (children.length > 1) {
          for (const c of children) {
            if (c.type !== Comment) {
              child = c;
              break;
            }
          }
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        let transitionKeyChanged = false;
        const { getTransitionKey } = innerChild.type;
        if (getTransitionKey) {
          const key = getTransitionKey();
          if (prevTransitionKey === void 0) {
            prevTransitionKey = key;
          } else if (key !== prevTransitionKey) {
            prevTransitionKey = key;
            transitionKeyChanged = true;
          }
        }
        if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
          const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in") {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (instance.update.active !== false) {
                instance.update();
              }
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el._leaveCb = () => {
                earlyRemove();
                el._leaveCb = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$2(hook)) {
        if (hook.every((hook2) => hook2.length <= 1))
          done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el._leaveCb) {
          el._leaveCb(true);
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
          leavingVNode.el._leaveCb();
        }
        callHook2(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el._enterCb = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el._enterCb = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key2 = String(vnode.key);
        if (el._enterCb) {
          el._enterCb(true);
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        let called = false;
        const done = el._leaveCb = (cancelled) => {
          if (called)
            return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el._leaveCb = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  function defineComponent(options, extraOptions) {
    return isFunction$2(options) ? /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))() : options;
  }
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        unsetCurrentInstance();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook("bu");
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook("bum");
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook("sp");
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString$3(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(Component, false);
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
          return Component;
        }
      }
      const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
      if (!res && maybeSelfReference) {
        return Component;
      }
      return res;
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
  }
  function renderList(source2, renderItem, cache2, index) {
    let ret;
    const cached = cache2 && cache2[index];
    if (isArray$2(source2) || isString$3(source2)) {
      ret = new Array(source2.length);
      for (let i = 0, l = source2.length; i < l; i++) {
        ret[i] = renderItem(source2[i], i, void 0, cached && cached[i]);
      }
    } else if (typeof source2 === "number") {
      ret = new Array(source2);
      for (let i = 0; i < source2; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
      }
    } else if (isObject$4(source2)) {
      if (source2[Symbol.iterator]) {
        ret = Array.from(source2, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
      } else {
        const keys = Object.keys(source2);
        ret = new Array(keys.length);
        for (let i = 0, l = keys.length; i < l; i++) {
          const key = keys[i];
          ret[i] = renderItem(source2[key], key, i, cached && cached[i]);
        }
      }
    } else {
      ret = [];
    }
    if (cache2) {
      cache2[index] = ret;
    }
    return ret;
  }
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
      if (name !== "default")
        props.name = name;
      return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
      key: props.key || validSlotContent && validSlotContent.key || `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode$1(child))
        return true;
      if (child.type === Comment)
        return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  const getPublicInstance = (i) => {
    if (!i)
      return null;
    if (isStatefulComponent(i))
      return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  });
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data2[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
          accessCache[key] = 2;
          return data2[key];
        } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)) {
        {
          return globalProperties[key];
        }
      } else
        ;
    },
    set({ _: instance }, key, value) {
      const { data: data2, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
        data2[key] = value;
        return true;
      } else if (hasOwn$1(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data2 !== EMPTY_OBJ && hasOwn$1(data2, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn$1(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  function normalizePropsOrEmits(props) {
    return isArray$2(props) ? props.reduce((normalized, p2) => (normalized[p2] = null, normalized), {}) : props;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    const {
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      expose,
      inheritAttrs,
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$2(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data2 = dataOptions.call(publicThis, publicThis);
      if (!isObject$4(data2))
        ;
      else {
        instance.data = reactive(data2);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c = computed({
          get: get2,
          set: set2
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$2(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$2(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$2(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject$4(opt)) {
        if ("default" in opt) {
          injected = inject(opt.from || key, opt.default, true);
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
  }
  function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString$3(raw)) {
      const handler = ctx[raw];
      if (isFunction$2(handler)) {
        watch(getter, handler);
      }
    } else if (isFunction$2(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject$4(raw)) {
      if (isArray$2(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$2(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else
      ;
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache2,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache2.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach((m) => mergeOptions$1(resolved, m, optionMergeStrategies, true));
      }
      mergeOptions$1(resolved, base, optionMergeStrategies);
    }
    if (isObject$4(base)) {
      cache2.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions$1(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions$1(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach((m) => mergeOptions$1(to, m, strats, true));
    }
    for (const key in from) {
      if (asMixin && key === "expose")
        ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend$1(isFunction$2(to) ? to.call(this, this) : to, isFunction$2(from) ? from.call(this, this) : from);
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$2(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray$2(to) && isArray$2(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend$1(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$2(rootComponent)) {
        rootComponent = extend$1({}, rootComponent);
      }
      if (rootProps != null && !isObject$4(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new Set();
      let isMounted = false;
      const app2 = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin))
            ;
          else if (plugin && isFunction$2(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app2, ...options);
          } else if (isFunction$2(plugin)) {
            installedPlugins.add(plugin);
            plugin(app2, ...options);
          } else
            ;
          return app2;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app2;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app2;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app2;
        },
        mount(rootContainer, isHydrate, isSVG) {
          if (!isMounted) {
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render(vnode, rootContainer, isSVG);
            }
            isMounted = true;
            app2._container = rootContainer;
            rootContainer.__vue_app__ = app2;
            return getExposeProxy(vnode.component) || vnode.component.proxy;
          }
        },
        unmount() {
          if (isMounted) {
            render(null, app2._container);
            delete app2._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app2;
        },
        runWithContext(fn) {
          currentApp = app2;
          try {
            return fn();
          } finally {
            currentApp = null;
          }
        }
      };
      return app2;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance)
      ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else
        ;
    }
  }
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn$1(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || !hasOwn$1(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn$1(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance, "set", "$attrs");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn$1(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn$1(castValues, key));
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn$1(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(null, props);
            unsetCurrentInstance();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.propsCache;
    const cached = cache2.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$2(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend$1(normalized, props);
        if (keys)
          needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$4(comp)) {
        cache2.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$2(raw)) {
      for (let i = 0; i < raw.length; i++) {
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$1({}, opt);
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[0] = booleanIndex > -1;
            prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$4(comp)) {
      cache2.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$") {
      return true;
    }
    return false;
  }
  function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
    return match ? match[2] : ctor === null ? "null" : "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
    if (isArray$2(expectedTypes)) {
      return expectedTypes.findIndex((t) => isSameType(t, type));
    } else if (isFunction$2(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot$1 = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false)
        ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key))
        continue;
      const value = rawSlots[key];
      if (isFunction$2(value)) {
        slots[key] = normalizeSlot$1(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        instance.slots = toRaw(children);
        def(children, "_", type);
      } else {
        normalizeObjectSlots(children, instance.slots = {});
      }
    } else {
      instance.slots = {};
      if (children) {
        normalizeVNodeSlots(instance, children);
      }
    }
    def(instance.slots, InternalObjectKey, 1);
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          extend$1(slots, children);
          if (!optimized && type === 1) {
            delete slots._;
          }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
          delete slots[key];
        }
      }
    }
  };
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$2(rawRef)) {
      rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref2 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref2) {
      if (isString$3(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn$1(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$2(ref2)) {
      callWithErrorHandling(ref2, owner, 12, [value, refs]);
    } else {
      const _isString = isString$3(ref2);
      const _isRef = isRef(ref2);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? hasOwn$1(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
            if (isUnmount) {
              isArray$2(existing) && remove(existing, refValue);
            } else {
              if (!isArray$2(existing)) {
                if (_isString) {
                  refs[ref2] = [refValue];
                  if (hasOwn$1(setupState, ref2)) {
                    setupState[ref2] = refs[ref2];
                  }
                } else {
                  ref2.value = [refValue];
                  if (rawRef.k)
                    refs[rawRef.k] = ref2.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref2] = value;
            if (hasOwn$1(setupState, ref2)) {
              setupState[ref2] = value;
            }
          } else if (_isRef) {
            ref2.value = value;
            if (rawRef.k)
              refs[rawRef.k] = value;
          } else
            ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis$1();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref2, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, isSVG);
          }
          break;
        case Fragment:
          processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          break;
        default:
          if (shapeFlag & 1) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else
            ;
      }
      if (ref2 != null && parentComponent) {
        setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      isSVG = isSVG || n2.type === "svg";
      if (n1 == null) {
        mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { type, props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      const areChildrenSVG = isSVG && n2.type !== "foreignObject";
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      } else if (!optimized) {
        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, isSVG);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
          if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
            traverseStaticChildren(n1, n2, true);
          }
        } else {
          patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
        } else {
          mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
      const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
        return;
      }
      setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              instance.subTree = renderComponentRoot(instance);
              hydrateNode(el, instance.subTree, instance, parentSuspense, null);
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
            } else {
              hydrateSubTree();
            }
          } else {
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
          }
        }
      };
      const effect = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope);
      const update = instance.update = () => effect.run();
      update.id = instance.uid;
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs();
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
      if (oldLength > newLength) {
        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
      } else {
        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref2,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs
      } = vnode;
      if (ref2 != null) {
        setRef(ref2, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, update, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update) {
        update.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(container._vnode || null, vnode, container, null, null, null, isSVG);
      }
      flushPreFlushCbs();
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
      render,
      hydrate,
      createApp: createAppAPI(render, hydrate)
    };
  }
  function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$2(ch1) && isArray$2(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  const isTeleport = (type) => type.__isTeleport;
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
  }
  function isVNode$1(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  const InternalObjectKey = `__vInternal`;
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref2,
    ref_key,
    ref_for
  }) => {
    if (typeof ref2 === "number") {
      ref2 = "" + ref2;
    }
    return ref2 != null ? isString$3(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$3(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode$1(type)) {
      const cloned = cloneVNode(type, props, true);
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag |= -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString$3(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$4(style)) {
        if (isProxy(style) && !isArray$2(style)) {
          style = extend$1({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString$3(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$4(type) ? 4 : isFunction$2(type) ? 2 : 0;
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref: ref2, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$2(child)) {
      return createVNode(Fragment, null, child.slice());
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$2(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$2(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new EffectScope(true),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let globalCurrentInstanceSetters;
  let settersKey = "__VUE_INSTANCE_SETTERS__";
  {
    if (!(globalCurrentInstanceSetters = getGlobalThis$1()[settersKey])) {
      globalCurrentInstanceSetters = getGlobalThis$1()[settersKey] = [];
    }
    globalCurrentInstanceSetters.push((i) => currentInstance = i);
    internalSetCurrentInstance = (instance) => {
      if (globalCurrentInstanceSetters.length > 1) {
        globalCurrentInstanceSetters.forEach((s) => s(instance));
      } else {
        globalCurrentInstanceSetters[0](instance);
      }
    };
  }
  const setCurrentInstance = (instance) => {
    internalSetCurrentInstance(instance);
    instance.scope.on();
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    const { setup } = Component;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
      resetTracking();
      unsetCurrentInstance();
      if (isPromise$1(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$2(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$4(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else
      ;
    finishComponentSetup(instance, isSSR);
  }
  let compile$1;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile$1 && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend$1(extend$1({
            isCustomElement,
            delimiters
          }, compilerOptions), componentCompilerOptions);
          Component.render = compile$1(template, finalCompilerOptions);
        }
      }
      instance.render = Component.render || NOOP;
    }
    {
      setCurrentInstance(instance);
      pauseTracking();
      applyOptions(instance);
      resetTracking();
      unsetCurrentInstance();
    }
  }
  function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs, {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }));
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        get attrs() {
          return getAttrsProxy(instance);
        },
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    }
  }
  function getComponentName(Component, includeInferred = true) {
    return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function isClassComponent(value) {
    return isFunction$2(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  };
  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject$4(propsOrChildren) && !isArray$2(propsOrChildren)) {
        if (isVNode$1(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode$1(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  const version = "3.3.4";
  const svgNS = "http://www.w3.org/2000/svg";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, isSVG, is, props) => {
      const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    insertStaticContent(content, parent, anchor, isSVG, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling))
            break;
        }
      } else {
        templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
        const template = templateContainer.content;
        if (isSVG) {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        before ? before.nextSibling : parent.firstChild,
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString$3(next);
    if (next && !isCssString) {
      if (prev && !isString$3(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
      for (const key in next) {
        setStyle(style, key, next[key]);
      }
    } else {
      const currentDisplay = style.display;
      if (isCssString) {
        if (prev !== next) {
          style.cssText = next;
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
      if ("_vod" in el) {
        style.display = currentDisplay;
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray$2(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null)
        val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize$1(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      const isBoolean2 = isSpecialBooleanAttr(key);
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, isBoolean2 ? "" : value);
      }
    }
  }
  function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key] = value == null ? "" : value;
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && !tag.includes("-")) {
      el._value = value;
      const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
      const newValue = value == null ? "" : value;
      if (oldValue !== newValue) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
    }
    needRemove && el.removeAttribute(key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray$2(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
    } else {
      return value;
    }
  }
  const nativeOnRE = /^on[a-z]/;
  const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && nativeOnRE.test(key) && isFunction$2(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (nativeOnRE.test(key) && isString$3(value)) {
      return false;
    }
    return key in el;
  }
  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  Transition.props = /* @__PURE__ */ extend$1({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);
  const callHook = (hook, args = []) => {
    if (isArray$2(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend$1(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$4(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber$1(val);
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el._vtc = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  const getModelAssigner = (vnode) => {
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  const vModelText = {
    created(el, { modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
      el._assign = getModelAssigner(vnode);
      const castToNumber = number2 || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", (e) => {
        if (e.target.composing)
          return;
        let domValue = el.value;
        if (trim2) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el._assign(domValue);
      });
      if (trim2) {
        addEventListener(el, "change", () => {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
      el._assign = getModelAssigner(vnode);
      if (el.composing)
        return;
      if (document.activeElement === el && el.type !== "range") {
        if (lazy) {
          return;
        }
        if (trim2 && el.value.trim() === value) {
          return;
        }
        if ((number2 || el.type === "number") && looseToNumber(el.value) === value) {
          return;
        }
      }
      const newValue = value == null ? "" : value;
      if (el.value !== newValue) {
        el.value = newValue;
      }
    }
  };
  const vModelCheckbox = {
    deep: true,
    created(el, _, vnode) {
      el._assign = getModelAssigner(vnode);
      addEventListener(el, "change", () => {
        const modelValue = el._modelValue;
        const elementValue = getValue(el);
        const checked = el.checked;
        const assign2 = el._assign;
        if (isArray$2(modelValue)) {
          const index = looseIndexOf(modelValue, elementValue);
          const found = index !== -1;
          if (checked && !found) {
            assign2(modelValue.concat(elementValue));
          } else if (!checked && found) {
            const filtered = [...modelValue];
            filtered.splice(index, 1);
            assign2(filtered);
          }
        } else if (isSet(modelValue)) {
          const cloned = new Set(modelValue);
          if (checked) {
            cloned.add(elementValue);
          } else {
            cloned.delete(elementValue);
          }
          assign2(cloned);
        } else {
          assign2(getCheckboxValue(el, checked));
        }
      });
    },
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
      el._assign = getModelAssigner(vnode);
      setChecked(el, binding, vnode);
    }
  };
  function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if (isArray$2(value)) {
      el.checked = looseIndexOf(value, vnode.props.value) > -1;
    } else if (isSet(value)) {
      el.checked = value.has(vnode.props.value);
    } else if (value !== oldValue) {
      el.checked = looseEqual(value, getCheckboxValue(el, true));
    }
  }
  function getValue(el) {
    return "_value" in el ? el._value : el.value;
  }
  function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
  }
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
  };
  const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
      for (let i = 0; i < modifiers.length; i++) {
        const guard = modifierGuards[modifiers[i]];
        if (guard && guard(event, modifiers))
          return;
      }
      return fn(event, ...args);
    };
  };
  const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  const withKeys = (fn, modifiers) => {
    return (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
        return fn(event);
      }
    };
  };
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el._vod = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue)
        return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  function setDisplay(el, value) {
    el.style.display = value ? el._vod : "none";
  }
  const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = (...args) => {
    const app2 = ensureRenderer().createApp(...args);
    const { mount } = app2;
    app2.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app2._component;
      if (!isFunction$2(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, container instanceof SVGElement);
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app2;
  };
  function normalizeContainer(container) {
    if (isString$3(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  /*!
    * shared v9.9.0
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  const inBrowser = typeof window !== "undefined";
  const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
  const generateFormatCacheKey = (locale, key, source2) => friendlyJSONstringify({ l: locale, k: key, s: source2 });
  const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
  const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
  const isDate$1 = (val) => toTypeString(val) === "[object Date]";
  const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
  const isEmptyObject = (val) => isPlainObject$2(val) && Object.keys(val).length === 0;
  const assign$3 = Object.assign;
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function escapeHtml(rawText) {
    return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }
  const isArray$1 = Array.isArray;
  const isFunction$1 = (val) => typeof val === "function";
  const isString$2 = (val) => typeof val === "string";
  const isBoolean = (val) => typeof val === "boolean";
  const isObject$3 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return isObject$3(val) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$1.call(value);
  const isPlainObject$2 = (val) => {
    if (!isObject$3(val))
      return false;
    const proto = Object.getPrototypeOf(val);
    return proto === null || proto.constructor === Object;
  };
  const toDisplayString = (val) => {
    return val == null ? "" : isArray$1(val) || isPlainObject$2(val) && val.toString === objectToString$1 ? JSON.stringify(val, null, 2) : String(val);
  };
  function join$1(items, separator = "") {
    return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
  }
  function incrementer(code2) {
    let current = code2;
    return () => ++current;
  }
  function warn(msg, err) {
    if (typeof console !== "undefined") {
      console.warn(`[intlify] ` + msg);
      if (err) {
        console.warn(err.stack);
      }
    }
  }
  const isNotObjectOrIsArray = (val) => !isObject$3(val) || isArray$1(val);
  function deepCopy(src, des) {
    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
      throw new Error("Invalid value");
    }
    const stack = [{ src, des }];
    while (stack.length) {
      const { src: src2, des: des2 } = stack.pop();
      Object.keys(src2).forEach((key) => {
        if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
          des2[key] = src2[key];
        } else {
          stack.push({ src: src2[key], des: des2[key] });
        }
      });
    }
  }
  /*!
    * message-compiler v9.9.0
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  function createPosition(line, column, offset) {
    return { line, column, offset };
  }
  function createLocation(start, end, source2) {
    const loc = { start, end };
    if (source2 != null) {
      loc.source = source2;
    }
    return loc;
  }
  const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
  function format$1(message, ...args) {
    if (args.length === 1 && isObject$2(args[0])) {
      args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
      args = {};
    }
    return message.replace(RE_ARGS, (match, identifier) => {
      return args.hasOwnProperty(identifier) ? args[identifier] : "";
    });
  }
  const assign$2 = Object.assign;
  const isString$1 = (val) => typeof val === "string";
  const isObject$2 = (val) => val !== null && typeof val === "object";
  function join(items, separator = "") {
    return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
  }
  const CompileErrorCodes = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    __EXTEND_POINT__: 17
  };
  const errorMessages = {
    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
  };
  function createCompileError(code2, loc, options = {}) {
    const { domain, messages: messages2, args } = options;
    const msg = format$1((messages2 || errorMessages)[code2] || "", ...args || []);
    const error = new SyntaxError(String(msg));
    error.code = code2;
    if (loc) {
      error.location = loc;
    }
    error.domain = domain;
    return error;
  }
  function defaultOnError(error) {
    throw error;
  }
  const CHAR_SP = " ";
  const CHAR_CR = "\r";
  const CHAR_LF = "\n";
  const CHAR_LS = String.fromCharCode(8232);
  const CHAR_PS = String.fromCharCode(8233);
  function createScanner(str) {
    const _buf = str;
    let _index = 0;
    let _line = 1;
    let _column = 1;
    let _peekOffset = 0;
    const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
    const isLF = (index2) => _buf[index2] === CHAR_LF;
    const isPS = (index2) => _buf[index2] === CHAR_PS;
    const isLS = (index2) => _buf[index2] === CHAR_LS;
    const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
    const index = () => _index;
    const line = () => _line;
    const column = () => _column;
    const peekOffset = () => _peekOffset;
    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
    const currentChar = () => charAt(_index);
    const currentPeek = () => charAt(_index + _peekOffset);
    function next() {
      _peekOffset = 0;
      if (isLineEnd(_index)) {
        _line++;
        _column = 0;
      }
      if (isCRLF(_index)) {
        _index++;
      }
      _index++;
      _column++;
      return _buf[_index];
    }
    function peek() {
      if (isCRLF(_index + _peekOffset)) {
        _peekOffset++;
      }
      _peekOffset++;
      return _buf[_index + _peekOffset];
    }
    function reset() {
      _index = 0;
      _line = 1;
      _column = 1;
      _peekOffset = 0;
    }
    function resetPeek(offset = 0) {
      _peekOffset = offset;
    }
    function skipToPeek() {
      const target = _index + _peekOffset;
      while (target !== _index) {
        next();
      }
      _peekOffset = 0;
    }
    return {
      index,
      line,
      column,
      peekOffset,
      charAt,
      currentChar,
      currentPeek,
      next,
      peek,
      reset,
      resetPeek,
      skipToPeek
    };
  }
  const EOF = void 0;
  const DOT = ".";
  const LITERAL_DELIMITER = "'";
  const ERROR_DOMAIN$3 = "tokenizer";
  function createTokenizer(source2, options = {}) {
    const location = options.location !== false;
    const _scnr = createScanner(source2);
    const currentOffset = () => _scnr.index();
    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
    const _initLoc = currentPosition();
    const _initOffset = currentOffset();
    const _context = {
      currentType: 14,
      offset: _initOffset,
      startLoc: _initLoc,
      endLoc: _initLoc,
      lastType: 14,
      lastOffset: _initOffset,
      lastStartLoc: _initLoc,
      lastEndLoc: _initLoc,
      braceNest: 0,
      inLinked: false,
      text: ""
    };
    const context = () => _context;
    const { onError } = options;
    function emitError(code2, pos, offset, ...args) {
      const ctx = context();
      pos.column += offset;
      pos.offset += offset;
      if (onError) {
        const loc = location ? createLocation(ctx.startLoc, pos) : null;
        const err = createCompileError(code2, loc, {
          domain: ERROR_DOMAIN$3,
          args
        });
        onError(err);
      }
    }
    function getToken(context2, type, value) {
      context2.endLoc = currentPosition();
      context2.currentType = type;
      const token = { type };
      if (location) {
        token.loc = createLocation(context2.startLoc, context2.endLoc);
      }
      if (value != null) {
        token.value = value;
      }
      return token;
    }
    const getEndToken = (context2) => getToken(context2, 14);
    function eat(scnr, ch) {
      if (scnr.currentChar() === ch) {
        scnr.next();
        return ch;
      } else {
        emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        return "";
      }
    }
    function peekSpaces(scnr) {
      let buf = "";
      while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
        buf += scnr.currentPeek();
        scnr.peek();
      }
      return buf;
    }
    function skipSpaces(scnr) {
      const buf = peekSpaces(scnr);
      scnr.skipToPeek();
      return buf;
    }
    function isIdentifierStart(ch) {
      if (ch === EOF) {
        return false;
      }
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || cc >= 65 && cc <= 90 || cc === 95;
    }
    function isNumberStart(ch) {
      if (ch === EOF) {
        return false;
      }
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57;
    }
    function isNamedIdentifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ret = isIdentifierStart(scnr.currentPeek());
      scnr.resetPeek();
      return ret;
    }
    function isListIdentifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
      const ret = isNumberStart(ch);
      scnr.resetPeek();
      return ret;
    }
    function isLiteralStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === LITERAL_DELIMITER;
      scnr.resetPeek();
      return ret;
    }
    function isLinkedDotStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 8) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === ".";
      scnr.resetPeek();
      return ret;
    }
    function isLinkedModifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 9) {
        return false;
      }
      peekSpaces(scnr);
      const ret = isIdentifierStart(scnr.currentPeek());
      scnr.resetPeek();
      return ret;
    }
    function isLinkedDelimiterStart(scnr, context2) {
      const { currentType } = context2;
      if (!(currentType === 8 || currentType === 12)) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === ":";
      scnr.resetPeek();
      return ret;
    }
    function isLinkedReferStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 10) {
        return false;
      }
      const fn = () => {
        const ch = scnr.currentPeek();
        if (ch === "{") {
          return isIdentifierStart(scnr.peek());
        } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
          return false;
        } else if (ch === CHAR_LF) {
          scnr.peek();
          return fn();
        } else {
          return isIdentifierStart(ch);
        }
      };
      const ret = fn();
      scnr.resetPeek();
      return ret;
    }
    function isPluralStart(scnr) {
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === "|";
      scnr.resetPeek();
      return ret;
    }
    function detectModuloStart(scnr) {
      const spaces = peekSpaces(scnr);
      const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
      scnr.resetPeek();
      return {
        isModulo: ret,
        hasSpace: spaces.length > 0
      };
    }
    function isTextStart(scnr, reset = true) {
      const fn = (hasSpace = false, prev = "", detectModulo = false) => {
        const ch = scnr.currentPeek();
        if (ch === "{") {
          return prev === "%" ? false : hasSpace;
        } else if (ch === "@" || !ch) {
          return prev === "%" ? true : hasSpace;
        } else if (ch === "%") {
          scnr.peek();
          return fn(hasSpace, "%", true);
        } else if (ch === "|") {
          return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
        } else if (ch === CHAR_SP) {
          scnr.peek();
          return fn(true, CHAR_SP, detectModulo);
        } else if (ch === CHAR_LF) {
          scnr.peek();
          return fn(true, CHAR_LF, detectModulo);
        } else {
          return true;
        }
      };
      const ret = fn();
      reset && scnr.resetPeek();
      return ret;
    }
    function takeChar(scnr, fn) {
      const ch = scnr.currentChar();
      if (ch === EOF) {
        return EOF;
      }
      if (fn(ch)) {
        scnr.next();
        return ch;
      }
      return null;
    }
    function takeIdentifierChar(scnr) {
      const closure = (ch) => {
        const cc = ch.charCodeAt(0);
        return cc >= 97 && cc <= 122 || cc >= 65 && cc <= 90 || cc >= 48 && cc <= 57 || cc === 95 || cc === 36;
      };
      return takeChar(scnr, closure);
    }
    function takeDigit(scnr) {
      const closure = (ch) => {
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57;
      };
      return takeChar(scnr, closure);
    }
    function takeHexDigit(scnr) {
      const closure = (ch) => {
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57 || cc >= 65 && cc <= 70 || cc >= 97 && cc <= 102;
      };
      return takeChar(scnr, closure);
    }
    function getDigits(scnr) {
      let ch = "";
      let num = "";
      while (ch = takeDigit(scnr)) {
        num += ch;
      }
      return num;
    }
    function readModulo(scnr) {
      skipSpaces(scnr);
      const ch = scnr.currentChar();
      if (ch !== "%") {
        emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      }
      scnr.next();
      return "%";
    }
    function readText(scnr) {
      let buf = "";
      while (true) {
        const ch = scnr.currentChar();
        if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
          break;
        } else if (ch === "%") {
          if (isTextStart(scnr)) {
            buf += ch;
            scnr.next();
          } else {
            break;
          }
        } else if (ch === CHAR_SP || ch === CHAR_LF) {
          if (isTextStart(scnr)) {
            buf += ch;
            scnr.next();
          } else if (isPluralStart(scnr)) {
            break;
          } else {
            buf += ch;
            scnr.next();
          }
        } else {
          buf += ch;
          scnr.next();
        }
      }
      return buf;
    }
    function readNamedIdentifier(scnr) {
      skipSpaces(scnr);
      let ch = "";
      let name = "";
      while (ch = takeIdentifierChar(scnr)) {
        name += ch;
      }
      if (scnr.currentChar() === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
      }
      return name;
    }
    function readListIdentifier(scnr) {
      skipSpaces(scnr);
      let value = "";
      if (scnr.currentChar() === "-") {
        scnr.next();
        value += `-${getDigits(scnr)}`;
      } else {
        value += getDigits(scnr);
      }
      if (scnr.currentChar() === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
      }
      return value;
    }
    function readLiteral(scnr) {
      skipSpaces(scnr);
      eat(scnr, `'`);
      let ch = "";
      let literal = "";
      const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;
      while (ch = takeChar(scnr, fn)) {
        if (ch === "\\") {
          literal += readEscapeSequence(scnr);
        } else {
          literal += ch;
        }
      }
      const current = scnr.currentChar();
      if (current === CHAR_LF || current === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
        if (current === CHAR_LF) {
          scnr.next();
          eat(scnr, `'`);
        }
        return literal;
      }
      eat(scnr, `'`);
      return literal;
    }
    function readEscapeSequence(scnr) {
      const ch = scnr.currentChar();
      switch (ch) {
        case "\\":
        case `'`:
          scnr.next();
          return `\\${ch}`;
        case "u":
          return readUnicodeEscapeSequence(scnr, ch, 4);
        case "U":
          return readUnicodeEscapeSequence(scnr, ch, 6);
        default:
          emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
          return "";
      }
    }
    function readUnicodeEscapeSequence(scnr, unicode, digits) {
      eat(scnr, unicode);
      let sequence = "";
      for (let i = 0; i < digits; i++) {
        const ch = takeHexDigit(scnr);
        if (!ch) {
          emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
          break;
        }
        sequence += ch;
      }
      return `\\${unicode}${sequence}`;
    }
    function readInvalidIdentifier(scnr) {
      skipSpaces(scnr);
      let ch = "";
      let identifiers = "";
      const closure = (ch2) => ch2 !== "{" && ch2 !== "}" && ch2 !== CHAR_SP && ch2 !== CHAR_LF;
      while (ch = takeChar(scnr, closure)) {
        identifiers += ch;
      }
      return identifiers;
    }
    function readLinkedModifier(scnr) {
      let ch = "";
      let name = "";
      while (ch = takeIdentifierChar(scnr)) {
        name += ch;
      }
      return name;
    }
    function readLinkedRefer(scnr) {
      const fn = (detect = false, buf) => {
        const ch = scnr.currentChar();
        if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
          return buf;
        } else if (ch === CHAR_SP) {
          return buf;
        } else if (ch === CHAR_LF || ch === DOT) {
          buf += ch;
          scnr.next();
          return fn(detect, buf);
        } else {
          buf += ch;
          scnr.next();
          return fn(true, buf);
        }
      };
      return fn(false, "");
    }
    function readPlural(scnr) {
      skipSpaces(scnr);
      const plural = eat(scnr, "|");
      skipSpaces(scnr);
      return plural;
    }
    function readTokenInPlaceholder(scnr, context2) {
      let token = null;
      const ch = scnr.currentChar();
      switch (ch) {
        case "{":
          if (context2.braceNest >= 1) {
            emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
          }
          scnr.next();
          token = getToken(context2, 2, "{");
          skipSpaces(scnr);
          context2.braceNest++;
          return token;
        case "}":
          if (context2.braceNest > 0 && context2.currentType === 2) {
            emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
          }
          scnr.next();
          token = getToken(context2, 3, "}");
          context2.braceNest--;
          context2.braceNest > 0 && skipSpaces(scnr);
          if (context2.inLinked && context2.braceNest === 0) {
            context2.inLinked = false;
          }
          return token;
        case "@":
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = readTokenInLinked(scnr, context2) || getEndToken(context2);
          context2.braceNest = 0;
          return token;
        default:
          let validNamedIdentifier = true;
          let validListIdentifier = true;
          let validLiteral = true;
          if (isPluralStart(scnr)) {
            if (context2.braceNest > 0) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            }
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            context2.braceNest = 0;
            return readToken(scnr, context2);
          }
          if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
            token = getToken(context2, 5, readNamedIdentifier(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
            token = getToken(context2, 6, readListIdentifier(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (validLiteral = isLiteralStart(scnr, context2)) {
            token = getToken(context2, 7, readLiteral(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
            token = getToken(context2, 13, readInvalidIdentifier(scnr));
            emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
            skipSpaces(scnr);
            return token;
          }
          break;
      }
      return token;
    }
    function readTokenInLinked(scnr, context2) {
      const { currentType } = context2;
      let token = null;
      const ch = scnr.currentChar();
      if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
        emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
      }
      switch (ch) {
        case "@":
          scnr.next();
          token = getToken(context2, 8, "@");
          context2.inLinked = true;
          return token;
        case ".":
          skipSpaces(scnr);
          scnr.next();
          return getToken(context2, 9, ".");
        case ":":
          skipSpaces(scnr);
          scnr.next();
          return getToken(context2, 10, ":");
        default:
          if (isPluralStart(scnr)) {
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
            skipSpaces(scnr);
            return readTokenInLinked(scnr, context2);
          }
          if (isLinkedModifierStart(scnr, context2)) {
            skipSpaces(scnr);
            return getToken(context2, 12, readLinkedModifier(scnr));
          }
          if (isLinkedReferStart(scnr, context2)) {
            skipSpaces(scnr);
            if (ch === "{") {
              return readTokenInPlaceholder(scnr, context2) || token;
            } else {
              return getToken(context2, 11, readLinkedRefer(scnr));
            }
          }
          if (currentType === 8) {
            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
          }
          context2.braceNest = 0;
          context2.inLinked = false;
          return readToken(scnr, context2);
      }
    }
    function readToken(scnr, context2) {
      let token = { type: 14 };
      if (context2.braceNest > 0) {
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      }
      if (context2.inLinked) {
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      }
      const ch = scnr.currentChar();
      switch (ch) {
        case "{":
          return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
        case "}":
          emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
          scnr.next();
          return getToken(context2, 3, "}");
        case "@":
          return readTokenInLinked(scnr, context2) || getEndToken(context2);
        default:
          if (isPluralStart(scnr)) {
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          const { isModulo, hasSpace } = detectModuloStart(scnr);
          if (isModulo) {
            return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
          }
          if (isTextStart(scnr)) {
            return getToken(context2, 0, readText(scnr));
          }
          break;
      }
      return token;
    }
    function nextToken() {
      const { currentType, offset, startLoc, endLoc } = _context;
      _context.lastType = currentType;
      _context.lastOffset = offset;
      _context.lastStartLoc = startLoc;
      _context.lastEndLoc = endLoc;
      _context.offset = currentOffset();
      _context.startLoc = currentPosition();
      if (_scnr.currentChar() === EOF) {
        return getToken(_context, 14);
      }
      return readToken(_scnr, _context);
    }
    return {
      nextToken,
      currentOffset,
      currentPosition,
      context
    };
  }
  const ERROR_DOMAIN$2 = "parser";
  const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function fromEscapeSequence(match, codePoint4, codePoint6) {
    switch (match) {
      case `\\\\`:
        return `\\`;
      case `\\'`:
        return `'`;
      default: {
        const codePoint = parseInt(codePoint4 || codePoint6, 16);
        if (codePoint <= 55295 || codePoint >= 57344) {
          return String.fromCodePoint(codePoint);
        }
        return "\uFFFD";
      }
    }
  }
  function createParser(options = {}) {
    const location = options.location !== false;
    const { onError } = options;
    function emitError(tokenzer, code2, start, offset, ...args) {
      const end = tokenzer.currentPosition();
      end.offset += offset;
      end.column += offset;
      if (onError) {
        const loc = location ? createLocation(start, end) : null;
        const err = createCompileError(code2, loc, {
          domain: ERROR_DOMAIN$2,
          args
        });
        onError(err);
      }
    }
    function startNode(type, offset, loc) {
      const node = { type };
      if (location) {
        node.start = offset;
        node.end = offset;
        node.loc = { start: loc, end: loc };
      }
      return node;
    }
    function endNode(node, offset, pos, type) {
      if (type) {
        node.type = type;
      }
      if (location) {
        node.end = offset;
        if (node.loc) {
          node.loc.end = pos;
        }
      }
    }
    function parseText(tokenizer, value) {
      const context = tokenizer.context();
      const node = startNode(3, context.offset, context.startLoc);
      node.value = value;
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseList(tokenizer, index) {
      const context = tokenizer.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(5, offset, loc);
      node.index = parseInt(index, 10);
      tokenizer.nextToken();
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseNamed(tokenizer, key) {
      const context = tokenizer.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(4, offset, loc);
      node.key = key;
      tokenizer.nextToken();
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseLiteral(tokenizer, value) {
      const context = tokenizer.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(9, offset, loc);
      node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
      tokenizer.nextToken();
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseLinkedModifier(tokenizer) {
      const token = tokenizer.nextToken();
      const context = tokenizer.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(8, offset, loc);
      if (token.type !== 12) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
        node.value = "";
        endNode(node, offset, loc);
        return {
          nextConsumeToken: token,
          node
        };
      }
      if (token.value == null) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
      }
      node.value = token.value || "";
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return {
        node
      };
    }
    function parseLinkedKey(tokenizer, value) {
      const context = tokenizer.context();
      const node = startNode(7, context.offset, context.startLoc);
      node.value = value;
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseLinked(tokenizer) {
      const context = tokenizer.context();
      const linkedNode = startNode(6, context.offset, context.startLoc);
      let token = tokenizer.nextToken();
      if (token.type === 9) {
        const parsed = parseLinkedModifier(tokenizer);
        linkedNode.modifier = parsed.node;
        token = parsed.nextConsumeToken || tokenizer.nextToken();
      }
      if (token.type !== 10) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
      }
      token = tokenizer.nextToken();
      if (token.type === 2) {
        token = tokenizer.nextToken();
      }
      switch (token.type) {
        case 11:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseNamed(tokenizer, token.value || "");
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseList(tokenizer, token.value || "");
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseLiteral(tokenizer, token.value || "");
          break;
        default:
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
          const nextContext = tokenizer.context();
          const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
          emptyLinkedKeyNode.value = "";
          endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
          linkedNode.key = emptyLinkedKeyNode;
          endNode(linkedNode, nextContext.offset, nextContext.startLoc);
          return {
            nextConsumeToken: token,
            node: linkedNode
          };
      }
      endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
      return {
        node: linkedNode
      };
    }
    function parseMessage(tokenizer) {
      const context = tokenizer.context();
      const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
      const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
      const node = startNode(2, startOffset, startLoc);
      node.items = [];
      let nextToken = null;
      do {
        const token = nextToken || tokenizer.nextToken();
        nextToken = null;
        switch (token.type) {
          case 0:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseText(tokenizer, token.value || ""));
            break;
          case 6:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseList(tokenizer, token.value || ""));
            break;
          case 5:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseNamed(tokenizer, token.value || ""));
            break;
          case 7:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseLiteral(tokenizer, token.value || ""));
            break;
          case 8:
            const parsed = parseLinked(tokenizer);
            node.items.push(parsed.node);
            nextToken = parsed.nextConsumeToken || null;
            break;
        }
      } while (context.currentType !== 14 && context.currentType !== 1);
      const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
      const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
      endNode(node, endOffset, endLoc);
      return node;
    }
    function parsePlural(tokenizer, offset, loc, msgNode) {
      const context = tokenizer.context();
      let hasEmptyMessage = msgNode.items.length === 0;
      const node = startNode(1, offset, loc);
      node.cases = [];
      node.cases.push(msgNode);
      do {
        const msg = parseMessage(tokenizer);
        if (!hasEmptyMessage) {
          hasEmptyMessage = msg.items.length === 0;
        }
        node.cases.push(msg);
      } while (context.currentType !== 14);
      if (hasEmptyMessage) {
        emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
      }
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseResource(tokenizer) {
      const context = tokenizer.context();
      const { offset, startLoc } = context;
      const msgNode = parseMessage(tokenizer);
      if (context.currentType === 14) {
        return msgNode;
      } else {
        return parsePlural(tokenizer, offset, startLoc, msgNode);
      }
    }
    function parse2(source2) {
      const tokenizer = createTokenizer(source2, assign$2({}, options));
      const context = tokenizer.context();
      const node = startNode(0, context.offset, context.startLoc);
      if (location && node.loc) {
        node.loc.source = source2;
      }
      node.body = parseResource(tokenizer);
      if (options.onCacheKey) {
        node.cacheKey = options.onCacheKey(source2);
      }
      if (context.currentType !== 14) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source2[context.offset] || "");
      }
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    return { parse: parse2 };
  }
  function getTokenCaption(token) {
    if (token.type === 14) {
      return "EOF";
    }
    const name = (token.value || "").replace(/\r?\n/gu, "\\n");
    return name.length > 10 ? name.slice(0, 9) + "\u2026" : name;
  }
  function createTransformer(ast, options = {}) {
    const _context = {
      ast,
      helpers: /* @__PURE__ */ new Set()
    };
    const context = () => _context;
    const helper = (name) => {
      _context.helpers.add(name);
      return name;
    };
    return { context, helper };
  }
  function traverseNodes(nodes, transformer) {
    for (let i = 0; i < nodes.length; i++) {
      traverseNode(nodes[i], transformer);
    }
  }
  function traverseNode(node, transformer) {
    switch (node.type) {
      case 1:
        traverseNodes(node.cases, transformer);
        transformer.helper("plural");
        break;
      case 2:
        traverseNodes(node.items, transformer);
        break;
      case 6:
        const linked = node;
        traverseNode(linked.key, transformer);
        transformer.helper("linked");
        transformer.helper("type");
        break;
      case 5:
        transformer.helper("interpolate");
        transformer.helper("list");
        break;
      case 4:
        transformer.helper("interpolate");
        transformer.helper("named");
        break;
    }
  }
  function transform(ast, options = {}) {
    const transformer = createTransformer(ast);
    transformer.helper("normalize");
    ast.body && traverseNode(ast.body, transformer);
    const context = transformer.context();
    ast.helpers = Array.from(context.helpers);
  }
  function optimize(ast) {
    const body = ast.body;
    if (body.type === 2) {
      optimizeMessageNode(body);
    } else {
      body.cases.forEach((c) => optimizeMessageNode(c));
    }
    return ast;
  }
  function optimizeMessageNode(message) {
    if (message.items.length === 1) {
      const item = message.items[0];
      if (item.type === 3 || item.type === 9) {
        message.static = item.value;
        delete item.value;
      }
    } else {
      const values = [];
      for (let i = 0; i < message.items.length; i++) {
        const item = message.items[i];
        if (!(item.type === 3 || item.type === 9)) {
          break;
        }
        if (item.value == null) {
          break;
        }
        values.push(item.value);
      }
      if (values.length === message.items.length) {
        message.static = join(values);
        for (let i = 0; i < message.items.length; i++) {
          const item = message.items[i];
          if (item.type === 3 || item.type === 9) {
            delete item.value;
          }
        }
      }
    }
  }
  const ERROR_DOMAIN$1 = "minifier";
  function minify(node) {
    node.t = node.type;
    switch (node.type) {
      case 0:
        const resource = node;
        minify(resource.body);
        resource.b = resource.body;
        delete resource.body;
        break;
      case 1:
        const plural = node;
        const cases = plural.cases;
        for (let i = 0; i < cases.length; i++) {
          minify(cases[i]);
        }
        plural.c = cases;
        delete plural.cases;
        break;
      case 2:
        const message = node;
        const items = message.items;
        for (let i = 0; i < items.length; i++) {
          minify(items[i]);
        }
        message.i = items;
        delete message.items;
        if (message.static) {
          message.s = message.static;
          delete message.static;
        }
        break;
      case 3:
      case 9:
      case 8:
      case 7:
        const valueNode = node;
        if (valueNode.value) {
          valueNode.v = valueNode.value;
          delete valueNode.value;
        }
        break;
      case 6:
        const linked = node;
        minify(linked.key);
        linked.k = linked.key;
        delete linked.key;
        if (linked.modifier) {
          minify(linked.modifier);
          linked.m = linked.modifier;
          delete linked.modifier;
        }
        break;
      case 5:
        const list = node;
        list.i = list.index;
        delete list.index;
        break;
      case 4:
        const named = node;
        named.k = named.key;
        delete named.key;
        break;
      default: {
        throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: ERROR_DOMAIN$1,
          args: [node.type]
        });
      }
    }
    delete node.type;
  }
  const ERROR_DOMAIN = "parser";
  function createCodeGenerator(ast, options) {
    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
    const location = options.location !== false;
    const _context = {
      filename,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode,
      needIndent: _needIndent,
      indentLevel: 0
    };
    if (location && ast.loc) {
      _context.source = ast.loc.source;
    }
    const context = () => _context;
    function push(code2, node) {
      _context.code += code2;
    }
    function _newline(n, withBreakLine = true) {
      const _breakLineCode = withBreakLine ? breakLineCode : "";
      push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
    }
    function indent(withNewLine = true) {
      const level = ++_context.indentLevel;
      withNewLine && _newline(level);
    }
    function deindent(withNewLine = true) {
      const level = --_context.indentLevel;
      withNewLine && _newline(level);
    }
    function newline() {
      _newline(_context.indentLevel);
    }
    const helper = (key) => `_${key}`;
    const needIndent = () => _context.needIndent;
    return {
      context,
      push,
      indent,
      deindent,
      newline,
      helper,
      needIndent
    };
  }
  function generateLinkedNode(generator, node) {
    const { helper } = generator;
    generator.push(`${helper("linked")}(`);
    generateNode(generator, node.key);
    if (node.modifier) {
      generator.push(`, `);
      generateNode(generator, node.modifier);
      generator.push(`, _type`);
    } else {
      generator.push(`, undefined, _type`);
    }
    generator.push(`)`);
  }
  function generateMessageNode(generator, node) {
    const { helper, needIndent } = generator;
    generator.push(`${helper("normalize")}([`);
    generator.indent(needIndent());
    const length = node.items.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator, node.items[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push("])");
  }
  function generatePluralNode(generator, node) {
    const { helper, needIndent } = generator;
    if (node.cases.length > 1) {
      generator.push(`${helper("plural")}([`);
      generator.indent(needIndent());
      const length = node.cases.length;
      for (let i = 0; i < length; i++) {
        generateNode(generator, node.cases[i]);
        if (i === length - 1) {
          break;
        }
        generator.push(", ");
      }
      generator.deindent(needIndent());
      generator.push(`])`);
    }
  }
  function generateResource(generator, node) {
    if (node.body) {
      generateNode(generator, node.body);
    } else {
      generator.push("null");
    }
  }
  function generateNode(generator, node) {
    const { helper } = generator;
    switch (node.type) {
      case 0:
        generateResource(generator, node);
        break;
      case 1:
        generatePluralNode(generator, node);
        break;
      case 2:
        generateMessageNode(generator, node);
        break;
      case 6:
        generateLinkedNode(generator, node);
        break;
      case 8:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 7:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 5:
        generator.push(`${helper("interpolate")}(${helper("list")}(${node.index}))`, node);
        break;
      case 4:
        generator.push(`${helper("interpolate")}(${helper("named")}(${JSON.stringify(node.key)}))`, node);
        break;
      case 9:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 3:
        generator.push(JSON.stringify(node.value), node);
        break;
      default: {
        throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: ERROR_DOMAIN,
          args: [node.type]
        });
      }
    }
  }
  const generate = (ast, options = {}) => {
    const mode = isString$1(options.mode) ? options.mode : "normal";
    const filename = isString$1(options.filename) ? options.filename : "message.intl";
    const sourceMap = !!options.sourceMap;
    const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
    const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
    const helpers = ast.helpers || [];
    const generator = createCodeGenerator(ast, {
      mode,
      filename,
      sourceMap,
      breakLineCode,
      needIndent
    });
    generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
    generator.indent(needIndent);
    if (helpers.length > 0) {
      generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
      generator.newline();
    }
    generator.push(`return `);
    generateNode(generator, ast);
    generator.deindent(needIndent);
    generator.push(`}`);
    delete ast.helpers;
    const { code: code2, map } = generator.context();
    return {
      ast,
      code: code2,
      map: map ? map.toJSON() : void 0
    };
  };
  function baseCompile$1(source2, options = {}) {
    const assignedOptions = assign$2({}, options);
    const jit = !!assignedOptions.jit;
    const enalbeMinify = !!assignedOptions.minify;
    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
    const parser = createParser(assignedOptions);
    const ast = parser.parse(source2);
    if (!jit) {
      transform(ast, assignedOptions);
      return generate(ast, assignedOptions);
    } else {
      enambeOptimize && optimize(ast);
      enalbeMinify && minify(ast);
      return { ast, code: "" };
    }
  }
  /*!
    * core-base v9.9.0
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  function initFeatureFlags$1() {
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
      getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
      getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
  }
  const pathStateMachine = [];
  pathStateMachine[0] = {
    ["w"]: [0],
    ["i"]: [3, 0],
    ["["]: [4],
    ["o"]: [7]
  };
  pathStateMachine[1] = {
    ["w"]: [1],
    ["."]: [2],
    ["["]: [4],
    ["o"]: [7]
  };
  pathStateMachine[2] = {
    ["w"]: [2],
    ["i"]: [3, 0],
    ["0"]: [3, 0]
  };
  pathStateMachine[3] = {
    ["i"]: [3, 0],
    ["0"]: [3, 0],
    ["w"]: [1, 1],
    ["."]: [2, 1],
    ["["]: [4, 1],
    ["o"]: [7, 1]
  };
  pathStateMachine[4] = {
    ["'"]: [5, 0],
    ['"']: [6, 0],
    ["["]: [
      4,
      2
    ],
    ["]"]: [1, 3],
    ["o"]: 8,
    ["l"]: [4, 0]
  };
  pathStateMachine[5] = {
    ["'"]: [4, 0],
    ["o"]: 8,
    ["l"]: [5, 0]
  };
  pathStateMachine[6] = {
    ['"']: [4, 0],
    ["o"]: 8,
    ["l"]: [6, 0]
  };
  const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function isLiteral(exp) {
    return literalValueRE.test(exp);
  }
  function stripQuotes(str) {
    const a = str.charCodeAt(0);
    const b = str.charCodeAt(str.length - 1);
    return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
  }
  function getPathCharType(ch) {
    if (ch === void 0 || ch === null) {
      return "o";
    }
    const code2 = ch.charCodeAt(0);
    switch (code2) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return ch;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function formatSubPath(path) {
    const trimmed = path.trim();
    if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
      return false;
    }
    return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
  }
  function parse(path) {
    const keys = [];
    let index = -1;
    let mode = 0;
    let subPathDepth = 0;
    let c;
    let key;
    let newChar;
    let type;
    let transition;
    let action;
    let typeMap;
    const actions = [];
    actions[0] = () => {
      if (key === void 0) {
        key = newChar;
      } else {
        key += newChar;
      }
    };
    actions[1] = () => {
      if (key !== void 0) {
        keys.push(key);
        key = void 0;
      }
    };
    actions[2] = () => {
      actions[0]();
      subPathDepth++;
    };
    actions[3] = () => {
      if (subPathDepth > 0) {
        subPathDepth--;
        mode = 4;
        actions[0]();
      } else {
        subPathDepth = 0;
        if (key === void 0) {
          return false;
        }
        key = formatSubPath(key);
        if (key === false) {
          return false;
        } else {
          actions[1]();
        }
      }
    };
    function maybeUnescapeQuote() {
      const nextChar = path[index + 1];
      if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
        index++;
        newChar = "\\" + nextChar;
        actions[0]();
        return true;
      }
    }
    while (mode !== null) {
      index++;
      c = path[index];
      if (c === "\\" && maybeUnescapeQuote()) {
        continue;
      }
      type = getPathCharType(c);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap["l"] || 8;
      if (transition === 8) {
        return;
      }
      mode = transition[0];
      if (transition[1] !== void 0) {
        action = actions[transition[1]];
        if (action) {
          newChar = c;
          if (action() === false) {
            return;
          }
        }
      }
      if (mode === 7) {
        return keys;
      }
    }
  }
  const cache = /* @__PURE__ */ new Map();
  function resolveWithKeyValue(obj, path) {
    return isObject$3(obj) ? obj[path] : null;
  }
  function resolveValue(obj, path) {
    if (!isObject$3(obj)) {
      return null;
    }
    let hit = cache.get(path);
    if (!hit) {
      hit = parse(path);
      if (hit) {
        cache.set(path, hit);
      }
    }
    if (!hit) {
      return null;
    }
    const len = hit.length;
    let last = obj;
    let i = 0;
    while (i < len) {
      const val = last[hit[i]];
      if (val === void 0) {
        return null;
      }
      if (isFunction$1(last)) {
        return null;
      }
      last = val;
      i++;
    }
    return last;
  }
  const DEFAULT_MODIFIER = (str) => str;
  const DEFAULT_MESSAGE = (ctx) => "";
  const DEFAULT_MESSAGE_DATA_TYPE = "text";
  const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
  const DEFAULT_INTERPOLATE = toDisplayString;
  function pluralDefault(choice, choicesLength) {
    choice = Math.abs(choice);
    if (choicesLength === 2) {
      return choice ? choice > 1 ? 1 : 0 : 1;
    }
    return choice ? Math.min(choice, 2) : 0;
  }
  function getPluralIndex(options) {
    const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1;
    return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
  }
  function normalizeNamed(pluralIndex, props) {
    if (!props.count) {
      props.count = pluralIndex;
    }
    if (!props.n) {
      props.n = pluralIndex;
    }
  }
  function createMessageContext(options = {}) {
    const locale = options.locale;
    const pluralIndex = getPluralIndex(options);
    const pluralRule = isObject$3(options.pluralRules) && isString$2(locale) && isFunction$1(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
    const orgPluralRule = isObject$3(options.pluralRules) && isString$2(locale) && isFunction$1(options.pluralRules[locale]) ? pluralDefault : void 0;
    const plural = (messages2) => {
      return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
    };
    const _list = options.list || [];
    const list = (index) => _list[index];
    const _named = options.named || {};
    isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
    const named = (key) => _named[key];
    function message(key) {
      const msg = isFunction$1(options.messages) ? options.messages(key) : isObject$3(options.messages) ? options.messages[key] : false;
      return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
    }
    const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
    const normalize = isPlainObject$2(options.processor) && isFunction$1(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
    const interpolate = isPlainObject$2(options.processor) && isFunction$1(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
    const type = isPlainObject$2(options.processor) && isString$2(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
    const linked = (key, ...args) => {
      const [arg1, arg2] = args;
      let type2 = "text";
      let modifier = "";
      if (args.length === 1) {
        if (isObject$3(arg1)) {
          modifier = arg1.modifier || modifier;
          type2 = arg1.type || type2;
        } else if (isString$2(arg1)) {
          modifier = arg1 || modifier;
        }
      } else if (args.length === 2) {
        if (isString$2(arg1)) {
          modifier = arg1 || modifier;
        }
        if (isString$2(arg2)) {
          type2 = arg2 || type2;
        }
      }
      const ret = message(key)(ctx);
      const msg = type2 === "vnode" && isArray$1(ret) && modifier ? ret[0] : ret;
      return modifier ? _modifier(modifier)(msg, type2) : msg;
    };
    const ctx = {
      ["list"]: list,
      ["named"]: named,
      ["plural"]: plural,
      ["linked"]: linked,
      ["message"]: message,
      ["type"]: type,
      ["interpolate"]: interpolate,
      ["normalize"]: normalize,
      ["values"]: assign$3({}, _list, _named)
    };
    return ctx;
  }
  let devtools = null;
  function setDevToolsHook(hook) {
    devtools = hook;
  }
  function initI18nDevTools(i18n2, version2, meta) {
    devtools && devtools.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: i18n2,
      version: version2,
      meta
    });
  }
  const translateDevTools = /* @__PURE__ */ createDevToolsHook("function:translate");
  function createDevToolsHook(hook) {
    return (payloads) => devtools && devtools.emit(hook, payloads);
  }
  const CoreWarnCodes = {
    NOT_FOUND_KEY: 1,
    FALLBACK_TO_TRANSLATE: 2,
    CANNOT_FORMAT_NUMBER: 3,
    FALLBACK_TO_NUMBER_FORMAT: 4,
    CANNOT_FORMAT_DATE: 5,
    FALLBACK_TO_DATE_FORMAT: 6,
    EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7,
    __EXTEND_POINT__: 8
  };
  const code$2 = CompileErrorCodes.__EXTEND_POINT__;
  const inc$2 = incrementer(code$2);
  const CoreErrorCodes = {
    INVALID_ARGUMENT: code$2,
    INVALID_DATE_ARGUMENT: inc$2(),
    INVALID_ISO_DATE_ARGUMENT: inc$2(),
    NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
    NOT_SUPPORT_LOCALE_TYPE: inc$2(),
    __EXTEND_POINT__: inc$2()
  };
  function createCoreError(code2) {
    return createCompileError(code2, null, void 0);
  }
  function getLocale$1(context, options) {
    return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
  }
  let _resolveLocale;
  function resolveLocale(locale) {
    if (isString$2(locale)) {
      return locale;
    } else {
      if (isFunction$1(locale)) {
        if (locale.resolvedOnce && _resolveLocale != null) {
          return _resolveLocale;
        } else if (locale.constructor.name === "Function") {
          const resolve2 = locale();
          if (isPromise(resolve2)) {
            throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
          }
          return _resolveLocale = resolve2;
        } else {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
        }
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
      }
    }
  }
  function fallbackWithSimple(ctx, fallback, start) {
    return [.../* @__PURE__ */ new Set([
      start,
      ...isArray$1(fallback) ? fallback : isObject$3(fallback) ? Object.keys(fallback) : isString$2(fallback) ? [fallback] : [start]
    ])];
  }
  function fallbackWithLocaleChain(ctx, fallback, start) {
    const startLocale = isString$2(start) ? start : DEFAULT_LOCALE;
    const context = ctx;
    if (!context.__localeChainCache) {
      context.__localeChainCache = /* @__PURE__ */ new Map();
    }
    let chain = context.__localeChainCache.get(startLocale);
    if (!chain) {
      chain = [];
      let block = [start];
      while (isArray$1(block)) {
        block = appendBlockToChain(chain, block, fallback);
      }
      const defaults2 = isArray$1(fallback) || !isPlainObject$2(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
      block = isString$2(defaults2) ? [defaults2] : defaults2;
      if (isArray$1(block)) {
        appendBlockToChain(chain, block, false);
      }
      context.__localeChainCache.set(startLocale, chain);
    }
    return chain;
  }
  function appendBlockToChain(chain, block, blocks) {
    let follow = true;
    for (let i = 0; i < block.length && isBoolean(follow); i++) {
      const locale = block[i];
      if (isString$2(locale)) {
        follow = appendLocaleToChain(chain, block[i], blocks);
      }
    }
    return follow;
  }
  function appendLocaleToChain(chain, locale, blocks) {
    let follow;
    const tokens = locale.split("-");
    do {
      const target = tokens.join("-");
      follow = appendItemToChain(chain, target, blocks);
      tokens.splice(-1, 1);
    } while (tokens.length && follow === true);
    return follow;
  }
  function appendItemToChain(chain, target, blocks) {
    let follow = false;
    if (!chain.includes(target)) {
      follow = true;
      if (target) {
        follow = target[target.length - 1] !== "!";
        const locale = target.replace(/!/g, "");
        chain.push(locale);
        if ((isArray$1(blocks) || isPlainObject$2(blocks)) && blocks[locale]) {
          follow = blocks[locale];
        }
      }
    }
    return follow;
  }
  const VERSION$2 = "9.9.0";
  const NOT_REOSLVED = -1;
  const DEFAULT_LOCALE = "en-US";
  const MISSING_RESOLVE_VALUE = "";
  const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
  function getDefaultLinkedModifiers() {
    return {
      upper: (val, type) => {
        return type === "text" && isString$2(val) ? val.toUpperCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
      },
      lower: (val, type) => {
        return type === "text" && isString$2(val) ? val.toLowerCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
      },
      capitalize: (val, type) => {
        return type === "text" && isString$2(val) ? capitalize(val) : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
      }
    };
  }
  let _compiler;
  function registerMessageCompiler(compiler) {
    _compiler = compiler;
  }
  let _resolver;
  function registerMessageResolver(resolver) {
    _resolver = resolver;
  }
  let _fallbacker;
  function registerLocaleFallbacker(fallbacker) {
    _fallbacker = fallbacker;
  }
  let _additionalMeta = null;
  const setAdditionalMeta = (meta) => {
    _additionalMeta = meta;
  };
  const getAdditionalMeta = () => _additionalMeta;
  let _fallbackContext = null;
  const setFallbackContext = (context) => {
    _fallbackContext = context;
  };
  const getFallbackContext = () => _fallbackContext;
  let _cid = 0;
  function createCoreContext(options = {}) {
    const onWarn = isFunction$1(options.onWarn) ? options.onWarn : warn;
    const version2 = isString$2(options.version) ? options.version : VERSION$2;
    const locale = isString$2(options.locale) || isFunction$1(options.locale) ? options.locale : DEFAULT_LOCALE;
    const _locale = isFunction$1(locale) ? DEFAULT_LOCALE : locale;
    const fallbackLocale = isArray$1(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || isString$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
    const messages2 = isPlainObject$2(options.messages) ? options.messages : { [_locale]: {} };
    const datetimeFormats = isPlainObject$2(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
    const numberFormats = isPlainObject$2(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
    const modifiers = assign$3({}, options.modifiers || {}, getDefaultLinkedModifiers());
    const pluralRules = options.pluralRules || {};
    const missing = isFunction$1(options.missing) ? options.missing : null;
    const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    const fallbackFormat = !!options.fallbackFormat;
    const unresolving = !!options.unresolving;
    const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    const processor = isPlainObject$2(options.processor) ? options.processor : null;
    const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const escapeParameter = !!options.escapeParameter;
    const messageCompiler = isFunction$1(options.messageCompiler) ? options.messageCompiler : _compiler;
    const messageResolver = isFunction$1(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
    const localeFallbacker = isFunction$1(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
    const fallbackContext = isObject$3(options.fallbackContext) ? options.fallbackContext : void 0;
    const internalOptions = options;
    const __datetimeFormatters = isObject$3(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
    const __numberFormatters = isObject$3(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
    const __meta = isObject$3(internalOptions.__meta) ? internalOptions.__meta : {};
    _cid++;
    const context = {
      version: version2,
      cid: _cid,
      locale,
      fallbackLocale,
      messages: messages2,
      modifiers,
      pluralRules,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackFormat,
      unresolving,
      postTranslation,
      processor,
      warnHtmlMessage,
      escapeParameter,
      messageCompiler,
      messageResolver,
      localeFallbacker,
      fallbackContext,
      onWarn,
      __meta
    };
    {
      context.datetimeFormats = datetimeFormats;
      context.numberFormats = numberFormats;
      context.__datetimeFormatters = __datetimeFormatters;
      context.__numberFormatters = __numberFormatters;
    }
    if (__INTLIFY_PROD_DEVTOOLS__) {
      initI18nDevTools(context, version2, __meta);
    }
    return context;
  }
  function handleMissing(context, key, locale, missingWarn, type) {
    const { missing, onWarn } = context;
    if (missing !== null) {
      const ret = missing(context, locale, key, type);
      return isString$2(ret) ? ret : key;
    } else {
      return key;
    }
  }
  function updateFallbackLocale(ctx, locale, fallback) {
    const context = ctx;
    context.__localeChainCache = /* @__PURE__ */ new Map();
    ctx.localeFallbacker(ctx, fallback, locale);
  }
  function format(ast) {
    const msg = (ctx) => formatParts(ctx, ast);
    return msg;
  }
  function formatParts(ctx, ast) {
    const body = ast.b || ast.body;
    if ((body.t || body.type) === 1) {
      const plural = body;
      const cases = plural.c || plural.cases;
      return ctx.plural(cases.reduce((messages2, c) => [
        ...messages2,
        formatMessageParts(ctx, c)
      ], []));
    } else {
      return formatMessageParts(ctx, body);
    }
  }
  function formatMessageParts(ctx, node) {
    const _static = node.s || node.static;
    if (_static) {
      return ctx.type === "text" ? _static : ctx.normalize([_static]);
    } else {
      const messages2 = (node.i || node.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
      return ctx.normalize(messages2);
    }
  }
  function formatMessagePart(ctx, node) {
    const type = node.t || node.type;
    switch (type) {
      case 3:
        const text = node;
        return text.v || text.value;
      case 9:
        const literal = node;
        return literal.v || literal.value;
      case 4:
        const named = node;
        return ctx.interpolate(ctx.named(named.k || named.key));
      case 5:
        const list = node;
        return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
      case 6:
        const linked = node;
        const modifier = linked.m || linked.modifier;
        return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
      case 7:
        const linkedKey = node;
        return linkedKey.v || linkedKey.value;
      case 8:
        const linkedModifier = node;
        return linkedModifier.v || linkedModifier.value;
      default:
        throw new Error(`unhandled node type on format message part: ${type}`);
    }
  }
  const defaultOnCacheKey = (message) => message;
  let compileCache = /* @__PURE__ */ Object.create(null);
  const isMessageAST = (val) => isObject$3(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
  function baseCompile(message, options = {}) {
    let detectError = false;
    const onError = options.onError || defaultOnError;
    options.onError = (err) => {
      detectError = true;
      onError(err);
    };
    return { ...baseCompile$1(message, options), detectError };
  }
  function compile(message, context) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$2(message)) {
      isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
      const onCacheKey = context.onCacheKey || defaultOnCacheKey;
      const cacheKey = onCacheKey(message);
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      const { ast, detectError } = baseCompile(message, {
        ...context,
        location: false,
        jit: true
      });
      const msg = format(ast);
      return !detectError ? compileCache[cacheKey] = msg : msg;
    } else {
      const cacheKey = message.cacheKey;
      if (cacheKey) {
        const cached = compileCache[cacheKey];
        if (cached) {
          return cached;
        }
        return compileCache[cacheKey] = format(message);
      } else {
        return format(message);
      }
    }
  }
  const NOOP_MESSAGE_FUNCTION = () => "";
  const isMessageFunction = (val) => isFunction$1(val);
  function translate(context, ...args) {
    const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
    const [key, options] = parseTranslateArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
    const resolvedMessage = !!options.resolvedMessage;
    const defaultMsgOrKey = isString$2(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
    const locale = getLocale$1(context, options);
    escapeParameter && escapeParams(options);
    let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
      key,
      locale,
      messages2[locale] || {}
    ];
    let format2 = formatScope;
    let cacheBaseKey = key;
    if (!resolvedMessage && !(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
      if (enableDefaultMsg) {
        format2 = defaultMsgOrKey;
        cacheBaseKey = format2;
      }
    }
    if (!resolvedMessage && (!(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$2(targetLocale))) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let occurred = false;
    const onError = () => {
      occurred = true;
    };
    const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
    if (occurred) {
      return format2;
    }
    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
    const msgContext = createMessageContext(ctxOptions);
    const messaged = evaluateMessage(context, msg, msgContext);
    const ret = postTranslation ? postTranslation(messaged, key) : messaged;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const payloads = {
        timestamp: Date.now(),
        key: isString$2(key) ? key : isMessageFunction(format2) ? format2.key : "",
        locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
        format: isString$2(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
        message: ret
      };
      payloads.meta = assign$3({}, context.__meta, getAdditionalMeta() || {});
      translateDevTools(payloads);
    }
    return ret;
  }
  function escapeParams(options) {
    if (isArray$1(options.list)) {
      options.list = options.list.map((item) => isString$2(item) ? escapeHtml(item) : item);
    } else if (isObject$3(options.named)) {
      Object.keys(options.named).forEach((key) => {
        if (isString$2(options.named[key])) {
          options.named[key] = escapeHtml(options.named[key]);
        }
      });
    }
  }
  function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
    const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
    const locales = localeFallbacker(context, fallbackLocale, locale);
    let message = {};
    let targetLocale;
    let format2 = null;
    const type = "translate";
    for (let i = 0; i < locales.length; i++) {
      targetLocale = locales[i];
      message = messages2[targetLocale] || {};
      if ((format2 = resolveValue2(message, key)) === null) {
        format2 = message[key];
      }
      if (isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
        break;
      }
      const missingRet = handleMissing(context, key, targetLocale, missingWarn, type);
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
    return [format2, targetLocale, message];
  }
  function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
    const { messageCompiler, warnHtmlMessage } = context;
    if (isMessageFunction(format2)) {
      const msg2 = format2;
      msg2.locale = msg2.locale || targetLocale;
      msg2.key = msg2.key || key;
      return msg2;
    }
    if (messageCompiler == null) {
      const msg2 = () => format2;
      msg2.locale = targetLocale;
      msg2.key = key;
      return msg2;
    }
    const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
    msg.locale = targetLocale;
    msg.key = key;
    msg.source = format2;
    return msg;
  }
  function evaluateMessage(context, msg, msgCtx) {
    const messaged = msg(msgCtx);
    return messaged;
  }
  function parseTranslateArgs(...args) {
    const [arg1, arg2, arg3] = args;
    const options = {};
    if (!isString$2(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
    if (isNumber$1(arg2)) {
      options.plural = arg2;
    } else if (isString$2(arg2)) {
      options.default = arg2;
    } else if (isPlainObject$2(arg2) && !isEmptyObject(arg2)) {
      options.named = arg2;
    } else if (isArray$1(arg2)) {
      options.list = arg2;
    }
    if (isNumber$1(arg3)) {
      options.plural = arg3;
    } else if (isString$2(arg3)) {
      options.default = arg3;
    } else if (isPlainObject$2(arg3)) {
      assign$3(options, arg3);
    }
    return [key, options];
  }
  function getCompileContext(context, locale, key, source2, warnHtmlMessage, onError) {
    return {
      locale,
      key,
      warnHtmlMessage,
      onError: (err) => {
        onError && onError(err);
        {
          throw err;
        }
      },
      onCacheKey: (source3) => generateFormatCacheKey(locale, key, source3)
    };
  }
  function getMessageContextOptions(context, locale, message, options) {
    const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
    const resolveMessage = (key) => {
      let val = resolveValue2(message, key);
      if (val == null && fallbackContext) {
        const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
        val = resolveValue2(message2, key);
      }
      if (isString$2(val) || isMessageAST(val)) {
        let occurred = false;
        const onError = () => {
          occurred = true;
        };
        const msg = compileMessageFormat(context, key, locale, val, key, onError);
        return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
      } else if (isMessageFunction(val)) {
        return val;
      } else {
        return NOOP_MESSAGE_FUNCTION;
      }
    };
    const ctxOptions = {
      locale,
      modifiers,
      pluralRules,
      messages: resolveMessage
    };
    if (context.processor) {
      ctxOptions.processor = context.processor;
    }
    if (options.list) {
      ctxOptions.list = options.list;
    }
    if (options.named) {
      ctxOptions.named = options.named;
    }
    if (isNumber$1(options.plural)) {
      ctxOptions.pluralIndex = options.plural;
    }
    return ctxOptions;
  }
  function datetime(context, ...args) {
    const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __datetimeFormatters } = context;
    const [key, value, options, overrides] = parseDateTimeArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale = getLocale$1(context, options);
    const locales = localeFallbacker(context, fallbackLocale, locale);
    if (!isString$2(key) || key === "") {
      return new Intl.DateTimeFormat(locale, overrides).format(value);
    }
    let datetimeFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "datetime format";
    for (let i = 0; i < locales.length; i++) {
      targetLocale = locales[i];
      datetimeFormat = datetimeFormats[targetLocale] || {};
      format2 = datetimeFormat[key];
      if (isPlainObject$2(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
    }
    if (!isPlainObject$2(format2) || !isString$2(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __datetimeFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.DateTimeFormat(targetLocale, assign$3({}, format2, overrides));
      __datetimeFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  const DATETIME_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function parseDateTimeArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    let value;
    if (isString$2(arg1)) {
      const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!matches) {
        throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
      }
      const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
      value = new Date(dateTime);
      try {
        value.toISOString();
      } catch (e) {
        throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (isDate$1(arg1)) {
      if (isNaN(arg1.getTime())) {
        throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
      }
      value = arg1;
    } else if (isNumber$1(arg1)) {
      value = arg1;
    } else {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    if (isString$2(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$2(arg2)) {
      Object.keys(arg2).forEach((key) => {
        if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
          overrides[key] = arg2[key];
        } else {
          options[key] = arg2[key];
        }
      });
    }
    if (isString$2(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$2(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$2(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearDateTimeFormat(ctx, locale, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale}__${key}`;
      if (!context.__datetimeFormatters.has(id)) {
        continue;
      }
      context.__datetimeFormatters.delete(id);
    }
  }
  function number(context, ...args) {
    const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __numberFormatters } = context;
    const [key, value, options, overrides] = parseNumberArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale = getLocale$1(context, options);
    const locales = localeFallbacker(context, fallbackLocale, locale);
    if (!isString$2(key) || key === "") {
      return new Intl.NumberFormat(locale, overrides).format(value);
    }
    let numberFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "number format";
    for (let i = 0; i < locales.length; i++) {
      targetLocale = locales[i];
      numberFormat = numberFormats[targetLocale] || {};
      format2 = numberFormat[key];
      if (isPlainObject$2(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
    }
    if (!isPlainObject$2(format2) || !isString$2(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __numberFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.NumberFormat(targetLocale, assign$3({}, format2, overrides));
      __numberFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  const NUMBER_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function parseNumberArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    if (!isNumber$1(arg1)) {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const value = arg1;
    if (isString$2(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$2(arg2)) {
      Object.keys(arg2).forEach((key) => {
        if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
          overrides[key] = arg2[key];
        } else {
          options[key] = arg2[key];
        }
      });
    }
    if (isString$2(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$2(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$2(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearNumberFormat(ctx, locale, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale}__${key}`;
      if (!context.__numberFormatters.has(id)) {
        continue;
      }
      context.__numberFormatters.delete(id);
    }
  }
  {
    initFeatureFlags$1();
  }
  /*!
    * vue-i18n v9.9.0
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  const VERSION$1 = "9.9.0";
  function initFeatureFlags() {
    if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
      getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
    }
    if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
      getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
      getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
      getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
  }
  const code$1 = CoreWarnCodes.__EXTEND_POINT__;
  const inc$1 = incrementer(code$1);
  ({
    FALLBACK_TO_ROOT: code$1,
    NOT_SUPPORTED_PRESERVE: inc$1(),
    NOT_SUPPORTED_FORMATTER: inc$1(),
    NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
    NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
    COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
    NOT_FOUND_PARENT_SCOPE: inc$1(),
    IGNORE_OBJ_FLATTEN: inc$1(),
    NOTICE_DROP_ALLOW_COMPOSITION: inc$1()
  });
  const code = CoreErrorCodes.__EXTEND_POINT__;
  const inc = incrementer(code);
  const I18nErrorCodes = {
    UNEXPECTED_RETURN_TYPE: code,
    INVALID_ARGUMENT: inc(),
    MUST_BE_CALL_SETUP_TOP: inc(),
    NOT_INSTALLED: inc(),
    NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
    REQUIRED_VALUE: inc(),
    INVALID_VALUE: inc(),
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
    NOT_INSTALLED_WITH_PROVIDE: inc(),
    UNEXPECTED_ERROR: inc(),
    NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
    BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
    __EXTEND_POINT__: inc()
  };
  function createI18nError(code2, ...args) {
    return createCompileError(code2, null, void 0);
  }
  const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
  const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
  const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
  const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
  makeSymbol("__intlifyMeta");
  const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
  const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
  function handleFlatJson(obj) {
    if (!isObject$3(obj)) {
      return obj;
    }
    for (const key in obj) {
      if (!hasOwn(obj, key)) {
        continue;
      }
      if (!key.includes(".")) {
        if (isObject$3(obj[key])) {
          handleFlatJson(obj[key]);
        }
      } else {
        const subKeys = key.split(".");
        const lastIndex = subKeys.length - 1;
        let currentObj = obj;
        let hasStringValue = false;
        for (let i = 0; i < lastIndex; i++) {
          if (!(subKeys[i] in currentObj)) {
            currentObj[subKeys[i]] = {};
          }
          if (!isObject$3(currentObj[subKeys[i]])) {
            hasStringValue = true;
            break;
          }
          currentObj = currentObj[subKeys[i]];
        }
        if (!hasStringValue) {
          currentObj[subKeys[lastIndex]] = obj[key];
          delete obj[key];
        }
        if (isObject$3(currentObj[subKeys[lastIndex]])) {
          handleFlatJson(currentObj[subKeys[lastIndex]]);
        }
      }
    }
    return obj;
  }
  function getLocaleMessages(locale, options) {
    const { messages: messages2, __i18n, messageResolver, flatJson } = options;
    const ret = isPlainObject$2(messages2) ? messages2 : isArray$1(__i18n) ? {} : { [locale]: {} };
    if (isArray$1(__i18n)) {
      __i18n.forEach((custom) => {
        if ("locale" in custom && "resource" in custom) {
          const { locale: locale2, resource } = custom;
          if (locale2) {
            ret[locale2] = ret[locale2] || {};
            deepCopy(resource, ret[locale2]);
          } else {
            deepCopy(resource, ret);
          }
        } else {
          isString$2(custom) && deepCopy(JSON.parse(custom), ret);
        }
      });
    }
    if (messageResolver == null && flatJson) {
      for (const key in ret) {
        if (hasOwn(ret, key)) {
          handleFlatJson(ret[key]);
        }
      }
    }
    return ret;
  }
  function getComponentOptions(instance) {
    return instance.type;
  }
  function adjustI18nResources(gl, options, componentOptions) {
    let messages2 = isObject$3(options.messages) ? options.messages : {};
    if ("__i18nGlobal" in componentOptions) {
      messages2 = getLocaleMessages(gl.locale.value, {
        messages: messages2,
        __i18n: componentOptions.__i18nGlobal
      });
    }
    const locales = Object.keys(messages2);
    if (locales.length) {
      locales.forEach((locale) => {
        gl.mergeLocaleMessage(locale, messages2[locale]);
      });
    }
    {
      if (isObject$3(options.datetimeFormats)) {
        const locales2 = Object.keys(options.datetimeFormats);
        if (locales2.length) {
          locales2.forEach((locale) => {
            gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
          });
        }
      }
      if (isObject$3(options.numberFormats)) {
        const locales2 = Object.keys(options.numberFormats);
        if (locales2.length) {
          locales2.forEach((locale) => {
            gl.mergeNumberFormat(locale, options.numberFormats[locale]);
          });
        }
      }
    }
  }
  function createTextNode(key) {
    return createVNode(Text, null, key, 0);
  }
  const DEVTOOLS_META = "__INTLIFY_META__";
  const NOOP_RETURN_ARRAY = () => [];
  const NOOP_RETURN_FALSE = () => false;
  let composerID = 0;
  function defineCoreMissingHandler(missing) {
    return (ctx, locale, key, type) => {
      return missing(locale, key, getCurrentInstance() || void 0, type);
    };
  }
  const getMetaInfo = () => {
    const instance = getCurrentInstance();
    let meta = null;
    return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
  };
  function createComposer(options = {}, VueI18nLegacy) {
    const { __root, __injectWithOption } = options;
    const _isGlobal = __root === void 0;
    const flatJson = options.flatJson;
    const _ref = inBrowser ? ref : shallowRef;
    let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
    const _locale = _ref(__root && _inheritLocale ? __root.locale.value : isString$2(options.locale) ? options.locale : DEFAULT_LOCALE);
    const _fallbackLocale = _ref(__root && _inheritLocale ? __root.fallbackLocale.value : isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);
    const _messages = _ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = _ref(isPlainObject$2(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = _ref(isPlainObject$2(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    let _fallbackFormat = !!options.fallbackFormat;
    let _missing = isFunction$1(options.missing) ? options.missing : null;
    let _runtimeMissing = isFunction$1(options.missing) ? defineCoreMissingHandler(options.missing) : null;
    let _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    let _escapeParameter = !!options.escapeParameter;
    const _modifiers = __root ? __root.modifiers : isPlainObject$2(options.modifiers) ? options.modifiers : {};
    let _pluralRules = options.pluralRules || __root && __root.pluralRules;
    let _context;
    const getCoreContext = () => {
      _isGlobal && setFallbackContext(null);
      const ctxOptions = {
        version: VERSION$1,
        locale: _locale.value,
        fallbackLocale: _fallbackLocale.value,
        messages: _messages.value,
        modifiers: _modifiers,
        pluralRules: _pluralRules,
        missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
        missingWarn: _missingWarn,
        fallbackWarn: _fallbackWarn,
        fallbackFormat: _fallbackFormat,
        unresolving: true,
        postTranslation: _postTranslation === null ? void 0 : _postTranslation,
        warnHtmlMessage: _warnHtmlMessage,
        escapeParameter: _escapeParameter,
        messageResolver: options.messageResolver,
        messageCompiler: options.messageCompiler,
        __meta: { framework: "vue" }
      };
      {
        ctxOptions.datetimeFormats = _datetimeFormats.value;
        ctxOptions.numberFormats = _numberFormats.value;
        ctxOptions.__datetimeFormatters = isPlainObject$2(_context) ? _context.__datetimeFormatters : void 0;
        ctxOptions.__numberFormatters = isPlainObject$2(_context) ? _context.__numberFormatters : void 0;
      }
      const ctx = createCoreContext(ctxOptions);
      _isGlobal && setFallbackContext(ctx);
      return ctx;
    };
    _context = getCoreContext();
    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale = computed({
      get: () => _locale.value,
      set: (val) => {
        _locale.value = val;
        _context.locale = _locale.value;
      }
    });
    const fallbackLocale = computed({
      get: () => _fallbackLocale.value,
      set: (val) => {
        _fallbackLocale.value = val;
        _context.fallbackLocale = _fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, val);
      }
    });
    const messages2 = computed(() => _messages.value);
    const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
    const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return isFunction$1(_postTranslation) ? _postTranslation : null;
    }
    function setPostTranslationHandler(handler) {
      _postTranslation = handler;
      _context.postTranslation = handler;
    }
    function getMissingHandler() {
      return _missing;
    }
    function setMissingHandler(handler) {
      if (handler !== null) {
        _runtimeMissing = defineCoreMissingHandler(handler);
      }
      _missing = handler;
      _context.missing = _runtimeMissing;
    }
    const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
      trackReactivityValues();
      let ret;
      try {
        if (__INTLIFY_PROD_DEVTOOLS__) {
          setAdditionalMeta(getMetaInfo());
        }
        if (!_isGlobal) {
          _context.fallbackContext = __root ? getFallbackContext() : void 0;
        }
        ret = fn(_context);
      } finally {
        if (__INTLIFY_PROD_DEVTOOLS__) {
          setAdditionalMeta(null);
        }
        if (!_isGlobal) {
          _context.fallbackContext = void 0;
        }
      }
      if (warnType !== "translate exists" && isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
        const [key, arg2] = argumentParser();
        return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
      } else if (successCondition(ret)) {
        return ret;
      } else {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
      }
    };
    function t(...args) {
      return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key) => key, (val) => isString$2(val));
    }
    function rt(...args) {
      const [arg1, arg2, arg3] = args;
      if (arg3 && !isObject$3(arg3)) {
        throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
      }
      return t(...[arg1, arg2, assign$3({ resolvedMessage: true }, arg3 || {})]);
    }
    function d(...args) {
      return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
    }
    function n(...args) {
      return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
    }
    function normalize(values) {
      return values.map((val) => isString$2(val) || isNumber$1(val) || isBoolean(val) ? createTextNode(String(val)) : val);
    }
    const interpolate = (val) => val;
    const processor = {
      normalize,
      interpolate,
      type: "vnode"
    };
    function translateVNode(...args) {
      return wrapWithDeps((context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      }, () => parseTranslateArgs(...args), "translate", (root2) => root2[TranslateVNodeSymbol](...args), (key) => [createTextNode(key)], (val) => isArray$1(val));
    }
    function numberParts(...args) {
      return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => root2[NumberPartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString$2(val) || isArray$1(val));
    }
    function datetimeParts(...args) {
      return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => root2[DatetimePartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString$2(val) || isArray$1(val));
    }
    function setPluralRules(rules) {
      _pluralRules = rules;
      _context.pluralRules = _pluralRules;
    }
    function te(key, locale2) {
      return wrapWithDeps(() => {
        if (!key) {
          return false;
        }
        const targetLocale = isString$2(locale2) ? locale2 : _locale.value;
        const message = getLocaleMessage(targetLocale);
        const resolved = _context.messageResolver(message, key);
        return isMessageAST(resolved) || isMessageFunction(resolved) || isString$2(resolved);
      }, () => [key], "translate exists", (root2) => {
        return Reflect.apply(root2.te, root2, [key, locale2]);
      }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
    }
    function resolveMessages(key) {
      let messages3 = null;
      const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
      for (let i = 0; i < locales.length; i++) {
        const targetLocaleMessages = _messages.value[locales[i]] || {};
        const messageValue = _context.messageResolver(targetLocaleMessages, key);
        if (messageValue != null) {
          messages3 = messageValue;
          break;
        }
      }
      return messages3;
    }
    function tm(key) {
      const messages3 = resolveMessages(key);
      return messages3 != null ? messages3 : __root ? __root.tm(key) || {} : {};
    }
    function getLocaleMessage(locale2) {
      return _messages.value[locale2] || {};
    }
    function setLocaleMessage(locale2, message) {
      if (flatJson) {
        const _message = { [locale2]: message };
        for (const key in _message) {
          if (hasOwn(_message, key)) {
            handleFlatJson(_message[key]);
          }
        }
        message = _message[locale2];
      }
      _messages.value[locale2] = message;
      _context.messages = _messages.value;
    }
    function mergeLocaleMessage(locale2, message) {
      _messages.value[locale2] = _messages.value[locale2] || {};
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
      deepCopy(message, _messages.value[locale2]);
      _context.messages = _messages.value;
    }
    function getDateTimeFormat(locale2) {
      return _datetimeFormats.value[locale2] || {};
    }
    function setDateTimeFormat(locale2, format2) {
      _datetimeFormats.value[locale2] = format2;
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale2, format2);
    }
    function mergeDateTimeFormat(locale2, format2) {
      _datetimeFormats.value[locale2] = assign$3(_datetimeFormats.value[locale2] || {}, format2);
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale2, format2);
    }
    function getNumberFormat(locale2) {
      return _numberFormats.value[locale2] || {};
    }
    function setNumberFormat(locale2, format2) {
      _numberFormats.value[locale2] = format2;
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale2, format2);
    }
    function mergeNumberFormat(locale2, format2) {
      _numberFormats.value[locale2] = assign$3(_numberFormats.value[locale2] || {}, format2);
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale2, format2);
    }
    composerID++;
    if (__root && inBrowser) {
      watch(__root.locale, (val) => {
        if (_inheritLocale) {
          _locale.value = val;
          _context.locale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
      watch(__root.fallbackLocale, (val) => {
        if (_inheritLocale) {
          _fallbackLocale.value = val;
          _context.fallbackLocale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
    }
    const composer = {
      id: composerID,
      locale,
      fallbackLocale,
      get inheritLocale() {
        return _inheritLocale;
      },
      set inheritLocale(val) {
        _inheritLocale = val;
        if (val && __root) {
          _locale.value = __root.locale.value;
          _fallbackLocale.value = __root.fallbackLocale.value;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      },
      get availableLocales() {
        return Object.keys(_messages.value).sort();
      },
      messages: messages2,
      get modifiers() {
        return _modifiers;
      },
      get pluralRules() {
        return _pluralRules || {};
      },
      get isGlobal() {
        return _isGlobal;
      },
      get missingWarn() {
        return _missingWarn;
      },
      set missingWarn(val) {
        _missingWarn = val;
        _context.missingWarn = _missingWarn;
      },
      get fallbackWarn() {
        return _fallbackWarn;
      },
      set fallbackWarn(val) {
        _fallbackWarn = val;
        _context.fallbackWarn = _fallbackWarn;
      },
      get fallbackRoot() {
        return _fallbackRoot;
      },
      set fallbackRoot(val) {
        _fallbackRoot = val;
      },
      get fallbackFormat() {
        return _fallbackFormat;
      },
      set fallbackFormat(val) {
        _fallbackFormat = val;
        _context.fallbackFormat = _fallbackFormat;
      },
      get warnHtmlMessage() {
        return _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        _warnHtmlMessage = val;
        _context.warnHtmlMessage = val;
      },
      get escapeParameter() {
        return _escapeParameter;
      },
      set escapeParameter(val) {
        _escapeParameter = val;
        _context.escapeParameter = val;
      },
      t,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      [SetPluralRulesSymbol]: setPluralRules
    };
    {
      composer.datetimeFormats = datetimeFormats;
      composer.numberFormats = numberFormats;
      composer.rt = rt;
      composer.te = te;
      composer.tm = tm;
      composer.d = d;
      composer.n = n;
      composer.getDateTimeFormat = getDateTimeFormat;
      composer.setDateTimeFormat = setDateTimeFormat;
      composer.mergeDateTimeFormat = mergeDateTimeFormat;
      composer.getNumberFormat = getNumberFormat;
      composer.setNumberFormat = setNumberFormat;
      composer.mergeNumberFormat = mergeNumberFormat;
      composer[InejctWithOptionSymbol] = __injectWithOption;
      composer[TranslateVNodeSymbol] = translateVNode;
      composer[DatetimePartsSymbol] = datetimeParts;
      composer[NumberPartsSymbol] = numberParts;
    }
    return composer;
  }
  function convertComposerOptions(options) {
    const locale = isString$2(options.locale) ? options.locale : DEFAULT_LOCALE;
    const fallbackLocale = isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
    const missing = isFunction$1(options.missing) ? options.missing : void 0;
    const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
    const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
    const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    const fallbackFormat = !!options.formatFallbackMessages;
    const modifiers = isPlainObject$2(options.modifiers) ? options.modifiers : {};
    const pluralizationRules = options.pluralizationRules;
    const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : void 0;
    const warnHtmlMessage = isString$2(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
    const escapeParameter = !!options.escapeParameterHtml;
    const inheritLocale = isBoolean(options.sync) ? options.sync : true;
    let messages2 = options.messages;
    if (isPlainObject$2(options.sharedMessages)) {
      const sharedMessages = options.sharedMessages;
      const locales = Object.keys(sharedMessages);
      messages2 = locales.reduce((messages3, locale2) => {
        const message = messages3[locale2] || (messages3[locale2] = {});
        assign$3(message, sharedMessages[locale2]);
        return messages3;
      }, messages2 || {});
    }
    const { __i18n, __root, __injectWithOption } = options;
    const datetimeFormats = options.datetimeFormats;
    const numberFormats = options.numberFormats;
    const flatJson = options.flatJson;
    return {
      locale,
      fallbackLocale,
      messages: messages2,
      flatJson,
      datetimeFormats,
      numberFormats,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackRoot,
      fallbackFormat,
      modifiers,
      pluralRules: pluralizationRules,
      postTranslation,
      warnHtmlMessage,
      escapeParameter,
      messageResolver: options.messageResolver,
      inheritLocale,
      __i18n,
      __root,
      __injectWithOption
    };
  }
  function createVueI18n(options = {}, VueI18nLegacy) {
    {
      const composer = createComposer(convertComposerOptions(options));
      const { __extender } = options;
      const vueI18n = {
        id: composer.id,
        get locale() {
          return composer.locale.value;
        },
        set locale(val) {
          composer.locale.value = val;
        },
        get fallbackLocale() {
          return composer.fallbackLocale.value;
        },
        set fallbackLocale(val) {
          composer.fallbackLocale.value = val;
        },
        get messages() {
          return composer.messages.value;
        },
        get datetimeFormats() {
          return composer.datetimeFormats.value;
        },
        get numberFormats() {
          return composer.numberFormats.value;
        },
        get availableLocales() {
          return composer.availableLocales;
        },
        get formatter() {
          return {
            interpolate() {
              return [];
            }
          };
        },
        set formatter(val) {
        },
        get missing() {
          return composer.getMissingHandler();
        },
        set missing(handler) {
          composer.setMissingHandler(handler);
        },
        get silentTranslationWarn() {
          return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
        },
        set silentTranslationWarn(val) {
          composer.missingWarn = isBoolean(val) ? !val : val;
        },
        get silentFallbackWarn() {
          return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
        },
        set silentFallbackWarn(val) {
          composer.fallbackWarn = isBoolean(val) ? !val : val;
        },
        get modifiers() {
          return composer.modifiers;
        },
        get formatFallbackMessages() {
          return composer.fallbackFormat;
        },
        set formatFallbackMessages(val) {
          composer.fallbackFormat = val;
        },
        get postTranslation() {
          return composer.getPostTranslationHandler();
        },
        set postTranslation(handler) {
          composer.setPostTranslationHandler(handler);
        },
        get sync() {
          return composer.inheritLocale;
        },
        set sync(val) {
          composer.inheritLocale = val;
        },
        get warnHtmlInMessage() {
          return composer.warnHtmlMessage ? "warn" : "off";
        },
        set warnHtmlInMessage(val) {
          composer.warnHtmlMessage = val !== "off";
        },
        get escapeParameterHtml() {
          return composer.escapeParameter;
        },
        set escapeParameterHtml(val) {
          composer.escapeParameter = val;
        },
        get preserveDirectiveContent() {
          return true;
        },
        set preserveDirectiveContent(val) {
        },
        get pluralizationRules() {
          return composer.pluralRules || {};
        },
        __composer: composer,
        t(...args) {
          const [arg1, arg2, arg3] = args;
          const options2 = {};
          let list = null;
          let named = null;
          if (!isString$2(arg1)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
          }
          const key = arg1;
          if (isString$2(arg2)) {
            options2.locale = arg2;
          } else if (isArray$1(arg2)) {
            list = arg2;
          } else if (isPlainObject$2(arg2)) {
            named = arg2;
          }
          if (isArray$1(arg3)) {
            list = arg3;
          } else if (isPlainObject$2(arg3)) {
            named = arg3;
          }
          return Reflect.apply(composer.t, composer, [
            key,
            list || named || {},
            options2
          ]);
        },
        rt(...args) {
          return Reflect.apply(composer.rt, composer, [...args]);
        },
        tc(...args) {
          const [arg1, arg2, arg3] = args;
          const options2 = { plural: 1 };
          let list = null;
          let named = null;
          if (!isString$2(arg1)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
          }
          const key = arg1;
          if (isString$2(arg2)) {
            options2.locale = arg2;
          } else if (isNumber$1(arg2)) {
            options2.plural = arg2;
          } else if (isArray$1(arg2)) {
            list = arg2;
          } else if (isPlainObject$2(arg2)) {
            named = arg2;
          }
          if (isString$2(arg3)) {
            options2.locale = arg3;
          } else if (isArray$1(arg3)) {
            list = arg3;
          } else if (isPlainObject$2(arg3)) {
            named = arg3;
          }
          return Reflect.apply(composer.t, composer, [
            key,
            list || named || {},
            options2
          ]);
        },
        te(key, locale) {
          return composer.te(key, locale);
        },
        tm(key) {
          return composer.tm(key);
        },
        getLocaleMessage(locale) {
          return composer.getLocaleMessage(locale);
        },
        setLocaleMessage(locale, message) {
          composer.setLocaleMessage(locale, message);
        },
        mergeLocaleMessage(locale, message) {
          composer.mergeLocaleMessage(locale, message);
        },
        d(...args) {
          return Reflect.apply(composer.d, composer, [...args]);
        },
        getDateTimeFormat(locale) {
          return composer.getDateTimeFormat(locale);
        },
        setDateTimeFormat(locale, format2) {
          composer.setDateTimeFormat(locale, format2);
        },
        mergeDateTimeFormat(locale, format2) {
          composer.mergeDateTimeFormat(locale, format2);
        },
        n(...args) {
          return Reflect.apply(composer.n, composer, [...args]);
        },
        getNumberFormat(locale) {
          return composer.getNumberFormat(locale);
        },
        setNumberFormat(locale, format2) {
          composer.setNumberFormat(locale, format2);
        },
        mergeNumberFormat(locale, format2) {
          composer.mergeNumberFormat(locale, format2);
        },
        getChoiceIndex(choice, choicesLength) {
          return -1;
        }
      };
      vueI18n.__extender = __extender;
      return vueI18n;
    }
  }
  const baseFormatProps = {
    tag: {
      type: [String, Object]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (val) => val === "parent" || val === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  function getInterpolateArg({ slots }, keys) {
    if (keys.length === 1 && keys[0] === "default") {
      const ret = slots.default ? slots.default() : [];
      return ret.reduce((slot, current) => {
        return [
          ...slot,
          ...current.type === Fragment ? current.children : [current]
        ];
      }, []);
    } else {
      return keys.reduce((arg, key) => {
        const slot = slots[key];
        if (slot) {
          arg[key] = slot();
        }
        return arg;
      }, {});
    }
  }
  function getFragmentableTag(tag) {
    return Fragment;
  }
  const TranslationImpl = /* @__PURE__ */ defineComponent({
    name: "i18n-t",
    props: assign$3({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [Number, String],
        validator: (val) => isNumber$1(val) || !isNaN(val)
      }
    }, baseFormatProps),
    setup(props, context) {
      const { slots, attrs } = context;
      const i18n2 = props.i18n || useI18n({
        useScope: props.scope,
        __useComponent: true
      });
      return () => {
        const keys = Object.keys(slots).filter((key) => key !== "_");
        const options = {};
        if (props.locale) {
          options.locale = props.locale;
        }
        if (props.plural !== void 0) {
          options.plural = isString$2(props.plural) ? +props.plural : props.plural;
        }
        const arg = getInterpolateArg(context, keys);
        const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
        const assignedAttrs = assign$3({}, attrs);
        const tag = isString$2(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
        return h(tag, assignedAttrs, children);
      };
    }
  });
  const Translation = TranslationImpl;
  function isVNode(target) {
    return isArray$1(target) && !isString$2(target[0]);
  }
  function renderFormatter(props, context, slotKeys, partFormatter) {
    const { slots, attrs } = context;
    return () => {
      const options = { part: true };
      let overrides = {};
      if (props.locale) {
        options.locale = props.locale;
      }
      if (isString$2(props.format)) {
        options.key = props.format;
      } else if (isObject$3(props.format)) {
        if (isString$2(props.format.key)) {
          options.key = props.format.key;
        }
        overrides = Object.keys(props.format).reduce((options2, prop) => {
          return slotKeys.includes(prop) ? assign$3({}, options2, { [prop]: props.format[prop] }) : options2;
        }, {});
      }
      const parts = partFormatter(...[props.value, options, overrides]);
      let children = [options.key];
      if (isArray$1(parts)) {
        children = parts.map((part, index) => {
          const slot = slots[part.type];
          const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
          if (isVNode(node)) {
            node[0].key = `${part.type}-${index}`;
          }
          return node;
        });
      } else if (isString$2(parts)) {
        children = [parts];
      }
      const assignedAttrs = assign$3({}, attrs);
      const tag = isString$2(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
  const NumberFormatImpl = /* @__PURE__ */ defineComponent({
    name: "i18n-n",
    props: assign$3({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    setup(props, context) {
      const i18n2 = props.i18n || useI18n({
        useScope: "parent",
        __useComponent: true
      });
      return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => i18n2[NumberPartsSymbol](...args));
    }
  });
  const NumberFormat = NumberFormatImpl;
  const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
    name: "i18n-d",
    props: assign$3({
      value: {
        type: [Number, Date],
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    setup(props, context) {
      const i18n2 = props.i18n || useI18n({
        useScope: "parent",
        __useComponent: true
      });
      return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => i18n2[DatetimePartsSymbol](...args));
    }
  });
  const DatetimeFormat = DatetimeFormatImpl;
  function getComposer$2(i18n2, instance) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      return i18nInternal.__getInstance(instance) || i18n2.global;
    } else {
      const vueI18n = i18nInternal.__getInstance(instance);
      return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
    }
  }
  function vTDirective(i18n2) {
    const _process = (binding) => {
      const { instance, modifiers, value } = binding;
      if (!instance || !instance.$) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const composer = getComposer$2(i18n2, instance.$);
      const parsedValue = parseValue(value);
      return [
        Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
        composer
      ];
    };
    const register = (el, binding) => {
      const [textContent, composer] = _process(binding);
      if (inBrowser && i18n2.global === composer) {
        el.__i18nWatcher = watch(composer.locale, () => {
          binding.instance && binding.instance.$forceUpdate();
        });
      }
      el.__composer = composer;
      el.textContent = textContent;
    };
    const unregister = (el) => {
      if (inBrowser && el.__i18nWatcher) {
        el.__i18nWatcher();
        el.__i18nWatcher = void 0;
        delete el.__i18nWatcher;
      }
      if (el.__composer) {
        el.__composer = void 0;
        delete el.__composer;
      }
    };
    const update = (el, { value }) => {
      if (el.__composer) {
        const composer = el.__composer;
        const parsedValue = parseValue(value);
        el.textContent = Reflect.apply(composer.t, composer, [
          ...makeParams(parsedValue)
        ]);
      }
    };
    const getSSRProps = (binding) => {
      const [textContent] = _process(binding);
      return { textContent };
    };
    return {
      created: register,
      unmounted: unregister,
      beforeUpdate: update,
      getSSRProps
    };
  }
  function parseValue(value) {
    if (isString$2(value)) {
      return { path: value };
    } else if (isPlainObject$2(value)) {
      if (!("path" in value)) {
        throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
      }
      return value;
    } else {
      throw createI18nError(I18nErrorCodes.INVALID_VALUE);
    }
  }
  function makeParams(value) {
    const { path, locale, args, choice, plural } = value;
    const options = {};
    const named = args || {};
    if (isString$2(locale)) {
      options.locale = locale;
    }
    if (isNumber$1(choice)) {
      options.plural = choice;
    }
    if (isNumber$1(plural)) {
      options.plural = plural;
    }
    return [path, named, options];
  }
  function apply(app2, i18n2, ...options) {
    const pluginOptions = isPlainObject$2(options[0]) ? options[0] : {};
    const useI18nComponentName = !!pluginOptions.useI18nComponentName;
    const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
    if (globalInstall) {
      [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
      [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
      [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
    }
    {
      app2.directive("t", vTDirective(i18n2));
    }
  }
  function defineMixin(vuei18n, composer, i18n2) {
    return {
      beforeCreate() {
        const instance = getCurrentInstance();
        if (!instance) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const options = this.$options;
        if (options.i18n) {
          const optionsI18n = options.i18n;
          if (options.__i18n) {
            optionsI18n.__i18n = options.__i18n;
          }
          optionsI18n.__root = composer;
          if (this === this.$root) {
            this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
          } else {
            optionsI18n.__injectWithOption = true;
            optionsI18n.__extender = i18n2.__vueI18nExtend;
            this.$i18n = createVueI18n(optionsI18n);
            const _vueI18n = this.$i18n;
            if (_vueI18n.__extender) {
              _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
            }
          }
        } else if (options.__i18n) {
          if (this === this.$root) {
            this.$i18n = mergeToGlobal(vuei18n, options);
          } else {
            this.$i18n = createVueI18n({
              __i18n: options.__i18n,
              __injectWithOption: true,
              __extender: i18n2.__vueI18nExtend,
              __root: composer
            });
            const _vueI18n = this.$i18n;
            if (_vueI18n.__extender) {
              _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
            }
          }
        } else {
          this.$i18n = vuei18n;
        }
        if (options.__i18nGlobal) {
          adjustI18nResources(composer, options, options);
        }
        this.$t = (...args) => this.$i18n.t(...args);
        this.$rt = (...args) => this.$i18n.rt(...args);
        this.$tc = (...args) => this.$i18n.tc(...args);
        this.$te = (key, locale) => this.$i18n.te(key, locale);
        this.$d = (...args) => this.$i18n.d(...args);
        this.$n = (...args) => this.$i18n.n(...args);
        this.$tm = (key) => this.$i18n.tm(key);
        i18n2.__setInstance(instance, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const instance = getCurrentInstance();
        if (!instance) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const _vueI18n = this.$i18n;
        delete this.$t;
        delete this.$rt;
        delete this.$tc;
        delete this.$te;
        delete this.$d;
        delete this.$n;
        delete this.$tm;
        if (_vueI18n.__disposer) {
          _vueI18n.__disposer();
          delete _vueI18n.__disposer;
          delete _vueI18n.__extender;
        }
        i18n2.__deleteInstance(instance);
        delete this.$i18n;
      }
    };
  }
  function mergeToGlobal(g, options) {
    g.locale = options.locale || g.locale;
    g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
    g.missing = options.missing || g.missing;
    g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
    g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
    g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
    g.postTranslation = options.postTranslation || g.postTranslation;
    g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
    g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
    g.sync = options.sync || g.sync;
    g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
    const messages2 = getLocaleMessages(g.locale, {
      messages: options.messages,
      __i18n: options.__i18n
    });
    Object.keys(messages2).forEach((locale) => g.mergeLocaleMessage(locale, messages2[locale]));
    if (options.datetimeFormats) {
      Object.keys(options.datetimeFormats).forEach((locale) => g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
    }
    if (options.numberFormats) {
      Object.keys(options.numberFormats).forEach((locale) => g.mergeNumberFormat(locale, options.numberFormats[locale]));
    }
    return g;
  }
  const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
  function createI18n(options = {}, VueI18nLegacy) {
    const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
    const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
    const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
    const __instances = /* @__PURE__ */ new Map();
    const [globalScope, __global] = createGlobal(options, __legacyMode);
    const symbol = /* @__PURE__ */ makeSymbol("");
    function __getInstance(component) {
      return __instances.get(component) || null;
    }
    function __setInstance(component, instance) {
      __instances.set(component, instance);
    }
    function __deleteInstance(component) {
      __instances.delete(component);
    }
    {
      const i18n2 = {
        get mode() {
          return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
        },
        get allowComposition() {
          return __allowComposition;
        },
        async install(app2, ...options2) {
          app2.__VUE_I18N_SYMBOL__ = symbol;
          app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
          if (isPlainObject$2(options2[0])) {
            const opts = options2[0];
            i18n2.__composerExtend = opts.__composerExtend;
            i18n2.__vueI18nExtend = opts.__vueI18nExtend;
          }
          let globalReleaseHandler = null;
          if (!__legacyMode && __globalInjection) {
            globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
          }
          if (__VUE_I18N_FULL_INSTALL__) {
            apply(app2, i18n2, ...options2);
          }
          if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
            app2.mixin(defineMixin(__global, __global.__composer, i18n2));
          }
          const unmountApp = app2.unmount;
          app2.unmount = () => {
            globalReleaseHandler && globalReleaseHandler();
            i18n2.dispose();
            unmountApp();
          };
        },
        get global() {
          return __global;
        },
        dispose() {
          globalScope.stop();
        },
        __instances,
        __getInstance,
        __setInstance,
        __deleteInstance
      };
      return i18n2;
    }
  }
  function useI18n(options = {}) {
    const instance = getCurrentInstance();
    if (instance == null) {
      throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
    }
    if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
      throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
    }
    const i18n2 = getI18nInstance(instance);
    const gl = getGlobalComposer(i18n2);
    const componentOptions = getComponentOptions(instance);
    const scope = getScope(options, componentOptions);
    if (__VUE_I18N_LEGACY_API__) {
      if (i18n2.mode === "legacy" && !options.__useComponent) {
        if (!i18n2.allowComposition) {
          throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
        }
        return useI18nForLegacy(instance, scope, gl, options);
      }
    }
    if (scope === "global") {
      adjustI18nResources(gl, options, componentOptions);
      return gl;
    }
    if (scope === "parent") {
      let composer2 = getComposer(i18n2, instance, options.__useComponent);
      if (composer2 == null) {
        composer2 = gl;
      }
      return composer2;
    }
    const i18nInternal = i18n2;
    let composer = i18nInternal.__getInstance(instance);
    if (composer == null) {
      const composerOptions = assign$3({}, options);
      if ("__i18n" in componentOptions) {
        composerOptions.__i18n = componentOptions.__i18n;
      }
      if (gl) {
        composerOptions.__root = gl;
      }
      composer = createComposer(composerOptions);
      if (i18nInternal.__composerExtend) {
        composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
      }
      setupLifeCycle(i18nInternal, instance, composer);
      i18nInternal.__setInstance(instance, composer);
    }
    return composer;
  }
  function createGlobal(options, legacyMode, VueI18nLegacy) {
    const scope = effectScope();
    {
      const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
      if (obj == null) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      return [scope, obj];
    }
  }
  function getI18nInstance(instance) {
    {
      const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
      if (!i18n2) {
        throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
      }
      return i18n2;
    }
  }
  function getScope(options, componentOptions) {
    return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
  }
  function getGlobalComposer(i18n2) {
    return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  }
  function getComposer(i18n2, target, useComponent = false) {
    let composer = null;
    const root2 = target.root;
    let current = getParentComponentInstance(target, useComponent);
    while (current != null) {
      const i18nInternal = i18n2;
      if (i18n2.mode === "composition") {
        composer = i18nInternal.__getInstance(current);
      } else {
        if (__VUE_I18N_LEGACY_API__) {
          const vueI18n = i18nInternal.__getInstance(current);
          if (vueI18n != null) {
            composer = vueI18n.__composer;
            if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
              composer = null;
            }
          }
        }
      }
      if (composer != null) {
        break;
      }
      if (root2 === current) {
        break;
      }
      current = current.parent;
    }
    return composer;
  }
  function getParentComponentInstance(target, useComponent = false) {
    if (target == null) {
      return null;
    }
    {
      return !useComponent ? target.parent : target.vnode.ctx || target.parent;
    }
  }
  function setupLifeCycle(i18n2, target, composer) {
    {
      onMounted(() => {
      }, target);
      onUnmounted(() => {
        const _composer = composer;
        i18n2.__deleteInstance(target);
        const dispose = _composer[DisposeSymbol];
        if (dispose) {
          dispose();
          delete _composer[DisposeSymbol];
        }
      }, target);
    }
  }
  function useI18nForLegacy(instance, scope, root2, options = {}) {
    const isLocalScope = scope === "local";
    const _composer = shallowRef(null);
    if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
      throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    }
    const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$2(options.locale);
    const _locale = ref(!isLocalScope || _inheritLocale ? root2.locale.value : isString$2(options.locale) ? options.locale : DEFAULT_LOCALE);
    const _fallbackLocale = ref(!isLocalScope || _inheritLocale ? root2.fallbackLocale.value : isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);
    const _messages = ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = ref(isPlainObject$2(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = ref(isPlainObject$2(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    const _missingWarn = isLocalScope ? root2.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    const _fallbackWarn = isLocalScope ? root2.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    const _fallbackRoot = isLocalScope ? root2.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    const _fallbackFormat = !!options.fallbackFormat;
    const _missing = isFunction$1(options.missing) ? options.missing : null;
    const _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    const _warnHtmlMessage = isLocalScope ? root2.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const _escapeParameter = !!options.escapeParameter;
    const _modifiers = isLocalScope ? root2.modifiers : isPlainObject$2(options.modifiers) ? options.modifiers : {};
    const _pluralRules = options.pluralRules || isLocalScope && root2.pluralRules;
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale = computed({
      get: () => {
        return _composer.value ? _composer.value.locale.value : _locale.value;
      },
      set: (val) => {
        if (_composer.value) {
          _composer.value.locale.value = val;
        }
        _locale.value = val;
      }
    });
    const fallbackLocale = computed({
      get: () => {
        return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
      },
      set: (val) => {
        if (_composer.value) {
          _composer.value.fallbackLocale.value = val;
        }
        _fallbackLocale.value = val;
      }
    });
    const messages2 = computed(() => {
      if (_composer.value) {
        return _composer.value.messages.value;
      } else {
        return _messages.value;
      }
    });
    const datetimeFormats = computed(() => _datetimeFormats.value);
    const numberFormats = computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
    }
    function setPostTranslationHandler(handler) {
      if (_composer.value) {
        _composer.value.setPostTranslationHandler(handler);
      }
    }
    function getMissingHandler() {
      return _composer.value ? _composer.value.getMissingHandler() : _missing;
    }
    function setMissingHandler(handler) {
      if (_composer.value) {
        _composer.value.setMissingHandler(handler);
      }
    }
    function warpWithDeps(fn) {
      trackReactivityValues();
      return fn();
    }
    function t(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
    }
    function rt(...args) {
      return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
    }
    function d(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
    }
    function n(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
    }
    function tm(key) {
      return _composer.value ? _composer.value.tm(key) : {};
    }
    function te(key, locale2) {
      return _composer.value ? _composer.value.te(key, locale2) : false;
    }
    function getLocaleMessage(locale2) {
      return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
    }
    function setLocaleMessage(locale2, message) {
      if (_composer.value) {
        _composer.value.setLocaleMessage(locale2, message);
        _messages.value[locale2] = message;
      }
    }
    function mergeLocaleMessage(locale2, message) {
      if (_composer.value) {
        _composer.value.mergeLocaleMessage(locale2, message);
      }
    }
    function getDateTimeFormat(locale2) {
      return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
    }
    function setDateTimeFormat(locale2, format2) {
      if (_composer.value) {
        _composer.value.setDateTimeFormat(locale2, format2);
        _datetimeFormats.value[locale2] = format2;
      }
    }
    function mergeDateTimeFormat(locale2, format2) {
      if (_composer.value) {
        _composer.value.mergeDateTimeFormat(locale2, format2);
      }
    }
    function getNumberFormat(locale2) {
      return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
    }
    function setNumberFormat(locale2, format2) {
      if (_composer.value) {
        _composer.value.setNumberFormat(locale2, format2);
        _numberFormats.value[locale2] = format2;
      }
    }
    function mergeNumberFormat(locale2, format2) {
      if (_composer.value) {
        _composer.value.mergeNumberFormat(locale2, format2);
      }
    }
    const wrapper = {
      get id() {
        return _composer.value ? _composer.value.id : -1;
      },
      locale,
      fallbackLocale,
      messages: messages2,
      datetimeFormats,
      numberFormats,
      get inheritLocale() {
        return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
      },
      set inheritLocale(val) {
        if (_composer.value) {
          _composer.value.inheritLocale = val;
        }
      },
      get availableLocales() {
        return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
      },
      get modifiers() {
        return _composer.value ? _composer.value.modifiers : _modifiers;
      },
      get pluralRules() {
        return _composer.value ? _composer.value.pluralRules : _pluralRules;
      },
      get isGlobal() {
        return _composer.value ? _composer.value.isGlobal : false;
      },
      get missingWarn() {
        return _composer.value ? _composer.value.missingWarn : _missingWarn;
      },
      set missingWarn(val) {
        if (_composer.value) {
          _composer.value.missingWarn = val;
        }
      },
      get fallbackWarn() {
        return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
      },
      set fallbackWarn(val) {
        if (_composer.value) {
          _composer.value.missingWarn = val;
        }
      },
      get fallbackRoot() {
        return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
      },
      set fallbackRoot(val) {
        if (_composer.value) {
          _composer.value.fallbackRoot = val;
        }
      },
      get fallbackFormat() {
        return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
      },
      set fallbackFormat(val) {
        if (_composer.value) {
          _composer.value.fallbackFormat = val;
        }
      },
      get warnHtmlMessage() {
        return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        if (_composer.value) {
          _composer.value.warnHtmlMessage = val;
        }
      },
      get escapeParameter() {
        return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
      },
      set escapeParameter(val) {
        if (_composer.value) {
          _composer.value.escapeParameter = val;
        }
      },
      t,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      rt,
      d,
      n,
      tm,
      te,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getDateTimeFormat,
      setDateTimeFormat,
      mergeDateTimeFormat,
      getNumberFormat,
      setNumberFormat,
      mergeNumberFormat
    };
    function sync(composer) {
      composer.locale.value = _locale.value;
      composer.fallbackLocale.value = _fallbackLocale.value;
      Object.keys(_messages.value).forEach((locale2) => {
        composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
      });
      Object.keys(_datetimeFormats.value).forEach((locale2) => {
        composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
      });
      Object.keys(_numberFormats.value).forEach((locale2) => {
        composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
      });
      composer.escapeParameter = _escapeParameter;
      composer.fallbackFormat = _fallbackFormat;
      composer.fallbackRoot = _fallbackRoot;
      composer.fallbackWarn = _fallbackWarn;
      composer.missingWarn = _missingWarn;
      composer.warnHtmlMessage = _warnHtmlMessage;
    }
    onBeforeMount(() => {
      if (instance.proxy == null || instance.proxy.$i18n == null) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
      }
      const composer = _composer.value = instance.proxy.$i18n.__composer;
      if (scope === "global") {
        _locale.value = composer.locale.value;
        _fallbackLocale.value = composer.fallbackLocale.value;
        _messages.value = composer.messages.value;
        _datetimeFormats.value = composer.datetimeFormats.value;
        _numberFormats.value = composer.numberFormats.value;
      } else if (isLocalScope) {
        sync(composer);
      }
    });
    return wrapper;
  }
  const globalExportProps = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ];
  const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
  function injectGlobalFields(app2, composer) {
    const i18n2 = /* @__PURE__ */ Object.create(null);
    globalExportProps.forEach((prop) => {
      const desc = Object.getOwnPropertyDescriptor(composer, prop);
      if (!desc) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const wrap = isRef(desc.value) ? {
        get() {
          return desc.value.value;
        },
        set(val) {
          desc.value.value = val;
        }
      } : {
        get() {
          return desc.get && desc.get();
        }
      };
      Object.defineProperty(i18n2, prop, wrap);
    });
    app2.config.globalProperties.$i18n = i18n2;
    globalExportMethods.forEach((method) => {
      const desc = Object.getOwnPropertyDescriptor(composer, method);
      if (!desc || !desc.value) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
    });
    const dispose = () => {
      delete app2.config.globalProperties.$i18n;
      globalExportMethods.forEach((method) => {
        delete app2.config.globalProperties[`$${method}`];
      });
    };
    return dispose;
  }
  {
    initFeatureFlags();
  }
  {
    registerMessageCompiler(compile);
  }
  registerMessageResolver(resolveValue);
  registerLocaleFallbacker(fallbackWithLocaleChain);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const target = getGlobalThis();
    target.__INTLIFY__ = true;
    setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  var isVue2 = false;
  /*!
    * pinia v2.0.14
    * (c) 2022 Eduardo San Martin Morote
    * @license MIT
    */
  let activePinia;
  const setActivePinia = (pinia2) => activePinia = pinia2;
  const piniaSymbol = Symbol();
  function isPlainObject$1(o) {
    return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia2 = markRaw({
      install(app2) {
        setActivePinia(pinia2);
        {
          pinia2._a = app2;
          app2.provide(piniaSymbol, pinia2);
          app2.config.globalProperties.$pinia = pinia2;
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia2;
  }
  const noop$1 = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && getCurrentInstance()) {
      onUnmounted(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  function mergeReactiveObjects(target, patchToApply) {
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = Symbol();
  function shouldHydrate(obj) {
    return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign: assign$1 } = Object;
  function isComputed(o) {
    return !!(isRef(o) && o.effect);
  }
  function createOptionsStore(id, options, pinia2, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia2.state.value[id];
    let store;
    function setup() {
      if (!initialState && true) {
        {
          pinia2.state.value[id] = state ? state() : {};
        }
      }
      const localState = toRefs(pinia2.state.value[id]);
      return assign$1(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(computed(() => {
          setActivePinia(pinia2);
          const store2 = pinia2._s.get(id);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia2, hot, true);
    store.$reset = function $reset() {
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign$1($state, newState);
      });
    };
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign$1({ actions: {} }, options);
    const $subscribeOptions = {
      deep: true
    };
    let isListening;
    let isSyncListening;
    let subscriptions = markRaw([]);
    let actionSubscriptions = markRaw([]);
    let debuggerEvents;
    const initialState = pinia2.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      {
        pinia2.state.value[$id] = {};
      }
    }
    ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia2.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
    }
    const $reset = noop$1;
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia2._s.delete($id);
    }
    function wrapAction(name, action) {
      return function() {
        setActivePinia(pinia2);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name,
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const partialStore = {
      _p: pinia2,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign$1({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(assign$1({}, partialStore));
    pinia2._s.set($id, store);
    const setupStore = pinia2._e.run(() => {
      scope = effectScope();
      return scope.run(() => setup());
    });
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia2.state.value[$id][key] = prop;
          }
        }
      } else if (typeof prop === "function") {
        const actionValue = wrapAction(key, prop);
        {
          setupStore[key] = actionValue;
        }
        optionsForPlugin.actions[key] = prop;
      } else
        ;
    }
    {
      assign$1(store, setupStore);
      assign$1(toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => pinia2.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign$1($state, state);
        });
      }
    });
    pinia2._p.forEach((extender) => {
      {
        assign$1(store, scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
    }
    function useStore(pinia2, hot) {
      const currentInstance2 = getCurrentInstance();
      pinia2 = pinia2 || currentInstance2 && inject(piniaSymbol);
      if (pinia2)
        setActivePinia(pinia2);
      pinia2 = activePinia;
      if (!pinia2._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia2);
        } else {
          createOptionsStore(id, options, pinia2);
        }
      }
      const store = pinia2._s.get(id);
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  function mapState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
      reduced[key] = function() {
        return useStore(this.$pinia)[key];
      };
      return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
      reduced[key] = function() {
        const store = useStore(this.$pinia);
        const storeKey = keysOrMapper[key];
        return typeof storeKey === "function" ? storeKey.call(this, store) : store[storeKey];
      };
      return reduced;
    }, {});
  }
  function mapActions(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
      reduced[key] = function(...args) {
        return useStore(this.$pinia)[key](...args);
      };
      return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
      reduced[key] = function(...args) {
        return useStore(this.$pinia)[keysOrMapper[key]](...args);
      };
      return reduced;
    }, {});
  }
  function mapWritableState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
      reduced[key] = {
        get() {
          return useStore(this.$pinia)[key];
        },
        set(value) {
          return useStore(this.$pinia)[key] = value;
        }
      };
      return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
      reduced[key] = {
        get() {
          return useStore(this.$pinia)[keysOrMapper[key]];
        },
        set(value) {
          return useStore(this.$pinia)[keysOrMapper[key]] = value;
        }
      };
      return reduced;
    }, {});
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var axios$2 = { exports: {} };
  var bind$2 = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  var bind$1 = bind$2;
  var toString = Object.prototype.toString;
  var kindOf = function(cache2) {
    return function(thing) {
      var str = toString.call(thing);
      return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
    };
  }(/* @__PURE__ */ Object.create(null));
  function kindOfTest(type) {
    type = type.toLowerCase();
    return function isKindOf(thing) {
      return kindOf(thing) === type;
    };
  }
  function isArray(val) {
    return Array.isArray(val);
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject$1(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (kindOf(val) !== "object") {
      return false;
    }
    var prototype2 = Object.getPrototypeOf(val);
    return prototype2 === null || prototype2 === Object.prototype;
  }
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject$1(val) && isFunction(val.pipe);
  }
  function isFormData(thing) {
    var pattern = "[object FormData]";
    return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
  }
  var isURLSearchParams = kindOfTest("URLSearchParams");
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  function inherits(constructor, superConstructor, props, descriptors2) {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    props && Object.assign(constructor.prototype, props);
  }
  function toFlatObject(sourceObj, destObj, filter) {
    var props;
    var i;
    var prop;
    var merged = {};
    destObj = destObj || {};
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if (!merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = Object.getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  }
  function endsWith(str, searchString, position) {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    var lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  }
  function toArray(thing) {
    if (!thing)
      return null;
    var i = thing.length;
    if (isUndefined(i))
      return null;
    var arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  }
  var isTypedArray = function(TypedArray) {
    return function(thing) {
      return TypedArray && thing instanceof TypedArray;
    };
  }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
  var utils$h = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject: isObject$1,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    isTypedArray,
    isFileList
  };
  var utils$g = utils$h;
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$2 = function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$g.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$g.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils$g.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils$g.forEach(val, function parseValue2(v) {
          if (utils$g.isDate(v)) {
            v = v.toISOString();
          } else if (utils$g.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
  var utils$f = utils$h;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  };
  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager$1.prototype.forEach = function forEach2(fn) {
    utils$f.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  };
  var InterceptorManager_1 = InterceptorManager$1;
  var utils$e = utils$h;
  var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
    utils$e.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
  var utils$d = utils$h;
  function AxiosError$5(message, code2, config, request3, response) {
    Error.call(this);
    this.message = message;
    this.name = "AxiosError";
    code2 && (this.code = code2);
    config && (this.config = config);
    request3 && (this.request = request3);
    response && (this.response = response);
  }
  utils$d.inherits(AxiosError$5, Error, {
    toJSON: function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  var prototype = AxiosError$5.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED"
  ].forEach(function(code2) {
    descriptors[code2] = { value: code2 };
  });
  Object.defineProperties(AxiosError$5, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError$5.from = function(error, code2, config, request3, response, customProps) {
    var axiosError = Object.create(prototype);
    utils$d.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    });
    AxiosError$5.call(axiosError, error.message, code2, config, request3, response);
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var AxiosError_1 = AxiosError$5;
  var transitional = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  var utils$c = utils$h;
  function toFormData$1(obj, formData) {
    formData = formData || new FormData();
    var stack = [];
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils$c.isDate(value)) {
        return value.toISOString();
      }
      if (utils$c.isArrayBuffer(value) || utils$c.isTypedArray(value)) {
        return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function build(data2, parentKey) {
      if (utils$c.isPlainObject(data2) || utils$c.isArray(data2)) {
        if (stack.indexOf(data2) !== -1) {
          throw Error("Circular reference detected in " + parentKey);
        }
        stack.push(data2);
        utils$c.forEach(data2, function each(value, key) {
          if (utils$c.isUndefined(value))
            return;
          var fullKey = parentKey ? parentKey + "." + key : key;
          var arr;
          if (value && !parentKey && typeof value === "object") {
            if (utils$c.endsWith(key, "{}")) {
              value = JSON.stringify(value);
            } else if (utils$c.endsWith(key, "[]") && (arr = utils$c.toArray(value))) {
              arr.forEach(function(el) {
                !utils$c.isUndefined(el) && formData.append(fullKey, convertValue(el));
              });
              return;
            }
          }
          build(value, fullKey);
        });
        stack.pop();
      } else {
        formData.append(parentKey, convertValue(data2));
      }
    }
    build(obj);
    return formData;
  }
  var toFormData_1 = toFormData$1;
  var AxiosError$4 = AxiosError_1;
  var settle$1 = function settle(resolve2, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError$4("Request failed with status code " + response.status, [AxiosError$4.ERR_BAD_REQUEST, AxiosError$4.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
    }
  };
  var utils$b = utils$h;
  var cookies$1 = utils$b.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils$b.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$b.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$b.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove2(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }();
  var isAbsoluteURL$1 = function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  };
  var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  var isAbsoluteURL2 = isAbsoluteURL$1;
  var combineURLs2 = combineURLs$1;
  var buildFullPath$2 = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  var utils$a = utils$h;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  var parseHeaders$1 = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils$a.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils$a.trim(line.substr(0, i)).toLowerCase();
      val = utils$a.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  var utils$9 = utils$h;
  var isURLSameOrigin$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv2() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils$9.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  var AxiosError$3 = AxiosError_1;
  var utils$8 = utils$h;
  function CanceledError$3(message) {
    AxiosError$3.call(this, message == null ? "canceled" : message, AxiosError$3.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils$8.inherits(CanceledError$3, AxiosError$3, {
    __CANCEL__: true
  });
  var CanceledError_1 = CanceledError$3;
  var parseProtocol$1 = function parseProtocol(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  };
  var utils$7 = utils$h;
  var settle2 = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath$1 = buildFullPath$2;
  var parseHeaders2 = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var transitionalDefaults$1 = transitional;
  var AxiosError$2 = AxiosError_1;
  var CanceledError$2 = CanceledError_1;
  var parseProtocol2 = parseProtocol$1;
  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils$7.isFormData(requestData) && utils$7.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request3 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath$1(config.baseURL, config.url);
      request3.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
      request3.timeout = config.timeout;
      function onloadend() {
        if (!request3) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders2(request3.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
        var response = {
          data: responseData,
          status: request3.status,
          statusText: request3.statusText,
          headers: responseHeaders,
          config,
          request: request3
        };
        settle2(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request3 = null;
      }
      if ("onloadend" in request3) {
        request3.onloadend = onloadend;
      } else {
        request3.onreadystatechange = function handleLoad() {
          if (!request3 || request3.readyState !== 4) {
            return;
          }
          if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request3.onabort = function handleAbort() {
        if (!request3) {
          return;
        }
        reject(new AxiosError$2("Request aborted", AxiosError$2.ECONNABORTED, config, request3));
        request3 = null;
      };
      request3.onerror = function handleError2() {
        reject(new AxiosError$2("Network Error", AxiosError$2.ERR_NETWORK, config, request3, request3));
        request3 = null;
      };
      request3.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional3 = config.transitional || transitionalDefaults$1;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError$2(timeoutErrorMessage, transitional3.clarifyTimeoutError ? AxiosError$2.ETIMEDOUT : AxiosError$2.ECONNABORTED, config, request3));
        request3 = null;
      };
      if (utils$7.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request3) {
        utils$7.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request3.setRequestHeader(key, val);
          }
        });
      }
      if (!utils$7.isUndefined(config.withCredentials)) {
        request3.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request3.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request3.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request3.upload) {
        request3.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request3) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError$2() : cancel);
          request3.abort();
          request3 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject(new AxiosError$2("Unsupported protocol " + protocol + ":", AxiosError$2.ERR_BAD_REQUEST, config));
        return;
      }
      request3.send(requestData);
    });
  };
  var _null = null;
  var utils$6 = utils$h;
  var normalizeHeaderName2 = normalizeHeaderName$1;
  var AxiosError$1 = AxiosError_1;
  var transitionalDefaults = transitional;
  var toFormData = toFormData_1;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils$6.isUndefined(headers) && utils$6.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = xhr;
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = xhr;
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$6.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$6.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults$3 = {
    transitional: transitionalDefaults,
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data2, headers) {
      normalizeHeaderName2(headers, "Accept");
      normalizeHeaderName2(headers, "Content-Type");
      if (utils$6.isFormData(data2) || utils$6.isArrayBuffer(data2) || utils$6.isBuffer(data2) || utils$6.isStream(data2) || utils$6.isFile(data2) || utils$6.isBlob(data2)) {
        return data2;
      }
      if (utils$6.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils$6.isURLSearchParams(data2)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data2.toString();
      }
      var isObjectPayload = utils$6.isObject(data2);
      var contentType = headers && headers["Content-Type"];
      var isFileList2;
      if ((isFileList2 = utils$6.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
        var _FormData = this.env && this.env.FormData;
        return toFormData(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
      } else if (isObjectPayload || contentType === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse(data2) {
      var transitional3 = this.transitional || defaults$3.transitional;
      var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
      var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils$6.isString(data2) && data2.length) {
        try {
          return JSON.parse(data2);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data2;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: _null
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils$6.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults$3.headers[method] = {};
  });
  utils$6.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults$3.headers[method] = utils$6.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$3;
  var utils$5 = utils$h;
  var defaults$2 = defaults_1;
  var transformData$1 = function transformData(data2, headers, fns) {
    var context = this || defaults$2;
    utils$5.forEach(fns, function transform2(fn) {
      data2 = fn.call(context, data2, headers);
    });
    return data2;
  };
  var isCancel$1 = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
  var utils$4 = utils$h;
  var transformData2 = transformData$1;
  var isCancel2 = isCancel$1;
  var defaults$1 = defaults_1;
  var CanceledError$1 = CanceledError_1;
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1();
    }
  }
  var dispatchRequest$1 = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData2.call(config, config.data, config.headers, config.transformRequest);
    config.headers = utils$4.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils$4.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults$1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData2.call(config, response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel2(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData2.call(config, reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
  var utils$3 = utils$h;
  var mergeConfig$2 = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source2) {
      if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source2)) {
        return utils$3.merge(target, source2);
      } else if (utils$3.isPlainObject(source2)) {
        return utils$3.merge({}, source2);
      } else if (utils$3.isArray(source2)) {
        return source2.slice();
      }
      return source2;
    }
    function mergeDeepProperties(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$3.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function valueFromConfig2(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      }
    }
    function defaultToConfig2(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      } else if (!utils$3.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function mergeDirectKeys(prop) {
      if (prop in config2) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    var mergeMap = {
      "url": valueFromConfig2,
      "method": valueFromConfig2,
      "data": valueFromConfig2,
      "baseURL": defaultToConfig2,
      "transformRequest": defaultToConfig2,
      "transformResponse": defaultToConfig2,
      "paramsSerializer": defaultToConfig2,
      "timeout": defaultToConfig2,
      "timeoutMessage": defaultToConfig2,
      "withCredentials": defaultToConfig2,
      "adapter": defaultToConfig2,
      "responseType": defaultToConfig2,
      "xsrfCookieName": defaultToConfig2,
      "xsrfHeaderName": defaultToConfig2,
      "onUploadProgress": defaultToConfig2,
      "onDownloadProgress": defaultToConfig2,
      "decompress": defaultToConfig2,
      "maxContentLength": defaultToConfig2,
      "maxBodyLength": defaultToConfig2,
      "beforeRedirect": defaultToConfig2,
      "transport": defaultToConfig2,
      "httpAgent": defaultToConfig2,
      "httpsAgent": defaultToConfig2,
      "cancelToken": defaultToConfig2,
      "socketPath": defaultToConfig2,
      "responseEncoding": defaultToConfig2,
      "validateStatus": mergeDirectKeys
    };
    utils$3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
      var merge2 = mergeMap[prop] || mergeDeepProperties;
      var configValue = merge2(prop);
      utils$3.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  };
  var data = {
    "version": "0.27.2"
  };
  var VERSION = data.version;
  var AxiosError = AxiosError_1;
  var validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  validators$1.transitional = function transitional2(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return function(value, opt, opts) {
      if (validator2 === false) {
        throw new AxiosError(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")), AxiosError.ERR_DEPRECATED);
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    var keys = Object.keys(options);
    var i = keys.length;
    while (i-- > 0) {
      var opt = keys[i];
      var validator2 = schema[opt];
      if (validator2) {
        var value = options[opt];
        var result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  var validator$1 = {
    assertOptions,
    validators: validators$1
  };
  var utils$2 = utils$h;
  var buildURL2 = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest2 = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  var buildFullPath2 = buildFullPath$2;
  var validator = validator$1;
  var validators = validator.validators;
  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios$1.prototype.request = function request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var transitional3 = config.transitional;
    if (transitional3 !== void 0) {
      validator.assertOptions(transitional3, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest2, void 0];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise = Promise.resolve(config);
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    }
    var newConfig = config;
    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected(error);
        break;
      }
    }
    try {
      promise = dispatchRequest2(newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    while (responseInterceptorChain.length) {
      promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise;
  };
  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    var fullPath = buildFullPath2(config.baseURL, config.url);
    return buildURL2(fullPath, config.params, config.paramsSerializer);
  };
  utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data2, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data: data2
        }));
      };
    }
    Axios$1.prototype[method] = generateHTTPMethod();
    Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios_1 = Axios$1;
  var CanceledError = CanceledError_1;
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners)
        return;
      var i;
      var l = token._listeners.length;
      for (i = 0; i < l; i++) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve2) {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  var CancelToken_1 = CancelToken;
  var spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  var utils$1 = utils$h;
  var isAxiosError = function isAxiosError2(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  };
  var utils = utils$h;
  var bind2 = bind$2;
  var Axios = Axios_1;
  var mergeConfig2 = mergeConfig$2;
  var defaults = defaults_1;
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind2(Axios.prototype.request, context);
    utils.extend(instance, Axios.prototype, context);
    utils.extend(instance, context);
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig2(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios$1 = createInstance(defaults);
  axios$1.Axios = Axios;
  axios$1.CanceledError = CanceledError_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1;
  axios$1.VERSION = data.version;
  axios$1.toFormData = toFormData_1;
  axios$1.AxiosError = AxiosError_1;
  axios$1.Cancel = axios$1.CanceledError;
  axios$1.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$1.spread = spread;
  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1;
  axios$2.exports.default = axios$1;
  var axios = axios$2.exports;
  var retrieveUrl$1 = () => {
    const { afd } = useConfigStore();
    return afd.type === "id" ? afd.idUrl : afd.serialUrl;
  };
  function mitt(n) {
    return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
      var i = n.get(t);
      i ? i.push(e) : n.set(t, [e]);
    }, off: function(t, e) {
      var i = n.get(t);
      i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
    }, emit: function(t, e) {
      var i = n.get(t);
      i && i.slice().map(function(n2) {
        n2(e);
      }), (i = n.get("*")) && i.slice().map(function(n2) {
        n2(t, e);
      });
    } };
  }
  var useGtmStore = defineStore("gtmStore", {
    state: () => ({
      active: void 0
    }),
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      trackGtmEvent(event) {
        if (window.dataLayer) {
          window.dataLayer.push({ ecommerce: null });
          window.dataLayer.push(event);
        } else {
          document.addEventListener("ga:inited", () => {
            this.setData({
              active: true
            });
            window.dataLayer.push({ ecommerce: null });
            window.dataLayer.push(event);
          });
        }
      },
      trackStep(actionField) {
        const { cartItems } = useCartStore();
        const { currencyCode } = useConfigStore();
        this.trackGtmEvent({
          event: "checkoutSteps",
          ecommerce: {
            currencyCode,
            checkout: {
              actionField,
              products: cartItems
            }
          }
        });
      },
      addToCartEvent(product, quantity) {
        const { currencyCode } = useConfigStore();
        this.trackGtmEvent({
          event: "addToCart",
          ecommerce: {
            currencyCode,
            add: {
              actionField: {
                action: "add",
                list: "Shopping Basket"
              },
              products: [{
                id: product.item_id,
                name: product.name,
                price: product.price,
                quantity: quantity || 1,
                brand: product.brand,
                category: product.category_name
              }]
            }
          }
        });
      },
      removeFromCartEvent(product, quantity) {
        const { currencyCode } = useConfigStore();
        this.trackGtmEvent({
          event: "removeFromCart",
          ecommerce: {
            currencyCode,
            remove: {
              actionField: {
                action: "remove",
                list: "Shopping Basket"
              },
              products: [{
                id: product.item_id,
                name: product.name,
                price: product.price,
                quantity: quantity || 1,
                brand: product.brand,
                category: product.category_name
              }]
            }
          }
        });
      }
    }
  });
  var getBaseUrl = () => {
    const { location: { hostname, origin, pathname } } = window;
    const splitPathname = pathname.split("/");
    const suffix = splitPathname[1].length === 4 ? `/${splitPathname[1]}` : "";
    return hostname === "localhost" ? "https://party.loc" : `${origin}${suffix}`;
  };
  var graphQlRequest = (request3) => {
    const { storeCode } = useConfigStore();
    const headers = {
      "content-type": "application/json"
    };
    if (storeCode) {
      headers.Store = storeCode;
    }
    return axios({
      url: `${getBaseUrl()}/graphql`,
      method: "post",
      data: { query: request3 },
      headers
    }).then((response) => response.data);
  };
  var getStoreConfig = (configs = []) => {
    const request3 = `{
    storeConfig {
      ${configs.join(" ")}
    }
  }`;
    return graphQlRequest(request3).then((response) => {
      var _a;
      return (_a = response.data) == null ? void 0 : _a.storeConfig;
    });
  };
  var tokenTypes = {
    authKey: "AUTHKEY",
    guestUser: "GUESTUSER",
    phpSessionId: "PHPSESSIONID"
  };
  var getBaseRestUrl = () => {
    const { storeCode } = useConfigStore();
    return `${getBaseUrl()}/rest/${storeCode}/V1`;
  };
  var buildCartUrl = (path, prefix = "") => {
    const { customer: { token, tokenType } } = useCustomerStore();
    const builtPath = tokenType === tokenTypes.guestUser ? `/guest-carts/${token}/${path}` : `/carts/mine/${path}`;
    return `${getBaseRestUrl()}${prefix}${builtPath}`;
  };
  var authenticatedRequest = () => {
    const instance = axios.create({
      baseURL: getBaseRestUrl()
    });
    instance.interceptors.request.use((config) => {
      const { customer: { token, tokenType } } = useCustomerStore();
      const customConfig = config;
      customConfig.headers["X-Requested-With"] = "XMLHttpRequest";
      if (tokenType === tokenTypes.authKey) {
        customConfig.headers.Authorization = `Bearer ${token}`;
      } else if (tokenType === tokenTypes.phpSessionId || tokenType === tokenTypes.guestUser) {
        customConfig.withCredentials = true;
      }
      return customConfig;
    }, (error) => Promise.reject(error));
    return instance;
  };
  const getAccessToken = () => {
    const configStore = useConfigStore();
    const { adyenAuthToken } = configStore;
    if (adyenAuthToken) {
      return adyenAuthToken;
    }
    const customerStore = useCustomerStore();
    const { customer: { token, tokenType } } = customerStore;
    return tokenType === tokenTypes.authKey ? token : null;
  };
  var getAdyenAuthenticatedRequest = (method, url, params) => {
    const accessToken = getAccessToken();
    const options = accessToken ? {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    } : {
      headers: {}
    };
    options.headers["X-Requested-With"] = "XMLHttpRequest";
    return axios[method](url, params, options);
  };
  var getAdyenPaymentMethods = () => {
    const { customer: { tokenType } } = useCustomerStore();
    const guestUrl = buildCartUrl("retrieve-adyen-payment-methods");
    const authUrl = `${getBaseRestUrl()}/internal/carts/mine/retrieve-adyen-payment-methods`;
    const request3 = tokenType === tokenTypes.guestUser ? getAdyenAuthenticatedRequest("post", guestUrl) : authenticatedRequest().post(authUrl, { formKey: "" });
    return request3.then((response) => {
      const { paymentMethodsResponse } = JSON.parse(response.data);
      return paymentMethodsResponse;
    });
  };
  var getPaymentInformation = () => authenticatedRequest().get(buildCartUrl("payment-information")).then((response) => response.data);
  var getAdyenProductionMode = () => {
    const { adyenEnvironmentMode } = useConfigStore();
    return adyenEnvironmentMode === "live";
  };
  var usePaymentStore = defineStore("paymentStore", {
    state: () => ({
      methodsResponse: [],
      loadingPaymentMethods: false,
      clientKey: "",
      cache: {},
      errorMessage: "",
      rvvupErrorMessage: "",
      paymentEmitter: mitt(),
      availableMethods: []
    }),
    getters: {
      methodsResponse: (state) => state.methodsResponse,
      clientKey: (state) => state.clientKey,
      isPaymentMethodAvailable: (state) => (paymentMethod) => state.availableMethods.some(({ code: code2 }) => code2 === paymentMethod)
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      async getPaymentMethodsResponse() {
        this.loadingPaymentMethods = true;
        const request3 = async () => getAdyenPaymentMethods();
        const getPaymentMethodsResponse = await this.getCachedResponse(request3, "getAdyenPaymentMethods");
        this.loadingPaymentMethods = false;
        return getPaymentMethodsResponse;
      },
      async getAdyenClientKey() {
        if (this.clientKey) {
          return this.clientKey;
        }
        this.loadingPaymentMethods = true;
        const config = getAdyenProductionMode() ? "adyen_client_key_live" : "adyen_client_key_test";
        const getPaymentMethodsResponse = await this.getCachedResponse(getStoreConfig, "getAdyenClientKey", [config]);
        this.$patch({ clientKey: getPaymentMethodsResponse[config] });
        this.loadingPaymentMethods = false;
        return getPaymentMethodsResponse[config];
      },
      setErrorMessage(message) {
        this.setData({
          errorMessage: message
        });
      },
      setRvvupErrorMessage(message) {
        this.setData({
          rvvupErrorMessage: message
        });
      },
      async getPaymentMethods() {
        const { payment_methods: paymentMethods } = await this.getCachedResponse(getPaymentInformation, "getPaymentInformation");
        this.setPaymentMethods(paymentMethods);
      },
      setPaymentMethods(paymentMethods) {
        this.setData({
          availableMethods: paymentMethods
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearPaymentReponseCache() {
        this.clearCaches(["getAdyenPaymentMethods", "getPaymentInformation"]);
      },
      clearCaches(cacheKeys) {
        if (cacheKeys.length) {
          cacheKeys.forEach((cacheKey) => {
            this.setData({
              cache: {
                [cacheKey]: void 0
              }
            });
          });
        }
      }
    }
  });
  var useStepsStore = defineStore("stepsStore", {
    state: () => ({
      yourDetailsActive: true,
      shippingActive: false,
      paymentActive: false
    }),
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      goToYouDetails() {
        this.setData({
          yourDetailsActive: true,
          shippingActive: false,
          paymentActive: false
        });
        this.$router.push("/");
      },
      goToShipping() {
        const { isItemRequiringDelivery } = useCartStore();
        if (isItemRequiringDelivery) {
          this.setData({
            yourDetailsActive: true,
            shippingActive: true,
            paymentActive: false
          });
          this.$router.push("/shipping");
        } else {
          this.goToPayment();
        }
      },
      goToPayment() {
        this.setData({
          yourDetailsActive: true,
          shippingActive: true,
          paymentActive: true
        });
        this.$router.push("/payments");
      }
    }
  });
  var cleanAddress = (address, removeSave = false) => {
    if (!address)
      return false;
    const cleanedAddress = address;
    const keysToRemove = [
      "customer_id",
      "default_shipping",
      "default_billing",
      "editing"
    ];
    keysToRemove.forEach((element) => {
      delete cleanedAddress[element];
    });
    if (cleanedAddress.region && cleanedAddress.region.region) {
      cleanedAddress.region = cleanedAddress.region.region;
    }
    if (removeSave) {
      delete cleanedAddress.save_in_address_book;
    }
    return cleanedAddress;
  };
  var lodash_clonedeep = { exports: {} };
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set2, value) {
      set2.add(value);
      return set2;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue2(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
    var coreJsData = root2["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    var objectToString2 = objectProto2.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
    }
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
    }
    function hashSet(key, value) {
      var data2 = this.__data__;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      return index < 0 ? void 0 : data2[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        data2.push([key, value]);
      } else {
        data2[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache2 = this.__data__;
      if (cache2 instanceof ListCache) {
        var pairs = cache2.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache2 = this.__data__ = new MapCache(pairs);
      }
      cache2.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source2) {
      return object && copyObject(source2, keys(source2), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject2(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString2.call(value);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
      return arrayReduce(array, addSetEntry, new set2.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source2, array) {
      var index = -1, length = source2.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source2[index];
      }
      return array;
    }
    function copyObject(source2, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
        assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
      }
      return object;
    }
    function copySymbols(source2, object) {
      return copyObject(source2, getSymbols(source2), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data2 = map.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function getNative(object, key) {
      var value = getValue2(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString2.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag2:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep2(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    var isBuffer2 = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      var tag = isObject2(value) ? objectToString2.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep2;
  })(lodash_clonedeep, lodash_clonedeep.exports);
  var cloneDeep = lodash_clonedeep.exports;
  var deepClone = (object) => cloneDeep(object);
  var doAddressesMatch = (address1, address2) => {
    const properties = [
      "city",
      "country_id",
      "firstname",
      "lastname",
      "postcode",
      "telephone"
    ];
    const same = properties.every((property) => address1[property] === address2[property]);
    if (!same) {
      return false;
    }
    const steetSame = address1.street.every((element, index) => address1.street[index] === address2.street[index]);
    return steetSame;
  };
  var afterSubmittingShippingInformation = () => {
  };
  var getDummyShippingMethods = () => [
    {
      carrier_code: "freeshipping",
      method_code: "freeshipping",
      carrier_title: "Free Shipping",
      method_title: "Free",
      amount: 0,
      base_amount: 0,
      available: true,
      error_message: "",
      price_excl_tax: 0,
      price_incl_tax: 0
    },
    {
      carrier_code: "flatrate",
      method_code: "flatrate",
      carrier_title: "Flat Rate",
      method_title: "Fixed",
      amount: 15,
      base_amount: 15,
      available: true,
      error_message: "",
      price_excl_tax: 15,
      price_incl_tax: 15
    }
  ];
  var formatAddress = (address) => {
    const formattedAddress = address;
    delete formattedAddress.id;
    delete formattedAddress.default_shipping;
    delete formattedAddress.default_billing;
    const { region } = formattedAddress;
    if (region && typeof region !== "string") {
      delete formattedAddress.region;
    }
    return formattedAddress;
  };
  var getShippingExtensionAttributes = () => {
    const { selectedMethod, nominatedSelectedDate, amastyClickAndCollectData } = useShippingMethodsStore();
    const attributes = {};
    if (selectedMethod.method_code === "nominated_delivery") {
      attributes.delivery_date = nominatedSelectedDate ? nominatedSelectedDate.toLocaleDateString("en-us") : false;
    }
    if (selectedMethod.method_code === "amstorepickup") {
      attributes.am_pickup = amastyClickAndCollectData;
    }
    return attributes;
  };
  var setShippingInformation = ({
    shippingAddress,
    billingAddress,
    carrierCode,
    methodCode
  }) => {
    const extensionAttributes = getShippingExtensionAttributes();
    const formattedBillingAddress = formatAddress(billingAddress);
    delete formattedBillingAddress.same_as_shipping;
    if (doAddressesMatch(shippingAddress, billingAddress)) {
      delete formattedBillingAddress.save_in_address_book;
    }
    return authenticatedRequest().post(buildCartUrl("shipping-information"), {
      addressInformation: {
        shipping_address: formatAddress(shippingAddress),
        billing_address: formattedBillingAddress,
        extension_attributes: extensionAttributes,
        shipping_carrier_code: carrierCode,
        shipping_method_code: methodCode
      }
    }).then((response) => response.data);
  };
  var getShippingMethods = (shippingAddress) => {
    const formattedShippingAddress = formatAddress(shippingAddress);
    return authenticatedRequest().post(buildCartUrl("estimate-shipping-methods"), {
      address: formattedShippingAddress
    }).then((response) => response.data.length ? response.data.filter((shippingMethod) => shippingMethod.available) : []);
  };
  var getNominatedDates = (postcode) => authenticatedRequest().get("/nominated-delivery", {
    address: {
      country_id: " ",
      postcode
    }
  }).then((response) => response.data);
  var setClickAndCollectAgent = (agentId) => {
    const request3 = `
    mutation {
      CollectPlusUpdateAgent(agent_id: "${agentId}")
    }`;
    return graphQlRequest(request3);
  };
  var updateAmastyClickCollectStores = async (radius, lat, lng) => {
    const cartStore = useCartStore();
    const cartData = await cartStore.getCartData();
    const headers = {
      "X-Requested-With": "XMLHttpRequest"
    };
    const data2 = `lat=${lat}&lng=${lng}&radius=${Number(radius)}&product=0&category=0&sortByDistance=1`;
    return axios.post(`${cartData.store_pickup.map_data.ajax_call_url}`, data2, { headers }).then((response) => JSON.parse(response.data));
  };
  var useShippingMethodsStore = defineStore("shippingMethodsStore", {
    state: () => ({
      shippingMethods: getDummyShippingMethods(),
      loadingShippingMethods: false,
      nominatedDayEnabled: false,
      nominatedDates: false,
      nominatedSelectedMethod: false,
      nominatedSelectedDate: false,
      nominatedSelectedDateFormatted: false,
      selectedMethod: getDummyShippingMethods()[0],
      cache: {},
      isClickAndCollect: false,
      clickAndCollectLocation: {},
      amastyClickAndCollectData: {},
      amastySelectedStore: null,
      amastyClickCollectUpdatedStores: {}
    }),
    getters: {
      getError: (state) => state.shippingMethods.filter((rate) => rate.error_message !== "")[0]
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      setShippingMethods(shippingMethods) {
        this.setData({
          shippingMethods
        });
        return shippingMethods;
      },
      async getShippingMethods() {
        this.loadingShippingMethods = true;
        const customerStore = useCustomerStore();
        await this.getNominatedDeliveryMethods(customerStore.selected.shipping.postcode);
        const clonedAddress = cleanAddress({ ...customerStore.selected.shipping });
        const isValid = customerStore.validateAddress("shipping") && customerStore.validatePostcode("shipping");
        if (!isValid) {
          this.loadingShippingMethods = false;
          const stepsStore = useStepsStore();
          stepsStore.goToYouDetails();
          return;
        }
        const shippingMethods = await this.getCachedResponse(getShippingMethods, "getShippingMethods", clonedAddress);
        this.setShippingMethods(shippingMethods);
        let isMethodAvailable = false;
        if (this.selectedMethod.carrier_code) {
          isMethodAvailable = shippingMethods.find((method) => method.method_code === this.selectedMethod.method_code);
        }
        if (this.selectedMethod.carrier_code === "nominated_delivery") {
          const shippingMethodsSliced = shippingMethods.slice(0, -1);
          const cheapestFromSliced = shippingMethodsSliced.reduce((prev, curr) => prev.price_incl_tax < curr.price_incl_tax ? prev : curr, {});
          this.selectShippingMethod(cheapestFromSliced);
        }
        if (shippingMethods.length && (!isMethodAvailable || !this.selectedMethod.carrier_code)) {
          const cheapest = shippingMethods.reduce((prev, curr) => prev.price_incl_tax < curr.price_incl_tax ? prev : curr, {});
          if (cheapest.carrier_code === "nominated_delivery" || cheapest.carrier_code === "amstorepickup") {
            const shippingMethodsSliced = shippingMethods.slice(0, -1);
            const cheapestFromSliced = shippingMethodsSliced.reduce((prev, curr) => prev.price_incl_tax < curr.price_incl_tax ? prev : curr, {});
            this.selectShippingMethod(cheapestFromSliced);
          } else {
            this.selectShippingMethod(cheapest);
          }
          await this.submitShippingInfo();
        }
        this.loadingShippingMethods = false;
      },
      async getNominatedDeliveryMethods(postcode) {
        this.nominatedDates = false;
        try {
          const nominatedDates = await this.getCachedResponse(getNominatedDates, "getNominatedDeliveryMethods", postcode);
          if (nominatedDates) {
            if (Object.keys(nominatedDates) < 1) {
              this.nominatedDayEnabled = false;
              return;
            }
            this.nominatedDates = nominatedDates;
            this.nominatedDayEnabled = true;
          }
        } catch {
        }
      },
      selectShippingMethod(item) {
        if (item.carrier_code && this.$state.selectedMethod.carrier_code && item.carrier_code !== this.$state.selectedMethod.carrier_code) {
          const gtmStore = useGtmStore();
          gtmStore.trackGtmEvent({
            event: "checkoutOption",
            ecommerce: {
              checkout_option: {
                actionField: {
                  step: 2,
                  option: "shipping"
                }
              }
            }
          });
        }
        const clonedMethod = deepClone(item);
        this.$patch({
          selectedMethod: clonedMethod
        });
        this.clearSubmitShippingInfoCache();
      },
      setShippingDataFromCartData(data2) {
        if (!this.selectedMethod.carrier_code && data2.extension_attributes.shipping_assignments.length) {
          const [{ shipping }] = data2.extension_attributes.shipping_assignments;
          const { method: shippingMethod, address } = shipping;
          if (shippingMethod) {
            const char = "_";
            const count = [...shippingMethod].filter((x) => x === char).length;
            let methodArray = [];
            if (count > 1) {
              const methodItems = shippingMethod.split("_");
              const firstUnderscore = methodItems.slice(0, -2);
              const secondUnderscore = methodItems.slice(-2);
              methodArray = [
                firstUnderscore.join("_"),
                secondUnderscore.join("_")
              ];
            } else {
              methodArray = shippingMethod ? shippingMethod.split("_") : [];
            }
            const [carrierCode, methodCode] = methodArray;
            if (carrierCode && methodCode) {
              this.selectShippingMethod({
                carrier_code: carrierCode,
                method_code: methodCode
              });
            }
            if (carrierCode === "collect") {
              this.setData({
                isClickAndCollect: true
              });
            }
          }
          const customerStore = useCustomerStore();
          if (address.firstname && address.lastname) {
            if (!customerStore.$state.selected.shipping.id) {
              customerStore.setAddress(address, "shipping");
              customerStore.setEditing("shipping", false);
            }
          }
          const { billing_address: billingAddress } = data2;
          if (billingAddress.firstname && billingAddress.lastname) {
            if (!customerStore.$state.selected.billing.id) {
              customerStore.setAddress(data2.billing_address, "billing");
            }
          }
          if (!doAddressesMatch(address, billingAddress)) {
            customerStore.setAddressAsCustom("billing");
            customerStore.setData({
              selected: {
                billing: {
                  same_as_shipping: false
                }
              }
            });
          }
          if (address.email && !customerStore.$state.customer.email) {
            customerStore.setData({
              customer: {
                email: address.email
              }
            });
          }
        }
      },
      async submitShippingInfo() {
        const customerStore = useCustomerStore();
        const cartStore = useCartStore();
        const clonedShipping = cleanAddress({ ...customerStore.selected.shipping });
        const clonedBilling = cleanAddress({ ...customerStore.selected.billing });
        this.loadingShippingMethods = true;
        const { totals } = await this.getCachedResponse(setShippingInformation, "submitShippingInfo", {
          shippingAddress: clonedShipping,
          billingAddress: clonedBilling,
          carrierCode: this.selectedMethod.carrier_code,
          methodCode: this.selectedMethod.method_code
        });
        cartStore.updateTotals(totals);
        cartStore.setData({
          cache: {
            getCartTotals: totals
          }
        });
        await afterSubmittingShippingInformation();
        this.loadingShippingMethods = false;
        return totals;
      },
      async setAsClickAndCollect(agentId) {
        this.loadingShippingMethods = true;
        await setClickAndCollectAgent(agentId);
        this.loadingShippingMethods = false;
      },
      setShippingMethodTitle() {
        const cartStore = useCartStore();
        const { totalSegments } = cartStore;
        const shippingIndex = totalSegments.findIndex((segment) => segment.code === "shipping");
        if (shippingIndex === -1) {
          return;
        }
        if (this.selectedMethod.method_title) {
          const matchingShippingTitle = totalSegments[shippingIndex].title.match(/\(([^]+)\)/);
          const formattedShippingTitle = matchingShippingTitle ? matchingShippingTitle[1] : totalSegments[shippingIndex].title;
          const title = this.selectedMethod.method_code === "nominated_delivery" ? `${this.nominatedSelectedDateFormatted}` : formattedShippingTitle;
          this.selectShippingMethod({ method_title: title });
        } else {
          const title = totalSegments[shippingIndex].title.replace(/\([^)].+ - */g, "(");
          this.selectShippingMethod({ method_title: title });
        }
      },
      async setClickAndCollect() {
        if (!this.isClickAndCollect) {
          const customerStore = useCustomerStore();
          customerStore.createNewAddress("billing");
          await customerStore.getCustomerInformation();
          customerStore.createNewAddress("shipping");
          this.setData({
            isClickAndCollect: true
          });
        }
      },
      async setNotClickAndCollect() {
        if (this.isClickAndCollect) {
          const customerStore = useCustomerStore();
          this.$state.selectedMethod = {};
          await this.setAsClickAndCollect("");
          customerStore.createNewAddress("shipping");
          customerStore.createNewAddress("billing");
          await customerStore.getCustomerInformation();
          this.setData({
            isClickAndCollect: false
          });
        }
      },
      setClickAndCollectLocation(location) {
        this.setData({
          clickAndCollectLocation: {
            ...location,
            lat: parseFloat(location.lat),
            long: parseFloat(location.long)
          }
        });
      },
      async searchAmastyClickCollectStores(radius, lat, lng) {
        const response = await updateAmastyClickCollectStores(radius, lat, lng);
        const stores = response.items;
        this.setData({
          amastyClickCollectUpdatedStores: {
            stores
          }
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCaches(cacheKeys) {
        if (cacheKeys.length) {
          cacheKeys.forEach((cacheKey) => {
            this.setData({
              cache: {
                [cacheKey]: void 0
              }
            });
          });
        }
      },
      clearShippingMethodCache() {
        this.clearCaches(["getNominatedDeliveryMethods", "getShippingMethods"]);
        this.clearSubmitShippingInfoCache();
      },
      clearSubmitShippingInfoCache() {
        this.clearCaches(["submitShippingInfo"]);
      }
    }
  });
  var addCartItem = (cartItem) => authenticatedRequest().post(buildCartUrl("items"), {
    cartItem
  }).then((response) => response.data);
  var addGiftCardCode = (code2) => {
    const { customer: { tokenType } } = useCustomerStore();
    const prefix = tokenType === tokenTypes.guestUser ? "/carts" : "";
    return authenticatedRequest().post(buildCartUrl("giftCards/", prefix), {
      giftCardAccountData: {
        gift_cards: [code2]
      }
    }).then((response) => response.data);
  };
  var addDiscountCode = (code2) => authenticatedRequest().put(buildCartUrl(`coupons/${code2}`)).then((response) => response.data);
  var getAmastyShippingInfo = () => {
    const url = `${getBaseRestUrl()}/amasty_shipbar/mine/bar/data`;
    const data2 = {
      customerGroup: 0,
      page: "cart",
      position: [10]
    };
    return axios.post(url, data2).then((response) => response.data).catch(() => ({}));
  };
  var getCart = () => authenticatedRequest().get(buildCartUrl("")).then((response) => response.data).then((originalData) => {
    var _a, _b;
    const data2 = originalData;
    if ((_b = (_a = data2 == null ? void 0 : data2.customer) == null ? void 0 : _a.addresses) == null ? void 0 : _b.length) {
      data2.customer.addresses = data2.customer.addresses.map((address) => ({
        company: "",
        ...address
      }));
    }
    return data2;
  });
  var handleServiceError = (error) => {
    let message = globalThis.$t("errorMessages.unexpectedPaymentError");
    if (error.response.data && error.response.data.message) {
      message = error.response.data.message;
    } else if (error.message) {
      message = error.message;
    }
    throw new Error(message);
  };
  var getCartData = () => {
    const { customer: { token, tokenType } } = useCustomerStore();
    const builtPath = tokenType === tokenTypes.guestUser ? `${getBaseRestUrl()}/checkout/${token}/data` : `${getBaseRestUrl()}/checkout/mine/data`;
    return authenticatedRequest().get(builtPath).then((response) => JSON.parse(response.data)).then((response) => response.result).catch(handleServiceError);
  };
  var getCartTotals = () => authenticatedRequest().get(buildCartUrl("totals")).then((response) => response.data);
  var formatPrice = (price) => {
    const { currencyCode: currency = "GBP" } = useConfigStore();
    return new Intl.NumberFormat("en-UK", { style: "currency", currency }).format(price);
  };
  const mergeProductCrosssells = (items) => items.reduce((prev, item) => item.crosssell_products ? prev.concat(item.crosssell_products) : prev, []);
  const convertToString = (sku) => `"${sku}"`;
  var getCrosssells = (products) => {
    const productSkus = Object.values(products).map(({ sku }) => sku);
    Object.values(products).forEach((item) => {
      if (item.extension_attributes && item.extension_attributes.parent_product_sku && typeof item.extension_attributes.parent_product_sku !== "undefined" && !productSkus.includes(item.extension_attributes.parent_product_sku)) {
        productSkus.push(item.extension_attributes.parent_product_sku);
      }
    });
    const request3 = `{
    products (
      filter: {
        sku: {
          in: [${productSkus.map(convertToString).join(",")}]
        }
      }
      pageSize: 10
    ) {
      items {
        crosssell_products {
          id
          __typename
          name
          stock_status
          thumbnail {
              url
              label
          }
          sku
          url_rewrites {
            url
          }
          price_range {
              minimum_price {
                  final_price {
                      value
                  }
              }
          }
        }
      }
    }
  }`;
    return graphQlRequest(request3).then((data2) => data2.data.products.items.length ? mergeProductCrosssells(data2.data.products.items).filter((value, index, self2) => index === self2.findIndex((t) => t.place === value.place && t.name === value.name)) : []).then((data2) => data2.filter((product) => product.stock_status === "IN_STOCK" && product.price_range.minimum_price.final_price.value && product.__typename === "SimpleProduct" && !productSkus.some((productSku) => productSku === product.sku))).then((data2) => data2.map((product) => ({
      formattedPrice: formatPrice(product.price_range.minimum_price.final_price.value),
      ...product
    })));
  };
  var getMaskedIdFromGraphQl = () => {
    const request3 = `{
    customerCart {
      id
    }
  }`;
    return graphQlRequest(request3).then((response) => response.data.customerCart.id);
  };
  var mergeGuestCart = (quoteId, customerId, storeId) => authenticatedRequest().put(`${getBaseRestUrl()}/guest-carts/${quoteId}`, {
    customerId,
    storeId,
    cartId: quoteId
  }).then((response) => response.data);
  var removeCartItem = (itemId) => authenticatedRequest().delete(buildCartUrl(`items/${itemId}`)).then((response) => response.data);
  var removeGiftCardCode = (code2) => {
    const { customer: { tokenType } } = useCustomerStore();
    const prefix = tokenType === tokenTypes.guestUser ? "/carts" : "";
    return authenticatedRequest().delete(buildCartUrl(`giftCards/${code2}`, prefix)).then((response) => response.data);
  };
  var updateCartItemQuantity = (itemId, sku, qty, quoteId) => authenticatedRequest().put(buildCartUrl(`items/${itemId}`), {
    cartItem: {
      sku,
      qty,
      quoteId
    }
  }).then((response) => response.data);
  var removeDiscountCode = () => authenticatedRequest().delete(buildCartUrl("coupons/")).then((response) => response.data);
  var removeRewardPoints = () => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      removeRewardPointsFromCart(cartId: "${maskedId}") {
        cart {
          id
        }
      }
    }`;
    return graphQlRequest(request3);
  };
  var useRewardPoints = () => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      applyRewardPointsToCart(cartId: "${maskedId}") {
        cart {
          id
        }
      }
    }`;
    return graphQlRequest(request3);
  };
  var refreshCustomerData = (sections = []) => {
    const { secureBaseUrl } = useConfigStore();
    const params = new URLSearchParams({
      sections,
      force_new_section_timestamp: false,
      _: new Date().getTime()
    });
    const url = `${secureBaseUrl}customer/section/load/?${params.toString()}`;
    return axios.get(url).then((response) => response.data).then((data2) => {
      const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
      sections.forEach((section) => {
        mageCache[section] = data2[section];
      });
      localStorage.setItem("mage-cache-storage", JSON.stringify(mageCache));
    });
  };
  const addCharityUrl = "pennies/charity/index/";
  const removeCharityUrl = "pennies/charity/remove/";
  var getStoreId = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.storeId ? mageCache.cart.storeId : null;
  };
  var pennies = {
    getPenniesConfigs() {
      const storeId = getStoreId();
      const request3 = `{
           PenniesData(store_id: "${storeId}") {
                charity_logo_url,
                enabled
           }
        }`;
      return graphQlRequest(request3).then((response) => response.data);
    },
    getCharityAmount() {
      const storeId = parseInt(getStoreId(), 10);
      const request3 = `{
           PenniesCalculate( store_id : ${storeId} ){
                amount
                charity_id
                currency
                soundbite
                message
           }
        }`;
      return graphQlRequest(request3).then((response) => response.data.PenniesCalculate);
    },
    logResponseErrors(error) {
      if (axios.isCancel(error))
        console.log("Pennies request cancelled");
    },
    addCharityAmount() {
      const { secureBaseUrl } = useConfigStore();
      const requestUrl = `${secureBaseUrl}${addCharityUrl}`;
      return axios.get(requestUrl).then((response) => response.data.success).catch(this.logResponseErrors);
    },
    removeCharityAmount() {
      const { secureBaseUrl } = useConfigStore();
      const requestUrl = `${secureBaseUrl}${removeCharityUrl}`;
      return axios.get(requestUrl).then((response) => response.data.success).catch(this.logResponseErrors);
    }
  };
  var duffle = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gODAK/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8IAEQgAlgCWAwEiAAIRAQMRAf/EABwAAQACAwEBAQAAAAAAAAAAAAAEBgMFBwIBCP/EABcBAQEBAQAAAAAAAAAAAAAAAAABAgP/2gAMAwEAAhADEAAAAeqAAAAAAAAAAAAAAMVFL+qtqAAAAAAABpyk9E5h1eKtD1s0vjz6oAAAAYjK08c3/Jt/sY0V55L1aqLnzx4zdA4n2k9igAAPnI71yLcj+JetiRta5MjdztPm6T3707ndxdKP826FX69rI/QnqnXHFAA5vz+5UjUzQpEMk45HohS8GGJGSF6NhlhfdydrfsfN6v0KkXfNAA5tz7uPJa1MPbxTEzfLMePN8IOTznzcPiX8qJJySDo9+p1xgAB8+jUQ7GKpq7+OU67s4/P2D9Daw4Zj7JDrlO2tVkjZbQAAAAAAAAAAAAAAAAAAAAAP/8QALxAAAQMDAgMHAgcAAAAAAAAAAgEDBAAFEQYSECAhExQiIyQwMiUxMzQ1QEFQYP/aAAgBAQABBQL/AALrgtN73r28CpanP2Gp5ROPxWhYj6gJpGbXIeiSPeukxIcVhjFuBdw6qP1EaV9HAkMfcJUFH3SvF11Q4jLEFd0LVSeqsAd4t2mJqqnsuOA0Ltyhtg1d4jlX64CTNltiRB1O5vu1t/TtVAuNKL5kslt99AkMOdVREutwKaZAo0LxBSPFvbI6XBKEl4BnTXnG7VOOI7ciKdJtVybjw5d6HZGuzkZ8SQx5L+/2NuzWaf6GlA8o0DiLWaleJY3y3VvSt1SS8Wl5CuwOTVjnmZrNOL4hBFEh20i4oXaM8k2XT5LupCpwsrpD8Hk1Z+f4F8h+NEPFFxXaJjelK7w0kX0/k1Y15uKxRJ1T7cFTgiZratYWsLQBitJJ5PJdonfIj0V1pezpwMKKZTHH+R+3DHXFaXTEHlVMo7bYjirZoa0ViiU7p9aOwykorZLCn4xtkIdNi1toE6tNZW2R+6w/cIUJHLdDcp2xwzotPs1LsLjaWa3d0a/vP//EABQRAQAAAAAAAAAAAAAAAAAAAGD/2gAIAQMBAT8BSf/EACARAAIBBAEFAAAAAAAAAAAAAAABEQIQICESMDFAUFH/2gAIAQIBAT8B9TShqNoT+2jZxQ0ksEVO3YT2SVPF3RBHRnyP/8QAORAAAgECAgcEBwYHAAAAAAAAAQIAAyEEERASICIxUWEwMnGBExQjQUJzwTNAkqGx8FBSYGJygtH/2gAIAQEABj8C/oEvUOqo4mFULUsCnE+9otN6rHDtZdb4f39fuK4amd1eI5mJTQZBRKKVhmGf8oMDis2U/ZVOY7cv8ZsomJxuIuzdzPnnxgPOUV5LnKFdxn6vUAPh+zAynNTcHtSTYCLTUkJwXoJhsLTsovMOedNf0lI/2fWYygffGwdXit0/52WtUdUXmxymt6xTbopzl2Kf5CLh8Mwc1OJXlPS1Pt2H4Y4/kAEw3y1/SUGHUTEL0Ed1+GpreRist1YZjsCTwEK8KANhOYljOcu2UzNzAEquAOTRUqVGZc87xmp6pzGW9DWIVSRlKdGvrZrbWmWGB1+ZEBruaiOd7OBlOam4OywHGpu6baL3EtoEvsDpDTbjTOXls0KfQnZvLS+xbQZXN/ds0/l/U6TBotpvo4y2h194fZoVOmrpPZZmYg9RslF74us9ojL4icO0qfM+g2rzNqI/1tO434jN30inxns6w8xN0I3gZfDv5DObyMviJlpF4LEk8BziUz3uLePa5MAR1m9h6fkMpuh08Gm7VceMDYU+kPI2mvXyNc/l/Hf/xAArEAEAAgEDAQcEAgMAAAAAAAABABEhMUFRYSBxgZGhscEQMNHwQOFQYPH/2gAIAQEAAT8h/wBBCaO02lvPUGF4iIvyb83Bj/iGSz+BZUqS3YK0ko53jwqJrUpl9SGro3pseHt9/Ep75MSypBamlfN8wR9AM1Lwu9/qW2TzHZ7CBaDQ3PuqWCtXYloJtmzq984uh6GD5l66o9E71U9UPQWnopj2joa9nG/2nSuAEVKhs0+UILfj8Vk1wYW+54wvkyOBxFV0H8r+Y7/WwjBisz5f3HEN2vlf5mP3EOcleTHzoE5H7DN0Fq7Rk+YfV6wyxh7BRttTClp0DDWxt2CEygQqYt6BXmB2twgOKEDZiXzTaCyrxM1q6YlNgG8dSFaDQ3OzbSmr46+kYKymJhIsYmKg6amekGp0grcomnLRBNMzo+nkUum72T57LZWDzuPj61j6Q0uFjPhzEVrMvxjLiVuoLqYmGISFahEepOTG/wCeymvav0Cesi8iLjrN+HGsqaYNTTFEAMxcYQcy1+rfBDspwV27m/nsFafd9QmiylGTxTNVM6oiidEvR7OFw9zzxEAsNaUtyj21rMTWka7SokRtKVvDHEscM0YT1RbtAIAR2ZTjep9s25kobcgD8TKW9K43+g9ajjcr9lTWEcxLrNYlHmTBFoxBNQGVxFovG5fteH3W71sLJ+w13T3Ab3uJM90D+IUneq8esah34yHg/wA7/9oADAMBAAIAAwAAABDzzzzzzzzzzzzzzzDzzzzzzzzrfTzzzzzwZTfrzzzwztsOdhpTzy/mG13GHzzzwzFlTDTzzzwwx5Ej7zzzzzzzzzzzzzzzzzzzzzz/xAAbEQEAAgMBAQAAAAAAAAAAAAABABEQIFAhMf/aAAgBAwEBPxDkrBuOL8lsG9EgY+ypUDU43//EABwRAQACAwEBAQAAAAAAAAAAAAEAERAgITFAUP/aAAgBAgEBPxD8Cr0NSeuMERQkRzi5jRUSwiCQXxPRAy3hoM8weYFsrOI6nJcLG8F+f//EACsQAQACAQMDAwMDBQAAAAAAAAEAESExQVFhcYGRobEgMNEQ4fBAUGDB8f/aAAgBAQABPxD/AAFNdm6BD+GSXZvWQNbah2zpfbjsSjtg4sqAQRLE3/oFY269APNCY5WUnLLjDLqrbfWdWQREF1LTqE0owS6Fi96aeDiq+8P2xdumqcGr4N5rlG/SB4VfBGi+3slxMhSnqU/0hWbKqxun8yQSiULELE8fdRuB6gC1Zg+GGLCvUC+htBsoWOx5/X0RtWF8pExcZXb8kfEaS25i8JfETxWhZq+0tnRePtOhVBKV0LUJtCg1uAX7RidNCT3oeWH1ATSWoKbrU4OsNsqgNppry6W+DlQ9e2aX7uXOdR6LPZzCAc6F6hBwuBcaj2KkAqAugLH0fsGhccwAtWGhYNeosO0XtflX0Pc1DrEy5Lwsn7R3Qx64YT6gQHpHOqY7XywcjB0DQAcEKHMxAFXeu7KuP2UqxxSZxFL9rRFXpxXpFXp41sRV3gQ02hWqKph1qF5fEHdqlY8Zgq9ApMbEMIlGxCxOlfTgpTPtZ9pPMHN76zSrZFdp2HMLUvmHDvEuTzB1R0Op3hVkd5QCzZvvX4iIgHuShgehMA+6YGT4IjwK0eX/AITeCO3jo8NOwfTS1HZyoHy9YU3smm9SDibCHU7gcyiIVoIDYDciUyOdmXgbCgjJQK1crGhq3rN2ce0pqIIZYKpc0V00+IBhV8OA8O7+HP08IKZ3Em8TfnVFB4EFdl6MwLcHJtAqhUQt7wiVhuzJ7QK7wAJ8y+C7tQ6aG9isQ6YzzLsZacLnw/TiPPuDQ+fpGuafJCEMW8Hov07xzmZpO8Y0TMPoD2YLVwYZXUqDkDtNiXWV7uWfJ9KMAOMKiZdRTvXEsvyWC+jo+J2TmWoki9Gb24jLNJxpuOmDMNYbsxI4HmWV6kt6F78MGA7kZopJcUpB6fm+os7UhYnaMlfV9jYQWqXA3ysvTWxPIwyxnRZ9RfiXOg46YEAe78x7RNcbFb7JBdgDYO5OdTtGzZXQjIQXgTJArouSdAcy1s7VWWWl7hi3A+7q4OKnhguu1sn61ZaL/WHpLvlofoHymcAwijWAtE6bddrMLVez02x1tNbq2v77/9k=";
  var giftCard = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gODAK/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8IAEQgAlgCWAwEiAAIRAQMRAf/EABsAAQADAQEBAQAAAAAAAAAAAAAEBQYCAQMH/8QAGgEBAAMBAQEAAAAAAAAAAAAAAAIEBQMBBv/aAAwDAQACEAMQAAAB/VAAAAAAAAAAHPh24HbgduB24HbgduPk8kKyVKElwj07ciKVpZK3ws2Ivy4U9wAAKiTmbNKBqshoI09QiS62wEvea/yH8/andV3298lqziS4l0UyHtirkVirhmKK1uPqcCl+P6VlKN9pPzywoe7NjXTzXeTC3D9liGmCH7LERLERLFFT6qqyu1hk4v31LXV31oJ1c60TtRC1MAAAABWWdZw7ZrQZ7SUdS1GrigAAAAAAKyzrOXbM6TN6TP1LUauKAS/CKlCKlCKlCKlCKlCLWXvkJ/nuku+69uMlLdGKlj0AAAAAAAAAAAAAAAAAAAH/xAAoEAABAwQBAwQCAwAAAAAAAAABAAIDBBESEwUQFDMVIDBANFAGISP/2gAIAQEAAQUC/c5BZBZBZBZBZBZBZBZBZBZBZBZBSTRxt76mUU8crcgsgrj5uT/GXF/j+wyO9RqpHMmikca9tfVdnNUmLjuNnMsXtqahsAqKp8zWyxmSCUwtgmEvW4U9PHNJJBHJDTwxwJsMTaZ0ETgyGJk1wrhXCuFcKrkymtLUyeiT4jbTOp32ftjW2PpNLgdji+MuLhN/mZzaOUuk9vKNMZ4Bg0L+QsHbUMpMfTWVqWorUVqWpalrK1laytZWsqqhEsVBIKM95T48nUCsNPHYdi9di/5ZGqanbKpaJ0bmRhqoqc5fPXf1CuPa0xfQ5DwLjvB9DkPAuO8H0OQ8C47wfQ5DwLjvB1sFYKwVgrBWCsFYKwVgrBWCsEWtK1RoMaFYKwVv3X//xAAmEQACAQMDAwQDAAAAAAAAAAABAgADBBMSIVERMDMQFEBBICIx/9oACAEDAQE/AfgE9NzFqI2wPZu66BSn3LJCG1wHr6YBzMAmFeZgHM9uOZ7ccxbNjUOuLbqDtDqpbGZJmaZmmZpmaZmmZppWp+0pWi/2XxRmCj6mgfnb+QS92pdm38qy+8XZpvoYNK92Kqaenx//xAAqEQABBAADBwMFAAAAAAAAAAACAAEDBBEVUQUSEzAxM1IQFEAgIiNBQv/aAAgBAgEBPwH4DNinAm6tya8RO7F+ldvRD+NCTE2Leg7YkJ8GFPteRv5ZZrL4ItsSD1FZ0fis6PxQ3wkBuHopY2IUEzwYivfFosqr6LKq+iyqvosqr6LKq2iyqtoglOjI8ZdEVvfH7VDWY23jXtI/rsCzxviqnc5M3bdVO5yTHeF2UNbhlvY/H//EAC8QAAEDAQUFCAIDAAAAAAAAAAEAAhExAxASIUEgIkBRkRMyM2FxcoGhBEIwUGD/2gAIAQEABj8C/wANie6AvE+ipY6RwPzcfdsss53DZF0echfjBpgPfB6K3sydxrWkDqiIm2IL2vjLChbE75aI9SnNe9r7SzdhLhr57WebuSh0BqwlyhkRVcncr6hC07R7HARLHQm2b3uOHMOxb0p2Fxc51XOMkrsAdyC2qsg7NtnQI2jIaSMJiiqFUKoVQqhWjjzWCzEnkpx2c8lhtBB1CY8UXiN6rxG9btBlPqmgDn9FPxRkYoi6Wk6NFU2B65KN3WmkbR5OKtH/ALF0XMtP2DoRadjS/RaLTacwiU/FPZmvkp7ZnVNa2ezb9prBqu81d5v8shcioLhFwtHjIU4CRkZuJIEzwPzcfdwPzcfdwPzcfdwPzcfdsUVAqBUCoFQKgVAqBUCoFQKgWbQu43osmhUCoP7v/8QAKRAAAgEDAwMCBwEAAAAAAAAAAAERITFhQVHxEKGxIEAwUHGRwdHwgf/aAAgBAQABPyH5zkM5nM5nM5nM5nM5nM5nL6TEwz+v6hgjDiYZnM4nWfxvF6d+8L0ro1ShoR+SfctO6k/wS4IMWbq8E70OahMt6Soj/UIdOtKSqncYvVCwt1Rj1L9xZS7KTCRFGsyV5Hdwm2L9XODjMZbES0ArM3TuSFlzSxYe6jvEO4zbW7o6RXcoZFIJqzbc5w5w5w5w5wmXRMl9EKSb7Joeep+YI99NzXIlgu7HGzifRkcoUk+FSMaG50mwt0JNnUSIaJ75GyGC2BvRk9VVUNrzEYJBbVWLpIr6qJXiYvmjhJfvozZRjw0/0VuYdH1zIk7sZEZES3EtxLcZkZkZkZkZkKRNp9RPNepu3NtPu+xUtUrLcSsw27n9TP6n8V86GpNN1LtamEkZA6sdiFg9fYPtoqhtty3LHlSvVqtl7Hx+nevC9j4/TvXhex8fp3rwvY+P0714Xom0fY4g4g4g4g4g4g4g4g4g4g4g4gSQyso4OIYRWEcQcQJFZJfOv//aAAwDAQACAAMAAAAQ88888888880888886/8APABBCAAFugQDMbBDTcUjAU4c4wQfwm8gAAAAAEzQAAAAAAAAfgABDDDDDC+DDPPPPPPPPPPPPPPPPPPPPP/EACURAAICAQIEBwAAAAAAAAAAAAERAGExEDAhQEFRcYGhscHh8P/aAAgBAwEBPxDkACxCFEyaI2S/LIfnHNjiLgAY0IwzAL1OkB8agGHRZ9/mLBpwCIzH7S+Xy+Xy+XwihOMGL8Rc6TJfWx49wyRdxs+sEyeI2XYGjFqvny//xAAlEQEAAgIBAwIHAAAAAAAAAAABABFhkSEwMVFAgRAgcaGx0eH/2gAIAQIBAT8Q9Aio7wm0D6dGnvBhNlXBxv8AUPPY/CkHbALdz5qCtU8d2KUO2Y+2Y+2A/MR7cdvacwj4FlzBmdtmdtmdtmdtmZtmZtlzJazxX9JVK4fEYjy9pjd/PQq+IBBjo/az8D0c0xLlvT//xAAoEAEAAgECBAYCAwAAAAAAAAABABEhMfBBUWHxECAwcYGRUMGhsdH/2gAIAQEAAT8Q/MoqJv2myM2RmyM2RmyM2RmyM2RmyM2RmyM2RlTFTJZfYnSQBHcdLNDWTqTZGbIx2h/r1tHfh8ph8KotAGQjdXosXWZRdA0cWMmMjSYNpE4kurbpryjV+MkXjBk4Ky6vEGE7YDC3ALW9BjzmDTMLRSvsfNWBPbKs5rwIrMgxVV1WGLlgAq+Vx7lKBdqBr8EZgULRvHM6eDO1JabqhWijWuQ+pau9HSujrpae0r1BhqUFeAaBiLGyRDn6vmGaooaxWniBa6sA8GmCIKOC0vkztSdqTtSdqTtSP8Z4JRX1DFqb1A5roe7DlnvS+0CAtLVg5HTPMlJNBVayw38XNyfuO1P78Ndlo2i6Q0yauuphuNLR3pAPIw3x9oWU9ss3G10fEaUKiVagRVzhoKpxK7S7jBLSpW1yj7RARcyrUOTY10zWvDy0Suimcp9/qVBG64hAPtfx4GLBlwqCfYfuFYlujdYfvwJu2NaxTZZp4mYaoC5Wpr8TWBqgXlo1m7Zu2btm7Zu2AUDduTly5fMdIQQWlih7anQ5Qfh+67j+IgBQFUvixwKuuOWCjJK6mpvf8Te/49UDK1oOEOuHoFnuIkRWQG09pfDGULw9owDOJSuDXI8H1mu1C02s8SMlJqrbCAxBUHM8X1tHZh8qB9bR2YfKgfW0dmHyoH1tHZh8qDXSKlVXiiduTtyduTtyduTtyduTtyduTtyduTtycfJUKTYH6maJXQhO3J25G7c6Ffmv/9k=";
  var jackshirt = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gODAK/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8IAEQgAlgCWAwEiAAIRAQMRAf/EABsAAQACAwEBAAAAAAAAAAAAAAADBgIEBQEH/8QAGQEBAAMBAQAAAAAAAAAAAAAAAAECBAMF/9oADAMBAAIQAxAAAAH6oAAACOlb1C59bvcfjP0qY7gvzAAAAAAApdWu1QzbYrpVvoE16A0ZAAAAABhDOLh1jLp5OGWpXTu2il2CK/SVYsenHIOvMAAABwe9UMvfm+RS+X6McG26V1JJVbedjjzTW/j2/JAAAAUG9UPBs0dzmbeLZse4+xHhlCD3ndK8/RfYZva8cJAAAQUO80bzt3ke/o8NEvhxt7JHIjQ93uZ3j6RswT+r5QWgAADUpN4o3m7tnTlgz6JMXvO2TFKfQ7vC78/os8UvqeYFoAAAjol+oeDZhp6ed43fND3nfoZc30t9c7nEifosmGfoYQmAAAHy/wCofIeOiHe4vZvRi17U2sosjq8vCXjo+qjvlAAAAfOituDsCfd0mulmJsW8VtZxfmAB/8QAKxAAAQMCBAUEAgMAAAAAAAAAAQACAwQFERIhMBATIDEzBhQyQSI0IyQl/9oACAEBAAEFAtiSRsTKi/tBpL5HIRqN/wBQEmL2+J9vgrM4mh37g9xrI3nPzCZLW53P37q+nEpIDm4E0cIij3nyNjF5k5lxD86dJyo/Tpexu49wY2evKnc5zqgMkTFlMjmSAKnuDgmPa9u1cpOJaCnRtw5bUGgcLfLll2q9+afHqOigd/JtSnGSQ4dUx/GHu3tsSaRv+dZ8GnoAUkhNVH2hOMOxUeB5QYHwM4ff2qqPKmHSm0p9iq/XeEMBaxw+0Vcx/VhUBxh2Kr9dymcBSBHiVU62yJU/g2KnwPVQNG9M7P8AGhUPi2JRjHIquVhfnaVqtVjwiwltkCj8ewe03cfN3D6TFZlAFH8Nmukfz4XHmI6AHgFSztghpJXGbaqCedTk5sUUzHFDvJ+TBCIK/avNMGVEbcqxWGZ1yaGXBN7wUrnU1ttxhl6f/8QAJBEAAQIGAgIDAQAAAAAAAAAAAQACAwQQESAxEiEUMDJBUXH/2gAIAQMBAT8BwZD5J7OPpg2so1gPRDlifkrAHpFofcJ8NzN5S4u+jtUe3k22UqN0tT6RxldFNN71YbhO3jK6TdVhno/1O3jK/aEct6XlD8Xkj8UB3LkjjL7UTdYRsMmOIPSJvW544f/EACQRAAECBQMFAQAAAAAAAAAAAAEAAgMEESAxEBIhFDAyQVEi/9oACAECAQE/AbHOomur2X5UPPYfNtHDU0mlSi9zKFQ4rYmLpt1GaQz+gqkph2urdOHARwgac6YQxbOeQUQUA1iCibgWznmFEzrF9JuBbO+kZYP5XRn6ujP1TDNoaEMWxQDlNxrEaHZuIrZTmz//xAAzEAABAwEFBAgFBQAAAAAAAAABAAIRAxAhMDFBEiBhcQQTMkBCUWKRIiRygbFDUqHB8P/aAAgBAQAGPwLAL6h2WjMqKFKeLkG129X6hkru4U6YyJkrNZpod4bu4VWu7LB8KhzfutnZu81UZ+nE9waxzvmHi4cFevh1UjNwE48vcAm1W6XBX9pFze1FydRc4lsSJ0xZdkopD7lS4krPZdxV4vQHg1KBpuv4ICqJHmpYZGGGbmULs2xocN3tgDDqfVKB47wbqUEMF3JFDmN4jQBFMPpGC/lZWc7wxHOd0qg/9wP5sp/SMF9hjPrd7omzx0V/4TDwwX2UWeZJO90cnQkWM5YL+VlIeif5V+63gUEzlguHCym1vhYAs92u3ylBN5YRTlCgBRJ91mfeyuDlA/tBN5YT4ddKIJmd7pRdqyFTbdecNwdnKaSrrDNoZMFzxf8A7mmMov668QRh7TDnejlB0sA81VaMrvwLeso7IqbXaOi6+q4OdoBvf//EACgQAQACAgEDAwMFAQAAAAAAAAEAESExQTBRYXGBoRCRsSBAwdHx4f/aAAgBAQABPyHoFZHacRmw8PV+0upnFl+7tEAoRyJ+w2eL2P8AYBY58pl+W+3j8/sF1xaJgsIF+kpX8xHGB4LK1cKzi39hT0rj2Zz9pSsfaYqj3cw7csL269UD5l+8ZnjiELHlmoWGFbalaPD+9XVWNQiBoQ9fkYbQafRL1oEx5Qc2qjXhTPpDXcrV8HTYScbZeWM3AMAkHomfSaQIYjZ3G9PAuH4RzxK7/QIwmO+JV6/T80VBPvAqXj6XX1rFtv2gr70Vt3Oi7PZM3O8GU3JkITmcz8kJegTBPFTzEnx0VXq4WGxxTB0sAXZD/sFY/QGIoW6lei/uaXMKN3/B0fiy68+0ALyAxU1xOIRzFiZJcYZcwtivYpHc2no/Em7BV/niE0yhiG5zHvxA7981DggofHom5N2ey491/cVlbExed/S5y32gNW7/AJqaWnwv46PkZQTviAelwoY3xxL7vieqWg5nMqVXzBrM/T/jom2eJTVzMru7Fim4YDK7zOD76WuZAac+sduzZihJe+YKLw6VCquqiuZeZsFgWs91A12mFuLMuBoBW1cH5mTsAuoFAdF01uKA7n4jg6bbhh2d5rNARvmH0CUrJmgBv8JjLk5DvpsaWwfO4qWxb5SzDgNqmlVjImRlsCpF0xoplpdGhgXm/wBX/9oADAMBAAIAAwAAABDzzzxKXzzzzzzzyL3zzzzzz/Eav7zzzzyv8/zrzzzzzo+p9JXzzzwIGqdPXzzzzZtJANXzzzwRnHzNTzzzyK2Qzhzzzzz96EAPzzz/xAAjEQEAAQQCAQQDAAAAAAAAAAABABEgITEQQXEwUZGxYaHB/9oACAEDAQE/ELGFSPn6KQTEeRldXgrQmXVD9zFQcu2O43Zx6mo8/EMagIrtyJWISjHgKKWnN+Yy8v4cMzb7v2zbX3t3+YQqO1++KSsB0vuZK16RfGoQ7IeqPnK/M2bahQGZ3nmp023ZEiKrO+EqBs//xAAjEQEAAQMEAgIDAAAAAAAAAAABABEgQRAhMaFRcWGxMJHB/9oACAECAQE/ELKqk4/4axHMK7MXqBVjHK9REjgm2YNv38ZuSmZYkY9xHmMcDi7uoNjEQMaJQR1Datr4gFPFda4Pg+iY3gt6n9iUDgDrU0q8h9Q09Vo3fuFFaLHF0hk6TeytCn6nFaYUVmLxqqArcQ3gBxDQDY//xAAoEAEAAgEDAwQCAwEBAAAAAAABABEhMUFRYXGRMIGhwbHRQOHwIPH/2gAIAQEAAT8Q9C47AcD/AG0A22qX1BzXdO0dijQN6NR5ghGELEdz+A0qdaqAHbLwR0uU5xCsOZQxGcRVdxT4APb+AiO4sE0263d+0oki0l69rfUHOWnomtaGeGHWoCBRDTe9deD+BZji0bstsNQOrpGIUHUtn2jHlFFKEs0MTemAdPXa9UWXsby/dQ0rg/Z8x/UtisPUqJkjKtGmufaF/Dda8VXDY10eX1aH/tZwA+s+xpLhNLUXMoeFCtJMmf3DXdqtx6ianWKBS3EAylvOnvKSh1Th6M4ELRPc3hZG3Wnfj02NAKurg/3WOAwT5jC4XCsVFVnLHOVTBeamlKuksoHeQF12fTCysc9xNNkuD/eIb1bEgLSXBBmK1b/Et96C+93+vPpLQroRGLgHu/siKatFytfbCA2RtvWpzCInMwdH9pAzFS2vTP5nQwfj0dlfhhi74vs5iIqhqGrzLupxlDBAgc6y8ZVxYDsUYSCCX5fzEdlPuf8At0D0QStFd8YYZOhgPhlwdY4Ensexi5CbK7w0Q0QULphjMpLZtEJrcsTCOLPD0e6/uS7Z06gG5fQX27wCD2CVC1aMWHhPtAJCzXnCvQzh5WPqNOQeWrAXBBDt6Lrtz5JgG0wnXJ5FT8ntGXVfDMQMVTcGI4fiIgqV6NvqUdSAV/k9Fjhbl4bmMtnYS5s1GCH6oqBhy5iJA3pcMlqbP1HjeLwr+xHY4PXEFClOj7PR3IpfE1HQl7APheaMxxcdoKzlbwxp0V1tBLZfokFqw8TUJBdyoTbgD8kcsbzhHUjs6Wvw9GgtVEQMQWx9RtfkK76wA6j4IgUAVhpASDrRLl8wfYUKS3mrgjMNbVvzBTGadDNvhjYMohszpOgxfB6WuJ4LC2+vzD8qFN7kVG+0yKy95mB4RRaHfrKMeI6Ne2FkAvc9iPTK1RLavH6hGaBXolSVIwvMrTlHsbfMwZrOxhx+JbgTcoqs7ZiA50oU0gj7iPvNE0pVcsJQAl2LT2g1ARymAAim+t7PHp5LslWWlo8W3DnQRCym9v1UGA+Ip7g34tqAZWJ4NCLBDR5YsQNDAYUCudefAd4DW6WBbVlUVf8A1//Z";
  var shoulder = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gODAK/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8IAEQgAlgCWAwEiAAIRAQMRAf/EABwAAQABBQEBAAAAAAAAAAAAAAADAgQFBgcIAf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHqgAAAAAAAAAAAAAGq7P52OiVcuhPR99y/qAAAAAAABovO9m0UyNttetRmO2eaPRVXoAAAAAGoZflBbWWRtS2x8kBL6V4h28AAAAAFJyTV7WkyDH1n2Ga6OsbWAAAAADBZ3WDiJQTRXFoTyRQnf83yLroAAAAA03ctVOKxXMJPaXlqVR1xGR9F+bfSJ9AAAAAwecHm6ntGnmm22UxxHTPtR87T8+gAAAAAADC5oaNuFyAAAAAAAAAAAAAAP//EACwQAAEDAwMDAgUFAAAAAAAAAAIBAwQABQYSMDEREzIhIhAUNUJQFRYjM0H/2gAIAQEAAQUC/Hz7wEd4shI6/cfZSDJCZF3jJAB09bgDpJ0lU8LfXfvdzFKOIijBjK5LvQdu7YiWm672TyBlGJkC4s43+oX76xFecjvQnHHYm5fp/YAkOjQ6D2lNdJ+TBb7srcucz5Nh1zWfNGBLXBvVi0UnrjuZJNRyf3KE6N309vV/1TGYyxrXtmSAOtTecJaGuvRfSoYAcrcvgodqHyMtKt8Gv8iV1qzy0mQdvJC02cfJzkfEv7fhiMjtzdvK/pQeTvKcff8A6nEJ3sy9vJkRbSPk9ynCUtfe0mpxONq9Mq/bPchO9FoPFKWl8rRanZZbkuxRX1k4/Kbp+G8xWlUVE6rj9t+bkCiCm/KtcSTS43H1x2G47X43/8QAFBEBAAAAAAAAAAAAAAAAAAAAYP/aAAgBAwEBPwFJ/8QAFBEBAAAAAAAAAAAAAAAAAAAAYP/aAAgBAgEBPwFJ/8QAMhAAAQQABAIHBwUBAAAAAAAAAQACAxESITAxBBATICMyUWFxIkJQUmKBkTNAcoKhwf/aAAgBAQAGPwL4eYo2h5HeN7ICJrGn6lXERh7voyTJ4+67Xc52wFp7juc1kja4iAnLvj/uvLwgoWKLrVxyflRQkZucuKaNsZKr5mEa7WRCxH73itynGY06qjXFfzTZIHYZBsVE+ZuGRzbI1egjPaP39FuswgQ6vunyP7zjaiZ8zgNXEM3nJoRe7N53ct1vQ5ApsmE9HHmTq9HHmIxh+6zKyN8rFoJpd3pDj1C52QGac69zaCs84my9wvF6vEYnOaA2/Z5ZKz1GPv2h7LvXUm86H+8xy+3J8JP6jcvXU/uOoUOUUg91wOpJfiOoUEU0eepO1ot1WFdcgjyPqg6sMV5uOqXMuJx+XZdkWSj8FdrC9nnS8eWOQdiw5+fkqaKA/YXJCMXi3JCpZcPghHC3CwfDv//EACgQAQACAgEDBAAHAQAAAAAAAAEAESExUTBBYXGBkaFAULHB0eHw8f/aAAgBAQABPyH8vwcBSguPM8qUtTCkjae373LXQbp2Ok67tU5PgipW1Xu3GRVpO64aisoKPjt+zro7yajnde0TfOWRo1Ma4vP1DAVSHrn9442/pn9uuO5TZ2v4mBH4SJsjnat3nmY2/wCVHsaJKA8cN6pjiWmz+0aaeh/yEGz2YS5hkrKZL7RiA7+RYFAGjqHhF2P1jP7tptjeRFrJXesDfOYbweJYM0HA1j76qpMsftKOy4gYx5g51ct++HaO92GCLV4cDr6PvqIYDUvYnfUkJQOiFTAPjEePnZzKvjTrxGGoh+LgUUa6hy0MlW9h8XMfbOBSzyJgR0pMESZ3jy8O/Urt0v603ekrtxPqTKBzXMC99QKaPgM/pfU/1+s2ekO/BNTKtpcXdOIjan7jqcBHPmDP0lT2TVU39c2jR8sUBpQXBQOOm1YAR3puYFHpKl5HWZRq4g+8yhuiLjg9A4OXq7sevK3p/EtnjQ/Q/wAxO/PmHzLqmjCollcspgJJhAFB+ASQV5v1uNTlVS/NQnmiH5d//9oADAMBAAIAAwAAABDzzzzzzzzzzzzzyDBzzzzzzzyjrTzzzzzzzzSzzzzzzgBBhTzzzzyyxCTTzzzzzyCSTzzzzzzyRgxTzzzzzzyxzzzzzzzzzzzzzzz/xAAUEQEAAAAAAAAAAAAAAAAAAABg/9oACAEDAQE/EEn/xAAUEQEAAAAAAAAAAAAAAAAAAABg/9oACAECAQE/EEn/xAAnEAEAAgEDAwQCAwEAAAAAAAABABEhMUFRMGFxgZGhscHwUNHh8f/aAAgBAQABPxD+PUg72fzCo34jSnULVO4WNffJLZ3uyDRkds3mzxDnbiukqK3ETr3RCbYLX2IsI8rqph7zRGUYnXsVdqxLZhbWl+br2npXQUECtLVbywc7RWJu1lJ7MXw1DVqPBZh6qIaF4GWgoc09YOC2KpC1Iwg8K9X5ujAU3xOFuHQtTesPBgO6eSgVtn0RUaPi9xhHkTFQtBgaJxxetbXXVSm4B5W3Z+B5lyQvRow0N6HHpn4inXDCit8P75iHlM8C0H4gZqQDkCEYAKA2OpVzaw3uux9pEJr5lH8djBCRh7rgZbXuEgRC/GOyLhIG8iLdjthVb5wa7dXVkA8ZrXxYek2S9EsmpKFV++JnCvhNS4UeTdMu5xmUcVojaPLacUgA+w9Ql0JqALVdioriLDQ2qtt+WWsEwwJWdcQbkmKW+Ix2qmpZ/qCYVLdq4gPkeMY7vtUAAAFAbdS8iVBFm0OVBOJmV+rjG65ne4jqrZzMWbf1/suDQbL4/WDVF75qjmBZGWM0Arzh9epSFCO9s/AxX+zWFXVVauYgJNhHobX9EoQr8mZpsBxGDLJXDhY/WuokAXm72kfu5gXT2Ih5BNX4F+5Q81Puf3MhMqlj7rUOAWeukGwTR6aoM+e1PpZjufylCVa0YB2lYnCjBO/5J4la83DXBCaC3WURoA6evnapEg7oJAaKGoc1EJji1Kr8QWQWl0yrVo4LAXwTlQH3ECQVqKOf+Ib9UhGlJYt1/SJW89LMex8ohRjVoeKUwQ7gHDCiUTNaMdJQ053ged+DyQPGA4BoAaHXQSksmXSzery4C8jBqA3ahwUV7MD7lZSu6uqvL/Hf/9k=";
  var getDummyCartItems = () => {
    const items = [
      {
        product_type: "configurable",
        options: [
          {
            label: "Size",
            value: "M",
            option_id: 186,
            option_value: "177"
          },
          {
            label: "Color",
            value: "Blue",
            option_id: 93,
            option_value: "59"
          }
        ],
        qty: 1,
        item_id: "174",
        configure_url: "https://braintree-checkout.test/checkout/cart/configure/id/174/product_id/430/",
        is_visible_in_site_visibility: true,
        product_id: "430",
        product_name: "Proteus Fitness Jackshirt",
        product_sku: "MJ12-M-Blue",
        product_url: "https://braintree-checkout.test/proteus-fitness-jackshirt.html",
        product_has_url: true,
        product_price: '\n\n    <span class="price-excluding-tax" data-label="Excl.&#x20;Tax">\n            <span class="minicart-price">\n            <span class="price">$45.00</span>        </span>\n\n        </span>\n',
        product_price_value: 45,
        product_image: {
          src: jackshirt,
          alt: "Proteus Fitness Jackshirt",
          width: 150,
          height: 150
        },
        canApplyMsrp: false,
        message: ""
      },
      {
        product_type: "giftcard",
        options: [
          {
            label: "Gift Card Sender",
            value: "Test User &lt;sender@example.com&gt;",
            option_type: "html"
          },
          {
            label: "Gift Card Recipient",
            value: "Recipient Name &lt;recipient@example.com&gt;",
            option_type: "html"
          },
          {
            label: "Gift Card Message",
            value: "                        ",
            option_type: "html"
          }
        ],
        qty: 1,
        item_id: "173",
        configure_url: "https://braintree-checkout.test/checkout/cart/configure/id/173/product_id/2042/",
        is_visible_in_site_visibility: true,
        product_id: "2042",
        product_name: "Luma Virtual Gift Card",
        product_sku: "243-MB09",
        product_url: "https://braintree-checkout.test/luma-virtual-gift-card.html",
        product_has_url: true,
        product_price: '\n\n    <span class="price-excluding-tax" data-label="Excl.&#x20;Tax">\n            <span class="minicart-price">\n            <span class="price">$30.00</span>        </span>\n\n        </span>\n',
        product_price_value: 30,
        product_image: {
          src: giftCard,
          alt: "Luma Virtual Gift Card",
          width: 150,
          height: 150
        },
        canApplyMsrp: false,
        message: "",
        is_virtual: 1
      },
      {
        product_type: "simple",
        options: [],
        qty: 1,
        item_id: "172",
        configure_url: "https://braintree-checkout.test/checkout/cart/configure/id/172/product_id/2/",
        is_visible_in_site_visibility: true,
        product_id: "2",
        product_name: "Strive Shoulder Pack",
        product_sku: "24-MB04",
        product_url: "https://braintree-checkout.test/strive-shoulder-pack.html",
        product_has_url: true,
        product_price: '\n\n    <span class="price-excluding-tax" data-label="Excl.&#x20;Tax">\n            <span class="minicart-price">\n            <span class="price">$32.00</span>        </span>\n\n        </span>\n',
        product_price_value: 32,
        product_image: {
          src: shoulder,
          alt: "Strive Shoulder Pack",
          width: 150,
          height: 150
        },
        canApplyMsrp: false,
        message: ""
      },
      {
        product_type: "simple",
        options: [],
        qty: 1,
        item_id: "171",
        configure_url: "https://braintree-checkout.test/checkout/cart/configure/id/171/product_id/1/",
        is_visible_in_site_visibility: true,
        product_id: "1",
        product_name: "Joust Duffle Bag",
        product_sku: "24-MB01",
        product_url: "https://braintree-checkout.test/joust-duffle-bag.html",
        product_has_url: true,
        product_price: '\n\n    <span class="price-excluding-tax" data-label="Excl.&#x20;Tax">\n            <span class="minicart-price">\n            <span class="price">$20.00</span>        </span>\n\n        </span>\n',
        product_price_value: 20,
        product_image: {
          src: duffle,
          alt: "Joust Duffle Bag",
          width: 150,
          height: 150
        },
        canApplyMsrp: false,
        message: ""
      }
    ];
    return items.reduce((prev, curr) => {
      const newItems = prev;
      newItems[curr.item_id] = {
        image: curr.product_image,
        name: curr.product_name,
        price: curr.product_price_value,
        price_incl_tax: curr.product_price_value,
        ...curr
      };
      return newItems;
    }, {});
  };
  var getDummyCartTotals = () => [
    {
      code: "subtotal",
      title: "Subtotal",
      value: 127
    },
    {
      code: "giftwrapping",
      title: "Gift Wrapping",
      value: null,
      extension_attributes: {
        gw_item_ids: [],
        gw_price: "0.0000",
        gw_base_price: "0.0000",
        gw_items_price: "0.0000",
        gw_items_base_price: "0.0000",
        gw_card_price: "0.0000",
        gw_card_base_price: "0.0000"
      }
    },
    {
      code: "discount",
      title: "Discount (discount)",
      value: -19.4
    },
    {
      code: "shipping",
      title: "Shipping & Handling",
      value: 0
    },
    {
      code: "tax",
      title: "Tax",
      value: 0,
      extension_attributes: {
        tax_grandtotal_details: []
      }
    },
    {
      code: "grand_total",
      title: "Grand Total",
      value: 97.6,
      area: "footer"
    },
    {
      code: "giftcardaccount",
      title: "Gift Cards",
      value: -10,
      extension_attributes: {
        gift_cards: '[{"i":1,"c":"00Z4OBD0ZJ4A","a":10,"ba":10}]'
      }
    },
    {
      code: "customerbalance",
      title: "Store Credit",
      value: 0
    },
    {
      code: "reward",
      title: "0 Reward points",
      value: 0
    }
  ];
  var getCartItemsQuantity = () => {
    const cartItems = getDummyCartItems();
    return Object.values(cartItems).reduce((prev, curr) => prev + curr.qty, 0);
  };
  var getCartSectionNames = () => ["cart"];
  var getMaskedId = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.guest_masked_id ? mageCache.cart.guest_masked_id : null;
  };
  var getBasketPath = () => {
    const { useStoreInUrl, storeCode } = useConfigStore();
    return useStoreInUrl ? `/${storeCode}/checkout/cart` : "/checkout/cart";
  };
  var redirectToBasketPage = async () => {
    await refreshCustomerData(getCartSectionNames());
    window.location.replace(getBasketPath());
  };
  var useCartStore = defineStore("cartStore", {
    state: () => ({
      id: null,
      cartItems: getDummyCartItems(),
      cartItemsQty: getCartItemsQuantity(),
      customer_is_guest: null,
      cartGrandTotal: 9760,
      subtotalInclTax: null,
      isVirtual: void 0,
      totalSegments: getDummyCartTotals(),
      cartLoading: "false",
      discountCode: "",
      giftCardCode: "",
      discountApplied: false,
      giftCardApplied: false,
      discountErrorMessage: null,
      giftCardErrorMessage: null,
      data: {},
      crosssells: [],
      amastyData: {},
      freeShipping: null,
      shippingPrice: null,
      cache: {},
      cartEmitter: mitt(),
      maskedId: getMaskedId(),
      penniesDonation: {
        logo: null,
        amount: null,
        enabled: false,
        isAvailable: true
      },
      rewards: {
        used: false
      }
    }),
    getters: {
      agreementIds: (state) => {
        const { agreements } = state.data;
        const agreementValues = agreements ? Object.values(agreements) : [];
        return agreementValues.map((agreementValue) => agreementValue.agreementId);
      },
      hasPenniesDonation: (state) => state.totalSegments.some((segment) => segment.code === "penniesdonation" && segment.value > 0),
      isItemRequiringDelivery: (state) => typeof state.isVirtual !== "undefined" ? !state.isVirtual : Object.values(state.cartItems).some(({ product_type: productType }) => productType !== "giftcard" && productType !== "virtual")
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      async getCart() {
        const data2 = await this.getCachedResponse(getCart, "getCart");
        const customerStore = useCustomerStore();
        const shippingMethodsStore = useShippingMethodsStore();
        if (data2.customer.email) {
          customerStore.setData({ customer: data2.customer });
          customerStore.submitEmail();
        } else if (data2.billing_address.email) {
          const custData = {
            email: data2.billing_address.email,
            firstname: data2.billing_address.firstname,
            lastname: data2.billing_address.lastname
          };
          customerStore.setData({ customer: custData });
          customerStore.submitEmail();
        }
        if (data2.items && data2.items.length) {
          const items = {};
          data2.items.forEach((item) => {
            items[item.item_id] = item;
          });
          this.setData({ cartItems: { ...this.$state.cartItems, ...items } });
        } else {
          redirectToBasketPage();
        }
        if (data2.items_qty) {
          const itemsQty = data2.items_qty;
          this.setData({ cartItemsQty: itemsQty });
        }
        if (typeof data2.is_virtual !== "undefined") {
          const isVirtual = data2.is_virtual;
          this.setData({ isVirtual });
        }
        shippingMethodsStore.setShippingDataFromCartData(data2);
        this.setData(data2);
        return data2;
      },
      async getCartData() {
        try {
          const data2 = await this.getCachedResponse(getCartData, "getCartData");
          if (data2.quote && data2.quote.items) {
            this.setData({ cartItems: { ...this.$state.cartItems, ...data2.quote.items } });
          }
          if (data2.agreements) {
            this.setData({ data: { ...this.$state.data, ...data2 } });
          }
          const customerStore = useCustomerStore();
          const { amastySubs } = customerStore;
          if (!Object.keys(amastySubs).length && data2.checkboxes) {
            Object.keys(data2.checkboxes).forEach((checkbox) => {
              customerStore.updateAmastySubscription({
                [checkbox]: data2.checkboxes[checkbox].is_prechecked
              });
            });
          }
          if (data2.quote.items.length === 0) {
            redirectToBasketPage();
          }
          return data2;
        } catch {
          redirectToBasketPage();
        }
      },
      async getCartTotals() {
        const data2 = await this.getCachedResponse(getCartTotals, "getCartTotals");
        this.updateTotals(data2);
      },
      async updateQuantity(product, change) {
        this.cartLoading = "true";
        this.clearProductMessages();
        await updateCartItemQuantity(product.item_id, product.sku, product.qty + change, product.quote_id).then(async (response) => {
          if (response && response.item_id) {
            const data2 = [];
            data2[response.item_id] = response;
            this.setData({ cartItems: { ...this.$state.cartItems, ...data2 } });
          }
          if (this.penniesDonation.enabled) {
            await this.calculateDonation();
          }
          this.cartLoading = false;
          const shippingMethodsStore = useShippingMethodsStore();
          shippingMethodsStore.clearShippingMethodCache();
          await shippingMethodsStore.getShippingMethods();
          this.cartLoading = "true";
          this.clearCaches(["getCartTotals"]);
          await this.getCartTotals();
          this.cartLoading = "false";
          this.emitUpdate();
          const gtmStore = useGtmStore();
          if (change > 0) {
            gtmStore.addToCartEvent(product);
          } else {
            gtmStore.removeFromCartEvent(product);
          }
        }, (response) => {
          const { message } = response.response.data;
          const formattedMessage = typeof message === "string" ? message : "The requested qty exceeds the maximum qty allowed in shopping cart.";
          Object.assign(product, { cartUpdateErrorMessage: formattedMessage });
          this.cartLoading = "false";
        });
      },
      async removeItem(product) {
        var _a, _b;
        const shippingMethodsStore = useShippingMethodsStore();
        const stepsStore = useStepsStore();
        this.cartLoading = "true";
        this.clearAllCaches();
        await removeCartItem(product.item_id);
        this.clearCartItems(product.item_id);
        await this.getCartData();
        await this.getCart();
        if (this.penniesDonation.enabled) {
          await this.calculateDonation();
        }
        await this.getCartTotals();
        await this.getCrosssells();
        this.emitUpdate();
        await shippingMethodsStore.getShippingMethods();
        if (!shippingMethodsStore.nominatedSelectedDate && ((_b = (_a = shippingMethodsStore.selectedMethod) == null ? void 0 : _a.method_title) == null ? void 0 : _b.startsWith("Nominated"))) {
          stepsStore.goToShipping();
        }
        const gtmStore = useGtmStore();
        gtmStore.removeFromCartEvent(product, product.qty);
        this.cartLoading = "false";
      },
      updateTotals(totals) {
        const { taxCartDisplayShipping } = useConfigStore();
        if (totals.coupon_code) {
          this.setData({
            discountApplied: true,
            discountErrorMessage: null,
            discountCode: totals.coupon_code
          });
        } else {
          this.setData({
            discountApplied: false,
            discountCode: ""
          });
        }
        const giftCard2 = totals.total_segments.find(({ code: code2 }) => code2 === "giftcardaccount");
        if (giftCard2) {
          this.setGiftCardData(giftCard2);
        }
        if (totals.items) {
          const items = {};
          totals.items.forEach((item) => {
            items[item.item_id] = {
              ...this.$state.cartItems[item.item_id],
              ...item,
              options: JSON.parse(item.options)
            };
          });
          this.setData({ cartItems: items });
        }
        if (totals.items_qty) {
          const itemsQty = totals.items_qty;
          this.setData({ cartItemsQty: itemsQty });
        }
        this.setData({
          shippingPrice: taxCartDisplayShipping ? totals.shipping_incl_tax : totals.shipping_amount,
          cartGrandTotal: totals.base_grand_total * 100,
          totalSegments: totals.total_segments,
          subtotalInclTax: totals.subtotal_incl_tax
        });
        this.setData({
          rewards: {
            used: totals.extension_attributes.reward_points_balance
          }
        });
        this.calculateFreeShipping();
        const shippingMethodsStore = useShippingMethodsStore();
        shippingMethodsStore.setShippingMethodTitle(totals);
        return totals;
      },
      addDiscountCode(code2) {
        return addDiscountCode(code2).then((response) => {
          if (response === true) {
            this.$patch(response);
            this.setData({ discountApplied: response, discountErrorMessage: null });
            if (this.penniesDonation.enabled) {
              this.setData({
                penniesDonation: { isAvailable: true }
              });
            }
            this.clearCaches(["getCartTotals"]);
            this.getCartTotals();
            this.emitUpdate();
          }
        }, (response) => {
          const { message } = response.response.data;
          this.discountErrorMessage = typeof message === "string" ? message : "The coupon could not be removed. Please try again.";
        });
      },
      setGiftCardData(giftCard2) {
        const [info] = JSON.parse(giftCard2.extension_attributes.gift_cards);
        this.setData({
          giftCardApplied: true,
          giftCardErrorMessage: null,
          giftCardCode: info.c
        });
      },
      addGiftCardCode(code2) {
        return addGiftCardCode(code2).then((response) => {
          if (response === true) {
            this.$patch(response);
            this.setData({ giftCardApplied: response, giftCardErrorMessage: null });
            if (this.penniesDonation.enabled) {
              this.setData({
                penniesDonation: { isAvailable: true }
              });
            }
            this.clearCaches(["getCartTotals"]);
            this.getCartTotals();
            this.emitUpdate();
          }
        }, (response) => {
          const { message } = response.response.data;
          this.giftCardErrorMessage = typeof message === "string" ? message : "The gift card could not be added. Please try again.";
        });
      },
      removeDiscountCode() {
        return removeDiscountCode().then((response) => {
          this.$patch(response);
          this.setData({ discountCode: "", discountApplied: false, discountErrorMessage: null });
          if (this.penniesDonation.enabled) {
            this.setData({
              penniesDonation: { isAvailable: true }
            });
          }
          this.clearCaches(["getCartTotals"]);
          this.getCartTotals();
          this.emitUpdate();
        }, (response) => {
          const { message } = response.response.data;
          this.discountErrorMessage = typeof message === "string" ? message : "The coupon could not be removed. Please try again.";
        });
      },
      removeGiftCardCode(code2) {
        return removeGiftCardCode(code2).then((response) => {
          if (response === true) {
            this.$patch(response);
            this.setData({ giftCardCode: "", giftCardApplied: false, giftCardErrorMessage: null });
            if (this.penniesDonation.enabled) {
              this.setData({
                penniesDonation: { isAvailable: true }
              });
            }
            this.clearCaches(["getCartTotals"]);
            this.getCartTotals();
            this.emitUpdate();
          }
        }, (response) => {
          const { message } = response.response.data;
          this.giftCardErrorMessage = typeof message === "string" ? message : "The gift card could not be removed. Please try again.";
        });
      },
      async mergeGuestCart(customerId, storeId) {
        const { maskedId } = this.$state;
        if (maskedId) {
          await mergeGuestCart(maskedId, customerId, storeId);
        }
      },
      updateAgreementData(agreement, approved) {
        this.setData({
          data: {
            agreements: {
              [agreement.agreementId]: {
                approved
              }
            }
          }
        });
      },
      validateAgreements() {
        const { agreements } = this.data;
        const agreementValues = agreements ? Object.values(agreements) : [];
        if (!agreementValues.length) {
          return true;
        }
        const updatedAgreements = agreementValues.map((agreement) => ({
          ...agreement,
          valid: agreement.mode !== "1" || agreement.approved === true
        }));
        updatedAgreements.forEach((updatedAgreement) => {
          this.setData({
            data: {
              agreements: {
                [updatedAgreement.agreementId]: {
                  ...updatedAgreement
                }
              }
            }
          });
        });
        const unaprovedAgreements = updatedAgreements.some((agreement) => agreement.mode === "1" && agreement.valid === false);
        return !unaprovedAgreements;
      },
      async getCrosssells() {
        const crosssells = await this.getCachedResponse(getCrosssells, "getCrosssells", this.cartItems);
        this.setData({
          crosssells
        });
        return crosssells;
      },
      async getAmastyShippingData() {
        const data2 = await this.getCachedResponse(getAmastyShippingInfo, "getAmastyShippingInfo");
        if (data2) {
          this.setData({
            amastyData: data2
          });
        }
        this.calculateFreeShipping();
      },
      async addCartItem(product) {
        this.cartLoading = "true";
        const {
          sku
        } = product;
        await addCartItem({
          sku,
          qty: 1,
          quote_id: this.id
        });
        this.clearAllCaches();
        await this.getCartData();
        await this.getCart();
        if (this.penniesDonation.enabled) {
          await this.calculateDonation();
        }
        await this.getCartTotals();
        await this.getCrosssells();
        this.calculateFreeShipping();
        this.emitUpdate();
        const gtmStore = useGtmStore();
        gtmStore.addToCartEvent(product);
        this.cartLoading = "false";
      },
      calculateFreeShipping() {
        const { goal } = this.amastyData;
        if (goal) {
          this.setData({
            freeShipping: goal - this.subtotalInclTax
          });
        }
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCaches(cacheKeys) {
        if (cacheKeys.length) {
          cacheKeys.forEach((cacheKey) => {
            this.setData({
              cache: {
                [cacheKey]: void 0
              }
            });
          });
        }
      },
      clearAllCaches() {
        this.clearCaches(["getCartData", "getCart", "getCartTotals", "getCrosssells"]);
      },
      async emitUpdate() {
        const paymentStore = usePaymentStore();
        const shippingMethodsStore = useShippingMethodsStore();
        paymentStore.clearPaymentReponseCache();
        shippingMethodsStore.clearShippingMethodCache();
        await shippingMethodsStore.getShippingMethods();
        this.$state.cartEmitter.emit("cartUpdated");
        await refreshCustomerData(getCartSectionNames());
      },
      async addDonation() {
        await pennies.addCharityAmount();
        this.setData({
          penniesDonation: { isAvailable: false }
        });
        this.clearCaches(["getCartTotals"]);
        this.getCartTotals();
        await this.calculateDonation();
        this.emitUpdate();
      },
      async removeDonation() {
        await pennies.removeCharityAmount();
        this.setData({
          penniesDonation: { isAvailable: true }
        });
        this.clearCaches(["getCartTotals"]);
        this.getCartTotals();
        await this.calculateDonation();
        this.emitUpdate();
      },
      async calculateDonation() {
        const charityData = await pennies.getCharityAmount();
        this.setData({
          penniesDonation: {
            charityData,
            amount: (parseFloat(charityData.amount) / 100).toString()
          }
        });
      },
      async penniesConfigs() {
        const data2 = await this.getCachedResponse(pennies.getPenniesConfigs, "penniesConfigs");
        this.setData({
          penniesDonation: {
            logo: data2.PenniesData.charity_logo_url,
            enabled: data2.PenniesData.enabled === "true"
          }
        });
      },
      async useRewardPoints() {
        if (!this.maskedId) {
          const maskedId = await getMaskedIdFromGraphQl();
          this.setData({ maskedId });
        }
        await useRewardPoints();
        this.clearCaches(["getCartTotals"]);
        await this.getCartTotals();
        this.emitUpdate();
      },
      async removeRewardPoints() {
        if (!this.maskedId) {
          const maskedId = await getMaskedIdFromGraphQl();
          this.setData({ maskedId });
        }
        await removeRewardPoints();
        this.clearCaches(["getCartTotals"]);
        await this.getCartTotals();
        this.emitUpdate();
      },
      clearProductMessages() {
        Object.values(this.cartItems).forEach((product) => {
          Object.assign(product, { cartUpdateErrorMessage: null });
        });
      },
      clearCartItems(cartItemIds) {
        if (cartItemIds === "all") {
          Object.keys(this.cartItems).forEach((cartItemId) => {
            delete this.cartItems[cartItemId];
          });
          return;
        }
        const cartItemsArray = Array.isArray(cartItemIds) ? cartItemIds : [cartItemIds];
        cartItemsArray.forEach((cartItemId) => {
          delete this.cartItems[cartItemId];
        });
      }
    }
  });
  var getCustomerInformation = () => authenticatedRequest().get(`${getBaseRestUrl()}/customers/me`).then((response) => response.data).catch(() => {
    const customerStore = useCustomerStore();
    customerStore.setData({
      customer: {
        tokenType: tokenTypes.guestUser
      }
    });
  });
  var getDummyCustomerDetails = (sameAsShipping = false) => {
    const address = {
      id: 1,
      street: ["20 Middle St", ""],
      city: "Brighton and Hove",
      region: "",
      country_id: "",
      postcode: "BN1 1AL",
      company: "",
      telephone: "01273 030390",
      firstname: "Gene",
      lastname: "Commerce",
      editing: false
    };
    if (sameAsShipping) {
      address.same_as_shipping = true;
    }
    return address;
  };
  var getCustomerRewardPoints = () => {
    const request3 = `{
    customer {
      reward_points {
        balance {
          points
          money {
            value
            currency
          }
        }
      }
    }
  }`;
    return graphQlRequest(request3).then((response) => response.data);
  };
  var isEmailAvailable = (customerEmail, controller) => axios.post(`${getBaseRestUrl()}/customers/isEmailAvailable`, {
    customerEmail
  }, {
    signal: controller.signal
  }).then((response) => response.data);
  var login = (username, password) => {
    const { secureBaseUrl } = useConfigStore();
    const headers = {
      "X-Requested-With": "XMLHttpRequest"
    };
    return axios.post(`${secureBaseUrl}customer/ajax/login`, {
      username,
      password,
      context: "checkout"
    }, { headers }).then(({ data: data2 }) => {
      if (data2.errors) {
        throw new Error(data2.message);
      }
      return data2;
    });
  };
  var subscribeToNewsletter = () => {
    const { customer: { email } } = useCustomerStore();
    const request3 = `
    mutation {
      subscribeEmailToNewsletter(email: "${email}") {
        status
      }
    }`;
    return graphQlRequest(request3);
  };
  var amastyConsentLogic = (email) => axios.post(`${getBaseRestUrl()}/consent/getStatuses`, {
    email
  }).then((response) => response.data);
  var getEmptyAddress = (sameAsShipping = false) => {
    const address = {
      id: null,
      street: ["", ""],
      city: "",
      region: "",
      country_id: "",
      postcode: "",
      company: "",
      telephone: "",
      firstname: "",
      lastname: "",
      editing: false
    };
    if (sameAsShipping) {
      address.same_as_shipping = true;
    }
    return address;
  };
  var getPhoneValidation = (phone) => {
    const phoneValid = /^[+]?[\d() -]{8,32}$/im.test(phone);
    return phoneValid;
  };
  var getUrlTokens = {
    token: "",
    tokenType: tokenTypes.phpSessionId
  };
  var CountryCode;
  (function(CountryCode2) {
    CountryCode2["UK"] = "UK";
    CountryCode2["GB"] = "GB";
    CountryCode2["JE"] = "JE";
    CountryCode2["GG"] = "GG";
    CountryCode2["IM"] = "IM";
    CountryCode2["US"] = "US";
    CountryCode2["CA"] = "CA";
    CountryCode2["IE"] = "IE";
    CountryCode2["DE"] = "DE";
    CountryCode2["JP"] = "JP";
    CountryCode2["FR"] = "FR";
    CountryCode2["AU"] = "AU";
    CountryCode2["IT"] = "IT";
    CountryCode2["CH"] = "CH";
    CountryCode2["AT"] = "AT";
    CountryCode2["ES"] = "ES";
    CountryCode2["NL"] = "NL";
    CountryCode2["BE"] = "BE";
    CountryCode2["DK"] = "DK";
    CountryCode2["SE"] = "SE";
    CountryCode2["NO"] = "NO";
    CountryCode2["BR"] = "BR";
    CountryCode2["PT"] = "PT";
    CountryCode2["FI"] = "FI";
    CountryCode2["AX"] = "AX";
    CountryCode2["KR"] = "KR";
    CountryCode2["CN"] = "CN";
    CountryCode2["TW"] = "TW";
    CountryCode2["SG"] = "SG";
    CountryCode2["DZ"] = "DZ";
    CountryCode2["AD"] = "AD";
    CountryCode2["AR"] = "AR";
    CountryCode2["AM"] = "AM";
    CountryCode2["AZ"] = "AZ";
    CountryCode2["BH"] = "BH";
    CountryCode2["BD"] = "BD";
    CountryCode2["BB"] = "BB";
    CountryCode2["BY"] = "BY";
    CountryCode2["BM"] = "BM";
    CountryCode2["BA"] = "BA";
    CountryCode2["IO"] = "IO";
    CountryCode2["BN"] = "BN";
    CountryCode2["BG"] = "BG";
    CountryCode2["KH"] = "KH";
    CountryCode2["CV"] = "CV";
    CountryCode2["CL"] = "CL";
    CountryCode2["CR"] = "CR";
    CountryCode2["HR"] = "HR";
    CountryCode2["CY"] = "CY";
    CountryCode2["CZ"] = "CZ";
    CountryCode2["DO"] = "DO";
    CountryCode2["EC"] = "EC";
    CountryCode2["EG"] = "EG";
    CountryCode2["EE"] = "EE";
    CountryCode2["FO"] = "FO";
    CountryCode2["GE"] = "GE";
    CountryCode2["GR"] = "GR";
    CountryCode2["GL"] = "GL";
    CountryCode2["GT"] = "GT";
    CountryCode2["HT"] = "HT";
    CountryCode2["HN"] = "HN";
    CountryCode2["HU"] = "HU";
    CountryCode2["IS"] = "IS";
    CountryCode2["IN"] = "IN";
    CountryCode2["ID"] = "ID";
    CountryCode2["IL"] = "IL";
    CountryCode2["JO"] = "JO";
    CountryCode2["KZ"] = "KZ";
    CountryCode2["KE"] = "KE";
    CountryCode2["KW"] = "KW";
    CountryCode2["KY"] = "KY";
    CountryCode2["LA"] = "LA";
    CountryCode2["LV"] = "LV";
    CountryCode2["LB"] = "LB";
    CountryCode2["LI"] = "LI";
    CountryCode2["LT"] = "LT";
    CountryCode2["LU"] = "LU";
    CountryCode2["MK"] = "MK";
    CountryCode2["MY"] = "MY";
    CountryCode2["MV"] = "MV";
    CountryCode2["MT"] = "MT";
    CountryCode2["MU"] = "MU";
    CountryCode2["MX"] = "MX";
    CountryCode2["MD"] = "MD";
    CountryCode2["MC"] = "MC";
    CountryCode2["MA"] = "MA";
    CountryCode2["NP"] = "NP";
    CountryCode2["NZ"] = "NZ";
    CountryCode2["NI"] = "NI";
    CountryCode2["NG"] = "NG";
    CountryCode2["OM"] = "OM";
    CountryCode2["PA"] = "PA";
    CountryCode2["PK"] = "PK";
    CountryCode2["PY"] = "PY";
    CountryCode2["PH"] = "PH";
    CountryCode2["PL"] = "PL";
    CountryCode2["PR"] = "PR";
    CountryCode2["RO"] = "RO";
    CountryCode2["RU"] = "RU";
    CountryCode2["SM"] = "SM";
    CountryCode2["SA"] = "SA";
    CountryCode2["SN"] = "SN";
    CountryCode2["SK"] = "SK";
    CountryCode2["SI"] = "SI";
    CountryCode2["ZA"] = "ZA";
    CountryCode2["LK"] = "LK";
    CountryCode2["TJ"] = "TJ";
    CountryCode2["TH"] = "TH";
    CountryCode2["TN"] = "TN";
    CountryCode2["TR"] = "TR";
    CountryCode2["TM"] = "TM";
    CountryCode2["UA"] = "UA";
    CountryCode2["UY"] = "UY";
    CountryCode2["UZ"] = "UZ";
    CountryCode2["VA"] = "VA";
    CountryCode2["VE"] = "VE";
    CountryCode2["ZM"] = "ZM";
    CountryCode2["AS"] = "AS";
    CountryCode2["CC"] = "CC";
    CountryCode2["CK"] = "CK";
    CountryCode2["RS"] = "RS";
    CountryCode2["ME"] = "ME";
    CountryCode2["CS"] = "CS";
    CountryCode2["YU"] = "YU";
    CountryCode2["CX"] = "CX";
    CountryCode2["ET"] = "ET";
    CountryCode2["FK"] = "FK";
    CountryCode2["NF"] = "NF";
    CountryCode2["FM"] = "FM";
    CountryCode2["GF"] = "GF";
    CountryCode2["GN"] = "GN";
    CountryCode2["GP"] = "GP";
    CountryCode2["GS"] = "GS";
    CountryCode2["GU"] = "GU";
    CountryCode2["GW"] = "GW";
    CountryCode2["HM"] = "HM";
    CountryCode2["IQ"] = "IQ";
    CountryCode2["KG"] = "KG";
    CountryCode2["LR"] = "LR";
    CountryCode2["LS"] = "LS";
    CountryCode2["MG"] = "MG";
    CountryCode2["MH"] = "MH";
    CountryCode2["MN"] = "MN";
    CountryCode2["MP"] = "MP";
    CountryCode2["MQ"] = "MQ";
    CountryCode2["NC"] = "NC";
    CountryCode2["NE"] = "NE";
    CountryCode2["VI"] = "VI";
    CountryCode2["VN"] = "VN";
    CountryCode2["PF"] = "PF";
    CountryCode2["PG"] = "PG";
    CountryCode2["PM"] = "PM";
    CountryCode2["PN"] = "PN";
    CountryCode2["PW"] = "PW";
    CountryCode2["RE"] = "RE";
    CountryCode2["SH"] = "SH";
    CountryCode2["SJ"] = "SJ";
    CountryCode2["SO"] = "SO";
    CountryCode2["SZ"] = "SZ";
    CountryCode2["TC"] = "TC";
    CountryCode2["WF"] = "WF";
    CountryCode2["XK"] = "XK";
    CountryCode2["YT"] = "YT";
    CountryCode2["PE"] = "PE";
    CountryCode2["INTL"] = "INTL";
  })(CountryCode || (CountryCode = {}));
  const POSTCODE_REGEXES = /* @__PURE__ */ new Map([
    [
      CountryCode.UK,
      /^([A-Z]){1}([0-9][0-9]|[0-9]|[A-Z][0-9][A-Z]|[A-Z][0-9][0-9]|[A-Z][0-9]|[0-9][A-Z]){1}([ ])?([0-9][A-z][A-z]){1}$/i
    ],
    [
      CountryCode.GB,
      /^([A-Z]){1}([0-9][0-9]|[0-9]|[A-Z][0-9][A-Z]|[A-Z][0-9][0-9]|[A-Z][0-9]|[0-9][A-Z]){1}([ ])?([0-9][A-z][A-z]){1}$/i
    ],
    [CountryCode.JE, /^JE\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}$/],
    [CountryCode.GG, /^GY\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}$/],
    [CountryCode.IM, /^IM\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}$/],
    [CountryCode.US, /^([0-9]{5})(?:-([0-9]{4}))?$/],
    [CountryCode.CA, /^([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\s*([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])$/i],
    [CountryCode.IE, /^([AC-FHKNPRTV-Y][0-9]{2}|D6W)[ -]?[0-9AC-FHKNPRTV-Y]{4}$/],
    [CountryCode.DE, /^\d{5}$/],
    [CountryCode.JP, /^\d{3}-\d{4}$/],
    [CountryCode.FR, /^\d{2}[ ]?\d{3}$/],
    [CountryCode.AU, /^\d{4}$/],
    [CountryCode.IT, /^\d{5}$/],
    [CountryCode.CH, /^\d{4}$/],
    [CountryCode.AT, /^(?!0)\d{4}$/],
    [CountryCode.ES, /^(?:0[1-9]|[1-4]\d|5[0-2])\d{3}$/],
    [CountryCode.NL, /^\d{4}[ ]?[A-Z]{2}$/],
    [CountryCode.BE, /^\d{4}$/],
    [CountryCode.DK, /^\d{4}$/],
    [CountryCode.SE, /^(SE-)?\d{3}[ ]?\d{2}$/],
    [CountryCode.NO, /^\d{4}$/],
    [CountryCode.BR, /^\d{5}[\-]?\d{3}$/],
    [CountryCode.PT, /^\d{4}([\-]\d{3})?$/],
    [CountryCode.FI, /^(FI-|AX-)?\d{5}$/],
    [CountryCode.AX, /^22\d{3}$/],
    [CountryCode.KR, /^\d{5}$/],
    [CountryCode.CN, /^\d{6}$/],
    [CountryCode.TW, /^\d{3}(\d{2,3})?$/],
    [CountryCode.SG, /^\d{6}$/],
    [CountryCode.DZ, /^\d{5}$/],
    [CountryCode.AD, /^AD\d{3}$/],
    [CountryCode.AR, /^([A-HJ-NP-Z])?\d{4}([A-Z]{3})?$/],
    [CountryCode.AM, /^(37)?\d{4}$/],
    [CountryCode.AZ, /^\d{4}$/],
    [CountryCode.BH, /^((1[0-2]|[2-9])\d{2})?$/],
    [CountryCode.BD, /^\d{4}$/],
    [CountryCode.BB, /^(BB\d{5})?$/],
    [CountryCode.BY, /^\d{6}$/],
    [CountryCode.BM, /^[A-Z]{2}[ ]?[A-Z0-9]{2}$/],
    [CountryCode.BA, /^\d{5}$/],
    [CountryCode.IO, /^BBND 1ZZ$/],
    [CountryCode.BN, /^[A-Z]{2}[ ]?\d{4}$/],
    [CountryCode.BG, /^\d{4}$/],
    [CountryCode.KH, /^\d{5}$/],
    [CountryCode.CV, /^\d{4}$/],
    [CountryCode.CL, /^\d{7}$/],
    [CountryCode.CR, /^(\d{4,5}|\d{3}-\d{4})$/],
    [CountryCode.HR, /^(HR-)?\d{5}$/],
    [CountryCode.CY, /^\d{4}$/],
    [CountryCode.CZ, /^\d{3}[ ]?\d{2}$/],
    [CountryCode.DO, /^\d{5}$/],
    [CountryCode.EC, /^([A-Z]\d{4}[A-Z]|(?:[A-Z]{2})?\d{6})?$/],
    [CountryCode.EG, /^\d{5}$/],
    [CountryCode.EE, /^\d{5}$/],
    [CountryCode.FO, /^\d{3}$/],
    [CountryCode.GE, /^\d{4}$/],
    [CountryCode.GR, /^\d{3}[ ]?\d{2}$/],
    [CountryCode.GL, /^39\d{2}$/],
    [CountryCode.GT, /^\d{5}$/],
    [CountryCode.HT, /^\d{4}$/],
    [CountryCode.HN, /^(?:\d{5})?$/],
    [CountryCode.HU, /^\d{4}$/],
    [CountryCode.IS, /^\d{3}$/],
    [CountryCode.IN, /^\d{6}$/],
    [CountryCode.ID, /^\d{5}$/],
    [CountryCode.IL, /^\d{5,7}$/],
    [CountryCode.JO, /^\d{5}$/],
    [CountryCode.KZ, /^\d{6}$/],
    [CountryCode.KE, /^\d{5}$/],
    [CountryCode.KW, /^\d{5}$/],
    [CountryCode.KY, /^KY[123]-\d{4}$/],
    [CountryCode.LA, /^\d{5}$/],
    [CountryCode.LV, /^(LV-)?\d{4}$/],
    [CountryCode.LB, /^(\d{4}([ ]?\d{4})?)?$/],
    [CountryCode.LI, /^(948[5-9])|(949[0-7])$/],
    [CountryCode.LT, /^(LT-)?\d{5}$/],
    [CountryCode.LU, /^(L-)?\d{4}$/],
    [CountryCode.MK, /^\d{4}$/],
    [CountryCode.MY, /^\d{5}$/],
    [CountryCode.MV, /^\d{5}$/],
    [CountryCode.MT, /^[A-Z]{3}[ ]?\d{2,4}$/],
    [CountryCode.MU, /^((\d|[A-Z])\d{4})?$/],
    [CountryCode.MX, /^\d{5}$/],
    [CountryCode.MD, /^\d{4}$/],
    [CountryCode.MC, /^980\d{2}$/],
    [CountryCode.MA, /^\d{5}$/],
    [CountryCode.NP, /^\d{5}$/],
    [CountryCode.NZ, /^\d{4}$/],
    [CountryCode.NI, /^((\d{4}-)?\d{3}-\d{3}(-\d{1})?)?$/],
    [CountryCode.NG, /^(\d{6})?$/],
    [CountryCode.OM, /^(PC )?\d{3}$/],
    [CountryCode.PA, /^\d{4}$/],
    [CountryCode.PK, /^\d{5}$/],
    [CountryCode.PY, /^\d{4}$/],
    [CountryCode.PH, /^\d{4}$/],
    [CountryCode.PL, /^\d{2}-\d{3}$/],
    [CountryCode.PR, /^00[679]\d{2}([ \-]\d{4})?$/],
    [CountryCode.RO, /^\d{6}$/],
    [CountryCode.RU, /^\d{6}$/],
    [CountryCode.SM, /^4789\d$/],
    [CountryCode.SA, /^\d{5}$/],
    [CountryCode.SN, /^\d{5}$/],
    [CountryCode.SK, /^\d{3}[ ]?\d{2}$/],
    [CountryCode.SI, /^(SI-)?\d{4}$/],
    [CountryCode.ZA, /^\d{4}$/],
    [CountryCode.LK, /^\d{5}$/],
    [CountryCode.TJ, /^\d{6}$/],
    [CountryCode.TH, /^\d{5}$/],
    [CountryCode.TN, /^\d{4}$/],
    [CountryCode.TR, /^\d{5}$/],
    [CountryCode.TM, /^\d{6}$/],
    [CountryCode.UA, /^\d{5}$/],
    [CountryCode.UY, /^\d{5}$/],
    [CountryCode.UZ, /^\d{6}$/],
    [CountryCode.VA, /^00120$/],
    [CountryCode.VE, /^\d{4}$/],
    [CountryCode.ZM, /^\d{5}$/],
    [CountryCode.AS, /^96799$/],
    [CountryCode.CC, /^6799$/],
    [CountryCode.CK, /^\d{4}$/],
    [CountryCode.RS, /^\d{5,6}$/],
    [CountryCode.ME, /^8\d{4}$/],
    [CountryCode.CS, /^\d{5}$/],
    [CountryCode.YU, /^\d{5}$/],
    [CountryCode.CX, /^6798$/],
    [CountryCode.ET, /^\d{4}$/],
    [CountryCode.FK, /^FIQQ 1ZZ$/],
    [CountryCode.NF, /^2899$/],
    [CountryCode.FM, /^(9694[1-4])([ \-]\d{4})?$/],
    [CountryCode.GF, /^9[78]3\d{2}$/],
    [CountryCode.GN, /^\d{3}$/],
    [CountryCode.GP, /^9[78][01]\d{2}$/],
    [CountryCode.GS, /^SIQQ 1ZZ$/],
    [CountryCode.GU, /^969[123]\d([ \-]\d{4})?$/],
    [CountryCode.GW, /^\d{4}$/],
    [CountryCode.HM, /^\d{4}$/],
    [CountryCode.IQ, /^\d{5}$/],
    [CountryCode.KG, /^\d{6}$/],
    [CountryCode.LR, /^\d{4}$/],
    [CountryCode.LS, /^\d{3}$/],
    [CountryCode.MG, /^\d{3}$/],
    [CountryCode.MH, /^969[67]\d([ \-]\d{4})?$/],
    [CountryCode.MN, /^\d{6}$/],
    [CountryCode.MP, /^9695[012]([ \-]\d{4})?$/],
    [CountryCode.MQ, /^9[78]2\d{2}$/],
    [CountryCode.NC, /^988\d{2}$/],
    [CountryCode.NE, /^\d{4}$/],
    [CountryCode.VI, /^008(([0-4]\d)|(5[01]))([ \-]\d{4})?$/],
    [CountryCode.VN, /^\d{6}$/],
    [CountryCode.PF, /^987\d{2}$/],
    [CountryCode.PG, /^\d{3}$/],
    [CountryCode.PM, /^9[78]5\d{2}$/],
    [CountryCode.PN, /^PCRN 1ZZ$/],
    [CountryCode.PW, /^96940$/],
    [CountryCode.RE, /^9[78]4\d{2}$/],
    [CountryCode.SH, /^(ASCN|STHL) 1ZZ$/],
    [CountryCode.SJ, /^\d{4}$/],
    [CountryCode.SO, /^\d{5}$/],
    [CountryCode.SZ, /^[HLMS]\d{3}$/],
    [CountryCode.TC, /^TKCA 1ZZ$/],
    [CountryCode.WF, /^986\d{2}$/],
    [CountryCode.XK, /^\d{5}$/],
    [CountryCode.YT, /^976\d{2}$/],
    [CountryCode.PE, /^\d{5}$/],
    [CountryCode.INTL, /^(?:[A-Z0-9]+([- ]?[A-Z0-9]+)*)?$/i]
  ]);
  const postcodeValidator = (postcode, country) => {
    if (!POSTCODE_REGEXES.has(country)) {
      throw Error(`Invalid country code: ${country}`);
    }
    return POSTCODE_REGEXES.get(country).test(postcode);
  };
  const postcodeValidatorExistsForCountry = (country) => {
    return POSTCODE_REGEXES.has(country);
  };
  var useCustomerStore = defineStore("customerStore", {
    state: () => ({
      customer: { addresses: [], email: "", ...getUrlTokens },
      hasPreviouslyOrderedFpf: false,
      emailEntered: false,
      selected: {
        shipping: getDummyCustomerDetails(),
        billing: getDummyCustomerDetails(true),
        formErrors: {
          billing: [],
          shipping: [],
          message: {
            billing: false,
            shipping: false
          }
        },
        regionRequired: {
          billing: {
            required: false,
            regionOptions: []
          },
          shipping: {
            required: false,
            regionOptions: []
          }
        }
      },
      newsletter: {
        subscribeToNewsletter: false,
        isSubscribed: false
      },
      amastySubs: {},
      amastyConsentStatus: {},
      isEmailAvailableController: void 0,
      loadingCustomerInformation: false,
      postCodeValid: false,
      cache: {}
    }),
    getters: {
      isLoggedIn: (state) => state.customer.tokenType === tokenTypes.authKey || state.customer.tokenType === tokenTypes.phpSessionId,
      getSelectedBillingAddress: (state) => formatAddress(cleanAddress({ ...state.selected.billing })),
      getSelectedShippingAddress: (state) => formatAddress(cleanAddress({ ...state.selected.shipping })),
      isUsingSavedShippingAddress: (state) => state.customer.addresses.some((address) => address.id === state.selected.shipping.id),
      isUsingSavedBillingAddress: (state) => state.customer.addresses.some((address) => address.id === state.selected.billing.id),
      getAddressFieldHasError: (state) => (addressType, field) => state.selected.formErrors[addressType].find((fieldError) => fieldError === field),
      getRegionOptions: (state) => (addressType) => state.selected.regionRequired[addressType].regionOptions,
      getRegionRequired: (state) => (addressType) => state.selected.regionRequired[addressType].required
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      setAddress(address, addressType) {
        if (addressType === "shipping") {
          const shippingMethodsStore = useShippingMethodsStore();
          shippingMethodsStore.clearShippingMethodCache();
          if (this.selected.billing.same_as_shipping && !shippingMethodsStore.isClickAndCollect) {
            this.setData({
              selected: {
                billing: Object.assign(address, { email: this.customer.email })
              }
            });
          }
        }
        this.setData({
          selected: {
            [addressType]: Object.assign(address, { email: this.customer.email })
          }
        });
        const cartStore = useCartStore();
        cartStore.emitUpdate();
      },
      setAddressAsCustom(addressType) {
        this.setData({
          selected: {
            [addressType]: {
              id: "custom"
            }
          }
        });
        if (addressType === "billing") {
          this.setData({
            selected: {
              billing: {
                same_as_shipping: false
              }
            }
          });
        }
      },
      updateRegionRequired(addressType) {
        const { stateRequired } = useConfigStore();
        const currentCountry = this.selected[addressType].country_id;
        this.setData({
          selected: {
            regionRequired: {
              [addressType]: {
                required: false,
                regionOptions: []
              }
            }
          }
        });
        if (stateRequired.indexOf(currentCountry) !== -1) {
          const { countries } = useConfigStore();
          const country = countries.find((cty) => cty.id === currentCountry);
          if (country) {
            const availableRegions = country.available_regions || [];
            const regionOptions = availableRegions.map((region) => ({
              option: {
                name: region.name,
                value: region.id,
                code: region.code
              }
            }));
            this.setData({
              selected: {
                regionRequired: {
                  [addressType]: {
                    required: true,
                    regionOptions
                  }
                }
              }
            });
          }
        }
      },
      addAddressError(addressType, error) {
        const errors = this.selected.formErrors[addressType];
        const index = errors.indexOf(error);
        if (index === -1) {
          errors.push(error);
          this.setData({
            selected: {
              formErrors: {
                [addressType]: errors
              }
            }
          });
        }
      },
      removeAddressError(addressType, error) {
        const errors = this.selected.formErrors[addressType];
        const index = errors.indexOf(error);
        if (index !== -1) {
          errors.splice(index, 1);
          this.setData({
            selected: {
              formErrors: {
                [addressType]: errors
              }
            }
          });
        }
      },
      setEditing(addressType, value) {
        this.setData({
          selected: {
            [addressType]: {
              editing: value
            }
          }
        });
      },
      isEmailAvailable(email) {
        if (this.$state.isEmailAvailableController) {
          this.$state.isEmailAvailableController.abort();
        }
        const controller = new AbortController();
        this.setData({
          isEmailAvailableController: controller
        });
        return isEmailAvailable(email, controller);
      },
      setEmailAddress(email) {
        this.setData({
          customer: {
            email
          }
        });
      },
      async login(email, pass) {
        const data2 = await login(email, pass);
        refreshCustomerData(["customer"]);
        const cartStore = useCartStore();
        this.setData({
          customer: {
            email,
            tokenType: tokenTypes.phpSessionId
          }
        });
        cartStore.clearAllCaches();
        cartStore.clearCartItems("all");
        await cartStore.getCartData();
        await cartStore.getCart();
        await cartStore.getCartTotals();
        this.clearCaches(["getCustomerInformation"]);
        await this.getCustomerInformation();
        cartStore.setData({
          maskedId: null
        });
        return data2;
      },
      async getCustomerInformation() {
        var _a;
        if (this.customer.tokenType !== tokenTypes.guestUser) {
          this.setData({
            loadingCustomerInformation: true
          });
          const data2 = await this.getCachedResponse(getCustomerInformation, "getCustomerInformation");
          if (data2) {
            const matchedShipping = data2.addresses.findIndex((address) => doAddressesMatch(address, this.selected.shipping));
            if (matchedShipping !== -1) {
              this.setAddress(data2.addresses[matchedShipping], "shipping");
            }
            const matchedBilling = data2.addresses.findIndex((address) => doAddressesMatch(address, this.selected.billing));
            if (matchedBilling !== -1) {
              this.setAddress(data2.addresses[matchedBilling], "billing");
            }
            if (!this.selected.shipping.id && !this.selected.shipping.firstname) {
              const defaultShipping = this.getDefaultAddress(data2, "default_shipping");
              defaultShipping && this.setAddress(defaultShipping, "shipping");
            }
            if (!this.selected.billing.id && !this.selected.billing.firstname) {
              const defaultBilling = this.getDefaultAddress(data2, "default_billing");
              defaultBilling && this.setAddress(defaultBilling, "billing");
            }
            if (!this.selected.shipping.id) {
              this.setEditing("shipping", true);
            }
            if (!doAddressesMatch(this.selected.billing, this.selected.shipping)) {
              this.setAddressAsCustom("billing");
            }
            this.setData({
              newsletter: {
                isSubscribed: ((_a = data2.extension_attributes) == null ? void 0 : _a.is_subscribed) || false
              }
            });
          }
          if (this.customer.tokenType !== tokenTypes.authKey) {
            const tokenType = data2 && data2.id ? tokenTypes.phpSessionId : tokenTypes.guestUser;
            this.setData({
              customer: {
                tokenType
              }
            });
          }
          this.setData({
            loadingCustomerInformation: false
          });
          return data2;
        }
        if (!doAddressesMatch(this.selected.billing, this.selected.shipping)) {
          this.setAddressAsCustom("billing");
        }
        return null;
      },
      checkForGuestUser() {
        const maskedId = getMaskedId();
        if (maskedId) {
          this.setMaskedId(maskedId);
        }
      },
      setMaskedId(maskedId) {
        this.setData({
          customer: {
            token: maskedId,
            tokenType: tokenTypes.guestUser
          }
        });
      },
      submitEmail() {
        this.setData({ emailEntered: true });
      },
      editEmail() {
        this.setData({ emailEntered: false });
      },
      createNewAddress(addressType) {
        const sameAsShipping = addressType === "billing";
        this.setData({
          selected: {
            [addressType]: getEmptyAddress(sameAsShipping)
          }
        });
      },
      validateAddress(addressType, addErrors = false) {
        const requiredFields = {
          street: "Address Line 1",
          city: "City",
          country_id: "Country",
          region: "State/Region"
        };
        let valid = true;
        const streetAddress1 = this.selected[addressType].street[0];
        const streetAddress2 = this.selected[addressType].street[1];
        const streetAddressLength = [streetAddress1, streetAddress2].join(" ").length;
        Object.entries(requiredFields).forEach(([key, value]) => {
          addErrors && this.removeAddressError(addressType, value);
          if (key === "street") {
            if (!this.selected[addressType].street[0].trim() || streetAddressLength > 75) {
              addErrors && this.addAddressError(addressType, value);
              valid = false;
            }
          }
          if (key === "region") {
            if (this.selected.regionRequired[addressType].required) {
              if (!this.selected[addressType][key] || typeof this.selected[addressType][key] === "string" && !this.selected[addressType][key].trim()) {
                addErrors && this.addAddressError(addressType, value);
                valid = false;
              }
            }
          } else if (!this.selected[addressType][key] || typeof this.selected[addressType][key] === "string" && !this.selected[addressType][key].trim()) {
            addErrors && this.addAddressError(addressType, value);
            valid = false;
          }
        });
        if (!valid) {
          addErrors && this.setAddressErrorMessage(addressType);
        }
        return valid;
      },
      validatePostcode(addressType, addErrors = false) {
        const configStore = useConfigStore();
        addErrors && this.removeAddressError(addressType, "Country");
        addErrors && this.removeAddressError(addressType, "Postcode");
        let isValid = true;
        if (configStore.postcodeRequired(this.selected[addressType].country_id)) {
          if (!this.selected[addressType].country_id) {
            addErrors && this.addAddressError(addressType, "Country");
          } else {
            const countId = this.selected[addressType].country_id;
            const postCode = this.selected[addressType].postcode;
            if (postcodeValidatorExistsForCountry(countId)) {
              isValid = postcodeValidator(postCode, countId);
            } else {
              isValid = true;
            }
            this.setData({
              postCodeValid: isValid
            });
            !isValid && addErrors && this.addAddressError(addressType, "Postcode");
          }
        }
        this.setData({
          postCodeValid: isValid
        });
        return isValid;
      },
      validateNameField(addressType, fieldName, value, addErrors = false) {
        const invalid = !value || typeof value === "string" && !value.trim();
        if (invalid) {
          addErrors && this.addAddressError(addressType, fieldName);
        } else {
          this.removeAddressError(addressType, fieldName);
        }
        return !invalid;
      },
      validatePhone(addressType, phone, addErrors = false) {
        const isValid = getPhoneValidation(phone);
        if (!isValid) {
          addErrors && this.addAddressError(addressType, "Telephone");
        } else {
          this.removeAddressError(addressType, "Telephone");
        }
        return isValid;
      },
      setAddressErrorMessage(addressType) {
        const address = this.selected.formErrors[addressType];
        if (address.length) {
          const message = `The following fields are missing from your ${addressType} address: ${address.join(", ").toString()}`;
          this.setData({
            selected: {
              formErrors: {
                message: {
                  [addressType]: message
                }
              }
            }
          });
        }
      },
      getDefaultAddress(data2, addressType) {
        const foundAddress = data2.addresses.find((address) => typeof address[addressType] !== "undefined" && address[addressType]);
        if (foundAddress) {
          const { region } = foundAddress;
          foundAddress.region = region.region ? region.region : region;
        }
        return foundAddress ? Object.assign(foundAddress, { editing: false }) : {};
      },
      async getAvailableRewardPoints() {
        const response = await getCustomerRewardPoints();
        if (response.customer) {
          this.setData(response);
        }
      },
      async subscribeToNewsletter() {
        const { newsletterEnabled, newsletterAllowGuests } = useConfigStore();
        const newSignUp = this.isLoggedIn ? !this.newsletter.isSubscribed : newsletterAllowGuests;
        if (newsletterEnabled && newSignUp && this.newsletter.subscribeToNewsletter) {
          await subscribeToNewsletter();
        }
      },
      updateNewsletterSubscription(state) {
        this.setData({
          newsletter: {
            subscribeToNewsletter: state
          }
        });
      },
      updateAmastySubscription(state) {
        this.setData({
          amastySubs: state
        });
      },
      async getAmastyConsentStatus(email) {
        const status = await amastyConsentLogic(email);
        this.setData({
          amastyConsentStatus: status
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCaches(cacheKeys) {
        if (cacheKeys.length) {
          cacheKeys.forEach((cacheKey) => {
            this.setData({
              cache: {
                [cacheKey]: void 0
              }
            });
          });
        }
      }
    }
  });
  var afdPostcode = {
    getAfdConfiguration() {
      const request3 = `{
      storeConfig {
        afd_general_account_type
        afd_general_account_serial_url
        afd_general_account_serial
        afd_general_account_password
        afd_general_account_id_url
        afd_general_account_id
        afd_general_account_token
        afd_response_max_quantity
      }
    }`;
      return graphQlRequest(request3).then((response) => response.data.storeConfig);
    },
    getSuggestions(query, addressType) {
      var _a;
      const { countryCode, afd: { maxQuantity } } = useConfigStore();
      const { selected } = useCustomerStore();
      const afdCountry = ((_a = selected[addressType]) == null ? void 0 : _a.country_id) || countryCode;
      const paramsObj = {
        format: "json",
        intp: "mag010603",
        intf: "jqu011001",
        countryiso: `${afdCountry}`,
        data: "address",
        fields: "fflist",
        task: "fastfindv4",
        lookup: `${query}`,
        allpc: "1",
        matchPositions: "1",
        maxquantity: maxQuantity,
        uniqueid: "89296&_=1664704178149"
      };
      const searchParams = new URLSearchParams(this.addCredentials(paramsObj));
      const requestUrl = `${retrieveUrl$1()}?${searchParams}`;
      return axios.get(requestUrl).then((response) => response.data.Item).catch(this.logResponseErrors);
    },
    logResponseErrors(error) {
      if (axios.isCancel(error))
        console.log("AFD request cancelled");
    },
    getAndUseAddress(id, addressType) {
      var _a;
      const { countryCode } = useConfigStore();
      const { selected } = useCustomerStore();
      const afdCountry = ((_a = selected[addressType]) == null ? void 0 : _a.country_id) || countryCode;
      const paramsObj = {
        format: "json",
        intp: "mag010603",
        intf: "jqu011001",
        countryiso: `${afdCountry}`,
        key: `${id}`,
        data: "address",
        fields: "standard",
        task: "retrieve"
      };
      const searchParams = new URLSearchParams(this.addCredentials(paramsObj));
      return axios.get(`${retrieveUrl$1()}?${searchParams}`).then((response) => {
        if (typeof response.data.Item[0].Error !== "string") {
          return response.data.Item[0];
        }
        return handleError({ error: { message: response.data.Item[0].Error } });
      });
    },
    addCredentials(params) {
      const { afd } = useConfigStore();
      const credentials = afd.type === "id" ? {
        id: afd.id,
        token: afd.token
      } : {
        serial: afd.serial,
        password: afd.password
      };
      return Object.assign(params, credentials);
    }
  };
  var getBlock = (blockId) => axios.get(`${getBaseRestUrl()}/cmsBlock/${blockId}`).then((response) => response.data);
  var getCountries = () => {
    const request3 = `{
    countries {
      id
      two_letter_abbreviation
      three_letter_abbreviation
      full_name_locale
      available_regions {
        id
        code
        name
      }
    }
  }`;
    return graphQlRequest(request3).then((response) => {
      response.data.countries.sort((a, b) => a.full_name_locale.toUpperCase().localeCompare(b.full_name_locale.toUpperCase()));
      return response;
    });
  };
  var getStoreCode = () => {
    const storeId = getStoreId();
    const request3 = `{
    storecode(store_id: "${storeId}") {
        store_code
    }
  }`;
    return graphQlRequest(request3).then((response) => {
      var _a, _b;
      return (_b = (_a = response.data) == null ? void 0 : _a.storecode) == null ? void 0 : _b.store_code;
    });
  };
  var getCustomConfigs = [];
  var getPrivacyPolicyId = () => "privacy_policy_content";
  var getGeneralTermsServicesId = () => "general_terms_services";
  var getWithdrawTermsServicesId = () => "withdraw_terms_services";
  var mapCustomConfigs = () => ({});
  var getFallBackStaticPath = () => {
    const element = document.querySelector("[data-static-path]");
    if (element) {
      const { staticPath } = element.dataset;
      const staticPathFragments = staticPath.split("/");
      const staticIndex = staticPathFragments.findIndex((path) => path.startsWith("version"));
      return staticPathFragments.slice(0, staticIndex + 1).join("/");
    }
    return void 0;
  };
  var getStoreCodeFromLocalStorage = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.storeCode ? mageCache.cart.storeCode : null;
  };
  var getLocale = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.locale ? mageCache.cart.locale : null;
  };
  var getCurrencyCode = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.currencyCode ? mageCache.cart.currencyCode : void 0;
  };
  var useConfigStore = defineStore("configStore", {
    state: () => ({
      staticUrl: getFallBackStaticPath(),
      currencyCode: getCurrencyCode(),
      storeCode: getStoreCodeFromLocalStorage(),
      locale: getLocale(),
      countryCode: void 0,
      adyenAuthToken: void 0,
      adyenEnvironmentMode: "live",
      adyenVaultEnabled: false,
      rvvupPaymentsActive: false,
      cache: {},
      privacyPolicy: {},
      generalTermsServices: {},
      withdrawTermsServices: {},
      countries: [],
      secureBaseUrl: void 0,
      useStoreInUrl: false,
      newsletterEnabled: false,
      newsletterAllowGuests: false,
      stateRequired: [],
      displayState: false,
      rewardsEnabled: false,
      clickandcollectSms: false,
      custom: {},
      optionalZipCountries: "",
      loqate: {},
      afd: {},
      websiteName: "",
      taxCartDisplayPrice: false,
      taxCartDisplayShipping: false,
      taxCartDisplayFullSummary: false,
      copyrightText: ""
    }),
    getters: {
      postcodeRequired: (state) => (countryId) => !state.optionalZipCountries.includes(countryId)
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      async getConfig(configs) {
        const cacheKey = this.createCacheKey(configs);
        const data2 = await this.getCachedResponse(getStoreConfig, cacheKey, configs);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      async getStoreCode() {
        const storeCode = await getStoreCode();
        this.setData({
          storeCode
        });
      },
      async getStoreConfig() {
        if (!this.storeCode) {
          await this.getCachedResponse(this.getStoreCode, "getStoreCode");
        }
        const configs = [
          "base_static_url",
          "default_display_currency_code",
          "code",
          "secure_base_url",
          "use_store_in_url",
          "website_name",
          "gene_better_checkout_newsletter_enabled",
          "gene_better_checkout_newsletter_allow_guest",
          "gene_better_checkout_country_state_required",
          "gene_better_checkout_country_display_state",
          "magento_reward_general_is_enabled",
          "magento_reward_general_is_enabled_on_front",
          "optional_zip_countries",
          "tax_cart_display_price",
          "tax_cart_display_shipping",
          "tax_cart_display_full_summary",
          "gene_better_checkout_copyright_text"
        ];
        if (this.locale) {
          this.setLocale(this.locale);
        } else {
          configs.push("locale");
        }
        const promises = [];
        if (!this.countries.length) {
          promises.push(this.getCachedResponse(this.getCountries, "getCountries"));
        }
        const allConfigs = configs.concat(getCustomConfigs);
        const getConfigRequest = this.getConfig(allConfigs).then(async (data2) => {
          this.setData({
            staticUrl: data2.base_static_url.replace(/\/+$/, ""),
            currencyCode: data2.default_display_currency_code,
            storeCode: data2.code,
            useStoreInUrl: data2.use_store_in_url,
            websiteName: data2.website_name || "",
            secureBaseUrl: data2.secure_base_url,
            newsletterEnabled: data2.gene_better_checkout_newsletter_enabled === "1",
            newsletterAllowGuests: data2.gene_better_checkout_newsletter_allow_guest === "1",
            stateRequired: data2.gene_better_checkout_country_state_required ? data2.gene_better_checkout_country_state_required.split(",") : [],
            displayState: data2.gene_better_checkout_country_display_state === "1",
            rewardsEnabled: data2.magento_reward_general_is_enabled === "1" && data2.magento_reward_general_is_enabled_on_front === "1",
            optionalZipCountries: data2.optional_zip_countries || "",
            taxCartDisplayPrice: data2.tax_cart_display_price === "2",
            taxCartDisplayShipping: data2.tax_cart_display_shipping === "2",
            taxCartDisplayFullSummary: data2.tax_cart_display_full_summary === "1",
            copyrightText: data2.gene_better_checkout_copyright_text
          });
          if (data2.locale) {
            this.setLocale(data2.locale);
          }
          const customConfigs = await mapCustomConfigs();
          this.setData({
            custom: customConfigs
          });
        });
        promises.push(getConfigRequest);
        await Promise.all(promises);
      },
      setLocale(locale) {
        const replaced = locale.replace("_", "-");
        const countryCode = replaced.split("-")[1];
        this.$i18n.global.locale = replaced;
        this.setData({
          countryCode,
          locale: replaced
        });
      },
      async getAdyenConfig() {
        const configs = [
          "gene_better_checkout_adyen_auth_token",
          "adyen_environment_mode",
          "adyen_vault_enabled"
        ];
        const data2 = await this.getCachedResponse(this.getConfig, "getAdyenConfig", configs);
        this.setData({
          adyenAuthToken: data2.gene_better_checkout_adyen_auth_token,
          adyenEnvironmentMode: data2.adyen_environment_mode === "0" ? "live" : "test",
          adyenVaultEnabled: data2.adyen_vault_enabled
        });
      },
      async getRvvupConfig() {
        const configs = [
          "rvvup_payments_active"
        ];
        const data2 = await this.getConfig(configs);
        if (data2) {
          this.setData({
            rvvupPaymentsActive: !!Number(data2.rvvup_payments_active)
          });
        }
      },
      createCacheKey(configs) {
        return configs.join("-");
      },
      getRegionsByCountry(countryId) {
        const country = this.countries.find((cty) => cty.id === countryId);
        if (country) {
          const availableRegions = country.available_regions || [];
          const regionOptions = availableRegions.map((region) => ({
            option: {
              name: region.name,
              value: region.id,
              code: region.code
            }
          }));
          return regionOptions;
        }
        return [];
      },
      async getPrivacyPolicyBlock() {
        const privacyPolicyId = getPrivacyPolicyId();
        {
          const data2 = await this.getCachedResponse(getBlock, "getPrivacyPolicyBlock", privacyPolicyId);
          this.setData({
            privacyPolicy: data2
          });
        }
      },
      async getGeneralTermsServicesBlock() {
        const generalTermsServicesId = getGeneralTermsServicesId();
        {
          const data2 = await this.getCachedResponse(getBlock, "getGeneralTermsServicesBlock", generalTermsServicesId);
          this.setData({
            generalTermsServices: data2
          });
        }
      },
      async getWithdrawTermsServicesBlock() {
        const withdrawTermsServicesId = getWithdrawTermsServicesId();
        {
          const data2 = await this.getCachedResponse(getBlock, "getWithdrawTermsServicesBlock", withdrawTermsServicesId);
          this.setData({
            withdrawTermsServices: data2
          });
        }
      },
      async getCountries() {
        const { data: data2 } = await getCountries();
        this.setData(data2);
      },
      async getLoqateConfiguration() {
        const config = await this.getConfig(["gene_better_checkout_loqate_api_key"]);
        this.setData({
          loqate: {
            apiKey: config.gene_better_checkout_loqate_api_key
          }
        });
      },
      async getAfdConfiguration() {
        const config = await this.getCachedResponse(afdPostcode.getAfdConfiguration, "getAfdConfiguration");
        this.setData({
          afd: {
            type: config.afd_general_account_type,
            serialUrl: config.afd_general_account_serial_url,
            serial: config.afd_general_account_serial,
            password: config.afd_general_account_password,
            idUrl: config.afd_general_account_id_url,
            id: config.afd_general_account_id,
            token: config.afd_general_account_token,
            maxQuantity: config.afd_response_max_quantity || "5"
          }
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCache(cacheKey) {
        if (cacheKey) {
          this.setData({
            cache: {
              [cacheKey]: void 0
            }
          });
        }
      }
    }
  });
  var _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$1k = {
    name: "TextField",
    props: {
      text: {
        type: String,
        required: true,
        default: ""
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      },
      fontStyle: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          fontSize: reactiveProps.fontSize,
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontStyle: reactiveProps.fontStyle
        })),
        classes: computed(() => ({
          "text-loading": typeof reactiveProps.text === "string" && reactiveProps.text === " "
        }))
      };
    }
  };
  const _hoisted_1$1e = ["innerHTML"];
  function _sfc_render$1k(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("p", {
      class: normalizeClass($setup.classes),
      style: normalizeStyle($setup.style),
      innerHTML: $setup.classes["text-loading"] ? "" : $props.text
    }, null, 14, _hoisted_1$1e);
  }
  var TextField = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$1k], ["__scopeId", "data-v-1f81e380"]]);
  var getStaticUrl = (file) => {
    const { location: { hostname } } = window;
    const { staticUrl } = useConfigStore();
    if (staticUrl) {
      return hostname === "localhost" ? file : staticUrl + file;
    }
    return "";
  };
  var ApplePaySvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-apple.svg";
  var GooglePaySvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-google.svg";
  var ExpressPaySvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-express.svg";
  var PayPalSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-paypal.svg";
  var KlarnaSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-klarna.svg";
  var MaestroPaySvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-maestro.svg";
  var MastercardPaySvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-mastercard.svg";
  var VisaPaySvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-visa.svg";
  var ClearpaySvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/icon-clearpay.svg";
  const _sfc_main$1j = {
    name: "FooterIcons",
    props: {
      visibility: {
        type: String
      }
    },
    computed: {
      ApplePayIcon() {
        return `${getStaticUrl(ApplePaySvg)}`;
      },
      GooglePayIcon() {
        return `${getStaticUrl(GooglePaySvg)}`;
      },
      ExpressPayIcon() {
        return `${getStaticUrl(ExpressPaySvg)}`;
      },
      PayPalIcon() {
        return `${getStaticUrl(PayPalSvg)}`;
      },
      KlarnaIcon() {
        return `${getStaticUrl(KlarnaSvg)}`;
      },
      MaestroPayIcon() {
        return `${getStaticUrl(MaestroPaySvg)}`;
      },
      MastercardPayIcon() {
        return `${getStaticUrl(MastercardPaySvg)}`;
      },
      VisaPayIcon() {
        return `${getStaticUrl(VisaPaySvg)}`;
      },
      ClearpayIcon() {
        return `${getStaticUrl(ClearpaySvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          display: reactiveProps.visibility
        }))
      };
    }
  };
  const _hoisted_1$1d = ["src", "alt"];
  const _hoisted_2$Y = ["src", "alt"];
  const _hoisted_3$L = ["src", "alt"];
  const _hoisted_4$u = ["src", "alt"];
  const _hoisted_5$n = ["src", "alt"];
  const _hoisted_6$f = ["src", "alt"];
  const _hoisted_7$b = ["src", "alt"];
  const _hoisted_8$a = ["src", "alt"];
  const _hoisted_9$9 = ["src", "alt"];
  function _sfc_render$1j(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", {
      style: normalizeStyle($setup.style),
      class: "footer-icons"
    }, [
      createBaseVNode("ul", null, [
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            src: $options.VisaPayIcon,
            alt: $options.VisaPayIcon
          }, null, 8, _hoisted_1$1d)
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            src: $options.PayPalIcon,
            alt: $options.PayPalIcon,
            style: { "width": "50px" }
          }, null, 8, _hoisted_2$Y)
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            src: $options.MaestroPayIcon,
            alt: $options.MaestroPayIcon,
            style: { "width": "20px" }
          }, null, 8, _hoisted_3$L)
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            src: $options.MastercardPayIcon,
            alt: $options.MastercardPayIcon,
            style: { "width": "20px" }
          }, null, 8, _hoisted_4$u)
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            src: $options.ExpressPayIcon,
            alt: $options.ExpressPayIcon
          }, null, 8, _hoisted_5$n)
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            src: $options.GooglePayIcon,
            alt: $options.GooglePayIcon
          }, null, 8, _hoisted_6$f)
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            src: $options.ApplePayIcon,
            alt: $options.ApplePayIcon
          }, null, 8, _hoisted_7$b)
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            class: "klarna-icon",
            src: $options.KlarnaIcon,
            alt: $options.KlarnaIcon
          }, null, 8, _hoisted_8$a)
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("img", {
            src: $options.ClearpayIcon,
            alt: $options.ClearpayIcon
          }, null, 8, _hoisted_9$9)
        ])
      ])
    ], 4);
  }
  var FooterIcons = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$1j], ["__scopeId", "data-v-4c71fc21"]]);
  const _sfc_main$1i = {
    name: "AppFooter",
    components: {
      TextField,
      FooterIcons
    },
    props: {
      backgroundColor: {
        type: String
      }
    },
    computed: {
      ...mapState(useConfigStore, ["copyrightText"])
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor
        }))
      };
    }
  };
  const _hoisted_1$1c = { class: "footer-block" };
  function _sfc_render$1i(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_FooterIcons = resolveComponent("FooterIcons");
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("footer", {
      class: "footer-container",
      style: normalizeStyle($setup.style)
    }, [
      createBaseVNode("div", _hoisted_1$1c, [
        createVNode(_component_FooterIcons),
        createVNode(_component_TextField, { text: _ctx.copyrightText }, null, 8, ["text"])
      ])
    ], 4);
  }
  var AppFooter = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$1i], ["__scopeId", "data-v-dc438d6a"]]);
  var logoSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/logo.svg";
  const _sfc_main$1h = {
    name: "Logo",
    props: {
      params: {
        type: String
      },
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      alt: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    },
    data() {
      return {
        logo: ""
      };
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.logo = ((_a = window.geneCheckout) == null ? void 0 : _a.logo) || getStaticUrl(logoSvg);
      document.addEventListener("gene:checkout-image-update", (event) => {
        this.logo = (event == null ? void 0 : event.detail) || getStaticUrl(logoSvg);
      });
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"])
    }
  };
  const _hoisted_1$1b = ["src", "alt"];
  function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $data.logo,
      alt: $props.alt,
      style: normalizeStyle($props.params)
    }, null, 12, _hoisted_1$1b);
  }
  var Logo = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["render", _sfc_render$1h]]);
  var lockIconSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/lockIcon.svg";
  const _sfc_main$1g = {
    name: "Lock",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      lockIconSvg() {
        return `${getStaticUrl(lockIconSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$1a = ["src", "alt"];
  function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.lockIconSvg,
      alt: $options.lockIconSvg
    }, null, 8, _hoisted_1$1a);
  }
  var Lock = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$1g]]);
  const _sfc_main$1f = {
    name: "AppHeader",
    components: {
      Logo,
      Lock,
      TextField
    },
    data() {
      return {
        headerText: "",
        headerTextId: "gene-bettercheckout-header-text"
      };
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.headerText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.headerTextId]) || this.$t("header.text");
      document.addEventListener(this.headerTextId, this.setHeaderText);
    },
    unmounted() {
      document.removeEventListener(this.headerTextId, this.setHeaderText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setHeaderText(event) {
        this.headerText = (event == null ? void 0 : event.detail) || this.$t("header.text");
      }
    }
  };
  const _hoisted_1$19 = { class: "header-content" };
  const _hoisted_2$X = { class: "header-title" };
  function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Logo = resolveComponent("Logo");
    const _component_Lock = resolveComponent("Lock");
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("header", {
      class: "header-container",
      style: normalizeStyle(_ctx.style)
    }, [
      createBaseVNode("div", _hoisted_1$19, [
        createVNode(_component_Logo, { alt: "logo" }),
        createBaseVNode("div", _hoisted_2$X, [
          createVNode(_component_Lock, {
            stroke: "white",
            class: "secure-logo"
          }),
          createVNode(_component_TextField, {
            class: "secure-text",
            text: $data.headerText
          }, null, 8, ["text"])
        ])
      ])
    ], 4);
  }
  var AppHeader = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["render", _sfc_render$1f], ["__scopeId", "data-v-758f2920"]]);
  const _sfc_main$1e = {
    name: "MockDesktop"
  };
  const _hoisted_1$18 = { class: "mock-desktop" };
  const _hoisted_2$W = { class: "display" };
  const _hoisted_3$K = /* @__PURE__ */ createBaseVNode("div", { class: "footer" }, null, -1);
  const _hoisted_4$t = /* @__PURE__ */ createBaseVNode("div", { class: "stand" }, null, -1);
  function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$18, [
        createBaseVNode("div", _hoisted_2$W, [
          renderSlot(_ctx.$slots, "default")
        ])
      ]),
      _hoisted_3$K,
      _hoisted_4$t
    ], 64);
  }
  var MockDesktop = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$1e]]);
  const _sfc_main$1d = {
    name: "MockFull"
  };
  const _hoisted_1$17 = { class: "mock-full" };
  const _hoisted_2$V = { class: "display" };
  function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$17, [
      createBaseVNode("div", _hoisted_2$V, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ]);
  }
  var MockFull = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$1d], ["__scopeId", "data-v-eed1cf12"]]);
  const _sfc_main$1c = {
    name: "MockLaptop"
  };
  const _withScopeId$5 = (n) => (pushScopeId("data-v-6e47274c"), n = n(), popScopeId(), n);
  const _hoisted_1$16 = { class: "mock-laptop" };
  const _hoisted_2$U = { class: "display" };
  const _hoisted_3$J = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "footer" }, null, -1));
  function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$16, [
        createBaseVNode("div", _hoisted_2$U, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      _hoisted_3$J
    ], 64);
  }
  var MockLaptop = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$1c], ["__scopeId", "data-v-6e47274c"]]);
  const _sfc_main$1b = {
    name: "MockMobile"
  };
  const _withScopeId$4 = (n) => (pushScopeId("data-v-c33f62b2"), n = n(), popScopeId(), n);
  const _hoisted_1$15 = { class: "mock-mobile" };
  const _hoisted_2$T = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "camera" }, null, -1));
  const _hoisted_3$I = { class: "display" };
  function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$15, [
      _hoisted_2$T,
      createBaseVNode("div", _hoisted_3$I, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ]);
  }
  var MockMobile = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$1b], ["__scopeId", "data-v-c33f62b2"]]);
  const _sfc_main$1a = {
    name: "MockTablet"
  };
  const _hoisted_1$14 = { class: "mock-tablet" };
  const _hoisted_2$S = { class: "display" };
  function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$14, [
      createBaseVNode("div", _hoisted_2$S, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ]);
  }
  var MockTablet = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$1a], ["__scopeId", "data-v-69519b4b"]]);
  const _sfc_main$19 = {
    name: "SlideUp",
    props: {
      visible: {
        type: Boolean,
        default: false
      }
    },
    emits: ["close", "focus"],
    methods: {
      close() {
        this.$emit("close");
      },
      focus() {
        this.$emit("focus");
      }
    }
  };
  const _hoisted_1$13 = {
    id: "slideUpTitle",
    class: "slideup-header"
  };
  const _hoisted_2$R = {
    id: "slideUpBody",
    class: "slideUp-body"
  };
  function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(Transition, { name: "fade" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: "slideup-backdrop",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.close && $options.close(...args)),
            onKeydown: _cache[1] || (_cache[1] = (...args) => $options.focus && $options.focus(...args))
          }, null, 544), [
            [vShow, $props.visible]
          ])
        ]),
        _: 1
      }),
      createVNode(Transition, {
        name: "slideup",
        appear: ""
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: "slideup-container",
            role: "dialog",
            "aria-labelledby": "slideUpTitle",
            "aria-describedby": "slideUpBody",
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("header", _hoisted_1$13, [
              renderSlot(_ctx.$slots, "header", {}, void 0, true)
            ]),
            createBaseVNode("section", _hoisted_2$R, [
              renderSlot(_ctx.$slots, "body", {}, void 0, true)
            ])
          ], 512), [
            [vShow, $props.visible]
          ])
        ]),
        _: 3
      })
    ], 64);
  }
  var SlideUp = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$19], ["__scopeId", "data-v-dbd0810a"]]);
  var Loader$1 = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/loader.gif";
  const _sfc_main$18 = {
    name: "Loader",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      overlay: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height
        }))
      };
    },
    computed: {
      Loader() {
        return `${getStaticUrl(Loader$1)}`;
      }
    },
    methods: {
      captureClick(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    }
  };
  const _hoisted_1$12 = { class: "loader" };
  const _hoisted_2$Q = ["src"];
  const _hoisted_3$H = {
    key: 1,
    class: "loader"
  };
  const _hoisted_4$s = ["src"];
  function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      $props.overlay ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "loading-mask",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.captureClick && $options.captureClick(...args)),
        onKeydown: _cache[1] || (_cache[1] = (...args) => $options.captureClick && $options.captureClick(...args))
      }, [
        createBaseVNode("div", _hoisted_1$12, [
          createBaseVNode("img", {
            style: normalizeStyle($setup.style),
            src: $options.Loader,
            alt: "loader"
          }, null, 12, _hoisted_2$Q)
        ])
      ], 32)) : createCommentVNode("", true),
      !$props.overlay ? (openBlock(), createElementBlock("div", _hoisted_3$H, [
        createBaseVNode("img", {
          style: normalizeStyle($setup.style),
          src: $options.Loader,
          alt: "loader"
        }, null, 12, _hoisted_4$s)
      ])) : createCommentVNode("", true)
    ], 64);
  }
  var Loader = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$18]]);
  const _sfc_main$17 = {
    name: "Price",
    props: {
      value: {
        type: String,
        required: true
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      },
      fontStyle: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          fontSize: reactiveProps.fontSize,
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontStyle: reactiveProps.fontStyle
        }))
      };
    },
    methods: {
      formatPrice(price) {
        if (price === void 0)
          return "";
        return price < 0 ? `-${formatPrice(Math.abs(price))}` : formatPrice(price);
      }
    }
  };
  function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("p", {
      style: normalizeStyle($setup.style)
    }, toDisplayString$1($options.formatPrice($props.value)), 5);
  }
  var Price = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$17]]);
  const _sfc_main$16 = {
    name: "ErrorIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$11 = ["role", "aria-label"];
  const _hoisted_2$P = /* @__PURE__ */ createBaseVNode("path", {
    d: "M10 0C12.6522 0 15.1957 1.05357 17.0711 2.92893C18.9464 4.8043 20 7.34784 20 10C20 12.6522 18.9464 15.1957 17.0711 17.0711C15.1957 18.9464 12.6522 20 10 20C7.34784 20 4.8043 18.9464 2.92893 17.0711C1.05357 15.1957 0 12.6522 0 10C0 7.34784 1.05357 4.8043 2.92893 2.92893C4.8043 1.05357 7.34784 0 10 0ZM10 4.28571C9.81863 4.28556 9.63922 4.32323 9.47323 4.39633C9.30724 4.46943 9.15832 4.57634 9.03598 4.71024C8.91364 4.84414 8.82058 5.00208 8.76273 5.17398C8.70487 5.34588 8.68351 5.52795 8.7 5.70857L9.22143 11.4314C9.24164 11.6238 9.33239 11.8019 9.47616 11.9314C9.61993 12.0608 9.80654 12.1325 10 12.1325C10.1935 12.1325 10.3801 12.0608 10.5238 11.9314C10.6676 11.8019 10.7584 11.6238 10.7786 11.4314L11.2986 5.70857C11.315 5.52807 11.2937 5.34612 11.236 5.17432C11.1782 5.00252 11.0853 4.84464 10.9631 4.71077C10.8409 4.57689 10.6921 4.46995 10.5263 4.39676C10.3605 4.32358 10.1813 4.28576 10 4.28571ZM10 15.7143C10.3031 15.7143 10.5938 15.5939 10.8081 15.3796C11.0224 15.1652 11.1429 14.8745 11.1429 14.5714C11.1429 14.2683 11.0224 13.9776 10.8081 13.7633C10.5938 13.549 10.3031 13.4286 10 13.4286C9.6969 13.4286 9.40621 13.549 9.19188 13.7633C8.97755 13.9776 8.85714 14.2683 8.85714 14.5714C8.85714 14.8745 8.97755 15.1652 9.19188 15.3796C9.40621 15.5939 9.6969 15.7143 10 15.7143Z",
    fill: ""
  }, null, -1);
  const _hoisted_3$G = [
    _hoisted_2$P
  ];
  function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "20",
      height: "20",
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$G, 12, _hoisted_1$11);
  }
  var ErrorIcon = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16]]);
  const _sfc_main$15 = {
    name: "ErrorMessage",
    components: {
      TextField,
      ErrorIcon
    },
    props: {
      message: {
        type: String,
        require: true,
        default: ""
      },
      backgroundColor: {
        type: String
      },
      color: {
        type: String
      },
      borderColor: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor,
          color: reactiveProps.color,
          borderColor: reactiveProps.borderColor
        }))
      };
    }
  };
  function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ErrorIcon = resolveComponent("ErrorIcon");
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", {
      class: "error-message",
      style: normalizeStyle($setup.style)
    }, [
      createVNode(_component_ErrorIcon),
      createVNode(_component_TextField, { text: $props.message }, null, 8, ["text"])
    ], 4);
  }
  var ErrorMessage = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$15], ["__scopeId", "data-v-018abdb3"]]);
  const _sfc_main$14 = {
    name: "ArrowUp",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$10 = ["role", "aria-label"];
  const _hoisted_2$O = /* @__PURE__ */ createBaseVNode("path", {
    d: "m1.5 13l12-12 12 12",
    stroke: "",
    "stroke-width": "3",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_3$F = [
    _hoisted_2$O
  ];
  function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 27 14",
      width: "27",
      height: "14"
    }, _hoisted_3$F, 12, _hoisted_1$10);
  }
  var ArrowUp = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$14]]);
  const _sfc_main$13 = {
    name: "ArrowDown",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$$ = ["role", "aria-label"];
  const _hoisted_2$N = /* @__PURE__ */ createBaseVNode("path", {
    d: "M1.70019 1.60002L9.5002 9.40002L17.3002 1.60002",
    stroke: "",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_3$E = [
    _hoisted_2$N
  ];
  function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "19",
      height: "11",
      viewBox: "0 0 19 11",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$E, 12, _hoisted_1$$);
  }
  var ArrowDown = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$13]]);
  const _sfc_main$12 = {
    name: "ProductOptions",
    components: {
      TextField,
      ArrowUp,
      ArrowDown
    },
    props: {
      product: {
        type: Object
      }
    },
    data() {
      return {
        productOptionsVisible: false
      };
    },
    methods: {
      showProductOptions() {
        this.productOptionsVisible = !this.productOptionsVisible;
      }
    }
  };
  const _hoisted_1$_ = {
    key: 0,
    class: "product-options"
  };
  const _hoisted_2$M = {
    key: 0,
    class: "product-option"
  };
  function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    return $props.product.options && $props.product.options.length ? (openBlock(), createElementBlock("div", _hoisted_1$_, [
      createBaseVNode("div", {
        class: "product-options-trigger",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.showProductOptions && $options.showProductOptions(...args)),
        onKeydown: _cache[1] || (_cache[1] = (...args) => $options.showProductOptions && $options.showProductOptions(...args))
      }, [
        createVNode(_component_TextField, {
          text: _ctx.$t("productOptionsTrigger")
        }, null, 8, ["text"]),
        $data.productOptionsVisible ? (openBlock(), createBlock(_component_ArrowUp, {
          key: 0,
          stroke: "black"
        })) : createCommentVNode("", true),
        !$data.productOptionsVisible ? (openBlock(), createBlock(_component_ArrowDown, {
          key: 1,
          stroke: "black"
        })) : createCommentVNode("", true)
      ], 32),
      $data.productOptionsVisible ? (openBlock(), createElementBlock("div", _hoisted_2$M, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.product.options, (option, index) => {
          return openBlock(), createElementBlock("div", {
            class: "option-value",
            key: index
          }, [
            createVNode(_component_TextField, {
              text: option.value.replaceAll("<", "<").replaceAll(">", ">")
            }, null, 8, ["text"])
          ]);
        }), 128))
      ])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true);
  }
  var ProductOptions = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$12], ["__scopeId", "data-v-0a231a85"]]);
  const _sfc_main$11 = {
    name: "MyButton",
    components: {
      TextField
    },
    props: {
      type: {
        type: String
      },
      label: {
        type: String,
        required: true
      },
      primary: {
        type: Boolean,
        default: false
      },
      secondary: {
        type: Boolean,
        default: false
      },
      tertiary: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        validator(value) {
          return ["small", "medium", "large"].indexOf(value) !== -1;
        },
        default: "medium"
      },
      backgroundColor: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    emits: ["click"],
    setup(props, { emit: emit2 }) {
      const reactiveProps = reactive(props);
      return {
        classes: computed(() => ({
          button: true,
          "button--primary": reactiveProps.primary,
          "button--secondary": reactiveProps.secondary,
          "button--tertiary": reactiveProps.tertiary,
          [`button--${reactiveProps.size || "medium"}`]: true
        })),
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor
        })),
        onClick() {
          emit2("click");
        }
      };
    }
  };
  const _hoisted_1$Z = ["type", "role", "aria-label", "disabled"];
  function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("button", {
      type: $props.type,
      class: normalizeClass($setup.classes),
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      disabled: $props.disabled,
      onClick: _cache[0] || (_cache[0] = (...args) => $setup.onClick && $setup.onClick(...args))
    }, [
      createVNode(_component_TextField, { text: $props.label }, null, 8, ["text"])
    ], 14, _hoisted_1$Z);
  }
  var MyButton = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$11]]);
  const _sfc_main$10 = {
    name: "QtyButton",
    components: {
      MyButton
    },
    props: {
      product: {
        type: Object
      }
    },
    methods: {
      ...mapActions(useCartStore, ["updateQuantity"])
    }
  };
  const _hoisted_1$Y = {
    key: 0,
    class: "item-qty-container"
  };
  const _hoisted_2$L = ["for"];
  const _hoisted_3$D = ["name", "placeholder"];
  function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_MyButton = resolveComponent("MyButton");
    return $props.product ? (openBlock(), createElementBlock("div", _hoisted_1$Y, [
      createVNode(_component_MyButton, {
        primary: false,
        "aria-label": _ctx.$t("orderSummary.minusOneItem"),
        label: " - ",
        onClick: _cache[0] || (_cache[0] = ($event) => $props.product.qty === 1 ? false : _ctx.updateQuantity($props.product, -1))
      }, null, 8, ["aria-label"]),
      createBaseVNode("label", {
        for: `input-qty-${$props.product.item_id}`
      }, [
        withDirectives(createBaseVNode("input", {
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $props.product.qty = $event),
          name: `input-qty-${$props.product.item_id}`,
          type: "text",
          disabled: "",
          placeholder: $props.product.qty
        }, null, 8, _hoisted_3$D), [
          [vModelText, $props.product.qty]
        ])
      ], 8, _hoisted_2$L),
      createVNode(_component_MyButton, {
        primary: false,
        "aria-label": _ctx.$t("orderSummary.plusOneItem"),
        label: " + ",
        onClick: _cache[2] || (_cache[2] = ($event) => _ctx.updateQuantity($props.product, 1))
      }, null, 8, ["aria-label"])
    ])) : createCommentVNode("", true);
  }
  var QtyButton = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$10], ["__scopeId", "data-v-490558a8"]]);
  var binSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/bin.svg";
  const _sfc_main$$ = {
    name: "Remove",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      bin() {
        return `${getStaticUrl(binSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$X = ["src", "alt"];
  function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.bin,
      width: "20",
      height: "20",
      alt: $options.bin
    }, null, 8, _hoisted_1$X);
  }
  var Remove = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$$]]);
  const _sfc_main$_ = {
    name: "RemoveItemButton",
    components: {
      Remove,
      TextField
    },
    props: {
      product: {
        type: Object
      }
    },
    data() {
      return {
        removeItemText: "",
        removeItemTextId: "gene-bettercheckout-removeitem-text"
      };
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.removeItemText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.removeItemTextId]) || this.$t("orderSummary.removeItemButton");
      document.addEventListener(this.removeItemTextId, this.setRemoveItemText);
    },
    unmounted() {
      document.removeEventListener(this.removeItemTextId, this.setRemoveItemText);
    },
    methods: {
      ...mapActions(useCartStore, ["removeItem"]),
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setRemoveItemText(event) {
        this.removeItemText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.removeItemButton");
      }
    }
  };
  const _hoisted_1$W = { class: "remove-item-icon" };
  const _hoisted_2$K = ["aria-label"];
  function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Remove = resolveComponent("Remove");
    const _component_TextField = resolveComponent("TextField");
    return $props.product ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "remove-item",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.removeItem($props.product)),
      onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.removeItem($props.product), ["enter"]))
    }, [
      createBaseVNode("div", _hoisted_1$W, [
        createVNode(_component_Remove)
      ]),
      createBaseVNode("button", {
        class: "remove-item-action button--blank",
        "aria-label": _ctx.$t("orderSummary.removeItemButtonLabel")
      }, [
        createVNode(_component_TextField, {
          class: "remove-item-copy",
          text: $data.removeItemText
        }, null, 8, ["text"])
      ], 8, _hoisted_2$K)
    ], 32)) : createCommentVNode("", true);
  }
  var RemoveItemButton = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$_], ["__scopeId", "data-v-11137e28"]]);
  const _sfc_main$Z = {
    name: "OrderSummaryItem",
    components: {
      TextField,
      Price,
      Loader,
      ErrorMessage,
      ProductOptions,
      QtyButton,
      RemoveItemButton
    },
    props: {
      response: {
        type: Object
      }
    },
    computed: {
      ...mapState(useCartStore, ["cartItems", "cartLoading"]),
      ...mapState(useConfigStore, ["taxCartDisplayPrice"])
    }
  };
  const _hoisted_1$V = { key: 0 };
  const _hoisted_2$J = { class: "product-item-container" };
  const _hoisted_3$C = { class: "product-image" };
  const _hoisted_4$r = ["src", "alt", "width", "height"];
  const _hoisted_5$m = { class: "product-item-info" };
  const _hoisted_6$e = { class: "product-item-price" };
  const _hoisted_7$a = { class: "product-item-actions" };
  const _hoisted_8$9 = {
    key: 0,
    class: "gift-message"
  };
  const _hoisted_9$8 = { class: "gift-message__item" };
  const _hoisted_10$8 = { class: "gift-message__item" };
  const _hoisted_11$7 = { class: "gift-message__item" };
  const _hoisted_12$7 = { class: "qty-error-message" };
  const _hoisted_13$4 = {
    key: 1,
    class: "loader__absolute-container"
  };
  const _hoisted_14$3 = {
    key: 2,
    class: "loader__absolute-container"
  };
  function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_ProductOptions = resolveComponent("ProductOptions");
    const _component_Price = resolveComponent("Price");
    const _component_QtyButton = resolveComponent("QtyButton");
    const _component_RemoveItemButton = resolveComponent("RemoveItemButton");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_Loader = resolveComponent("Loader");
    return openBlock(), createElementBlock(Fragment, null, [
      Object.keys(_ctx.cartItems).length !== 0 ? (openBlock(), createElementBlock("div", _hoisted_1$V, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.cartItems, (product, index) => {
          return openBlock(), createElementBlock("div", {
            class: "product-item",
            key: index
          }, [
            createBaseVNode("div", _hoisted_2$J, [
              createBaseVNode("div", _hoisted_3$C, [
                createBaseVNode("img", {
                  src: product.image.src,
                  alt: product.image.alt,
                  width: product.image.width,
                  height: product.image.height
                }, null, 8, _hoisted_4$r)
              ]),
              createBaseVNode("div", _hoisted_5$m, [
                createVNode(_component_TextField, {
                  text: product.name
                }, null, 8, ["text"]),
                createVNode(_component_ProductOptions, { product }, null, 8, ["product"]),
                createBaseVNode("div", _hoisted_6$e, [
                  _ctx.taxCartDisplayPrice ? (openBlock(), createBlock(_component_Price, {
                    key: 0,
                    value: product.price_incl_tax
                  }, null, 8, ["value"])) : (openBlock(), createBlock(_component_Price, {
                    key: 1,
                    value: product.price
                  }, null, 8, ["value"]))
                ]),
                createBaseVNode("div", _hoisted_7$a, [
                  createVNode(_component_QtyButton, { product }, null, 8, ["product"]),
                  createVNode(_component_RemoveItemButton, { product }, null, 8, ["product"])
                ]),
                product.giftMessage ? (openBlock(), createElementBlock("div", _hoisted_8$9, [
                  createBaseVNode("div", _hoisted_9$8, [
                    createVNode(_component_TextField, {
                      text: _ctx.$t("giftMessage.to")
                    }, null, 8, ["text"]),
                    createVNode(_component_TextField, {
                      text: product.giftMessage.to
                    }, null, 8, ["text"])
                  ]),
                  createBaseVNode("div", _hoisted_10$8, [
                    createVNode(_component_TextField, {
                      text: _ctx.$t("giftMessage.from")
                    }, null, 8, ["text"]),
                    createVNode(_component_TextField, {
                      text: product.giftMessage.from
                    }, null, 8, ["text"])
                  ]),
                  createBaseVNode("div", _hoisted_11$7, [
                    createVNode(_component_TextField, {
                      text: _ctx.$t("giftMessage.message")
                    }, null, 8, ["text"]),
                    createVNode(_component_TextField, {
                      text: product.giftMessage.message
                    }, null, 8, ["text"])
                  ])
                ])) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_12$7, [
                  product.cartUpdateErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
                    key: 0,
                    message: product.cartUpdateErrorMessage
                  }, null, 8, ["message"])) : createCommentVNode("", true)
                ])
              ])
            ])
          ]);
        }), 128))
      ])) : (openBlock(), createElementBlock("div", _hoisted_13$4, [
        createVNode(_component_Loader)
      ])),
      _ctx.cartLoading === "true" ? (openBlock(), createElementBlock("div", _hoisted_14$3, [
        createVNode(_component_Loader)
      ])) : createCommentVNode("", true)
    ], 64);
  }
  var OrderSummaryItem = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Z], ["__scopeId", "data-v-2b6733e7"]]);
  const _sfc_main$Y = {
    name: "OrderSummaryTotal",
    components: {
      Price,
      TextField
    },
    data() {
      return {
        orderSummaryText: "",
        orderSummaryTextId: "gene-bettercheckout-ordersummary-text",
        grandTotalText: "",
        grandTotalTextId: "gene-bettercheckout-grandtotal-text",
        subtotalText: "",
        subtotalTextId: "gene-bettercheckout-subtotal-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["cartGrandTotal", "totalSegments", "shippingPrice", "cartItemsQty"]),
      ...mapState(useConfigStore, ["taxCartDisplayFullSummary"]),
      ...mapState(useShippingMethodsStore, ["selectedMethod"])
    },
    async created() {
      var _a, _b, _c;
      await this.getStoreConfig();
      this.orderSummaryText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.orderSummaryTextId]) || this.$t("orderSummary.modalHeader");
      this.grandTotalText = ((_b = window.geneCheckout) == null ? void 0 : _b[this.grandTotalTextId]) || this.$t("orderSummary.grandTotalTitle");
      this.subtotalText = ((_c = window.geneCheckout) == null ? void 0 : _c[this.subtotalTextId]) || this.$t("orderSummary.subtotalTitle");
      document.addEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
      document.addEventListener(this.grandTotalTextId, this.setGrandTotalText);
      document.addEventListener(this.subtotalTextId, this.setSubtotalText);
    },
    unmounted() {
      document.removeEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
      document.removeEventListener(this.grandTotalTextId, this.setGrandTotalText);
      document.removeEventListener(this.subtotalTextId, this.setSubtotalText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setOrderSummaryText(event) {
        this.orderSummaryText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.modalHeader");
      },
      setGrandTotalText(event) {
        this.grandTotalText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.grandTotalTitle");
      },
      setSubtotalText(event) {
        this.subtotalText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.subtotalTitle");
      }
    }
  };
  const _hoisted_1$U = { class: "order-total-title" };
  const _hoisted_2$I = { class: "order-total-container" };
  const _hoisted_3$B = { class: "order-total-wrapper" };
  const _hoisted_4$q = {
    key: 0,
    class: "total__row"
  };
  const _hoisted_5$l = {
    key: 1,
    class: "total__row"
  };
  const _hoisted_6$d = {
    key: 2,
    class: "total__row"
  };
  const _hoisted_7$9 = {
    key: 3,
    class: "total__row"
  };
  const _hoisted_8$8 = {
    key: 4,
    class: "total__row"
  };
  const _hoisted_9$7 = {
    key: 5,
    class: "total__row"
  };
  const _hoisted_10$7 = {
    key: 6,
    class: "total__row"
  };
  const _hoisted_11$6 = {
    key: 7,
    class: "total__row"
  };
  const _hoisted_12$6 = { class: "order-total-grand" };
  function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_Price = resolveComponent("Price");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$U, [
        createVNode(_component_TextField, { text: $data.orderSummaryText }, null, 8, ["text"]),
        _ctx.cartItemsQty > 0 ? (openBlock(), createBlock(_component_TextField, {
          key: 0,
          class: "order-total-title-amount",
          text: `(${_ctx.cartItemsQty})`
        }, null, 8, ["text"])) : createCommentVNode("", true)
      ]),
      createBaseVNode("div", _hoisted_2$I, [
        createBaseVNode("div", _hoisted_3$B, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.totalSegments, (total, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: "order-total"
            }, [
              total.code === "penniesdonation" ? (openBlock(), createElementBlock("div", _hoisted_4$q, [
                createVNode(_component_TextField, {
                  class: "total__text",
                  text: total.title
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "total__text",
                  value: total.value
                }, null, 8, ["value"])
              ])) : createCommentVNode("", true),
              total.code === "shipping" ? (openBlock(), createElementBlock("div", _hoisted_5$l, [
                createVNode(_component_TextField, {
                  class: "total__text",
                  text: _ctx.$t("progressBar.shippingStepTitle")
                }, null, 8, ["text"]),
                _ctx.selectedMethod.method_code ? (openBlock(), createBlock(_component_Price, {
                  key: 0,
                  class: "total__text",
                  value: _ctx.shippingPrice
                }, null, 8, ["value"])) : (openBlock(), createBlock(_component_TextField, {
                  key: 1,
                  class: "total__text",
                  text: _ctx.$t("shippingStep.tbc")
                }, null, 8, ["text"]))
              ])) : total.code === "discount" ? (openBlock(), createElementBlock("div", _hoisted_6$d, [
                createVNode(_component_TextField, {
                  class: "total__text",
                  text: total.title
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "total__text",
                  value: total.value
                }, null, 8, ["value"])
              ])) : total.code === "giftcardaccount" ? (openBlock(), createElementBlock("div", _hoisted_7$9, [
                createVNode(_component_TextField, {
                  class: "total__text",
                  text: total.title
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "total__text",
                  value: total.value
                }, null, 8, ["value"])
              ])) : total.code === "reward" && total.value ? (openBlock(), createElementBlock("div", _hoisted_8$8, [
                createVNode(_component_TextField, {
                  class: "total__text",
                  text: _ctx.$t("orderSummary.rewardsTitle")
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "total__text",
                  value: total.value
                }, null, 8, ["value"])
              ])) : total.code === "subtotal" ? (openBlock(), createElementBlock("div", _hoisted_9$7, [
                createVNode(_component_TextField, {
                  class: "total__text",
                  text: $data.subtotalText
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "total__text",
                  value: total.value
                }, null, 8, ["value"])
              ])) : total.code === "giftwrapping" && total.extension_attributes.gw_base_price > 0 ? (openBlock(), createElementBlock("div", _hoisted_10$7, [
                createVNode(_component_TextField, {
                  class: "total__text",
                  text: _ctx.$t("orderSummary.discountTitle")
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "total__text",
                  value: total.extension_attributes.gw_base_price
                }, null, 8, ["value"])
              ])) : total.code === "tax" && _ctx.taxCartDisplayFullSummary ? (openBlock(), createElementBlock("div", _hoisted_11$6, [
                createVNode(_component_TextField, {
                  class: "total__text",
                  text: _ctx.$t("orderSummary.inclTaxTitle")
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "total__text",
                  value: total.value
                }, null, 8, ["value"])
              ])) : createCommentVNode("", true)
            ]);
          }), 128))
        ]),
        createBaseVNode("div", _hoisted_12$6, [
          createVNode(_component_TextField, { text: $data.grandTotalText }, null, 8, ["text"]),
          createVNode(_component_Price, {
            value: _ctx.cartGrandTotal / 100
          }, null, 8, ["value"])
        ])
      ])
    ], 64);
  }
  var OrderSummaryTotal = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$Y], ["__scopeId", "data-v-dc6e3bb2"]]);
  const _sfc_main$X = {
    name: "DropDown"
  };
  const _hoisted_1$T = { class: "dropdown" };
  function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$T, [
      renderSlot(_ctx.$slots, "content", {}, () => [
        createTextVNode(" default content ")
      ])
    ]);
  }
  var DropDown = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$X]]);
  var promoSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/promo-icon.svg";
  const _sfc_main$W = {
    name: "PromotionComponent",
    components: {
      Price,
      TextField,
      MyButton,
      DropDown,
      ArrowUp,
      ArrowDown
    },
    data() {
      return {
        isDropDownVisible: false,
        freeShippingText: "",
        freeShippingTextId: "gene-bettercheckout-freeshipping-text"
      };
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.freeShippingText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.freeShippingTextId]) || this.$t("orderSummary.freeShippingAvailable");
      document.addEventListener(this.freeShippingTextId, this.setFreeShippingText);
    },
    unmounted() {
      document.removeEventListener(this.freeShippingTextId, this.setFreeShippingText);
    },
    computed: {
      ...mapState(useCartStore, ["crosssells", "freeShipping"]),
      promoIconUrl() {
        return `${getStaticUrl(promoSvg)}`;
      }
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      ...mapActions(useCartStore, [
        "getCartData",
        "getCartTotals",
        "getCrosssells",
        "getAmastyShippingData",
        "addCartItem"
      ]),
      setFreeShippingText(event) {
        this.freeShippingText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.freeShippingAvailable");
      },
      openDropDown() {
        this.isDropDownVisible = !this.isDropDownVisible;
      },
      async addItem(product) {
        await this.addCartItem(product);
      }
    }
  };
  const _hoisted_1$S = { class: "promotion-icon-container" };
  const _hoisted_2$H = ["src"];
  const _hoisted_3$A = {
    key: 0,
    class: "promo-title no-shipping"
  };
  const _hoisted_4$p = {
    key: 1,
    class: "promo-title"
  };
  const _hoisted_5$k = { class: "product-item-image" };
  const _hoisted_6$c = ["src", "alt"];
  const _hoisted_7$8 = { class: "product-item-info" };
  const _hoisted_8$7 = { class: "product-actions" };
  function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_Price = resolveComponent("Price");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_DropDown = resolveComponent("DropDown");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", {
        class: normalizeClass(["promotion-trigger dropdown-button", { opened: $data.isDropDownVisible }]),
        onClick: _cache[0] || (_cache[0] = (...args) => $options.openDropDown && $options.openDropDown(...args)),
        onKeydown: _cache[1] || (_cache[1] = (...args) => $options.openDropDown && $options.openDropDown(...args))
      }, [
        createBaseVNode("div", _hoisted_1$S, [
          createBaseVNode("img", {
            src: $options.promoIconUrl,
            alt: "promo-dropdown-icon"
          }, null, 8, _hoisted_2$H)
        ]),
        _ctx.freeShipping > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$A, [
          createBaseVNode("div", null, [
            createVNode(_component_TextField, {
              text: _ctx.$t("orderSummary.couponCodeTitle"),
              "font-weight": "325"
            }, null, 8, ["text"]),
            createVNode(_component_Price, { value: _ctx.freeShipping }, null, 8, ["value"]),
            createVNode(_component_TextField, {
              text: _ctx.$t("orderSummary.couponCodeTitleBottom"),
              "font-weight": "325"
            }, null, 8, ["text"]),
            createVNode(_component_TextField, {
              text: _ctx.$t("orderSummary.couponCodeTitleFreeShipping")
            }, null, 8, ["text"])
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_4$p, [
          createBaseVNode("div", null, [
            createVNode(_component_TextField, { text: $data.freeShippingText }, null, 8, ["text"])
          ])
        ])),
        !$data.isDropDownVisible && _ctx.crosssells.length ? (openBlock(), createBlock(_component_ArrowDown, {
          key: 2,
          class: "dropdown-arrow__down",
          stroke: "black"
        })) : createCommentVNode("", true),
        $data.isDropDownVisible && _ctx.crosssells.length ? (openBlock(), createBlock(_component_ArrowUp, {
          key: 3,
          class: "dropdown-arrow__up",
          stroke: "black"
        })) : createCommentVNode("", true)
      ], 34),
      $data.isDropDownVisible && _ctx.crosssells.length ? (openBlock(), createBlock(_component_DropDown, {
        key: 0,
        class: normalizeClass(["promo-dropdown", { active: $data.isDropDownVisible }])
      }, {
        content: withCtx(() => [
          createVNode(_component_TextField, {
            class: "promo-title",
            text: _ctx.$t("orderSummary.promoTitle"),
            "font-weight": "500",
            "font-size": "16px"
          }, null, 8, ["text"]),
          createBaseVNode("div", {
            class: normalizeClass(["product-item-carousel", `product-item-carousel-${_ctx.crosssells.length}`])
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.crosssells, (product, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "product-item"
              }, [
                createBaseVNode("div", _hoisted_5$k, [
                  createBaseVNode("img", {
                    src: product.thumbnail.url,
                    alt: product.thumbnail.label
                  }, null, 8, _hoisted_6$c)
                ]),
                createBaseVNode("div", _hoisted_7$8, [
                  createVNode(_component_Price, {
                    value: product.price_range.minimum_price.final_price.value,
                    "font-size": "18px",
                    "font-weight": "500"
                  }, null, 8, ["value"]),
                  createVNode(_component_TextField, {
                    text: product.name,
                    class: "product-item-name",
                    "font-weight": "325",
                    "font-size": "14px"
                  }, null, 8, ["text"])
                ]),
                createBaseVNode("div", _hoisted_8$7, [
                  createVNode(_component_MyButton, {
                    primary: "",
                    label: _ctx.$t("orderSummary.addToCart"),
                    onClick: ($event) => $options.addItem(product)
                  }, null, 8, ["label", "onClick"])
                ])
              ]);
            }), 128))
          ], 2)
        ]),
        _: 1
      }, 8, ["class"])) : createCommentVNode("", true)
    ], 64);
  }
  var PromotionComponent = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$W], ["__scopeId", "data-v-18443b06"]]);
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  var now = function() {
    return root.Date.now();
  };
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var lodash_debounce = debounce;
  const screenXxs = "320px";
  const screenXs = "480px";
  const screenS = "640px";
  const screenM = "768px";
  const screenMl = "992px";
  const screenL = "1024px";
  const screenXl = "1440px";
  var breakpoints = {
    screenXxs,
    screenXs,
    screenS,
    screenM,
    screenMl,
    screenL,
    screenXl
  };
  const _sfc_main$V = {
    name: "TextInput",
    components: {
      ErrorMessage
    },
    props: {
      modelValue: {
        type: String,
        default: ""
      },
      placeholder: {
        type: String
      },
      label: {
        type: String
      },
      ariaLabel: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      },
      required: {
        type: Boolean,
        default: false
      },
      type: {
        type: String
      },
      borderColor: {
        type: String
      },
      error: {
        type: Boolean
      },
      errorMessage: {
        type: String,
        default: ""
      },
      customValidation: {
        type: Function
      },
      identifier: {
        type: String
      },
      onBlur: {
        type: Function,
        default: () => {
        }
      },
      onFocus: {
        type: Function,
        default: () => {
        }
      },
      autocomplete: {
        type: String,
        default: null
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        classes: computed(() => ({
          error: reactiveProps.error
        })),
        style: computed(() => ({
          borderColor: reactiveProps.borderColor
        }))
      };
    },
    data() {
      return {
        inputVal: ""
      };
    },
    methods: {
      moveIntoViewport(event) {
        const breakpoint = parseInt(breakpoints.screenM, 10);
        if (window.innerWidth > breakpoint) {
          return;
        }
        const { target } = event;
        const container = target.closest(".text-input");
        const footer = document.querySelector(".order-summary-container");
        const footerHeight = footer.getBoundingClientRect().height;
        const currScroll = window.scrollY;
        const debouncedResize = lodash_debounce(() => {
          const boundingRect = container.getBoundingClientRect();
          const isHidden = window.innerHeight - footerHeight < boundingRect.bottom;
          if (isHidden) {
            window.scrollTo({
              top: boundingRect.bottom + currScroll - (window.innerHeight - footerHeight),
              behavior: "smooth"
            });
          }
          window.removeEventListener("resize", debouncedResize);
        }, 20);
        window.addEventListener("resize", debouncedResize);
      }
    }
  };
  const _hoisted_1$R = { class: "text-input" };
  const _hoisted_2$G = ["for"];
  const _hoisted_3$z = ["id", "autocomplete", "type", "placeholder", "disabled", "required", "aria-label", "value"];
  function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    return openBlock(), createElementBlock("div", _hoisted_1$R, [
      createBaseVNode("label", {
        for: $props.identifier,
        class: normalizeClass($setup.classes)
      }, [
        $props.label ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass($props.modelValue.length > 0 ? "text-input-has-value" : "text-input-no-value")
        }, toDisplayString$1($props.required ? $props.label + " *" : $props.label), 3)) : createCommentVNode("", true),
        createBaseVNode("input", {
          id: $props.identifier,
          ref: "input",
          autocomplete: $props.autocomplete,
          style: normalizeStyle($setup.style),
          type: $props.type,
          placeholder: $props.required ? $props.placeholder + " *" : $props.placeholder,
          disabled: $props.disabled,
          required: $props.required,
          "aria-label": $props.ariaLabel,
          value: $props.modelValue,
          onBlur: _cache[0] || (_cache[0] = (...args) => $props.onBlur && $props.onBlur(...args)),
          onKeyup: _cache[1] || (_cache[1] = (...args) => $props.customValidation && $props.customValidation(...args)),
          onFocus: _cache[2] || (_cache[2] = (event) => {
            $options.moveIntoViewport(event);
            $props.onFocus();
          }),
          onInput: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:modelValue", $event.target.value))
        }, null, 44, _hoisted_3$z),
        renderSlot(_ctx.$slots, "icon", {}, void 0, true)
      ], 10, _hoisted_2$G),
      $props.errorMessage !== "" ? (openBlock(), createBlock(_component_ErrorMessage, {
        key: 0,
        message: $props.errorMessage
      }, null, 8, ["message"])) : createCommentVNode("", true)
    ]);
  }
  var TextInput = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$V], ["__scopeId", "data-v-19d81c2c"]]);
  const _sfc_main$U = {
    name: "SuccessIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$Q = ["role", "aria-label"];
  const _hoisted_2$F = /* @__PURE__ */ createBaseVNode("path", { d: "M0 7.5a7.5 7.5 0 1 1 15 0a7.5 7.5 0 0 1-15 0Zm7.072 3.21l4.318-5.398l-.78-.624l-3.682 4.601L4.32 7.116l-.64.768l3.392 2.827Z" }, null, -1);
  const _hoisted_3$y = [
    _hoisted_2$F
  ];
  function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "20",
      height: "20",
      viewBox: "0 0 15 15",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$y, 12, _hoisted_1$Q);
  }
  var SuccessIcon = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$U]]);
  const _sfc_main$T = {
    name: "SuccessMessage",
    components: {
      TextField,
      SuccessIcon
    },
    props: {
      message: {
        type: String,
        require: true,
        default: ""
      },
      backgroundColor: {
        type: String
      },
      color: {
        type: String
      },
      borderColor: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor,
          color: reactiveProps.color,
          borderColor: reactiveProps.borderColor
        }))
      };
    }
  };
  function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_SuccessIcon = resolveComponent("SuccessIcon");
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", {
      class: "success-message",
      style: normalizeStyle($setup.style)
    }, [
      createVNode(_component_SuccessIcon),
      createVNode(_component_TextField, { text: $props.message }, null, 8, ["text"])
    ], 4);
  }
  var SuccessMessage = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$T], ["__scopeId", "data-v-1e41ddac"]]);
  var GiftIcon = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/gift-icon.svg";
  const _sfc_main$S = {
    name: "GiftCardDiscount",
    components: {
      DropDown,
      TextField,
      ArrowDown,
      ArrowUp,
      TextInput,
      MyButton,
      ErrorMessage,
      Loader,
      SuccessMessage
    },
    data() {
      return {
        isDropDownVisible: true,
        loadingDiscountCode: false,
        applyButtonText: "",
        applyButtonTextId: "gene-bettercheckout-applybutton-text",
        removeButtonText: "",
        removeButtonTextId: "gene-bettercheckout-removebutton-text",
        giftCardText: "",
        giftCardTextId: "gene-bettercheckout-giftcard-text",
        giftCardPlaceholderText: "",
        giftCardPlaceholderTextId: "gene-bettercheckout-giftcardplaceholder-text",
        discountAppliedOverride: true,
        discountCodeOverride: "TestCode123"
      };
    },
    async created() {
      var _a, _b, _c, _d;
      await this.getStoreConfig();
      this.applyButtonText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.applyButtonTextId]) || this.$t("orderSummary.applyBtn");
      this.removeButtonText = ((_b = window.geneCheckout) == null ? void 0 : _b[this.removeButtonTextId]) || this.$t("orderSummary.removeBtn");
      this.giftCardText = ((_c = window.geneCheckout) == null ? void 0 : _c[this.giftCardTextId]) || this.$t("orderSummary.giftDiscountTitle");
      this.giftCardPlaceholderText = ((_d = window.geneCheckout) == null ? void 0 : _d[this.giftCardPlaceholderTextId]) || this.$t("orderSummary.giftCardDiscount.placeholder");
      document.addEventListener(this.applyButtonTextId, this.setApplyButtonText);
      document.addEventListener(this.removeButtonTextId, this.setRemoveButtonText);
      document.addEventListener(this.giftCardTextId, this.setGiftCardText);
      document.addEventListener(this.giftCardPlaceholderTextId, this.setGiftCardPlaceholderText);
    },
    unmounted() {
      document.removeEventListener(this.applyButtonTextId, this.setApplyButtonText);
      document.removeEventListener(this.removeButtonTextId, this.setRemoveButtonText);
      document.removeEventListener(this.giftCardTextId, this.setGiftCardText);
      document.removeEventListener(this.giftCardPlaceholderTextId, this.setGiftCardPlaceholderText);
    },
    computed: {
      ...mapWritableState(useCartStore, [
        "discountCode",
        "discountApplied",
        "giftCardErrorMessage"
      ]),
      GiftIcon() {
        return `${getStaticUrl(GiftIcon)}`;
      }
    },
    methods: {
      ...mapActions(useCartStore, ["addGiftCardCode", "removeGiftCardCode"]),
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setApplyButtonText(event) {
        this.applyButtonText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.applyBtn");
      },
      setRemoveButtonText(event) {
        this.removeButtonText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.removeBtn");
      },
      setGiftCardText(event) {
        this.giftCardText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.giftDiscountTitle");
      },
      setGiftCardPlaceholderText(event) {
        this.giftCardPlaceholderText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.giftCardDiscount.placeholder");
      },
      async dispatchDiscountCode(discountCode) {
        this.loadingDiscountCode = true;
        await this.addGiftCardCode(discountCode);
        this.loadingDiscountCode = false;
      },
      openDropDown() {
        this.isDropDownVisible = !this.isDropDownVisible;
      }
    }
  };
  const _hoisted_1$P = { key: 0 };
  const _hoisted_2$E = { class: "gift-discount-icon-container" };
  const _hoisted_3$x = ["src"];
  const _hoisted_4$o = { class: "field coupon-code-field" };
  const _hoisted_5$j = { class: "success" };
  const _hoisted_6$b = { class: "error" };
  function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_TextField = resolveComponent("TextField");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_SuccessMessage = resolveComponent("SuccessMessage");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_DropDown = resolveComponent("DropDown");
    return openBlock(), createElementBlock(Fragment, null, [
      $data.loadingDiscountCode ? (openBlock(), createElementBlock("div", _hoisted_1$P, [
        createVNode(_component_Loader)
      ])) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(["gift-discount-trigger dropdown-button", { opened: $data.isDropDownVisible }]),
        onClick: _cache[0] || (_cache[0] = (...args) => $options.openDropDown && $options.openDropDown(...args)),
        onKeydown: _cache[1] || (_cache[1] = (...args) => $options.openDropDown && $options.openDropDown(...args))
      }, [
        createBaseVNode("div", _hoisted_2$E, [
          createBaseVNode("img", {
            src: $options.GiftIcon,
            alt: "gift-dropdown-icon"
          }, null, 8, _hoisted_3$x)
        ]),
        createVNode(_component_TextField, {
          text: $data.giftCardText,
          class: "gift-discount-title"
        }, null, 8, ["text"]),
        withDirectives(createVNode(_component_ArrowDown, {
          class: "dropdown-arrow__down",
          stroke: "black"
        }, null, 512), [
          [vShow, !$data.isDropDownVisible]
        ]),
        withDirectives(createVNode(_component_ArrowUp, {
          class: "dropdown-arrow__up",
          stroke: "black"
        }, null, 512), [
          [vShow, $data.isDropDownVisible]
        ])
      ], 34),
      withDirectives(createVNode(_component_DropDown, {
        class: normalizeClass(["gift-dropdown", { active: $data.isDropDownVisible }])
      }, {
        content: withCtx(() => [
          createBaseVNode("div", _hoisted_4$o, [
            createVNode(_component_TextInput, {
              modelValue: _ctx.discountCode,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.discountCode = $event),
              error: _ctx.giftCardErrorMessage,
              name: "coupon-code",
              placeholder: $data.giftCardPlaceholderText,
              disabled: $data.discountAppliedOverride,
              autocomplete: "off"
            }, null, 8, ["modelValue", "error", "placeholder", "disabled"]),
            !$data.discountAppliedOverride ? (openBlock(), createBlock(_component_MyButton, {
              key: 0,
              primary: "",
              label: $data.applyButtonText,
              onClick: _cache[3] || (_cache[3] = ($event) => $options.dispatchDiscountCode(_ctx.discountCode))
            }, null, 8, ["label"])) : createCommentVNode("", true),
            $data.discountAppliedOverride ? (openBlock(), createBlock(_component_MyButton, {
              key: 1,
              secondary: "",
              label: $data.removeButtonText
            }, null, 8, ["label"])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_5$j, [
              $data.discountAppliedOverride ? (openBlock(), createBlock(_component_SuccessMessage, {
                key: 0,
                message: _ctx.$t("orderSummary.giftCardDiscount.successMessage", { code: $data.discountCodeOverride })
              }, null, 8, ["message"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_6$b, [
              _ctx.giftCardErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
                key: 0,
                message: _ctx.giftCardErrorMessage
              }, null, 8, ["message"])) : createCommentVNode("", true)
            ])
          ])
        ]),
        _: 1
      }, 8, ["class"]), [
        [vShow, $data.isDropDownVisible]
      ])
    ], 64);
  }
  var GiftCardDiscount = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$S], ["__scopeId", "data-v-a42107b4"]]);
  const _sfc_main$R = {
    name: "CouponDiscount",
    components: {
      DropDown,
      TextField,
      ArrowDown,
      ArrowUp,
      TextInput,
      MyButton,
      ErrorMessage,
      Loader,
      SuccessMessage
    },
    data() {
      return {
        isDropDownVisible: true,
        loadingDiscountCode: false,
        applyButtonText: "",
        applyButtonTextId: "gene-bettercheckout-applybutton-text",
        removeButtonText: "",
        removeButtonTextId: "gene-bettercheckout-removebutton-text",
        couponDiscountText: "",
        couponDiscountTextId: "gene-bettercheckout-coupondiscount-text",
        couponDiscountPlaceholderText: "",
        couponDiscountPlaceholderTextId: "gene-bettercheckout-coupondiscountplaceholder-text",
        discountErrorMessageOverride: "The code isn't valid. Verify the code and try again."
      };
    },
    async created() {
      var _a, _b, _c, _d;
      await this.getStoreConfig();
      this.applyButtonText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.applyButtonTextId]) || this.$t("orderSummary.applyBtn");
      this.removeButtonText = ((_b = window.geneCheckout) == null ? void 0 : _b[this.removeButtonTextId]) || this.$t("orderSummary.removeBtn");
      this.couponDiscountText = ((_c = window.geneCheckout) == null ? void 0 : _c[this.couponDiscountTextId]) || this.$t("orderSummary.couponDiscountTitle");
      this.couponDiscountPlaceholderText = ((_d = window.geneCheckout) == null ? void 0 : _d[this.couponDiscountTextId]) || this.$t("orderSummary.couponDiscount.placeholder");
      document.addEventListener(this.applyButtonTextId, this.setApplyButtonText);
      document.addEventListener(this.removeButtonTextId, this.setRemoveButtonText);
      document.addEventListener(this.couponDiscountTextId, this.setcouponDiscountText);
      document.addEventListener(this.couponDiscountPlaceholderTextId, this.setCouponDiscountPlaceholderText);
    },
    unmounted() {
      document.removeEventListener(this.applyButtonTextId, this.setApplyButtonText);
      document.removeEventListener(this.removeButtonTextId, this.setRemoveButtonText);
      document.removeEventListener(this.couponDiscountTextId, this.setcouponDiscountText);
      document.removeEventListener(this.couponDiscountPlaceholderTextId, this.setCouponDiscountPlaceholderText);
    },
    computed: {
      ...mapWritableState(useCartStore, [
        "discountCode",
        "discountApplied",
        "discountErrorMessage"
      ]),
      GiftIcon() {
        return `${getStaticUrl(GiftIcon)}`;
      }
    },
    methods: {
      ...mapActions(useCartStore, ["addDiscountCode", "removeDiscountCode"]),
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setApplyButtonText(event) {
        this.applyButtonText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.applyBtn");
      },
      setRemoveButtonText(event) {
        this.removeButtonText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.removeBtn");
      },
      setcouponDiscountText(event) {
        this.couponDiscountText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.couponDiscountTitle");
      },
      setCouponDiscountPlaceholderText(event) {
        this.couponDiscountPlaceholderText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.couponDiscount.placeholder");
      },
      async dispatchDiscountCode(discountCode) {
      },
      openDropDown() {
        this.isDropDownVisible = !this.isDropDownVisible;
      }
    }
  };
  const _hoisted_1$O = { key: 0 };
  const _hoisted_2$D = { class: "coupon-discount-icon-container" };
  const _hoisted_3$w = ["src"];
  const _hoisted_4$n = { class: "field coupon-code-field" };
  const _hoisted_5$i = { class: "success" };
  const _hoisted_6$a = { class: "error" };
  function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_TextField = resolveComponent("TextField");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_SuccessMessage = resolveComponent("SuccessMessage");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_DropDown = resolveComponent("DropDown");
    return openBlock(), createElementBlock(Fragment, null, [
      $data.loadingDiscountCode ? (openBlock(), createElementBlock("div", _hoisted_1$O, [
        createVNode(_component_Loader)
      ])) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(["coupon-discount-trigger dropdown-button", { opened: $data.isDropDownVisible }]),
        onClick: _cache[0] || (_cache[0] = (...args) => $options.openDropDown && $options.openDropDown(...args)),
        onKeydown: _cache[1] || (_cache[1] = (...args) => $options.openDropDown && $options.openDropDown(...args))
      }, [
        createBaseVNode("div", _hoisted_2$D, [
          createBaseVNode("img", {
            src: $options.GiftIcon,
            alt: "coupon-dropdown-icon"
          }, null, 8, _hoisted_3$w)
        ]),
        createVNode(_component_TextField, {
          text: $data.couponDiscountText,
          class: "coupon-discount-title"
        }, null, 8, ["text"]),
        withDirectives(createVNode(_component_ArrowDown, {
          class: "dropdown-arrow__down",
          stroke: "black"
        }, null, 512), [
          [vShow, !$data.isDropDownVisible]
        ]),
        withDirectives(createVNode(_component_ArrowUp, {
          class: "dropdown-arrow__up",
          stroke: "black"
        }, null, 512), [
          [vShow, $data.isDropDownVisible]
        ])
      ], 34),
      withDirectives(createVNode(_component_DropDown, {
        class: normalizeClass(["coupon-dropdown", { active: $data.isDropDownVisible }])
      }, {
        content: withCtx(() => [
          createBaseVNode("div", _hoisted_4$n, [
            createVNode(_component_TextInput, {
              modelValue: _ctx.discountCode,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.discountCode = $event),
              error: _ctx.discountErrorMessage,
              name: "coupon-code",
              placeholder: $data.couponDiscountPlaceholderText,
              disabled: _ctx.discountApplied,
              autocomplete: "off"
            }, null, 8, ["modelValue", "error", "placeholder", "disabled"]),
            !_ctx.discountApplied ? (openBlock(), createBlock(_component_MyButton, {
              key: 0,
              primary: "",
              label: $data.applyButtonText,
              onClick: _cache[3] || (_cache[3] = ($event) => $options.dispatchDiscountCode(_ctx.discountCode))
            }, null, 8, ["label"])) : createCommentVNode("", true),
            _ctx.discountApplied ? (openBlock(), createBlock(_component_MyButton, {
              key: 1,
              secondary: "",
              label: $data.removeButtonText,
              onClick: _ctx.removeDiscountCode
            }, null, 8, ["label", "onClick"])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_5$i, [
              _ctx.discountApplied ? (openBlock(), createBlock(_component_SuccessMessage, {
                key: 0,
                message: _ctx.$t("orderSummary.couponDiscount.successMessage", { code: _ctx.discountCode })
              }, null, 8, ["message"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_6$a, [
              $data.discountErrorMessageOverride ? (openBlock(), createBlock(_component_ErrorMessage, {
                key: 0,
                message: $data.discountErrorMessageOverride
              }, null, 8, ["message"])) : createCommentVNode("", true)
            ])
          ])
        ]),
        _: 1
      }, 8, ["class"]), [
        [vShow, $data.isDropDownVisible]
      ])
    ], 64);
  }
  var CouponDiscount = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$R], ["__scopeId", "data-v-2538b8be"]]);
  const _sfc_main$Q = {
    name: "OrderSummaryTitleWithAmount",
    props: ["orderItemsAmount"],
    components: {
      TextField
    },
    data() {
      return {
        orderSummaryText: "",
        orderSummaryTextId: "gene-bettercheckout-ordersummary-text"
      };
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.orderSummaryText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.orderSummaryTextId]) || this.$t("orderSummary.modalHeader");
      document.addEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
    },
    unmounted() {
      document.removeEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setOrderSummaryText(event) {
        this.orderSummaryText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.modalHeader");
      }
    }
  };
  const _hoisted_1$N = { class: "order-summary-title-amount" };
  function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", _hoisted_1$N, [
      createVNode(_component_TextField, { text: $data.orderSummaryText }, null, 8, ["text"]),
      createVNode(_component_TextField, { text: "(" }),
      createVNode(_component_TextField, { text: $props.orderItemsAmount }, null, 8, ["text"]),
      createVNode(_component_TextField, { text: ")" })
    ]);
  }
  var OrderSummaryTitleWithAmount = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$Q], ["__scopeId", "data-v-6b5eabc5"]]);
  const _sfc_main$P = {
    name: "Close",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$M = ["role", "aria-label"];
  const _hoisted_2$C = /* @__PURE__ */ createBaseVNode("path", { d: "M16.7334 8.66211C16.7334 8.55469 16.6455 8.4668 16.5381 8.4668L14.9268 8.47412L12.5 11.3672L10.0757 8.47656L8.46191 8.46924C8.35449 8.46924 8.2666 8.55469 8.2666 8.66455C8.2666 8.71094 8.28369 8.75488 8.31299 8.7915L11.4893 12.5757L8.31299 16.3574C8.28349 16.3932 8.26712 16.438 8.2666 16.4844C8.2666 16.5918 8.35449 16.6797 8.46191 16.6797L10.0757 16.6724L12.5 13.7793L14.9243 16.6699L16.5356 16.6772C16.6431 16.6772 16.731 16.5918 16.731 16.4819C16.731 16.4355 16.7139 16.3916 16.6846 16.355L13.5132 12.5732L16.6895 8.78906C16.7187 8.75488 16.7334 8.7085 16.7334 8.66211Z" }, null, -1);
  const _hoisted_3$v = /* @__PURE__ */ createBaseVNode("path", { d: "M12.5 1.58691C6.45996 1.58691 1.5625 6.48438 1.5625 12.5244C1.5625 18.5645 6.45996 23.4619 12.5 23.4619C18.54 23.4619 23.4375 18.5645 23.4375 12.5244C23.4375 6.48438 18.54 1.58691 12.5 1.58691ZM12.5 21.6064C7.48535 21.6064 3.41797 17.5391 3.41797 12.5244C3.41797 7.50977 7.48535 3.44238 12.5 3.44238C17.5146 3.44238 21.582 7.50977 21.582 12.5244C21.582 17.5391 17.5146 21.6064 12.5 21.6064Z" }, null, -1);
  const _hoisted_4$m = [
    _hoisted_2$C,
    _hoisted_3$v
  ];
  function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 25 25",
      width: "25",
      height: "25"
    }, _hoisted_4$m, 12, _hoisted_1$M);
  }
  var Close = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$P]]);
  const _sfc_main$O = {
    name: "OrderSummaryMobile",
    components: {
      TextField,
      ArrowUp,
      OrderSummaryItem,
      OrderSummaryTotal,
      Price,
      GiftCardDiscount,
      CouponDiscount,
      PromotionComponent,
      Loader,
      SlideUp,
      Close,
      OrderSummaryTitleWithAmount
    },
    props: {
      backgroundColor: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor
        }))
      };
    },
    data() {
      return {
        isModalVisible: false,
        orderSummaryText: "",
        orderSummaryTextId: "gene-bettercheckout-ordersummary-text",
        orderSummaryDescriptionText: "",
        orderSummaryDescriptionTextId: "gene-bettercheckout-ordersummarydescription-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["cartGrandTotal", "cartItemsQty"])
    },
    async created() {
      var _a, _b;
      await this.getStoreConfig();
      this.orderSummaryText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.orderSummaryTextId]) || this.$t("orderSummary.modalHeader");
      this.orderSummaryDescriptionText = ((_b = window.geneCheckout) == null ? void 0 : _b[this.orderSummaryDescriptionTextId]) || this.$t("orderSummary.mobileDiscountText");
      document.addEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
      document.addEventListener(this.orderSummaryDescriptionTextId, this.setOrderSummaryDescriptionText);
    },
    unmounted() {
      document.removeEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
      document.removeEventListener(this.orderSummaryDescriptionTextId, this.setOrderSummaryDescriptionText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      ...mapActions(useCustomerStore, ["getCustomerInformation", "checkForGuestUser"]),
      ...mapActions(useCartStore, ["getCart", "getCartData", "getCartTotals"]),
      toggleSummary() {
        this.isModalVisible = !this.isModalVisible;
        if (this.isModalVisible) {
          document.body.classList.add("no-scrollable");
        } else {
          document.body.classList.remove("no-scrollable");
        }
      },
      closeSummary() {
        document.body.classList.remove("no-scrollable");
        this.isModalVisible = false;
      },
      setOrderSummaryText(event) {
        this.orderSummaryText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.modalHeader");
      },
      setOrderSummaryDescriptionText(event) {
        this.orderSummaryDescriptionText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.mobileDiscountText");
      }
    }
  };
  const _hoisted_1$L = ["aria-label"];
  const _hoisted_2$B = { class: "product-items" };
  const _hoisted_3$u = {
    key: 0,
    class: "order-summary-header"
  };
  const _hoisted_4$l = { class: "order-summary-title" };
  const _hoisted_5$h = { class: "order-summary-icon" };
  const _hoisted_6$9 = { class: "order-summary-description" };
  const _hoisted_7$7 = { key: 1 };
  function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OrderSummaryTitleWithAmount = resolveComponent("OrderSummaryTitleWithAmount");
    const _component_Close = resolveComponent("Close");
    const _component_PromotionComponent = resolveComponent("PromotionComponent");
    const _component_GiftCardDiscount = resolveComponent("GiftCardDiscount");
    const _component_CouponDiscount = resolveComponent("CouponDiscount");
    const _component_OrderSummaryItem = resolveComponent("OrderSummaryItem");
    const _component_OrderSummaryTotal = resolveComponent("OrderSummaryTotal");
    const _component_SlideUp = resolveComponent("SlideUp");
    const _component_TextField = resolveComponent("TextField");
    const _component_Price = resolveComponent("Price");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_Loader = resolveComponent("Loader");
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(_component_SlideUp, {
        visible: $data.isModalVisible,
        onClose: $options.closeSummary
      }, {
        header: withCtx(() => [
          createVNode(_component_OrderSummaryTitleWithAmount, { "order-items-amount": _ctx.cartItemsQty }, null, 8, ["order-items-amount"]),
          createBaseVNode("button", {
            class: "order-summary-close-button",
            "aria-label": _ctx.$t("orderSummary.closeButton"),
            onClick: _cache[0] || (_cache[0] = (...args) => $options.toggleSummary && $options.toggleSummary(...args)),
            onKeydown: _cache[1] || (_cache[1] = (...args) => $options.toggleSummary && $options.toggleSummary(...args))
          }, [
            createVNode(_component_Close)
          ], 40, _hoisted_1$L)
        ]),
        body: withCtx(() => [
          createVNode(_component_PromotionComponent),
          createVNode(_component_GiftCardDiscount),
          createVNode(_component_CouponDiscount),
          createBaseVNode("div", _hoisted_2$B, [
            createVNode(_component_OrderSummaryItem)
          ]),
          createVNode(_component_OrderSummaryTotal)
        ]),
        _: 1
      }, 8, ["visible", "onClose"]),
      createBaseVNode("div", {
        class: "is-hidden-desktop is-hidden-tablet order-summary-container",
        style: normalizeStyle($setup.style),
        onClick: _cache[2] || (_cache[2] = (...args) => $options.toggleSummary && $options.toggleSummary(...args)),
        onKeydown: _cache[3] || (_cache[3] = (...args) => $options.toggleSummary && $options.toggleSummary(...args))
      }, [
        _ctx.cartGrandTotal || _ctx.cartItemsQty ? (openBlock(), createElementBlock("div", _hoisted_3$u, [
          createBaseVNode("div", _hoisted_4$l, [
            createVNode(_component_TextField, {
              class: "order-summary-title-text",
              text: $data.orderSummaryText
            }, null, 8, ["text"]),
            _ctx.cartGrandTotal !== null ? (openBlock(), createBlock(_component_Price, {
              key: 0,
              class: "price",
              value: _ctx.cartGrandTotal / 100
            }, null, 8, ["value"])) : createCommentVNode("", true),
            createVNode(_component_Price, {
              class: "storyBookEmptyPrice",
              value: "532.5"
            })
          ]),
          createBaseVNode("div", _hoisted_5$h, [
            $data.isModalVisible ? (openBlock(), createBlock(_component_Close, { key: 0 })) : (openBlock(), createBlock(_component_ArrowUp, {
              key: 1,
              width: "14px"
            }))
          ]),
          createBaseVNode("div", _hoisted_6$9, [
            createVNode(_component_TextField, { text: $data.orderSummaryDescriptionText }, null, 8, ["text"])
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_7$7, [
          createVNode(_component_Loader)
        ]))
      ], 36)
    ], 64);
  }
  var OrderSummaryMobile = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$O], ["__scopeId", "data-v-f7b62c88"]]);
  var detailsIconSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/detailsIcon.svg";
  const _sfc_main$N = {
    name: "YourDetails",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      detailsIconSvg() {
        return `${getStaticUrl(detailsIconSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$K = ["src", "alt"];
  function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.detailsIconSvg,
      alt: $options.detailsIconSvg
    }, null, 8, _hoisted_1$K);
  }
  var YourDetails = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$N]]);
  var shippingSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/shippingIcon.svg";
  const _sfc_main$M = {
    name: "Shipping",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      shippingSvgIcon() {
        return `${getStaticUrl(shippingSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$J = ["src", "alt"];
  function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.shippingSvgIcon,
      alt: $options.shippingSvgIcon
    }, null, 8, _hoisted_1$J);
  }
  var Shipping = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$M]]);
  var paymentSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/paymentIcon.svg";
  const _sfc_main$L = {
    name: "Payment",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      paymentSvgIcon() {
        return `${getStaticUrl(paymentSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$I = ["src", "alt"];
  function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.paymentSvgIcon,
      alt: $options.paymentSvgIcon
    }, null, 8, _hoisted_1$I);
  }
  var Payment = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$L]]);
  const _sfc_main$K = {
    name: "ProgressBar",
    components: {
      YourDetails,
      Shipping,
      Payment,
      TextField
    },
    computed: {
      ...mapState(useStepsStore, ["yourDetailsActive", "shippingActive", "paymentActive"])
    },
    methods: {
      ...mapActions(useStepsStore, ["goToYouDetails", "goToShipping", "goToPayment"])
    }
  };
  const _hoisted_1$H = {
    class: "progress-bar-container",
    id: "progress-bar"
  };
  const _hoisted_2$A = { class: "details-icon" };
  const _hoisted_3$t = { class: "shipping-icon" };
  const _hoisted_4$k = { class: "payment-icon" };
  function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_YourDetails = resolveComponent("YourDetails");
    const _component_TextField = resolveComponent("TextField");
    const _component_router_link = resolveComponent("router-link");
    const _component_Shipping = resolveComponent("Shipping");
    const _component_Payment = resolveComponent("Payment");
    return openBlock(), createElementBlock("div", _hoisted_1$H, [
      createVNode(_component_router_link, {
        "aria-label": "progress-bar-link",
        to: "/checkout",
        class: "details active",
        onClick: _ctx.goToYouDetails
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_2$A, [
            createVNode(_component_YourDetails)
          ]),
          createVNode(_component_TextField, {
            class: "details-text",
            text: _ctx.$t("progressBar.detailStepTitle"),
            "font-weight": "325"
          }, null, 8, ["text"])
        ]),
        _: 1
      }, 8, ["onClick"]),
      createBaseVNode("p", {
        class: normalizeClass(["progress-bar-divider shipping-divider", { active: _ctx.shippingActive }])
      }, null, 2),
      createVNode(_component_router_link, {
        "aria-label": "progress-bar-link",
        to: _ctx.shippingActive ? "/shipping" : "",
        class: normalizeClass([{ active: _ctx.shippingActive }, "shipping"]),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.shippingActive ? _ctx.goToShipping() : null)
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_3$t, [
            createVNode(_component_Shipping)
          ]),
          createVNode(_component_TextField, {
            text: _ctx.$t("progressBar.shippingStepTitle"),
            "font-weight": "325"
          }, null, 8, ["text"])
        ]),
        _: 1
      }, 8, ["to", "class"]),
      createBaseVNode("p", {
        class: normalizeClass(["progress-bar-divider payment-divider", { active: _ctx.paymentActive }])
      }, null, 2),
      createVNode(_component_router_link, {
        "aria-label": "progress-bar-link",
        to: _ctx.paymentActive ? "/payments" : "",
        class: normalizeClass([{ active: _ctx.paymentActive }, "payment"]),
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.paymentActive ? _ctx.goToPayment() : null)
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_4$k, [
            createVNode(_component_Payment)
          ]),
          createVNode(_component_TextField, {
            text: _ctx.$t("progressBar.paymentStepTitle"),
            "font-weight": "325"
          }, null, 8, ["text"])
        ]),
        _: 1
      }, 8, ["to", "class"])
    ]);
  }
  var ProgressBar = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$K], ["__scopeId", "data-v-b3c7f078"]]);
  const _sfc_main$J = {
    name: "OrderSummaryDesktop",
    components: {
      OrderSummaryTotal,
      OrderSummaryItem,
      PromotionComponent,
      GiftCardDiscount,
      CouponDiscount
    }
  };
  const _hoisted_1$G = { class: "order-summary-desktop" };
  const _hoisted_2$z = { class: "order-summary-desktop-items" };
  function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OrderSummaryTotal = resolveComponent("OrderSummaryTotal");
    const _component_OrderSummaryItem = resolveComponent("OrderSummaryItem");
    const _component_PromotionComponent = resolveComponent("PromotionComponent");
    const _component_GiftCardDiscount = resolveComponent("GiftCardDiscount");
    const _component_CouponDiscount = resolveComponent("CouponDiscount");
    return openBlock(), createElementBlock("div", _hoisted_1$G, [
      createVNode(_component_OrderSummaryTotal),
      createBaseVNode("div", _hoisted_2$z, [
        createVNode(_component_OrderSummaryItem)
      ]),
      createVNode(_component_PromotionComponent),
      createVNode(_component_GiftCardDiscount),
      createVNode(_component_CouponDiscount)
    ]);
  }
  var OrderSummaryDesktop = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$J], ["__scopeId", "data-v-0d737809"]]);
  const _sfc_main$I = {
    name: "AppSteps",
    components: {
      ProgressBar,
      OrderSummaryDesktop
    }
  };
  const _hoisted_1$F = { class: "root" };
  const _hoisted_2$y = { class: "steps-container" };
  const _hoisted_3$s = { class: "container" };
  const _hoisted_4$j = { class: "is-hidden-mobile summary" };
  const _hoisted_5$g = { class: "content" };
  function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ProgressBar = resolveComponent("ProgressBar");
    const _component_OrderSummaryDesktop = resolveComponent("OrderSummaryDesktop");
    const _component_router_view = resolveComponent("router-view");
    return openBlock(), createElementBlock("div", _hoisted_1$F, [
      createVNode(_component_ProgressBar),
      createBaseVNode("div", _hoisted_2$y, [
        createBaseVNode("div", _hoisted_3$s, [
          createBaseVNode("div", _hoisted_4$j, [
            createVNode(_component_OrderSummaryDesktop)
          ]),
          createBaseVNode("div", _hoisted_5$g, [
            createVNode(_component_router_view, null, {
              default: withCtx(({ Component }) => [
                createVNode(Transition, null, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(Component)))
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 1
            })
          ])
        ])
      ])
    ]);
  }
  var Steps = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$I]]);
  const _sfc_main$H = {
    name: "App",
    components: {
      AppFooter,
      AppHeader,
      MockDesktop,
      MockFull,
      MockLaptop,
      MockMobile,
      MockTablet,
      OrderSummaryMobile,
      Steps
    },
    data() {
      return {
        currentDevice: "MockDesktop",
        currentStep: "YourDetails",
        devices: [
          { deviceName: "MockMobile", displayName: "Mobile" },
          { deviceName: "MockTablet", displayName: "Tablet" },
          { deviceName: "MockLaptop", displayName: "Laptop" },
          { deviceName: "MockDesktop", displayName: "Desktop" },
          { deviceName: "MockFull", displayName: "Full" }
        ],
        checkoutSteps: [
          { stepName: "YourDetails", displayName: "Your Details" },
          { stepName: "Shipping", displayName: "Shipping" },
          { stepName: "Payment", displayName: "Payment" }
        ]
      };
    },
    computed: {
      ...mapState(useStepsStore, ["yourDetailsActive", "shippingActive", "paymentActive"])
    },
    async created() {
      await this.getStoreConfig();
      this.dispatchDeviceType(this.currentDevice);
      this.dispatchStep(this.currentStep);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      ...mapActions(useStepsStore, ["goToYouDetails", "goToShipping", "goToPayment"]),
      switchDevice(device) {
        this.currentDevice = device.deviceName;
        this.dispatchDeviceType(device.deviceName);
      },
      dispatchDeviceType(deviceName) {
        document.dispatchEvent(new CustomEvent("switchDeviceType", { detail: deviceName }));
      },
      goToStep(step) {
        this.currentStep = step.stepName;
        switch (step.stepName) {
          case "YourDetails":
            this.goToYouDetails();
            break;
          case "Shipping":
            this.goToShipping();
            break;
          case "Payment":
            this.goToPayment();
            break;
        }
        this.dispatchStep(step.stepName);
      },
      dispatchStep(stepName) {
        document.dispatchEvent(new CustomEvent("switchDisplayedStep", { detail: stepName }));
      }
    }
  };
  const _hoisted_1$E = { class: "switchers" };
  const _hoisted_2$x = ["onClick"];
  const _hoisted_3$r = { id: "vue-checkout-display" };
  const _hoisted_4$i = { class: "switchers" };
  const _hoisted_5$f = ["onClick"];
  function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_AppHeader = resolveComponent("AppHeader");
    const _component_Steps = resolveComponent("Steps");
    const _component_AppFooter = resolveComponent("AppFooter");
    const _component_OrderSummaryMobile = resolveComponent("OrderSummaryMobile");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$E, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.devices, (device, index) => {
          return openBlock(), createElementBlock("button", {
            key: index,
            class: normalizeClass({
              "action-secondary": $data.currentDevice === device.deviceName
            }),
            onClick: ($event) => $options.switchDevice(device)
          }, toDisplayString$1(device.displayName), 11, _hoisted_2$x);
        }), 128))
      ]),
      createBaseVNode("div", _hoisted_3$r, [
        (openBlock(), createBlock(resolveDynamicComponent($data.currentDevice), null, {
          default: withCtx(() => [
            createVNode(_component_AppHeader),
            createVNode(_component_Steps),
            createVNode(_component_AppFooter),
            createVNode(_component_OrderSummaryMobile)
          ]),
          _: 1
        }))
      ]),
      createBaseVNode("div", _hoisted_4$i, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.checkoutSteps, (step, index) => {
          return openBlock(), createElementBlock("button", {
            key: index,
            class: normalizeClass({
              "action-secondary": $data.currentStep === step.stepName
            }),
            onClick: ($event) => $options.goToStep(step)
          }, toDisplayString$1(step.displayName), 11, _hoisted_5$f);
        }), 128))
      ])
    ], 64);
  }
  var App = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$H], ["__scopeId", "data-v-0f06240b"]]);
  /*!
    * vue-router v4.0.16
    * (c) 2022 Eduardo San Martin Morote
    * @license MIT
    */
  const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  const PolySymbol = (name) => hasSymbol ? Symbol(name) : "_vr_" + name;
  const matchedRouteKey = /* @__PURE__ */ PolySymbol("rvlm");
  const viewDepthKey = /* @__PURE__ */ PolySymbol("rvd");
  const routerKey = /* @__PURE__ */ PolySymbol("r");
  const routeLocationKey = /* @__PURE__ */ PolySymbol("rl");
  const routerViewLocationKey = /* @__PURE__ */ PolySymbol("rvl");
  const isBrowser = typeof window !== "undefined";
  function isESModule(obj) {
    return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === "Module";
  }
  const assign = Object.assign;
  function applyToParams(fn, params) {
    const newParams = {};
    for (const key in params) {
      const value = params[key];
      newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
    }
    return newParams;
  }
  const noop = () => {
  };
  const TRAILING_SLASH_RE = /\/$/;
  const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
  function parseURL(parseQuery2, location, currentLocation = "/") {
    let path, query = {}, searchString = "", hash = "";
    const searchPos = location.indexOf("?");
    const hashPos = location.indexOf("#", searchPos > -1 ? searchPos : 0);
    if (searchPos > -1) {
      path = location.slice(0, searchPos);
      searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);
      query = parseQuery2(searchString);
    }
    if (hashPos > -1) {
      path = path || location.slice(0, hashPos);
      hash = location.slice(hashPos, location.length);
    }
    path = resolveRelativePath(path != null ? path : location, currentLocation);
    return {
      fullPath: path + (searchString && "?") + searchString + hash,
      path,
      query,
      hash
    };
  }
  function stringifyURL(stringifyQuery2, location) {
    const query = location.query ? stringifyQuery2(location.query) : "";
    return location.path + (query && "?") + query + (location.hash || "");
  }
  function isSameRouteLocation(stringifyQuery2, a, b) {
    const aLastIndex = a.matched.length - 1;
    const bLastIndex = b.matched.length - 1;
    return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
  }
  function isSameRouteRecord(a, b) {
    return (a.aliasOf || a) === (b.aliasOf || b);
  }
  function isSameRouteLocationParams(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length)
      return false;
    for (const key in a) {
      if (!isSameRouteLocationParamsValue(a[key], b[key]))
        return false;
    }
    return true;
  }
  function isSameRouteLocationParamsValue(a, b) {
    return Array.isArray(a) ? isEquivalentArray(a, b) : Array.isArray(b) ? isEquivalentArray(b, a) : a === b;
  }
  function isEquivalentArray(a, b) {
    return Array.isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
  }
  function resolveRelativePath(to, from) {
    if (to.startsWith("/"))
      return to;
    if (!to)
      return from;
    const fromSegments = from.split("/");
    const toSegments = to.split("/");
    let position = fromSegments.length - 1;
    let toPosition;
    let segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
      segment = toSegments[toPosition];
      if (position === 1 || segment === ".")
        continue;
      if (segment === "..")
        position--;
      else
        break;
    }
    return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
  }
  var NavigationType;
  (function(NavigationType2) {
    NavigationType2["pop"] = "pop";
    NavigationType2["push"] = "push";
  })(NavigationType || (NavigationType = {}));
  var NavigationDirection;
  (function(NavigationDirection2) {
    NavigationDirection2["back"] = "back";
    NavigationDirection2["forward"] = "forward";
    NavigationDirection2["unknown"] = "";
  })(NavigationDirection || (NavigationDirection = {}));
  const START = "";
  function normalizeBase(base) {
    if (!base) {
      if (isBrowser) {
        const baseEl = document.querySelector("base");
        base = baseEl && baseEl.getAttribute("href") || "/";
        base = base.replace(/^\w+:\/\/[^\/]+/, "");
      } else {
        base = "/";
      }
    }
    if (base[0] !== "/" && base[0] !== "#")
      base = "/" + base;
    return removeTrailingSlash(base);
  }
  const BEFORE_HASH_RE = /^[^#]+#/;
  function createHref(base, location) {
    return base.replace(BEFORE_HASH_RE, "#") + location;
  }
  function getElementPosition(el, offset) {
    const docRect = document.documentElement.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    return {
      behavior: offset.behavior,
      left: elRect.left - docRect.left - (offset.left || 0),
      top: elRect.top - docRect.top - (offset.top || 0)
    };
  }
  const computeScrollPosition = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
  });
  function scrollToPosition(position) {
    let scrollToOptions;
    if ("el" in position) {
      const positionEl = position.el;
      const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
      const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
      if (!el) {
        return;
      }
      scrollToOptions = getElementPosition(el, position);
    } else {
      scrollToOptions = position;
    }
    if ("scrollBehavior" in document.documentElement.style)
      window.scrollTo(scrollToOptions);
    else {
      window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
    }
  }
  function getScrollKey(path, delta) {
    const position = history.state ? history.state.position - delta : -1;
    return position + path;
  }
  const scrollPositions = /* @__PURE__ */ new Map();
  function saveScrollPosition(key, scrollPosition) {
    scrollPositions.set(key, scrollPosition);
  }
  function getSavedScrollPosition(key) {
    const scroll = scrollPositions.get(key);
    scrollPositions.delete(key);
    return scroll;
  }
  function createMemoryHistory(base = "") {
    let listeners = [];
    let queue2 = [START];
    let position = 0;
    base = normalizeBase(base);
    function setLocation(location) {
      position++;
      if (position === queue2.length) {
        queue2.push(location);
      } else {
        queue2.splice(position);
        queue2.push(location);
      }
    }
    function triggerListeners(to, from, { direction, delta }) {
      const info = {
        direction,
        delta,
        type: NavigationType.pop
      };
      for (const callback of listeners) {
        callback(to, from, info);
      }
    }
    const routerHistory = {
      location: START,
      state: {},
      base,
      createHref: createHref.bind(null, base),
      replace(to) {
        queue2.splice(position--, 1);
        setLocation(to);
      },
      push(to, data2) {
        setLocation(to);
      },
      listen(callback) {
        listeners.push(callback);
        return () => {
          const index = listeners.indexOf(callback);
          if (index > -1)
            listeners.splice(index, 1);
        };
      },
      destroy() {
        listeners = [];
        queue2 = [START];
        position = 0;
      },
      go(delta, shouldTrigger = true) {
        const from = this.location;
        const direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
        position = Math.max(0, Math.min(position + delta, queue2.length - 1));
        if (shouldTrigger) {
          triggerListeners(this.location, from, {
            direction,
            delta
          });
        }
      }
    };
    Object.defineProperty(routerHistory, "location", {
      enumerable: true,
      get: () => queue2[position]
    });
    return routerHistory;
  }
  function isRouteLocation(route) {
    return typeof route === "string" || route && typeof route === "object";
  }
  function isRouteName(name) {
    return typeof name === "string" || typeof name === "symbol";
  }
  const START_LOCATION_NORMALIZED = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
  };
  const NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("nf");
  var NavigationFailureType;
  (function(NavigationFailureType2) {
    NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
    NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
    NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
  })(NavigationFailureType || (NavigationFailureType = {}));
  function createRouterError(type, params) {
    {
      return assign(new Error(), {
        type,
        [NavigationFailureSymbol]: true
      }, params);
    }
  }
  function isNavigationFailure(error, type) {
    return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
  }
  const BASE_PARAM_PATTERN = "[^/]+?";
  const BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true
  };
  const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
  function tokensToParser(segments, extraOptions) {
    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    const score = [];
    let pattern = options.start ? "^" : "";
    const keys = [];
    for (const segment of segments) {
      const segmentScores = segment.length ? [] : [90];
      if (options.strict && !segment.length)
        pattern += "/";
      for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
        const token = segment[tokenIndex];
        let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
        if (token.type === 0) {
          if (!tokenIndex)
            pattern += "/";
          pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
          subSegmentScore += 40;
        } else if (token.type === 1) {
          const { value, repeatable, optional, regexp } = token;
          keys.push({
            name: value,
            repeatable,
            optional
          });
          const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
          if (re2 !== BASE_PARAM_PATTERN) {
            subSegmentScore += 10;
            try {
              new RegExp(`(${re2})`);
            } catch (err) {
              throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
            }
          }
          let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
          if (!tokenIndex)
            subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
          if (optional)
            subPattern += "?";
          pattern += subPattern;
          subSegmentScore += 20;
          if (optional)
            subSegmentScore += -8;
          if (repeatable)
            subSegmentScore += -20;
          if (re2 === ".*")
            subSegmentScore += -50;
        }
        segmentScores.push(subSegmentScore);
      }
      score.push(segmentScores);
    }
    if (options.strict && options.end) {
      const i = score.length - 1;
      score[i][score[i].length - 1] += 0.7000000000000001;
    }
    if (!options.strict)
      pattern += "/?";
    if (options.end)
      pattern += "$";
    else if (options.strict)
      pattern += "(?:/|$)";
    const re = new RegExp(pattern, options.sensitive ? "" : "i");
    function parse2(path) {
      const match = path.match(re);
      const params = {};
      if (!match)
        return null;
      for (let i = 1; i < match.length; i++) {
        const value = match[i] || "";
        const key = keys[i - 1];
        params[key.name] = value && key.repeatable ? value.split("/") : value;
      }
      return params;
    }
    function stringify(params) {
      let path = "";
      let avoidDuplicatedSlash = false;
      for (const segment of segments) {
        if (!avoidDuplicatedSlash || !path.endsWith("/"))
          path += "/";
        avoidDuplicatedSlash = false;
        for (const token of segment) {
          if (token.type === 0) {
            path += token.value;
          } else if (token.type === 1) {
            const { value, repeatable, optional } = token;
            const param = value in params ? params[value] : "";
            if (Array.isArray(param) && !repeatable)
              throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
            const text = Array.isArray(param) ? param.join("/") : param;
            if (!text) {
              if (optional) {
                if (segment.length < 2 && segments.length > 1) {
                  if (path.endsWith("/"))
                    path = path.slice(0, -1);
                  else
                    avoidDuplicatedSlash = true;
                }
              } else
                throw new Error(`Missing required param "${value}"`);
            }
            path += text;
          }
        }
      }
      return path;
    }
    return {
      re,
      score,
      keys,
      parse: parse2,
      stringify
    };
  }
  function compareScoreArray(a, b) {
    let i = 0;
    while (i < a.length && i < b.length) {
      const diff = b[i] - a[i];
      if (diff)
        return diff;
      i++;
    }
    if (a.length < b.length) {
      return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
    } else if (a.length > b.length) {
      return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
    }
    return 0;
  }
  function comparePathParserScore(a, b) {
    let i = 0;
    const aScore = a.score;
    const bScore = b.score;
    while (i < aScore.length && i < bScore.length) {
      const comp = compareScoreArray(aScore[i], bScore[i]);
      if (comp)
        return comp;
      i++;
    }
    if (Math.abs(bScore.length - aScore.length) === 1) {
      if (isLastScoreNegative(aScore))
        return 1;
      if (isLastScoreNegative(bScore))
        return -1;
    }
    return bScore.length - aScore.length;
  }
  function isLastScoreNegative(score) {
    const last = score[score.length - 1];
    return score.length > 0 && last[last.length - 1] < 0;
  }
  const ROOT_TOKEN = {
    type: 0,
    value: ""
  };
  const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
  function tokenizePath(path) {
    if (!path)
      return [[]];
    if (path === "/")
      return [[ROOT_TOKEN]];
    if (!path.startsWith("/")) {
      throw new Error(`Invalid path "${path}"`);
    }
    function crash(message) {
      throw new Error(`ERR (${state})/"${buffer}": ${message}`);
    }
    let state = 0;
    let previousState = state;
    const tokens = [];
    let segment;
    function finalizeSegment() {
      if (segment)
        tokens.push(segment);
      segment = [];
    }
    let i = 0;
    let char;
    let buffer = "";
    let customRe = "";
    function consumeBuffer() {
      if (!buffer)
        return;
      if (state === 0) {
        segment.push({
          type: 0,
          value: buffer
        });
      } else if (state === 1 || state === 2 || state === 3) {
        if (segment.length > 1 && (char === "*" || char === "+"))
          crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
        segment.push({
          type: 1,
          value: buffer,
          regexp: customRe,
          repeatable: char === "*" || char === "+",
          optional: char === "*" || char === "?"
        });
      } else {
        crash("Invalid state to consume buffer");
      }
      buffer = "";
    }
    function addCharToBuffer() {
      buffer += char;
    }
    while (i < path.length) {
      char = path[i++];
      if (char === "\\" && state !== 2) {
        previousState = state;
        state = 4;
        continue;
      }
      switch (state) {
        case 0:
          if (char === "/") {
            if (buffer) {
              consumeBuffer();
            }
            finalizeSegment();
          } else if (char === ":") {
            consumeBuffer();
            state = 1;
          } else {
            addCharToBuffer();
          }
          break;
        case 4:
          addCharToBuffer();
          state = previousState;
          break;
        case 1:
          if (char === "(") {
            state = 2;
          } else if (VALID_PARAM_RE.test(char)) {
            addCharToBuffer();
          } else {
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i--;
          }
          break;
        case 2:
          if (char === ")") {
            if (customRe[customRe.length - 1] == "\\")
              customRe = customRe.slice(0, -1) + char;
            else
              state = 3;
          } else {
            customRe += char;
          }
          break;
        case 3:
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
          customRe = "";
          break;
        default:
          crash("Unknown state");
          break;
      }
    }
    if (state === 2)
      crash(`Unfinished custom RegExp for param "${buffer}"`);
    consumeBuffer();
    finalizeSegment();
    return tokens;
  }
  function createRouteRecordMatcher(record, parent, options) {
    const parser = tokensToParser(tokenizePath(record.path), options);
    const matcher = assign(parser, {
      record,
      parent,
      children: [],
      alias: []
    });
    if (parent) {
      if (!matcher.record.aliasOf === !parent.record.aliasOf)
        parent.children.push(matcher);
    }
    return matcher;
  }
  function createRouterMatcher(routes2, globalOptions) {
    const matchers = [];
    const matcherMap = /* @__PURE__ */ new Map();
    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
    function getRecordMatcher(name) {
      return matcherMap.get(name);
    }
    function addRoute(record, parent, originalRecord) {
      const isRootAdd = !originalRecord;
      const mainNormalizedRecord = normalizeRouteRecord(record);
      mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
      const options = mergeOptions(globalOptions, record);
      const normalizedRecords = [
        mainNormalizedRecord
      ];
      if ("alias" in record) {
        const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
        for (const alias of aliases) {
          normalizedRecords.push(assign({}, mainNormalizedRecord, {
            components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
            path: alias,
            aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          }));
        }
      }
      let matcher;
      let originalMatcher;
      for (const normalizedRecord of normalizedRecords) {
        const { path } = normalizedRecord;
        if (parent && path[0] !== "/") {
          const parentPath = parent.record.path;
          const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
          normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
        }
        matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
        if (originalRecord) {
          originalRecord.alias.push(matcher);
        } else {
          originalMatcher = originalMatcher || matcher;
          if (originalMatcher !== matcher)
            originalMatcher.alias.push(matcher);
          if (isRootAdd && record.name && !isAliasRecord(matcher))
            removeRoute(record.name);
        }
        if ("children" in mainNormalizedRecord) {
          const children = mainNormalizedRecord.children;
          for (let i = 0; i < children.length; i++) {
            addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
          }
        }
        originalRecord = originalRecord || matcher;
        insertMatcher(matcher);
      }
      return originalMatcher ? () => {
        removeRoute(originalMatcher);
      } : noop;
    }
    function removeRoute(matcherRef) {
      if (isRouteName(matcherRef)) {
        const matcher = matcherMap.get(matcherRef);
        if (matcher) {
          matcherMap.delete(matcherRef);
          matchers.splice(matchers.indexOf(matcher), 1);
          matcher.children.forEach(removeRoute);
          matcher.alias.forEach(removeRoute);
        }
      } else {
        const index = matchers.indexOf(matcherRef);
        if (index > -1) {
          matchers.splice(index, 1);
          if (matcherRef.record.name)
            matcherMap.delete(matcherRef.record.name);
          matcherRef.children.forEach(removeRoute);
          matcherRef.alias.forEach(removeRoute);
        }
      }
    }
    function getRoutes() {
      return matchers;
    }
    function insertMatcher(matcher) {
      let i = 0;
      while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))
        i++;
      matchers.splice(i, 0, matcher);
      if (matcher.record.name && !isAliasRecord(matcher))
        matcherMap.set(matcher.record.name, matcher);
    }
    function resolve2(location, currentLocation) {
      let matcher;
      let params = {};
      let path;
      let name;
      if ("name" in location && location.name) {
        matcher = matcherMap.get(location.name);
        if (!matcher)
          throw createRouterError(1, {
            location
          });
        name = matcher.record.name;
        params = assign(paramsFromLocation(currentLocation.params, matcher.keys.filter((k) => !k.optional).map((k) => k.name)), location.params);
        path = matcher.stringify(params);
      } else if ("path" in location) {
        path = location.path;
        matcher = matchers.find((m) => m.re.test(path));
        if (matcher) {
          params = matcher.parse(path);
          name = matcher.record.name;
        }
      } else {
        matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
        if (!matcher)
          throw createRouterError(1, {
            location,
            currentLocation
          });
        name = matcher.record.name;
        params = assign({}, currentLocation.params, location.params);
        path = matcher.stringify(params);
      }
      const matched = [];
      let parentMatcher = matcher;
      while (parentMatcher) {
        matched.unshift(parentMatcher.record);
        parentMatcher = parentMatcher.parent;
      }
      return {
        name,
        path,
        params,
        matched,
        meta: mergeMetaFields(matched)
      };
    }
    routes2.forEach((route) => addRoute(route));
    return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
  }
  function paramsFromLocation(params, keys) {
    const newParams = {};
    for (const key of keys) {
      if (key in params)
        newParams[key] = params[key];
    }
    return newParams;
  }
  function normalizeRouteRecord(record) {
    return {
      path: record.path,
      redirect: record.redirect,
      name: record.name,
      meta: record.meta || {},
      aliasOf: void 0,
      beforeEnter: record.beforeEnter,
      props: normalizeRecordProps(record),
      children: record.children || [],
      instances: {},
      leaveGuards: /* @__PURE__ */ new Set(),
      updateGuards: /* @__PURE__ */ new Set(),
      enterCallbacks: {},
      components: "components" in record ? record.components || {} : { default: record.component }
    };
  }
  function normalizeRecordProps(record) {
    const propsObject = {};
    const props = record.props || false;
    if ("component" in record) {
      propsObject.default = props;
    } else {
      for (const name in record.components)
        propsObject[name] = typeof props === "boolean" ? props : props[name];
    }
    return propsObject;
  }
  function isAliasRecord(record) {
    while (record) {
      if (record.record.aliasOf)
        return true;
      record = record.parent;
    }
    return false;
  }
  function mergeMetaFields(matched) {
    return matched.reduce((meta, record) => assign(meta, record.meta), {});
  }
  function mergeOptions(defaults2, partialOptions) {
    const options = {};
    for (const key in defaults2) {
      options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
    }
    return options;
  }
  function isRecordChildOf(record, parent) {
    return parent.children.some((child) => child === record || isRecordChildOf(record, child));
  }
  const HASH_RE = /#/g;
  const AMPERSAND_RE = /&/g;
  const SLASH_RE = /\//g;
  const EQUAL_RE = /=/g;
  const IM_RE = /\?/g;
  const PLUS_RE = /\+/g;
  const ENC_BRACKET_OPEN_RE = /%5B/g;
  const ENC_BRACKET_CLOSE_RE = /%5D/g;
  const ENC_CARET_RE = /%5E/g;
  const ENC_BACKTICK_RE = /%60/g;
  const ENC_CURLY_OPEN_RE = /%7B/g;
  const ENC_PIPE_RE = /%7C/g;
  const ENC_CURLY_CLOSE_RE = /%7D/g;
  const ENC_SPACE_RE = /%20/g;
  function commonEncode(text) {
    return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
  }
  function encodeHash(text) {
    return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryValue(text) {
    return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryKey(text) {
    return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
  }
  function encodePath(text) {
    return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
  }
  function encodeParam(text) {
    return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
  }
  function decode(text) {
    try {
      return decodeURIComponent("" + text);
    } catch (err) {
    }
    return "" + text;
  }
  function parseQuery(search) {
    const query = {};
    if (search === "" || search === "?")
      return query;
    const hasLeadingIM = search[0] === "?";
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
    for (let i = 0; i < searchParams.length; ++i) {
      const searchParam = searchParams[i].replace(PLUS_RE, " ");
      const eqPos = searchParam.indexOf("=");
      const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
      const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
      if (key in query) {
        let currentValue = query[key];
        if (!Array.isArray(currentValue)) {
          currentValue = query[key] = [currentValue];
        }
        currentValue.push(value);
      } else {
        query[key] = value;
      }
    }
    return query;
  }
  function stringifyQuery(query) {
    let search = "";
    for (let key in query) {
      const value = query[key];
      key = encodeQueryKey(key);
      if (value == null) {
        if (value !== void 0) {
          search += (search.length ? "&" : "") + key;
        }
        continue;
      }
      const values = Array.isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
      values.forEach((value2) => {
        if (value2 !== void 0) {
          search += (search.length ? "&" : "") + key;
          if (value2 != null)
            search += "=" + value2;
        }
      });
    }
    return search;
  }
  function normalizeQuery(query) {
    const normalizedQuery = {};
    for (const key in query) {
      const value = query[key];
      if (value !== void 0) {
        normalizedQuery[key] = Array.isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
      }
    }
    return normalizedQuery;
  }
  function useCallbacks() {
    let handlers = [];
    function add2(handler) {
      handlers.push(handler);
      return () => {
        const i = handlers.indexOf(handler);
        if (i > -1)
          handlers.splice(i, 1);
      };
    }
    function reset() {
      handlers = [];
    }
    return {
      add: add2,
      list: () => handlers,
      reset
    };
  }
  function guardToPromiseFn(guard, to, from, record, name) {
    const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return () => new Promise((resolve2, reject) => {
      const next = (valid) => {
        if (valid === false)
          reject(createRouterError(4, {
            from,
            to
          }));
        else if (valid instanceof Error) {
          reject(valid);
        } else if (isRouteLocation(valid)) {
          reject(createRouterError(2, {
            from: to,
            to: valid
          }));
        } else {
          if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function")
            enterCallbackArray.push(valid);
          resolve2();
        }
      };
      const guardReturn = guard.call(record && record.instances[name], to, from, next);
      let guardCall = Promise.resolve(guardReturn);
      if (guard.length < 3)
        guardCall = guardCall.then(next);
      guardCall.catch((err) => reject(err));
    });
  }
  function extractComponentsGuards(matched, guardType, to, from) {
    const guards = [];
    for (const record of matched) {
      for (const name in record.components) {
        let rawComponent = record.components[name];
        if (guardType !== "beforeRouteEnter" && !record.instances[name])
          continue;
        if (isRouteComponent(rawComponent)) {
          const options = rawComponent.__vccOpts || rawComponent;
          const guard = options[guardType];
          guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
        } else {
          let componentPromise = rawComponent();
          guards.push(() => componentPromise.then((resolved) => {
            if (!resolved)
              return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
            const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
            record.components[name] = resolvedComponent;
            const options = resolvedComponent.__vccOpts || resolvedComponent;
            const guard = options[guardType];
            return guard && guardToPromiseFn(guard, to, from, record, name)();
          }));
        }
      }
    }
    return guards;
  }
  function isRouteComponent(component) {
    return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
  }
  function useLink(props) {
    const router2 = inject(routerKey);
    const currentRoute = inject(routeLocationKey);
    const route = computed(() => router2.resolve(unref(props.to)));
    const activeRecordIndex = computed(() => {
      const { matched } = route.value;
      const { length } = matched;
      const routeMatched = matched[length - 1];
      const currentMatched = currentRoute.matched;
      if (!routeMatched || !currentMatched.length)
        return -1;
      const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
      if (index > -1)
        return index;
      const parentRecordPath = getOriginalPath(matched[length - 2]);
      return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
    });
    const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
    const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
    function navigate(e = {}) {
      if (guardEvent(e)) {
        return router2[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop);
      }
      return Promise.resolve();
    }
    return {
      route,
      href: computed(() => route.value.href),
      isActive,
      isExactActive,
      navigate
    };
  }
  const RouterLinkImpl = /* @__PURE__ */ defineComponent({
    name: "RouterLink",
    compatConfig: { MODE: 3 },
    props: {
      to: {
        type: [String, Object],
        required: true
      },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        default: "page"
      }
    },
    useLink,
    setup(props, { slots }) {
      const link = reactive(useLink(props));
      const { options } = inject(routerKey);
      const elClass = computed(() => ({
        [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
        [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
      }));
      return () => {
        const children = slots.default && slots.default(link);
        return props.custom ? children : h("a", {
          "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
          href: link.href,
          onClick: link.navigate,
          class: elClass.value
        }, children);
      };
    }
  });
  const RouterLink = RouterLinkImpl;
  function guardEvent(e) {
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
      return;
    if (e.defaultPrevented)
      return;
    if (e.button !== void 0 && e.button !== 0)
      return;
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const target = e.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(target))
        return;
    }
    if (e.preventDefault)
      e.preventDefault();
    return true;
  }
  function includesParams(outer, inner) {
    for (const key in inner) {
      const innerValue = inner[key];
      const outerValue = outer[key];
      if (typeof innerValue === "string") {
        if (innerValue !== outerValue)
          return false;
      } else {
        if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
          return false;
      }
    }
    return true;
  }
  function getOriginalPath(record) {
    return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
  }
  const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
  const RouterViewImpl = /* @__PURE__ */ defineComponent({
    name: "RouterView",
    inheritAttrs: false,
    props: {
      name: {
        type: String,
        default: "default"
      },
      route: Object
    },
    compatConfig: { MODE: 3 },
    setup(props, { attrs, slots }) {
      const injectedRoute = inject(routerViewLocationKey);
      const routeToDisplay = computed(() => props.route || injectedRoute.value);
      const depth = inject(viewDepthKey, 0);
      const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);
      provide(viewDepthKey, depth + 1);
      provide(matchedRouteKey, matchedRouteRef);
      provide(routerViewLocationKey, routeToDisplay);
      const viewRef = ref();
      watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
        if (to) {
          to.instances[name] = instance;
          if (from && from !== to && instance && instance === oldInstance) {
            if (!to.leaveGuards.size) {
              to.leaveGuards = from.leaveGuards;
            }
            if (!to.updateGuards.size) {
              to.updateGuards = from.updateGuards;
            }
          }
        }
        if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
          (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
        }
      }, { flush: "post" });
      return () => {
        const route = routeToDisplay.value;
        const matchedRoute = matchedRouteRef.value;
        const ViewComponent = matchedRoute && matchedRoute.components[props.name];
        const currentName = props.name;
        if (!ViewComponent) {
          return normalizeSlot(slots.default, { Component: ViewComponent, route });
        }
        const routePropsOption = matchedRoute.props[props.name];
        const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
        const onVnodeUnmounted = (vnode) => {
          if (vnode.component.isUnmounted) {
            matchedRoute.instances[currentName] = null;
          }
        };
        const component = h(ViewComponent, assign({}, routeProps, attrs, {
          onVnodeUnmounted,
          ref: viewRef
        }));
        return normalizeSlot(slots.default, { Component: component, route }) || component;
      };
    }
  });
  function normalizeSlot(slot, data2) {
    if (!slot)
      return null;
    const slotContent = slot(data2);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
  }
  const RouterView = RouterViewImpl;
  function createRouter(options) {
    const matcher = createRouterMatcher(options.routes, options);
    const parseQuery$1 = options.parseQuery || parseQuery;
    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
    const routerHistory = options.history;
    const beforeGuards = useCallbacks();
    const beforeResolveGuards = useCallbacks();
    const afterGuards = useCallbacks();
    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
    let pendingLocation = START_LOCATION_NORMALIZED;
    if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }
    const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
    const encodeParams = applyToParams.bind(null, encodeParam);
    const decodeParams = applyToParams.bind(null, decode);
    function addRoute(parentOrRoute, route) {
      let parent;
      let record;
      if (isRouteName(parentOrRoute)) {
        parent = matcher.getRecordMatcher(parentOrRoute);
        record = route;
      } else {
        record = parentOrRoute;
      }
      return matcher.addRoute(record, parent);
    }
    function removeRoute(name) {
      const recordMatcher = matcher.getRecordMatcher(name);
      if (recordMatcher) {
        matcher.removeRoute(recordMatcher);
      }
    }
    function getRoutes() {
      return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
    }
    function hasRoute(name) {
      return !!matcher.getRecordMatcher(name);
    }
    function resolve2(rawLocation, currentLocation) {
      currentLocation = assign({}, currentLocation || currentRoute.value);
      if (typeof rawLocation === "string") {
        const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
        const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
        const href2 = routerHistory.createHref(locationNormalized.fullPath);
        return assign(locationNormalized, matchedRoute2, {
          params: decodeParams(matchedRoute2.params),
          hash: decode(locationNormalized.hash),
          redirectedFrom: void 0,
          href: href2
        });
      }
      let matcherLocation;
      if ("path" in rawLocation) {
        matcherLocation = assign({}, rawLocation, {
          path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
        });
      } else {
        const targetParams = assign({}, rawLocation.params);
        for (const key in targetParams) {
          if (targetParams[key] == null) {
            delete targetParams[key];
          }
        }
        matcherLocation = assign({}, rawLocation, {
          params: encodeParams(rawLocation.params)
        });
        currentLocation.params = encodeParams(currentLocation.params);
      }
      const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
      const hash = rawLocation.hash || "";
      matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
      const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
        hash: encodeHash(hash),
        path: matchedRoute.path
      }));
      const href = routerHistory.createHref(fullPath);
      return assign({
        fullPath,
        hash,
        query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      }, matchedRoute, {
        redirectedFrom: void 0,
        href
      });
    }
    function locationAsObject(to) {
      return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
    }
    function checkCanceledNavigation(to, from) {
      if (pendingLocation !== to) {
        return createRouterError(8, {
          from,
          to
        });
      }
    }
    function push(to) {
      return pushWithRedirect(to);
    }
    function replace(to) {
      return push(assign(locationAsObject(to), { replace: true }));
    }
    function handleRedirectRecord(to) {
      const lastMatched = to.matched[to.matched.length - 1];
      if (lastMatched && lastMatched.redirect) {
        const { redirect } = lastMatched;
        let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
        if (typeof newTargetLocation === "string") {
          newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
          newTargetLocation.params = {};
        }
        return assign({
          query: to.query,
          hash: to.hash,
          params: to.params
        }, newTargetLocation);
      }
    }
    function pushWithRedirect(to, redirectedFrom) {
      const targetLocation = pendingLocation = resolve2(to);
      const from = currentRoute.value;
      const data2 = to.state;
      const force = to.force;
      const replace2 = to.replace === true;
      const shouldRedirect = handleRedirectRecord(targetLocation);
      if (shouldRedirect)
        return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
          state: data2,
          force,
          replace: replace2
        }), redirectedFrom || targetLocation);
      const toLocation = targetLocation;
      toLocation.redirectedFrom = redirectedFrom;
      let failure;
      if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
        failure = createRouterError(16, { to: toLocation, from });
        handleScroll(from, from, true, false);
      }
      return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {
        if (failure2) {
          if (isNavigationFailure(failure2, 2)) {
            return pushWithRedirect(assign(locationAsObject(failure2.to), {
              state: data2,
              force,
              replace: replace2
            }), redirectedFrom || toLocation);
          }
        } else {
          failure2 = finalizeNavigation(toLocation, from, true, replace2, data2);
        }
        triggerAfterEach(toLocation, from, failure2);
        return failure2;
      });
    }
    function checkCanceledNavigationAndReject(to, from) {
      const error = checkCanceledNavigation(to, from);
      return error ? Promise.reject(error) : Promise.resolve();
    }
    function navigate(to, from) {
      let guards;
      const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
      guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
      for (const record of leavingRecords) {
        record.leaveGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards).then(() => {
        guards = [];
        for (const guard of beforeGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
        for (const record of updatingRecords) {
          record.updateGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = [];
        for (const record of to.matched) {
          if (record.beforeEnter && !from.matched.includes(record)) {
            if (Array.isArray(record.beforeEnter)) {
              for (const beforeEnter of record.beforeEnter)
                guards.push(guardToPromiseFn(beforeEnter, to, from));
            } else {
              guards.push(guardToPromiseFn(record.beforeEnter, to, from));
            }
          }
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        to.matched.forEach((record) => record.enterCallbacks = {});
        guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = [];
        for (const guard of beforeResolveGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
    }
    function triggerAfterEach(to, from, failure) {
      for (const guard of afterGuards.list())
        guard(to, from, failure);
    }
    function finalizeNavigation(toLocation, from, isPush, replace2, data2) {
      const error = checkCanceledNavigation(toLocation, from);
      if (error)
        return error;
      const isFirstNavigation = from === START_LOCATION_NORMALIZED;
      const state = !isBrowser ? {} : history.state;
      if (isPush) {
        if (replace2 || isFirstNavigation)
          routerHistory.replace(toLocation.fullPath, assign({
            scroll: isFirstNavigation && state && state.scroll
          }, data2));
        else
          routerHistory.push(toLocation.fullPath, data2);
      }
      currentRoute.value = toLocation;
      handleScroll(toLocation, from, isPush, isFirstNavigation);
      markAsReady();
    }
    let removeHistoryListener;
    function setupListeners() {
      if (removeHistoryListener)
        return;
      removeHistoryListener = routerHistory.listen((to, _from, info) => {
        const toLocation = resolve2(to);
        const shouldRedirect = handleRedirectRecord(toLocation);
        if (shouldRedirect) {
          pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
          return;
        }
        pendingLocation = toLocation;
        const from = currentRoute.value;
        if (isBrowser) {
          saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
        }
        navigate(toLocation, from).catch((error) => {
          if (isNavigationFailure(error, 4 | 8)) {
            return error;
          }
          if (isNavigationFailure(error, 2)) {
            pushWithRedirect(error.to, toLocation).then((failure) => {
              if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
                routerHistory.go(-1, false);
              }
            }).catch(noop);
            return Promise.reject();
          }
          if (info.delta)
            routerHistory.go(-info.delta, false);
          return triggerError(error, toLocation, from);
        }).then((failure) => {
          failure = failure || finalizeNavigation(toLocation, from, false);
          if (failure) {
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
              routerHistory.go(-1, false);
            }
          }
          triggerAfterEach(toLocation, from, failure);
        }).catch(noop);
      });
    }
    let readyHandlers = useCallbacks();
    let errorHandlers = useCallbacks();
    let ready;
    function triggerError(error, to, from) {
      markAsReady(error);
      const list = errorHandlers.list();
      if (list.length) {
        list.forEach((handler) => handler(error, to, from));
      } else {
        console.error(error);
      }
      return Promise.reject(error);
    }
    function isReady() {
      if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
        return Promise.resolve();
      return new Promise((resolve3, reject) => {
        readyHandlers.add([resolve3, reject]);
      });
    }
    function markAsReady(err) {
      if (!ready) {
        ready = !err;
        setupListeners();
        readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
        readyHandlers.reset();
      }
      return err;
    }
    function handleScroll(to, from, isPush, isFirstNavigation) {
      const { scrollBehavior } = options;
      if (!isBrowser || !scrollBehavior)
        return Promise.resolve();
      const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
      return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
    }
    const go = (delta) => routerHistory.go(delta);
    let started;
    const installedApps = /* @__PURE__ */ new Set();
    const router2 = {
      currentRoute,
      addRoute,
      removeRoute,
      hasRoute,
      getRoutes,
      resolve: resolve2,
      options,
      push,
      replace,
      go,
      back: () => go(-1),
      forward: () => go(1),
      beforeEach: beforeGuards.add,
      beforeResolve: beforeResolveGuards.add,
      afterEach: afterGuards.add,
      onError: errorHandlers.add,
      isReady,
      install(app2) {
        const router3 = this;
        app2.component("RouterLink", RouterLink);
        app2.component("RouterView", RouterView);
        app2.config.globalProperties.$router = router3;
        Object.defineProperty(app2.config.globalProperties, "$route", {
          enumerable: true,
          get: () => unref(currentRoute)
        });
        if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
          started = true;
          push(routerHistory.location).catch((err) => {
          });
        }
        const reactiveRoute = {};
        for (const key in START_LOCATION_NORMALIZED) {
          reactiveRoute[key] = computed(() => currentRoute.value[key]);
        }
        app2.provide(routerKey, router3);
        app2.provide(routeLocationKey, reactive(reactiveRoute));
        app2.provide(routerViewLocationKey, currentRoute);
        const unmountApp = app2.unmount;
        installedApps.add(app2);
        app2.unmount = function() {
          installedApps.delete(app2);
          if (installedApps.size < 1) {
            pendingLocation = START_LOCATION_NORMALIZED;
            removeHistoryListener && removeHistoryListener();
            removeHistoryListener = null;
            currentRoute.value = START_LOCATION_NORMALIZED;
            started = false;
            ready = false;
          }
          unmountApp();
        };
      }
    };
    return router2;
  }
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
  }
  function extractChangingRecords(to, from) {
    const leavingRecords = [];
    const updatingRecords = [];
    const enteringRecords = [];
    const len = Math.max(from.matched.length, to.matched.length);
    for (let i = 0; i < len; i++) {
      const recordFrom = from.matched[i];
      if (recordFrom) {
        if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
          updatingRecords.push(recordFrom);
        else
          leavingRecords.push(recordFrom);
      }
      const recordTo = to.matched[i];
      if (recordTo) {
        if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
          enteringRecords.push(recordTo);
        }
      }
    }
    return [leavingRecords, updatingRecords, enteringRecords];
  }
  var deliverySvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/delivery.svg";
  const _sfc_main$G = {
    name: "Locate",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      deliverySvgIcon() {
        return `${getStaticUrl(deliverySvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$D = ["src", "alt"];
  function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.deliverySvgIcon,
      alt: $options.deliverySvgIcon
    }, null, 8, _hoisted_1$D);
  }
  var Locate = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$G]]);
  const _sfc_main$F = {
    name: "Edit",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$C = ["role", "aria-label"];
  const _hoisted_2$w = /* @__PURE__ */ createBaseVNode("path", {
    d: "M2.73188 12C2.76938 12 2.80688 11.9963 2.84438 11.9906L5.99813 11.4375C6.03563 11.43 6.07125 11.4131 6.0975 11.385L14.0456 3.43687C14.063 3.41953 14.0768 3.39892 14.0862 3.37624C14.0956 3.35356 14.1005 3.32924 14.1005 3.30469C14.1005 3.28013 14.0956 3.25582 14.0862 3.23313C14.0768 3.21045 14.063 3.18985 14.0456 3.1725L10.9294 0.054375C10.8938 0.01875 10.8469 0 10.7963 0C10.7456 0 10.6988 0.01875 10.6631 0.054375L2.715 8.0025C2.68687 8.03063 2.67 8.06437 2.6625 8.10187L2.10938 11.2556C2.09113 11.3561 2.09765 11.4594 2.12836 11.5568C2.15907 11.6542 2.21305 11.7426 2.28562 11.8144C2.40937 11.9344 2.565 12 2.73188 12V12ZM3.99563 8.73L10.7963 1.93125L12.1706 3.30562L5.37 10.1044L3.70313 10.3987L3.99563 8.73V8.73ZM14.4 13.575H0.6C0.268125 13.575 0 13.8431 0 14.175V14.85C0 14.9325 0.0675 15 0.15 15H14.85C14.9325 15 15 14.9325 15 14.85V14.175C15 13.8431 14.7319 13.575 14.4 13.575Z",
    fill: "#25303B"
  }, null, -1);
  const _hoisted_3$q = [
    _hoisted_2$w
  ];
  function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "15",
      height: "15",
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$q, 12, _hoisted_1$C);
  }
  var Edit = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$F]]);
  var AmericanExpress = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/AmericanExpress.svg";
  var ClearPay = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/ClearPay.svg";
  var Klarna = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/Klarna.svg";
  var MasterCard = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/MasterCard.svg";
  var Visa = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/Visa.svg";
  const _sfc_main$E = {
    name: "PayWith",
    components: {
      TextField
    },
    data() {
      return {
        payWithText: "",
        payWithTextId: "gene-bettercheckout-paywith-text"
      };
    },
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      background: {
        type: String
      },
      isExpressPaymentsVisible: {
        type: Boolean
      }
    },
    computed: {
      icons() {
        return [
          { icon: `${getStaticUrl(MasterCard)}` },
          { icon: `${getStaticUrl(Visa)}` },
          { icon: `${getStaticUrl(AmericanExpress)}` },
          { icon: `${getStaticUrl(Klarna)}` },
          { icon: `${getStaticUrl(ClearPay)}` }
        ];
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          background: reactiveProps.background,
          width: reactiveProps.width,
          height: reactiveProps.height
        }))
      };
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.payWithText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.payWithTextId]) || this.$t("payWithBlockTitle");
      document.addEventListener(this.payWithTextId, this.setPayWithText);
    },
    unmounted() {
      document.removeEventListener(this.payWithTextId, this.setPayWithText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setPayWithText(event) {
        this.payWithText = (event == null ? void 0 : event.detail) || this.$t("payWithBlockTitle");
      }
    }
  };
  const _hoisted_1$B = { class: "pay-with__column" };
  const _hoisted_2$v = ["src", "alt"];
  function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", {
      style: normalizeStyle($setup.style),
      class: "pay-with__container"
    }, [
      $props.isExpressPaymentsVisible ? (openBlock(), createBlock(_component_TextField, {
        key: 0,
        class: "pay-with__message",
        text: $data.payWithText
      }, null, 8, ["text"])) : (openBlock(), createBlock(_component_TextField, {
        key: 1,
        class: "pay-with__message",
        text: _ctx.$t("payNoExpressWithBlockTitle")
      }, null, 8, ["text"])),
      createBaseVNode("ul", _hoisted_1$B, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.icons, (icon, index) => {
          return openBlock(), createElementBlock("li", {
            class: "pay-with__content",
            key: index
          }, [
            createBaseVNode("img", {
              src: icon.icon,
              alt: icon.icon
            }, null, 8, _hoisted_2$v)
          ]);
        }), 128))
      ])
    ], 4);
  }
  var PayWith = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$E], ["__scopeId", "data-v-0f3f9196"]]);
  const _sfc_main$D = {
    name: "DividerComponent",
    components: {
      TextField
    }
  };
  const _withScopeId$3 = (n) => (pushScopeId("data-v-461b6a22"), n = n(), popScopeId(), n);
  const _hoisted_1$A = { class: "divider" };
  const _hoisted_2$u = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_3$p = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", _hoisted_1$A, [
      _hoisted_2$u,
      createVNode(_component_TextField, {
        text: _ctx.$t("dividerText"),
        "font-size": "18px",
        "font-weight": "400"
      }, null, 8, ["text"]),
      _hoisted_3$p
    ]);
  }
  var DividerComponent = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$D], ["__scopeId", "data-v-461b6a22"]]);
  const findUrl = "https://services.postcodeanywhere.co.uk/Capture/Interactive/Find/v1.00/json3.ws";
  const retrieveUrl = "https://services.postcodeanywhere.co.uk/Capture/Interactive/Retrieve/v1.00/json3.ws";
  let request2 = null;
  var loqate = {
    cancel() {
      request2.cancel();
      this.clearOldRequest();
    },
    clearOldRequest() {
      request2 = null;
    },
    getSuggestions(containerQuery, query, addressType) {
      var _a;
      const { countryCode, loqate: loqate2 } = useConfigStore();
      const { selected } = useCustomerStore();
      if (request2)
        this.cancel();
      const axiosSource = axios.CancelToken.source();
      request2 = { cancel: axiosSource.cancel, msg: "Loading..." };
      const container = containerQuery ? `&Container=${containerQuery}` : "";
      const loqateCountry = ((_a = selected[addressType]) == null ? void 0 : _a.country_id) || countryCode;
      const requestUrl = `${findUrl}?key=${loqate2.apiKey}&Countries=${loqateCountry}&Limit=10&Text=${query}${container}`;
      return axios.get(requestUrl, { cancelToken: axiosSource.token }).then((response) => {
        this.clearOldRequest();
        return response.data.Items;
      }).catch(this.logResponseErrors);
    },
    logResponseErrors(error) {
      if (axios.isCancel(error))
        console.log("Loqate request cancelled");
    },
    getAndUseAddress(id) {
      const { loqate: loqate2 } = useConfigStore();
      return axios.get(`${retrieveUrl}?key=${loqate2.apiKey}&Id=${id}`).then((response) => {
        if (typeof response.data.Items[0].Error !== "string") {
          return response.data.Items[0];
        }
        return handleError({ error: { message: response.data.Items[0].Error } });
      });
    }
  };
  const _sfc_main$C = {
    name: "AddressBlock",
    props: {
      address_type: {
        type: String,
        default: "shipping"
      },
      address: {
        default: {
          street: ["", ""],
          city: "",
          region: "",
          country_id: "",
          postcode: "",
          company: "",
          telephone: "",
          firstname: "",
          lastname: ""
        }
      },
      showNameFields: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      showRegion() {
        const { region } = this.address;
        return region && typeof region === "string";
      }
    }
  };
  const _hoisted_1$z = { class: "address-block__address" };
  const _hoisted_2$t = { key: 0 };
  const _hoisted_3$o = { key: 1 };
  function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$z, [
      createBaseVNode("div", null, [
        $props.showNameFields ? (openBlock(), createElementBlock("p", _hoisted_2$t, toDisplayString$1($props.address.firstname) + " " + toDisplayString$1($props.address.lastname), 1)) : createCommentVNode("", true),
        createBaseVNode("p", null, toDisplayString$1($props.address.street[0]), 1),
        createBaseVNode("p", null, [
          $props.address.street[1] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString$1($props.address.street[1]), 1)
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("p", null, toDisplayString$1($props.address.city), 1),
        createBaseVNode("p", null, [
          $options.showRegion ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString$1($props.address.region), 1)
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("p", null, toDisplayString$1($props.address.postcode), 1),
        $props.showNameFields ? (openBlock(), createElementBlock("p", _hoisted_3$o, toDisplayString$1($props.address.telephone), 1)) : createCommentVNode("", true)
      ])
    ]);
  }
  var AddressBlock = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$C], ["__scopeId", "data-v-14c9605f"]]);
  const _sfc_main$B = {
    name: "Remove",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$y = ["role", "aria-label"];
  const _hoisted_2$s = /* @__PURE__ */ createBaseVNode("circle", {
    cx: "9",
    cy: "9",
    r: "8",
    stroke: "#343434",
    "stroke-width": "2"
  }, null, -1);
  const _hoisted_3$n = /* @__PURE__ */ createBaseVNode("path", {
    d: "M15 15L21.5 21.5",
    stroke: "#343434",
    "stroke-width": "2",
    "stroke-linecap": "round"
  }, null, -1);
  const _hoisted_4$h = [
    _hoisted_2$s,
    _hoisted_3$n
  ];
  function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "23",
      height: "23",
      viewBox: "0 0 23 23",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_4$h, 12, _hoisted_1$y);
  }
  var Search = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$B]]);
  const _sfc_main$A = {
    name: "LoqateAddress",
    components: {
      AddressBlock,
      TextInput,
      TextField,
      Search,
      Edit,
      MyButton
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    data() {
      return {
        query: "",
        addressList: [],
        arrowCounter: -1,
        address: false,
        request: null
      };
    },
    computed: {
      ...mapWritableState(useCustomerStore, ["selected"]),
      ...mapState(useConfigStore, ["countryCode", "stateRequired", "countries"])
    },
    async mounted() {
      await this.getLoqateConfiguration();
    },
    methods: {
      ...mapActions(useConfigStore, ["getLoqateConfiguration", "getRegionsByCountry"]),
      ...mapActions(useCustomerStore, [
        "setAddress",
        "validateAddress",
        "validatePostcode",
        "updateRegionRequired"
      ]),
      editAddress() {
        this.address = false;
      },
      resetAddressData() {
        this.addressList = [];
        this.arrowCounter = -1;
        this.address = false;
      },
      getSuggestions(containerQuery) {
        this.resetAddressData();
        loqate.getSuggestions(containerQuery, this.query, this.address_type).then((addresses) => {
          this.addressList = addresses;
        });
      },
      selectSuggestion(item) {
        this.arrowCounter = -1;
        this.addressList = [];
        if (item.Type === "Address") {
          loqate.getAndUseAddress(item.Id).then(this.updateAddress);
          this.displayResults = false;
        } else {
          this.query = item.Text;
          loqate.getSuggestions(item.Id, this.query).then((addresses) => {
            this.addressList = addresses;
          });
        }
      },
      onBlur(event) {
        if (!event.relatedTarget || !event.relatedTarget.classList.contains("afd-postcode__action")) {
          this.displayResults = false;
        }
      },
      onFocus() {
        this.displayResults = true;
      },
      onArrowDown() {
        if (this.arrowCounter < this.addressList.length) {
          this.arrowCounter += 1;
        }
      },
      onArrowUp() {
        if (this.arrowCounter > 0) {
          this.arrowCounter -= 1;
        }
      },
      onEnter() {
        this.selectSuggestion(this.addressList[this.arrowCounter]);
      },
      getResultsCount() {
        return this.addressList && this.addressList.length;
      },
      updateAddress(address) {
        let countryCode = "";
        if (address.CountryIso2 === "GG" || address.CountryIso2 === "IM" || address.CountryIso2 === "JE") {
          countryCode = this.countryCode;
        } else {
          countryCode = address.CountryIso2;
        }
        const availableRegions = this.getRegionsByCountry(countryCode);
        const region = availableRegions.length && availableRegions.find((rgin) => rgin.option.name === address.PostalCounty || rgin.option.name === address.ProvinceName);
        const newAddress = {
          id: "custom",
          company: address.Company,
          street: [address.Line1, address.Line2],
          city: address.City,
          country_id: countryCode,
          region: region ? region.option.name : address.ProvinceName,
          region_id: region ? region.option.value : 0,
          postcode: address.PostalCode
        };
        this.setAddress(newAddress, this.address_type);
        this.updateRegionRequired(this.address_type);
        const isValid = this.validateAddress(this.address_type, true) && this.validatePostcode(this.address_type, true);
        if (!isValid) {
          this.setEditing(this.address_type, true);
        }
      }
    }
  };
  const _hoisted_1$x = { class: "loqate__container" };
  const _hoisted_2$r = { class: "loqate__field" };
  const _hoisted_3$m = {
    key: 0,
    class: "loqate__results"
  };
  const _hoisted_4$g = ["onClick"];
  const _hoisted_5$e = {
    key: 0,
    class: "address-block"
  };
  const _hoisted_6$8 = { class: "address-block__item" };
  function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_Search = resolveComponent("Search");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_Edit = resolveComponent("Edit");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$x, [
        createVNode(_component_TextField, {
          class: "loqate__title",
          text: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.title"),
          "font-size": "16px",
          "font-weight": "500"
        }, null, 8, ["text"]),
        createBaseVNode("div", _hoisted_2$r, [
          createVNode(_component_TextInput, {
            id: "loqate",
            modelValue: $data.query,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.query = $event),
            type: "text",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.label"),
            class: "loqate__input",
            autocomplete: "postal-code",
            onBlur: $options.onBlur,
            onFocus: $options.onFocus,
            onInput: $options.getSuggestions,
            onKeydown: [
              withKeys($options.onArrowDown, ["down"]),
              withKeys($options.onArrowUp, ["up"]),
              withKeys($options.onEnter, ["enter"])
            ]
          }, null, 8, ["modelValue", "placeholder", "label", "onBlur", "onFocus", "onInput", "onKeydown"]),
          createVNode(_component_Search, { stroke: "black" })
        ]),
        $options.getResultsCount() > 0 ? (openBlock(), createElementBlock("ul", _hoisted_3$m, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.addressList, (item, i) => {
            return openBlock(), createElementBlock("li", {
              key: i,
              class: normalizeClass([{ "locate__suggestion--active": i === $data.arrowCounter }, "loqate__result"])
            }, [
              createBaseVNode("button", {
                tabindex: "-1",
                type: "button",
                class: "loqate__action",
                onClick: ($event) => {
                  $options.selectSuggestion(item);
                }
              }, toDisplayString$1(item.Text) + " - " + toDisplayString$1(item.Description), 9, _hoisted_4$g)
            ], 2);
          }), 128))
        ])) : createCommentVNode("", true)
      ]),
      $data.address ? (openBlock(), createElementBlock("div", _hoisted_5$e, [
        createBaseVNode("div", _hoisted_6$8, [
          createBaseVNode("article", null, [
            createVNode(_component_AddressBlock, {
              address_type: $props.address_type,
              address: $data.address
            }, null, 8, ["address_type", "address"])
          ])
        ]),
        createBaseVNode("div", {
          class: "address-block__edit",
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"])),
          onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"]))
        }, [
          createVNode(_component_Edit),
          createVNode(_component_MyButton, {
            label: _ctx.$t("yourDetailsSection.editButton"),
            secondary: ""
          }, null, 8, ["label"])
        ], 32)
      ])) : createCommentVNode("", true)
    ], 64);
  }
  var Loqate = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$A], ["__scopeId", "data-v-a970ae7c"]]);
  const _sfc_main$z = {
    name: "AddressFormName",
    components: {
      TextInput,
      TextField
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    emits: [
      "isCustomerInfoFull"
    ],
    setup() {
      const customerStore = useCustomerStore();
      return {
        getAddressFieldHasError: customerStore.getAddressFieldHasError
      };
    },
    computed: {
      ...mapWritableState(useCustomerStore, ["selected"])
    },
    mounted() {
      this.validateFields();
    },
    updated() {
      this.validateFields();
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "validateNameField",
        "validatePhone"
      ]),
      validateFields() {
        const type = this.address_type;
        const first = this.validateNameField(type, "First name", this.selected[type].firstname);
        const last = this.validateNameField(type, "Last name", this.selected[type].lastname);
        const phone = this.validatePhone(type, this.selected[type].telephone);
        const fullDetails = first && last && phone;
        this.$emit("isCustomerInfoFull", fullDetails);
      },
      phoneChange(event) {
        if (event.key === "Enter") {
          this.validatePhone(this.address_type, this.selected[this.address_type].telephone, true);
        }
      },
      textChange(event, type) {
        if (event.key === "Enter") {
          this.validateNameField(this.address_type, type, this.selected[this.address_type][type]);
        }
      }
    }
  };
  const _hoisted_1$w = { class: "phone-field" };
  function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextInput = resolveComponent("TextInput");
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(_component_TextInput, {
        modelValue: _ctx.selected[$props.address_type].firstname,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selected[$props.address_type].firstname = $event),
        identifier: `${$props.address_type}-first-name`,
        label: _ctx.$t("yourDetailsSection.firstName.label"),
        placeholder: _ctx.$t("yourDetailsSection.firstName.placeholder"),
        error: $setup.getAddressFieldHasError($props.address_type, "First name"),
        "error-message": $setup.getAddressFieldHasError($props.address_type, "First name") ? _ctx.$t("errorMessages.firstNameErrorMessage") : "",
        type: "text",
        required: "",
        autocomplete: "given-name",
        onKeyup: _cache[1] || (_cache[1] = ($event) => $options.textChange("First name")),
        onFocusout: _cache[2] || (_cache[2] = ($event) => _ctx.validateNameField($props.address_type, "First name", _ctx.selected[$props.address_type].firstname, true))
      }, null, 8, ["modelValue", "identifier", "label", "placeholder", "error", "error-message"]),
      createVNode(_component_TextInput, {
        modelValue: _ctx.selected[$props.address_type].lastname,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.selected[$props.address_type].lastname = $event),
        identifier: `${$props.address_type}-last-name`,
        label: _ctx.$t("yourDetailsSection.lastName.label"),
        placeholder: _ctx.$t("yourDetailsSection.lastName.placeholder"),
        error: $setup.getAddressFieldHasError($props.address_type, "Last name"),
        "error-message": $setup.getAddressFieldHasError($props.address_type, "Last name") ? _ctx.$t("errorMessages.lastNameErrorMessage") : "",
        type: "text",
        required: "",
        autocomplete: "family-name",
        onKeyup: _cache[4] || (_cache[4] = ($event) => $options.textChange("Last name")),
        onFocusout: _cache[5] || (_cache[5] = ($event) => _ctx.validateNameField($props.address_type, "Last name", _ctx.selected[$props.address_type].lastname, true))
      }, null, 8, ["modelValue", "identifier", "label", "placeholder", "error", "error-message"]),
      createBaseVNode("div", _hoisted_1$w, [
        createVNode(_component_TextInput, {
          modelValue: _ctx.selected[$props.address_type].telephone,
          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.selected[$props.address_type].telephone = $event),
          error: $setup.getAddressFieldHasError($props.address_type, "Telephone"),
          "error-message": $setup.getAddressFieldHasError($props.address_type, "Telephone") ? _ctx.$t("errorMessages.phoneErrorMessage") : "",
          identifier: `${$props.address_type}-phone`,
          type: "tel",
          label: _ctx.$t("yourDetailsSection.phoneField.label"),
          placeholder: _ctx.$t("yourDetailsSection.phoneField.placeholder"),
          required: "",
          autocomplete: "tel",
          onKeyup: $options.phoneChange,
          onFocusout: _cache[7] || (_cache[7] = ($event) => _ctx.validatePhone($props.address_type, _ctx.selected[$props.address_type].telephone, true))
        }, null, 8, ["modelValue", "error", "error-message", "identifier", "label", "placeholder", "onKeyup"]),
        !_ctx.phoneErrorClass ? (openBlock(), createBlock(_component_TextField, {
          key: 0,
          text: _ctx.$t("yourDetailsSection.phoneField.infoMessage"),
          "font-weight": "300"
        }, null, 8, ["text"])) : createCommentVNode("", true)
      ])
    ], 64);
  }
  var NameFields = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$z]]);
  const _sfc_main$y = {
    name: "SelectInput",
    components: {
      ArrowDown
    },
    props: {
      error: {
        type: Boolean
      },
      label: {
        type: String
      },
      modelValue: {
        type: String || Number,
        default: ""
      },
      name: {
        type: String
      },
      selectedOption: {
        type: String || Number
      },
      identifier: {
        type: String
      },
      options: {
        type: Array,
        default() {
          return [
            {
              option: {
                name: "First",
                value: "1"
              }
            },
            {
              option: {
                name: "Second",
                value: "2"
              }
            }
          ];
        }
      },
      dataRole: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        classes: computed(() => ({
          error: reactiveProps.error
        }))
      };
    }
  };
  const _hoisted_1$v = { class: "select-input" };
  const _hoisted_2$q = ["for"];
  const _hoisted_3$l = ["id", "name", "data-role", "disabled", "value"];
  const _hoisted_4$f = {
    value: "",
    disabled: "",
    selected: ""
  };
  const _hoisted_5$d = ["value"];
  function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ArrowDown = resolveComponent("ArrowDown");
    return openBlock(), createElementBlock("div", _hoisted_1$v, [
      createBaseVNode("label", {
        for: $props.identifier,
        class: normalizeClass($setup.classes)
      }, [
        createBaseVNode("span", null, toDisplayString$1($props.label), 1),
        createBaseVNode("select", {
          id: $props.identifier,
          name: $props.name,
          "data-role": $props.dataRole,
          disabled: $props.disabled,
          value: $props.modelValue,
          onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event.target.value))
        }, [
          createBaseVNode("option", _hoisted_4$f, toDisplayString$1($props.selectedOption), 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options, (option, index) => {
            return openBlock(), createElementBlock("option", {
              value: option.option.value,
              key: index
            }, toDisplayString$1(option.option.name), 9, _hoisted_5$d);
          }), 128))
        ], 40, _hoisted_3$l),
        createVNode(_component_ArrowDown)
      ], 10, _hoisted_2$q)
    ]);
  }
  var SelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$y], ["__scopeId", "data-v-2ab401c7"]]);
  const _sfc_main$x = {
    name: "AddressForm",
    components: {
      TextField,
      TextInput,
      SelectInput,
      MyButton,
      ErrorMessage
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    setup() {
      const customerStore = useCustomerStore();
      return {
        getAddressFieldHasError: customerStore.getAddressFieldHasError,
        getRegionOptions: customerStore.getRegionOptions,
        getRegionRequired: customerStore.getRegionRequired
      };
    },
    data() {
      return {
        buttonEnabled: false,
        requiredErrorMessage: ""
      };
    },
    computed: {
      ...mapWritableState(useCustomerStore, ["selected", "isLoggedIn"]),
      ...mapState(useConfigStore, [
        "countries",
        "stateRequired",
        "displayState",
        "countryCode",
        "optionalZipCountries",
        "postcodeRequired"
      ]),
      selectOptions() {
        return this.countries.map((country) => ({
          option: {
            name: country.full_name_locale,
            value: country.id
          }
        }));
      }
    },
    async created() {
      this.setupCountry();
      this.updateRegionRequired(this.address_type);
      const customerStore = useCustomerStore();
      customerStore.$subscribe((mutation) => {
        if (mutation.type === "direct" || mutation.type === "patch object" && mutation.payload.selected && mutation.payload.selected[this.address_type]) {
          this.updateButtonState();
        }
      });
      this.updateButtonState();
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "validateAddress",
        "setAddressAsCustom",
        "setAddress",
        "setEditing",
        "addAddressError",
        "removeAddressError",
        "updateRegionRequired",
        "validateNameField",
        "validatePhone",
        "validatePostcode"
      ]),
      validateAndSave() {
        this.requiredErrorMessage = "";
        const isValid = this.validateAddress(this.address_type, true) && this.validatePostcode(this.address_type, true);
        if (isValid) {
          this.setAddressAsCustom(this.address_type);
          this.setEditing(this.address_type, false);
          if (this.address_type === "shipping" && this.selected.billing.same_as_shipping) {
            const clonedShipping = deepClone(this.selected.shipping);
            this.setAddress(clonedShipping, "billing");
          }
        } else {
          const fieldErrors = this.selected.formErrors[this.address_type];
          Object.entries(fieldErrors).forEach(([value]) => {
            this.addAddressError(this.address_type, value);
          });
          this.requiredErrorMessage = this.selected.formErrors.message[this.address_type];
        }
      },
      setupCountry() {
        if (!this.selected[this.address_type].country_id) {
          this.selected[this.address_type].country_id = this.countryCode;
        }
      },
      countryUpdated() {
        this.updateRegionRequired(this.address_type);
        this.validatePostcode(this.address_type, true);
      },
      setRegion(event) {
        const availableRegions = this.getRegionOptions(this.address_type);
        if (availableRegions.length) {
          const regionId = parseInt(event.target.value, 10);
          const region = availableRegions.find((rgion) => rgion.option.value === regionId);
          if (region) {
            this.selected[this.address_type].region = region.option.name;
          } else {
            this.selected[this.address_type].region = "";
            this.selected[this.address_type].region_id = 0;
          }
        }
      },
      validateStreet(text) {
        let hasError = !text || typeof text === "string" && !text.trim();
        if (!hasError) {
          const streetAddress1 = this.selected[this.address_type].street[0];
          const streetAddress2 = this.selected[this.address_type].street[1];
          hasError = [streetAddress1, streetAddress2].join(" ").length > 75;
        }
        hasError ? this.addAddressError(this.address_type, "Address Line 1") : this.removeAddressError(this.address_type, "Address Line 1");
      },
      validateStreet2(text) {
        const streetAddress1 = this.selected[this.address_type].street[0];
        const streetAddress2 = this.selected[this.address_type].street[1];
        const hasError = text && [streetAddress1, streetAddress2].join(" ").length > 75;
        hasError ? this.addAddressError(this.address_type, "Address Line 2") : this.removeAddressError(this.address_type, "Address Line 2");
      },
      validateCity(text) {
        const hasError = !text || typeof text === "string" && !text.trim();
        hasError ? this.addAddressError(this.address_type, "City") : this.removeAddressError(this.address_type, "City");
      },
      validateRegion(text) {
        if (this.getRegionRequired(this.address_type)) {
          const hasError = !text || typeof text === "string" && !text.trim();
          hasError ? this.addAddressError(this.address_type, "State/Region") : this.removeAddressError(this.address_type, "State/Region");
        }
      },
      updateButtonState() {
        const addressType = this.address_type;
        const areNamesValid = addressType !== "billing" || this.validateNameField(addressType, "First name", this.selected[addressType].firstname) && this.validateNameField(addressType, "First name", this.selected[addressType].firstname) && this.validatePhone(addressType, this.selected[addressType].telephone);
        this.buttonEnabled = this.validateAddress(addressType) && this.validatePostcode(this.address_type) && areNamesValid;
      }
    }
  };
  const _hoisted_1$u = { class: "address-form" };
  const _hoisted_2$p = { class: "address-form-fields" };
  const _hoisted_3$k = {
    key: 5,
    class: "save-address-field"
  };
  const _hoisted_4$e = ["for"];
  const _hoisted_5$c = ["id"];
  function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextInput = resolveComponent("TextInput");
    const _component_SelectInput = resolveComponent("SelectInput");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_TextField = resolveComponent("TextField");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock("div", _hoisted_1$u, [
      createBaseVNode("div", _hoisted_2$p, [
        createBaseVNode("form", {
          autocomplete: "on",
          onSubmit: _cache[19] || (_cache[19] = withModifiers(($event) => $options.validateAndSave(), ["prevent"]))
        }, [
          createVNode(_component_TextInput, {
            modelValue: _ctx.selected[$props.address_type].street[0],
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selected[$props.address_type].street[0] = $event),
            type: "text",
            error: $setup.getAddressFieldHasError($props.address_type, "Address Line 1"),
            "error-message": $setup.getAddressFieldHasError($props.address_type, "Address Line 1") ? _ctx.$t("errorMessages.streetErrorMessage") : "",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.addressField.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.addressField.label"),
            required: "",
            onInput: _cache[1] || (_cache[1] = ($event) => ($options.validateStreet(_ctx.selected[$props.address_type].street[0]), $options.validateStreet2(_ctx.selected[$props.address_type].street[1]))),
            onFocusout: _cache[2] || (_cache[2] = ($event) => ($options.validateStreet(_ctx.selected[$props.address_type].street[0]), $options.validateStreet2(_ctx.selected[$props.address_type].street[1])))
          }, null, 8, ["modelValue", "error", "error-message", "placeholder", "label"]),
          createVNode(_component_TextInput, {
            modelValue: _ctx.selected[$props.address_type].street[1],
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.selected[$props.address_type].street[1] = $event),
            type: "text",
            error: $setup.getAddressFieldHasError($props.address_type, "Address Line 2"),
            "error-message": $setup.getAddressFieldHasError($props.address_type, "Address Line 2") ? _ctx.$t("errorMessages.streetErrorMessage") : "",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.addressField.unrequired"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.addressField.unrequiredLabel"),
            onInput: _cache[4] || (_cache[4] = ($event) => ($options.validateStreet(_ctx.selected[$props.address_type].street[0]), $options.validateStreet2(_ctx.selected[$props.address_type].street[1]))),
            onFocusout: _cache[5] || (_cache[5] = ($event) => ($options.validateStreet(_ctx.selected[$props.address_type].street[0]), $options.validateStreet2(_ctx.selected[$props.address_type].street[1])))
          }, null, 8, ["modelValue", "error", "error-message", "placeholder", "label"]),
          createVNode(_component_TextInput, {
            modelValue: _ctx.selected[$props.address_type].city,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.selected[$props.address_type].city = $event),
            type: "text",
            error: $setup.getAddressFieldHasError($props.address_type, "City"),
            "error-message": $setup.getAddressFieldHasError($props.address_type, "City") ? _ctx.$t("errorMessages.cityErrorMessage") : "",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.cityField.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.cityField.label"),
            required: "",
            onInput: _cache[7] || (_cache[7] = ($event) => $options.validateCity(_ctx.selected[$props.address_type].city)),
            onFocusout: _cache[8] || (_cache[8] = ($event) => $options.validateCity(_ctx.selected[$props.address_type].city))
          }, null, 8, ["modelValue", "error", "error-message", "placeholder", "label"]),
          _ctx.displayState && !$setup.getRegionOptions($props.address_type).length ? (openBlock(), createBlock(_component_TextInput, {
            key: 0,
            modelValue: _ctx.selected[$props.address_type].region,
            "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.selected[$props.address_type].region = $event),
            type: "text",
            error: $setup.getAddressFieldHasError($props.address_type, "State/Region"),
            "error-message": $setup.getAddressFieldHasError($props.address_type, "State/Region") ? _ctx.$t("errorMessages.regionErrorMessage") : "",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.regionField.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.regionField.label"),
            required: $setup.getRegionRequired($props.address_type),
            onFocusout: _cache[10] || (_cache[10] = ($event) => $options.validateRegion(_ctx.selected[$props.address_type].region))
          }, null, 8, ["modelValue", "error", "error-message", "placeholder", "label", "required"])) : createCommentVNode("", true),
          _ctx.displayState && $setup.getRegionOptions($props.address_type).length ? (openBlock(), createBlock(_component_SelectInput, {
            key: 1,
            modelValue: _ctx.selected[$props.address_type].region_id,
            "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => _ctx.selected[$props.address_type].region_id = $event),
            options: $setup.getRegionOptions($props.address_type),
            error: $setup.getAddressFieldHasError($props.address_type, "State/Region"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.regionField.label"),
            required: $setup.getRegionRequired($props.address_type),
            onChange: _cache[12] || (_cache[12] = ($event) => $options.setRegion($event))
          }, null, 8, ["modelValue", "options", "error", "label", "required"])) : createCommentVNode("", true),
          createVNode(_component_TextInput, {
            modelValue: _ctx.selected[$props.address_type].postcode,
            "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => _ctx.selected[$props.address_type].postcode = $event),
            error: $setup.getAddressFieldHasError($props.address_type, "Postcode"),
            type: "text",
            autocomplete: "postal-code",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.postCodeField.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.postCodeField.label"),
            required: _ctx.postcodeRequired(_ctx.selected[$props.address_type].country_id),
            onInput: _cache[14] || (_cache[14] = ($event) => _ctx.validatePostcode($props.address_type, true)),
            onFocusout: _cache[15] || (_cache[15] = ($event) => _ctx.validatePostcode($props.address_type, true))
          }, null, 8, ["modelValue", "error", "placeholder", "label", "required"]),
          $setup.getAddressFieldHasError($props.address_type, "Postcode") ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 2,
            message: `${_ctx.$t("errorMessages.postCodeErrorMessage")} ${_ctx.selected[$props.address_type].country_id}`
          }, null, 8, ["message"])) : createCommentVNode("", true),
          createVNode(_component_SelectInput, {
            modelValue: _ctx.selected[$props.address_type].country_id,
            "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.selected[$props.address_type].country_id = $event),
            options: $options.selectOptions,
            error: $setup.getAddressFieldHasError($props.address_type, "Country"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.countryField.label"),
            "selected-option": _ctx.$t("yourDetailsSection.selectPlaceholder"),
            required: "",
            onChange: _cache[17] || (_cache[17] = ($event) => $options.countryUpdated($event))
          }, null, 8, ["modelValue", "options", "error", "label", "selected-option"]),
          $setup.getAddressFieldHasError($props.address_type, "Country") ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 3,
            message: _ctx.$t("errorMessages.countryErrorMessage")
          }, null, 8, ["message"])) : createCommentVNode("", true),
          $data.requiredErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 4,
            message: $data.requiredErrorMessage
          }, null, 8, ["message"])) : createCommentVNode("", true),
          _ctx.isLoggedIn ? (openBlock(), createElementBlock("div", _hoisted_3$k, [
            createBaseVNode("label", {
              for: `${$props.address_type}-save-in-address-book`
            }, [
              withDirectives(createBaseVNode("input", {
                id: `${$props.address_type}-save-in-address-book`,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => _ctx.selected[$props.address_type].save_in_address_book = $event),
                type: "checkbox",
                class: "field__checkbox",
                value: "1",
                "true-value": 1,
                "false-value": 0
              }, null, 8, _hoisted_5$c), [
                [
                  vModelCheckbox,
                  _ctx.selected[$props.address_type].save_in_address_book,
                  void 0,
                  { number: true }
                ]
              ]),
              createVNode(_component_TextField, {
                text: _ctx.$t("saveNewAddress"),
                "font-size": "15px",
                "font-weight": "300"
              }, null, 8, ["text"])
            ], 8, _hoisted_4$e)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", null, [
            createVNode(_component_MyButton, {
              class: "select-address-btn",
              type: "submit",
              primary: "",
              disabled: !$data.buttonEnabled,
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.saveAddressButton")
            }, null, 8, ["disabled", "label"])
          ])
        ], 32)
      ])
    ]);
  }
  var AddressForm = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$x], ["__scopeId", "data-v-3f81f94c"]]);
  const _sfc_main$w = {
    name: "ShippingForm",
    components: {
      AddressForm
    },
    data() {
      return {
        address_type: "shipping"
      };
    },
    computed: {
      ...mapState(useCustomerStore, ["selected"]),
      formErrors() {
        return this.selected.formErrors;
      }
    }
  };
  function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_AddressForm = resolveComponent("AddressForm");
    return openBlock(), createElementBlock("div", null, [
      createVNode(_component_AddressForm, { address_type: $data.address_type }, null, 8, ["address_type"])
    ]);
  }
  var ShippingForm = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$w]]);
  const _sfc_main$v = {
    name: "ShowIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$t = ["role", "aria-label"];
  const _hoisted_2$o = /* @__PURE__ */ createBaseVNode("path", { d: "M0 0h35.455v30H0z" }, null, -1);
  const _hoisted_3$j = /* @__PURE__ */ createBaseVNode("path", {
    d: "M17.5 10.857a3.8 3.8 0 0 0-2.63 1.074 3.625 3.625 0 0 0-1.1 2.569c0 1.994 1.689 3.643 3.73 3.643 2.04 0 3.73-1.65 3.73-3.643 0-1.993-1.69-3.643-3.73-3.643Z",
    fill: "#3C3C3C"
  }, null, -1);
  const _hoisted_4$d = /* @__PURE__ */ createBaseVNode("path", {
    d: "M17.5 6C8.01 6 5.158 14.035 5.132 14.116L5 14.5l.13.384C5.159 14.965 8.01 23 17.5 23c9.49 0 12.342-8.035 12.368-8.116L30 14.5l-.13-.384C29.841 14.035 26.99 6 17.5 6Zm0 14.571c-6.653 0-9.23-4.67-9.854-6.071.626-1.406 3.205-6.071 9.854-6.071 6.653 0 9.23 4.67 9.854 6.071-.626 1.406-3.205 6.071-9.854 6.071Z",
    fill: "#3C3C3C"
  }, null, -1);
  const _hoisted_5$b = [
    _hoisted_2$o,
    _hoisted_3$j,
    _hoisted_4$d
  ];
  function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "36",
      height: "30",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      "data-v-3203e236": ""
    }, _hoisted_5$b, 12, _hoisted_1$t);
  }
  var ShowIcon = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v]]);
  const _sfc_main$u = {
    name: "HideIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$s = ["role", "aria-label"];
  const _hoisted_2$n = /* @__PURE__ */ createBaseVNode("path", { d: "M0 0h35.455v30H0z" }, null, -1);
  const _hoisted_3$i = /* @__PURE__ */ createBaseVNode("path", {
    d: "M17.5 23.654a14.85 14.85 0 0 0 3.247-.348l-2.196-2.172c-.342.026-.688.047-1.052.047-6.688 0-9.28-4.754-9.907-6.181a10.674 10.674 0 0 1 1.885-2.84L7.73 10.432c-1.923 2.06-2.652 4.137-2.665 4.177a1.216 1.216 0 0 0 0 .783c.026.082 2.893 8.262 12.434 8.262Zm0-17.308c-2.297 0-4.183.49-5.755 1.213L7.133 3 5.366 4.748 27.866 27l1.767-1.748-4.149-4.103c3.268-2.412 4.434-5.705 4.451-5.757a1.215 1.215 0 0 0 0-.783c-.027-.082-2.895-8.263-12.436-8.263Zm6.214 13.052-2.85-2.818A3.559 3.559 0 0 0 21.25 15c0-2.029-1.698-3.709-3.75-3.709a3.64 3.64 0 0 0-1.596.382l-2.26-2.235c1.24-.42 2.545-.63 3.856-.62 6.689 0 9.28 4.755 9.908 6.182-.378.855-1.458 2.895-3.693 4.398Z",
    fill: "#3C3C3C"
  }, null, -1);
  const _hoisted_4$c = [
    _hoisted_2$n,
    _hoisted_3$i
  ];
  function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "36",
      height: "30",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      "data-v-3203e236": ""
    }, _hoisted_4$c, 12, _hoisted_1$s);
  }
  var HideIcon = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u]]);
  var isEmailValid = (emailAddress) => {
    if (emailAddress.length < 4) {
      return false;
    }
    const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(String(emailAddress).toLowerCase());
  };
  var scrollToTarget = (target) => {
    const element = typeof target === "string" ? document.querySelector(target) : target;
    element.scrollIntoView({
      behavior: "smooth"
    });
  };
  const _sfc_main$t = {
    name: "EmailAddress",
    components: {
      TextInput,
      MyButton,
      HideIcon,
      ShowIcon,
      TextField,
      ErrorMessage,
      Loader,
      Edit
    },
    data() {
      return {
        emailError: false,
        emailRegistered: void 0,
        emailErrorMessage: "",
        passwordErrorMessage: "",
        passwordError: false,
        loginErrorMessage: null,
        showPassword: false,
        passwordValid: false,
        loadingLogin: false,
        baseURL: getBaseUrl(),
        isEmailAvailableRequest: void 0,
        continueButtonText: "",
        continueButtonTextId: "gene-bettercheckout-continuebutton-text"
      };
    },
    computed: {
      ...mapState(useCustomerStore, ["isLoggedIn", "emailEntered"]),
      ...mapWritableState(useCustomerStore, ["customer"]),
      ...mapState(useCartStore, ["guestCheckoutEnabled"]),
      proceedAsGuestInvalid() {
        return this.emailError;
      },
      passwordInputType() {
        return this.showPassword ? "text" : "password";
      }
    },
    async mounted() {
      var _a;
      await this.getStoreConfig();
      this.continueButtonText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.continueButtonTextId]) || this.$t("continueButton");
      document.addEventListener(this.continueButtonTextId, this.setContinueButtonText);
    },
    unmounted() {
      document.removeEventListener(this.continueButtonTextId, this.setContinueButtonText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      ...mapActions(useCustomerStore, [
        "login",
        "submitEmail",
        "isEmailAvailable",
        "editEmail"
      ]),
      ...mapActions(useCartStore, ["getCart", "getCartData", "emitUpdate"]),
      ...mapActions(useGtmStore, ["trackStep"]),
      setContinueButtonText(event) {
        this.continueButtonText = (event == null ? void 0 : event.detail) || this.$t("continueButton");
      },
      toggleShowPassword() {
        this.showPassword = !this.showPassword;
      },
      changeEmail() {
        this.editEmail();
        setTimeout(() => {
          this.$refs.email.$refs.input.focus();
        }, 0);
      },
      async loginAndProceed() {
        try {
          await this.login(this.customer.email, this.password);
          this.loginErrorMessage = "";
          this.proceed();
        } catch (error) {
          this.loginErrorMessage = error.message;
        }
      },
      async submitForm() {
        scrollToTarget(".details-form");
        this.loginErrorMessage = "";
        this.validatePassword();
        if (this.emailError || this.passwordError)
          return;
        this.loadingLogin = true;
        await this.loginAndProceed();
        this.emitUpdate();
        this.loadingLogin = false;
      },
      validatePassword() {
        this.passwordValid = false;
        let counter = 0;
        const requiredNumber = 3;
        if (/[0-9]+/.test(this.password))
          counter++;
        if (/[A-Z]+/.test(this.password))
          counter++;
        if (/[a-z]+/.test(this.password))
          counter++;
        if (/[^a-zA-Z0-9]+/.test(this.password))
          counter++;
        this.passwordValid = counter >= requiredNumber;
        if (this.passwordValid === false) {
          this.passwordError = true;
          this.passwordErrorMessage = this.$t("errorMessages.passwordErrorMessage");
        } else {
          this.passwordError = false;
          this.passwordErrorMessage = "";
        }
      },
      proceed() {
        this.submitEmail();
      },
      setEmailErrorState(hasError) {
        this.emailError = hasError;
        this.emailErrorMessage = hasError ? this.$t("errorMessages.emailErrorMessage") : "";
      },
      emailAddressBlur() {
        if (!isEmailValid(this.customer.email.toLowerCase())) {
          this.setEmailErrorState(this.customer.email.length > 0);
        }
      },
      async emailAddressChange() {
        this.setEmailErrorState(false);
        if (isEmailValid(this.customer.email.toLowerCase())) {
          this.emailRegistered = !await this.isEmailAvailable(this.customer.email);
        } else {
          this.emailRegistered = void 0;
        }
      }
    }
  };
  const _withScopeId$2 = (n) => (pushScopeId("data-v-322e02e6"), n = n(), popScopeId(), n);
  const _hoisted_1$r = { class: "customer-form" };
  const _hoisted_2$m = {
    key: 0,
    class: "loader__absolute-container"
  };
  const _hoisted_3$h = { class: "checkout-section checkout-email" };
  const _hoisted_4$b = ["aria-label"];
  const _hoisted_5$a = { key: 1 };
  const _hoisted_6$7 = { class: "field__password" };
  const _hoisted_7$6 = ["aria-label"];
  const _hoisted_8$6 = { key: 0 };
  const _hoisted_9$6 = { key: 1 };
  const _hoisted_10$6 = { id: "password_help_text" };
  const _hoisted_11$5 = { class: "checkout-email__footer" };
  const _hoisted_12$5 = ["href"];
  const _hoisted_13$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { style: { "display": "none" } }, "forgotPass link", -1));
  const _hoisted_14$2 = {
    key: 1,
    class: "actions"
  };
  const _hoisted_15$1 = {
    key: 2,
    class: "actions"
  };
  function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_TextField = resolveComponent("TextField");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_Edit = resolveComponent("Edit");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_ShowIcon = resolveComponent("ShowIcon");
    const _component_HideIcon = resolveComponent("HideIcon");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    return openBlock(), createElementBlock("section", _hoisted_1$r, [
      $data.loadingLogin ? (openBlock(), createElementBlock("div", _hoisted_2$m, [
        createVNode(_component_Loader)
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_3$h, [
        $data.emailRegistered !== void 0 && !_ctx.isLoggedIn ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createVNode(_component_TextField, {
            class: "welcome-message-title",
            text: $data.emailRegistered ? _ctx.$t("welcomeMessages.accountTitle") : _ctx.$t("welcomeMessages.guestTitle")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            class: "welcome-message",
            text: $data.emailRegistered ? _ctx.$t("welcomeMessages.accountBody") : _ctx.$t("welcomeMessages.guestBody")
          }, null, 8, ["text"])
        ], 64)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass({ "logged-in-email": _ctx.isLoggedIn })
        }, [
          createVNode(_component_TextInput, {
            ref: "email",
            modelValue: _ctx.customer.email,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.customer.email = $event),
            error: $data.emailError,
            "error-message": $data.emailErrorMessage,
            identifier: "email",
            label: _ctx.$t("yourDetailsSection.emailAddress.label"),
            placeholder: _ctx.$t("yourDetailsSection.emailAddress.placeholder"),
            required: !_ctx.isLoggedIn,
            autocomplete: "email",
            type: "email",
            disabled: _ctx.emailEntered,
            onBlur: $options.emailAddressBlur,
            onKeyup: $options.emailAddressChange
          }, null, 8, ["modelValue", "error", "error-message", "label", "placeholder", "required", "disabled", "onBlur", "onKeyup"]),
          _ctx.emailEntered && !_ctx.isLoggedIn ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "email-address-edit-btn",
            onClick: _cache[1] || (_cache[1] = ($event) => $options.changeEmail()),
            onKeydown: _cache[2] || (_cache[2] = withKeys(($event) => $options.changeEmail(), ["enter"]))
          }, [
            createBaseVNode("button", {
              class: "edit-button",
              "aria-label": _ctx.$t("yourDetailsSection.editDetailsButtonLabel")
            }, [
              createVNode(_component_TextField, {
                text: _ctx.$t("yourDetailsSection.editButton"),
                "font-weight": "400",
                "font-size": "12px"
              }, null, 8, ["text"]),
              createVNode(_component_Edit)
            ], 8, _hoisted_4$b)
          ], 32)) : createCommentVNode("", true)
        ], 2),
        createBaseVNode("div", null, [
          $data.emailRegistered === void 0 && !_ctx.emailEntered ? (openBlock(), createBlock(_component_MyButton, {
            key: 0,
            class: "continue-btn",
            primary: "",
            label: $data.continueButtonText,
            onClick: _cache[3] || (_cache[3] = ($event) => $options.emailAddressChange())
          }, null, 8, ["label"])) : createCommentVNode("", true)
        ]),
        $data.emailRegistered && !_ctx.emailEntered ? (openBlock(), createElementBlock("div", _hoisted_5$a, [
          createBaseVNode("div", _hoisted_6$7, [
            createVNode(_component_TextInput, {
              modelValue: _ctx.password,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.password = $event),
              error: $data.passwordError,
              "error-message": $data.passwordErrorMessage,
              type: $options.passwordInputType,
              identifier: "password",
              label: _ctx.$t("yourDetailsSection.passwordField.label"),
              placeholder: _ctx.$t("yourDetailsSection.passwordField.placeholder"),
              required: ""
            }, {
              icon: withCtx(() => [
                createBaseVNode("button", {
                  class: "button_show_password",
                  "aria-label": _ctx.$t("yourDetailsSection.showPassLabel"),
                  onClick: _cache[4] || (_cache[4] = (...args) => $options.toggleShowPassword && $options.toggleShowPassword(...args))
                }, [
                  $data.showPassword ? (openBlock(), createElementBlock("span", _hoisted_8$6, [
                    createVNode(_component_ShowIcon)
                  ])) : (openBlock(), createElementBlock("span", _hoisted_9$6, [
                    createVNode(_component_HideIcon)
                  ]))
                ], 8, _hoisted_7$6)
              ]),
              _: 1
            }, 8, ["modelValue", "error", "error-message", "type", "label", "placeholder"])
          ]),
          createBaseVNode("div", _hoisted_10$6, [
            createVNode(_component_TextField, {
              class: "field__help-text",
              text: _ctx.$t("errorMessages.passwordHelpText"),
              "font-weight": "300",
              "font-size": "12px"
            }, null, 8, ["text"])
          ]),
          $data.loginErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 0,
            message: $data.loginErrorMessage
          }, null, 8, ["message"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_11$5, [
            createBaseVNode("a", {
              href: $data.baseURL + "/customer/account/forgotpassword/",
              class: "forgot-pass"
            }, [
              _hoisted_13$3,
              createVNode(_component_TextField, {
                text: _ctx.$t("forgotPass"),
                "font-weight": "300",
                "font-size": "14px"
              }, null, 8, ["text"])
            ], 8, _hoisted_12$5)
          ]),
          !_ctx.emailEntered ? (openBlock(), createElementBlock("div", _hoisted_14$2, [
            createVNode(_component_MyButton, {
              type: "submit",
              class: "sign-in-btn",
              primary: "",
              label: _ctx.$t("signInButton"),
              onClick: $options.submitForm
            }, null, 8, ["label", "onClick"]),
            createVNode(_component_MyButton, {
              class: "guest-btn",
              secondary: "",
              disabled: $options.proceedAsGuestInvalid,
              label: _ctx.$t("accountGuestButton"),
              onClick: _cache[6] || (_cache[6] = ($event) => {
                $options.proceed();
              })
            }, null, 8, ["disabled", "label"])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        $data.emailRegistered === false && !_ctx.emailEntered ? (openBlock(), createElementBlock("div", _hoisted_15$1, [
          createVNode(_component_MyButton, {
            class: "guest-btn",
            secondary: "",
            disabled: $options.proceedAsGuestInvalid,
            label: _ctx.$t("noAccountGuestButton"),
            onClick: _cache[7] || (_cache[7] = ($event) => {
              $options.proceed();
            })
          }, null, 8, ["disabled", "label"])
        ])) : createCommentVNode("", true)
      ])
    ]);
  }
  var EmailAddress = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t], ["__scopeId", "data-v-322e02e6"]]);
  const _sfc_main$s = {
    name: "LinkComponent",
    props: {
      label: {
        type: String,
        required: true
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontSize: reactiveProps.fontSize
        }))
      };
    }
  };
  function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("button", {
      type: "button",
      class: "button--link",
      style: normalizeStyle($setup.style)
    }, toDisplayString$1($props.label), 5);
  }
  var LinkComponent = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s]]);
  const _sfc_main$r = {
    name: "Tick",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$q = ["role", "aria-label"];
  const _hoisted_2$l = /* @__PURE__ */ createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M0 7.5C0 5.51088 0.790176 3.60322 2.1967 2.1967C3.60322 0.790176 5.51088 0 7.5 0C9.48912 0 11.3968 0.790176 12.8033 2.1967C14.2098 3.60322 15 5.51088 15 7.5C15 9.48912 14.2098 11.3968 12.8033 12.8033C11.3968 14.2098 9.48912 15 7.5 15C5.51088 15 3.60322 14.2098 2.1967 12.8033C0.790176 11.3968 0 9.48912 0 7.5H0ZM7.072 10.71L11.39 5.312L10.61 4.688L6.928 9.289L4.32 7.116L3.68 7.884L7.072 10.711V10.71Z"
  }, null, -1);
  const _hoisted_3$g = [
    _hoisted_2$l
  ];
  function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 15 15",
      width: "25",
      height: "25"
    }, _hoisted_3$g, 12, _hoisted_1$q);
  }
  var Tick = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r]]);
  const _sfc_main$q = {
    name: "AddressList",
    components: {
      Locate,
      TextField,
      Tick
    },
    props: {
      addressType: {
        type: String,
        default: "shipping"
      },
      displayTitle: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      ...mapState(useCustomerStore, ["customer", "selected"])
    },
    mounted() {
      this.$emit("showAddressBlock", false);
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "setAddress",
        "createNewAddress",
        "setEditing",
        "setAddressAsCustom"
      ]),
      selectAddress(address) {
        const clonedAddress = deepClone(address);
        this.setAddress(clonedAddress, this.addressType);
        this.setEditing(this.addressType, false);
        if (this.selected.billing.same_as_shipping) {
          this.setAddress(clonedAddress, "billing");
        }
      },
      newAddress() {
        this.createNewAddress(this.addressType);
      }
    }
  };
  const _withScopeId$1 = (n) => (pushScopeId("data-v-d5b29fd8"), n = n(), popScopeId(), n);
  const _hoisted_1$p = { class: "address-list" };
  const _hoisted_2$k = {
    key: 0,
    class: "delivery-section-title"
  };
  const _hoisted_3$f = { class: "delivery-section-title-text" };
  const _hoisted_4$a = { class: "address-list__list" };
  const _hoisted_5$9 = ["onClick", "onKeydown"];
  const _hoisted_6$6 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
  const _hoisted_7$5 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
  const _hoisted_8$5 = { key: 2 };
  const _hoisted_9$5 = { key: 3 };
  const _hoisted_10$5 = { key: 4 };
  const _hoisted_11$4 = { key: 5 };
  const _hoisted_12$4 = ["textContent"];
  function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Locate = resolveComponent("Locate");
    const _component_TextField = resolveComponent("TextField");
    const _component_Tick = resolveComponent("Tick");
    return openBlock(), createElementBlock("div", _hoisted_1$p, [
      $props.displayTitle ? (openBlock(), createElementBlock("div", _hoisted_2$k, [
        createVNode(_component_Locate),
        createBaseVNode("div", _hoisted_3$f, [
          createVNode(_component_TextField, {
            text: _ctx.$t("yourDetailsSection.deliverySection.savedAddressesTitle", { addressType: $props.addressType })
          }, null, 8, ["text"])
        ])
      ])) : createCommentVNode("", true),
      createBaseVNode("ul", _hoisted_4$a, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.customer.addresses, (item) => {
          return openBlock(), createElementBlock("li", {
            key: item.id,
            class: normalizeClass(["address-list__item", { active: item.id === _ctx.selected[$props.addressType].id }]),
            onClick: ($event) => $options.selectAddress(item),
            onKeydown: ($event) => $options.selectAddress(item)
          }, [
            item.id === _ctx.selected[$props.addressType].id ? (openBlock(), createBlock(_component_Tick, { key: 0 })) : $props.addressType == "shipping" ? (openBlock(), createBlock(_component_TextField, {
              key: 1,
              class: "ship-here",
              text: _ctx.$t("yourDetailsSection.deliverySection.shipHere")
            }, null, 8, ["text"])) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.firstname) + " " + toDisplayString$1(item.lastname), 1),
            _hoisted_6$6,
            _hoisted_7$5,
            createTextVNode(" " + toDisplayString$1(item.street[0]), 1),
            item.street[0] ? (openBlock(), createElementBlock("br", _hoisted_8$5)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.street[1]), 1),
            item.street[1] ? (openBlock(), createElementBlock("br", _hoisted_9$5)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.city), 1),
            item.city ? (openBlock(), createElementBlock("br", _hoisted_10$5)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.postcode), 1),
            item.postcode ? (openBlock(), createElementBlock("br", _hoisted_11$4)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.telephone), 1)
          ], 42, _hoisted_5$9);
        }), 128)),
        _ctx.selected[$props.addressType].id !== "custom" ? (openBlock(), createElementBlock("li", {
          key: 0,
          value: "",
          class: "address-list__item-new",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.newAddress && $options.newAddress(...args)),
          onKeydown: _cache[1] || (_cache[1] = (...args) => $options.newAddress && $options.newAddress(...args)),
          textContent: toDisplayString$1(_ctx.$t("addNewAddressBtn"))
        }, null, 40, _hoisted_12$4)) : createCommentVNode("", true)
      ])
    ]);
  }
  var AddressList = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q], ["__scopeId", "data-v-d5b29fd8"]]);
  const _sfc_main$p = {
    name: "AdyenGooglePay",
    components: {
      ErrorMessage,
      Loader
    },
    data() {
      return {
        browserInfo: {},
        googlePayNoShippingMethods: "",
        orderId: null,
        googlePayLoaded: false
      };
    },
    computed: {
      ...mapState(useCartStore, ["cartGrandTotal"]),
      ...mapState(useShippingMethodsStore, ["selectedMethod"]),
      ...mapState(useConfigStore, [
        "currencyCode",
        "locale",
        "countryCode",
        "stateRequired",
        "countries",
        "getStoreConfig"
      ]),
      ...mapState(usePaymentStore, ["errorMessage"])
    },
    mounted() {
      const googlePayScript = document.createElement("script");
      googlePayScript.setAttribute("src", "https://pay.google.com/gp/p/js/pay.js");
      googlePayScript.onload = this.createButton;
      document.head.appendChild(googlePayScript);
    },
    async created() {
      await this.getStoreConfig();
    },
    methods: {
      createButton() {
        const paymentsClient = new window.google.payments.api.PaymentsClient({ environment: "TEST" });
        const button = paymentsClient.createButton({
          onClick: () => {
          },
          allowedPaymentMethods: []
        });
        document.getElementById("adyen-google-pay").appendChild(button);
        this.googlePayLoaded = true;
      }
    }
  };
  function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", {
      id: "adyen-google-pay",
      class: normalizeClass(!$data.googlePayLoaded ? "text-loading" : "")
    }, null, 2);
  }
  var AdyenGooglePay = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p]]);
  var getPaymentExtensionAttributes = () => ({});
  var getSuccessPageUrl = () => {
    const { secureBaseUrl } = useConfigStore();
    return `${secureBaseUrl}checkout/onepage/success`;
  };
  var expressPaymentOnClick = (resolve2) => {
    resolve2();
  };
  var beforePaymentRequest = () => Promise.resolve();
  var createPayment = (payment) => {
    const { selected: { shipping: shippingAddress } } = useCustomerStore();
    const clonedPayment = deepClone(payment);
    delete clonedPayment.billingAddress.same_as_shipping;
    if (doAddressesMatch(clonedPayment.billingAddress, shippingAddress)) {
      delete clonedPayment.billingAddress.save_in_address_book;
    }
    return beforePaymentRequest().then(() => authenticatedRequest().post(buildCartUrl("payment-information"), clonedPayment)).then((response) => response.data);
  };
  const _sfc_main$o = {
    name: "AdyenApplePay",
    data() {
      return {
        applePayTotal: "",
        applPaySubtotaltitle: "",
        applePayShippingStepTitle: "",
        applePayNoShippingMethods: ""
      };
    },
    computed: {
      ...mapState(useCartStore, ["cartGrandTotal"]),
      ...mapState(useShippingMethodsStore, ["shippingMethods", "selectedMethod"]),
      ...mapState(useConfigStore, ["currencyCode", "locale", "countryCode", "stateRequired", "websiteName", "countries"])
    },
    methods: {
      ...mapActions(useShippingMethodsStore, ["selectShippingMethod", "setShippingMethods", "submitShippingInfo"]),
      ...mapActions(usePaymentStore, ["getPaymentMethodsResponse", "getAdyenClientKey"]),
      ...mapActions(useCartStore, ["getCart", "getCartData", "getCartTotals"]),
      ...mapActions(useConfigStore, ["getStoreConfig", "getAdyenConfig"]),
      ...mapActions(useCustomerStore, ["setEmailAddress", "setAddress", "validatePostcode"]),
      getApplePayMethod(paymentMethodsResponse) {
        return paymentMethodsResponse.paymentMethods.find(({ type }) => type === "applepay");
      },
      expressPaymentsLoad() {
        this.$emit("expressPaymentsLoad", "true");
        this.applePayLoaded = true;
      },
      getApplePayConfiguration(applePayMethod) {
        return {
          amount: {
            value: this.cartGrandTotal,
            currency: this.currencyCode
          },
          currencyCode: this.currencyCode,
          countryCode: this.countryCode,
          totalPriceLabel: this.websiteName,
          environment: getAdyenProductionMode() ? "LIVE" : "TEST",
          configuration: {
            domainName: window.location.hostname,
            merchantName: applePayMethod.configuration.merchantName,
            merchantId: applePayMethod.configuration.merchantId
          },
          requiredShippingContactFields: ["postalAddress", "name", "email", "phone"],
          requiredBillingContactFields: ["postalAddress", "name"],
          shippingMethods: [],
          onAuthorized: this.onAuthorized.bind(this),
          onShippingContactSelected: this.onShippingContactSelect.bind(this),
          onShippingMethodSelected: this.onShippingMethodSelect.bind(this),
          onClick: (resolve2, reject) => expressPaymentOnClick(resolve2, reject, applePayMethod.type),
          onSubmit: () => {
          }
        };
      },
      async onAuthorized(resolve2, reject, data2) {
        const extensionAttributes = getPaymentExtensionAttributes();
        const { shippingContact, billingContact } = data2.payment;
        const email = shippingContact.emailAddress;
        const telephone = shippingContact.phoneNumber;
        const shippingAddress = this.mapAddress(shippingContact, email, telephone);
        const billingAddress = this.mapAddress(billingContact, email, telephone);
        if (!this.validatePostcode("shipping", false)) {
          this.setAddress(shippingAddress, "shipping");
          await this.submitShippingInfo();
        }
        this.setAddress(shippingAddress, "shipping");
        this.setAddress(billingAddress, "billing");
        await this.submitShippingInfo();
        if (!this.countries.some(({ id }) => id === billingAddress.country_id)) {
          reject(window.ApplePaySession.STATUS_FAILURE);
          return;
        }
        const stateData = {
          paymentMethod: {
            type: "applepay",
            applePayToken: btoa(JSON.stringify(data2.payment.token.paymentData))
          }
        };
        const payload = {
          email,
          shippingAddress,
          billingAddress,
          paymentMethod: {
            method: "adyen_hpp",
            additional_data: {
              brand_code: "applepay",
              stateData: JSON.stringify(stateData)
            },
            extension_attributes: extensionAttributes
          }
        };
        const response = await createPayment(payload);
        if (response.action) {
          console.log(response.action);
        } else {
          resolve2(window.ApplePaySession.STATUS_SUCCESS);
          await refreshCustomerData(getCartSectionNames());
          window.location.href = getSuccessPageUrl();
        }
      },
      async onShippingContactSelect(resolve2, reject, data2) {
        const address = {
          city: data2.shippingContact.locality,
          region: data2.shippingContact.administrativeArea,
          country_id: data2.shippingContact.countryCode.toUpperCase(),
          postcode: data2.shippingContact.postalCode
        };
        this.address = address;
        const result = await getShippingMethods(address);
        const filteredMethods = result.filter(({ method_code: methodCode }) => methodCode !== "nominated_delivery");
        this.setShippingMethods(filteredMethods);
        if (!filteredMethods.length) {
          const errors = {
            errors: [
              new window.ApplePayError("addressUnserviceable", "postalAddress", this.applePayNoShippingMethods)
            ],
            newTotal: {
              label: this.applePayTotal,
              amount: "0.00",
              type: "pending"
            }
          };
          resolve2(errors);
          return;
        }
        const selectedShipping = filteredMethods[0];
        if (selectedShipping) {
          this.selectShippingMethod(selectedShipping);
        }
        this.setAddress(address, "shipping");
        this.setAddress(address, "billing");
        const totals = await this.submitShippingInfo();
        const newShippingMethods = this.mapShippingMethods(filteredMethods);
        const applePayShippingContactUpdate = {
          newShippingMethods,
          newTotal: {
            label: this.applePayTotal,
            amount: totals.base_grand_total.toString()
          },
          newLineItems: [
            {
              type: "final",
              label: "Subtotal",
              amount: totals.subtotal.toString()
            },
            {
              type: "final",
              label: "Shipping",
              amount: selectedShipping.amount.toString()
            }
          ]
        };
        if (totals.discount_amount) {
          applePayShippingContactUpdate.newLineItems.push({
            type: "final",
            label: "Discount",
            amount: totals.discount_amount.toString()
          });
        }
        resolve2(applePayShippingContactUpdate);
      },
      async onShippingMethodSelect(resolve2, reject, data2) {
        const selectedShipping = this.shippingMethods.find(({ method_code: id }) => id === data2.shippingMethod.identifier);
        this.selectShippingMethod(selectedShipping);
        const totals = await this.submitShippingInfo();
        const applePayShippingContactUpdate = {
          newTotal: {
            type: "final",
            label: this.applePayTotal,
            amount: totals.base_grand_total.toString()
          },
          newLineItems: [
            {
              type: "final",
              label: this.applPaySubtotaltitle,
              amount: totals.subtotal.toString()
            },
            {
              type: "final",
              label: this.applePayShippingStepTitle,
              amount: selectedShipping.amount.toString()
            }
          ]
        };
        resolve2(applePayShippingContactUpdate);
      },
      mapShippingMethods(shippingMethods) {
        return shippingMethods.map((shippingMethod) => ({
          label: shippingMethod.method_title,
          detail: shippingMethod.carrier_title || "",
          amount: shippingMethod.amount.toString(),
          identifier: shippingMethod.method_code,
          carrierCode: shippingMethod.carrier_code
        }));
      },
      mapAddress(address, email, telephone) {
        const statesRequired = this.stateRequired;
        let region;
        if (statesRequired.indexOf(address.countryCode) !== -1) {
          const country = this.countries.find((cty) => cty.id === address.countryCode);
          if (country.available_regions && country.available_regions.length) {
            region = country.available_regions.find((rgin) => rgin.name === address.administrativeArea);
          }
        }
        return {
          email,
          telephone,
          firstname: address.givenName,
          lastname: address.familyName,
          street: address.addressLines,
          city: address.locality,
          region: address.administrativeArea,
          region_id: region ? region.id : 0,
          country_id: address.countryCode.toUpperCase(),
          postcode: address.postalCode,
          same_as_billing: 0,
          customer_address_id: 0,
          save_in_address_book: 0
        };
      }
    }
  };
  const _hoisted_1$o = { class: "apple-pay-button apple-pay-button-black" };
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("button", _hoisted_1$o, "Apple Pay");
  }
  var AdyenApplePay = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
  const _sfc_main$n = {
    name: "Checkbox",
    props: {
      id: {
        type: String,
        default: ""
      },
      text: {
        type: String
      },
      content: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      },
      checked: {
        type: Boolean,
        default: false
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      },
      fontStyle: {
        type: String
      },
      ariaChecked: {
        type: String
      },
      role: {
        type: String
      },
      changeHandler: {
        type: Function,
        default: () => {
        }
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          fontSize: reactiveProps.fontSize,
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontStyle: reactiveProps.fontStyle
        }))
      };
    }
  };
  const _hoisted_1$n = ["for"];
  const _hoisted_2$j = ["id", "disabled", "checked", "aria-checked", "role", "content"];
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("label", {
        for: "input-checkbox-" + $props.id
      }, [
        createBaseVNode("input", {
          id: "input-checkbox-" + $props.id,
          type: "checkbox",
          disabled: $props.disabled,
          checked: $props.checked,
          "aria-checked": $props.ariaChecked,
          role: $props.role,
          content: $props.content,
          onChange: _cache[0] || (_cache[0] = (...args) => $props.changeHandler && $props.changeHandler(...args))
        }, null, 40, _hoisted_2$j),
        createBaseVNode("span", {
          style: normalizeStyle($setup.style)
        }, [
          createTextVNode(toDisplayString$1($props.text), 1),
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ], 4)
      ], 8, _hoisted_1$n)
    ]);
  }
  var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n], ["__scopeId", "data-v-b94ceeb0"]]);
  const _sfc_main$m = {
    name: "BillingForm",
    components: {
      TextField,
      AddressForm,
      AddressBlock,
      Edit,
      NameFields,
      CheckboxComponent: Checkbox,
      Loqate,
      LinkComponent,
      AddressList
    },
    props: {
      showCheckbox: {
        type: Boolean,
        default: true
      }
    },
    emits: [
      "billingInfoFull"
    ],
    data() {
      return {
        address_type: "billing",
        customerInfoValidation: false
      };
    },
    computed: {
      ...mapState(useCustomerStore, ["customer", "emailEntered", "selected", "isUsingSavedBillingAddress"]),
      ...mapState(useCartStore, ["isLoggedIn", "isItemRequiringDelivery"]),
      ...mapState(useShippingMethodsStore, ["isClickAndCollect"])
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "setEditing",
        "createNewAddress",
        "submitCustom",
        "setAddressAsCustom"
      ]),
      toggleBillingAddress(event) {
        if (!event.target.checked) {
          this.createNewAddress(this.address_type);
          this.selected[this.address_type].same_as_shipping = false;
        } else {
          this.selected[this.address_type] = deepClone(this.selected.shipping);
          this.selected[this.address_type].same_as_shipping = true;
          this.setEditing(this.address_type, false);
        }
      },
      editBillingAddress() {
        this.setEditing(this.address_type, true);
      },
      isCustomerInfoFull(value) {
        this.customerInfoValidation = value;
        this.$emit("billingInfoFull", value);
      }
    }
  };
  const _hoisted_1$m = { class: "billing-address-not-same" };
  const _hoisted_2$i = { class: "address-block__checkbox" };
  const _hoisted_3$e = {
    key: 2,
    class: "address-block"
  };
  const _hoisted_4$9 = { class: "address-block__item" };
  const _hoisted_5$8 = { class: "billing-form-address" };
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_CheckboxComponent = resolveComponent("CheckboxComponent");
    const _component_TextField = resolveComponent("TextField");
    const _component_AddressList = resolveComponent("AddressList");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_Edit = resolveComponent("Edit");
    const _component_NameFields = resolveComponent("NameFields");
    const _component_Loqate = resolveComponent("Loqate");
    const _component_LinkComponent = resolveComponent("LinkComponent");
    const _component_AddressForm = resolveComponent("AddressForm");
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1$m, [
        createBaseVNode("div", _hoisted_2$i, [
          $props.showCheckbox && _ctx.isItemRequiringDelivery ? (openBlock(), createBlock(_component_CheckboxComponent, {
            key: 0,
            checked: _ctx.selected[$data.address_type].same_as_shipping,
            text: _ctx.$t("billingForm.notSameAddress"),
            onChange: $options.toggleBillingAddress
          }, null, 8, ["checked", "text", "onChange"])) : createCommentVNode("", true)
        ]),
        !_ctx.selected[$data.address_type].same_as_shipping && !_ctx.isClickAndCollect || !_ctx.isItemRequiringDelivery ? (openBlock(), createBlock(_component_TextField, {
          key: 0,
          class: "address-block__title",
          text: _ctx.$t("yourDetailsSection.deliverySection.billingAddressTitle")
        }, null, 8, ["text"])) : createCommentVNode("", true),
        _ctx.emailEntered && _ctx.customer.addresses.length && (!_ctx.selected[$data.address_type].same_as_shipping || !_ctx.isItemRequiringDelivery) ? (openBlock(), createBlock(_component_AddressList, {
          key: 1,
          "display-title": false,
          "address-type": "billing"
        })) : createCommentVNode("", true),
        !_ctx.selected[$data.address_type].editing && (!_ctx.selected[$data.address_type].same_as_shipping || _ctx.isClickAndCollect || !_ctx.isItemRequiringDelivery) && _ctx.selected[$data.address_type].postcode && !_ctx.isUsingSavedBillingAddress ? (openBlock(), createElementBlock("div", _hoisted_3$e, [
          createBaseVNode("div", _hoisted_4$9, [
            createBaseVNode("article", null, [
              createVNode(_component_AddressBlock, {
                address_type: $data.address_type,
                address: _ctx.selected[$data.address_type]
              }, null, 8, ["address_type", "address"])
            ])
          ]),
          _ctx.selected[$data.address_type].id ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "address-block__edit",
            onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.editBillingAddress && $options.editBillingAddress(...args), ["prevent"])),
            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.editBillingAddress && $options.editBillingAddress(...args), ["prevent"]), ["enter"]))
          }, [
            createVNode(_component_Edit)
          ], 32)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]),
      (!_ctx.selected[$data.address_type].id || _ctx.selected[$data.address_type].id === "custom" && _ctx.selected[$data.address_type].editing) && (!_ctx.selected[$data.address_type].same_as_shipping || _ctx.isClickAndCollect || !_ctx.isItemRequiringDelivery) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createVNode(_component_NameFields, {
          address_type: $data.address_type,
          onIsCustomerInfoFull: $options.isCustomerInfoFull
        }, null, 8, ["address_type", "onIsCustomerInfoFull"]),
        createBaseVNode("div", _hoisted_5$8, [
          createBaseVNode("div", {
            class: normalizeClass(!$data.customerInfoValidation ? "disabled" : "")
          }, [
            !_ctx.selected[$data.address_type].id || _ctx.selected[$data.address_type].id === "custom" && _ctx.selected[$data.address_type].editing ? (openBlock(), createBlock(_component_Loqate, {
              key: 0,
              address_type: $data.address_type
            }, null, 8, ["address_type"])) : createCommentVNode("", true)
          ], 2),
          _ctx.selected[$data.address_type].id !== "custom" ? (openBlock(), createBlock(_component_LinkComponent, {
            key: 0,
            class: normalizeClass(["manually-button", !$data.customerInfoValidation ? "disabled" : ""]),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.linkText"),
            onClick: withModifiers($options.editBillingAddress, ["prevent"])
          }, null, 8, ["class", "label", "onClick"])) : createCommentVNode("", true),
          _ctx.selected[$data.address_type].editing ? (openBlock(), createBlock(_component_AddressForm, {
            key: 1,
            address_type: $data.address_type
          }, null, 8, ["address_type"])) : createCommentVNode("", true)
        ])
      ], 64)) : createCommentVNode("", true)
    ]);
  }
  var BillingForm = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m], ["__scopeId", "data-v-2807b3f1"]]);
  const _sfc_main$l = {
    name: "Newsletter",
    components: {
      Checkbox
    },
    computed: {
      ...mapState(useConfigStore, ["newsletterEnabled", "newsletterAllowGuests"]),
      ...mapState(useCustomerStore, ["isLoggedIn", "newsletter"])
    },
    methods: {
      ...mapActions(useCustomerStore, ["updateNewsletterSubscription"]),
      changeNewsletterSubscription(event) {
        const { target } = event;
        if (typeof target.checked !== "undefined") {
          this.updateNewsletterSubscription(target.checked);
        }
      }
    }
  };
  const _hoisted_1$l = {
    key: 0,
    class: "newsletter-container"
  };
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Checkbox = resolveComponent("Checkbox");
    return _ctx.newsletterEnabled && (!_ctx.isLoggedIn && _ctx.newsletterAllowGuests || _ctx.isLoggedIn && !_ctx.newsletter.isSubscribed) ? (openBlock(), createElementBlock("div", _hoisted_1$l, [
      createVNode(_component_Checkbox, {
        id: "newsletter-signup",
        checked: _ctx.newsletter.subscribeToNewsletter,
        text: _ctx.$t("newsletter.label"),
        "change-handler": $options.changeNewsletterSubscription
      }, null, 8, ["checked", "text", "change-handler"])
    ])) : createCommentVNode("", true);
  }
  var Newsletter = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l], ["__scopeId", "data-v-97ea6f32"]]);
  const _sfc_main$k = {
    name: "Present",
    props: {
      width: {
        type: String,
        default: "20"
      },
      height: {
        type: String,
        default: "20"
      },
      fill: {
        type: String
      },
      stroke: {
        type: String,
        default: "currentColor"
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$k = ["role", "aria-label", "width", "height"];
  const _hoisted_2$h = ["stroke"];
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: $props.width,
      height: $props.height,
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      createBaseVNode("path", {
        d: "M9.99874 6.00052V18.9987M2.99972 9.99996H16.9978M2.99972 9.99996C2.46936 9.99996 1.96072 9.78928 1.5857 9.41426C1.21068 9.03924 1 8.5306 1 8.00024C1 7.46989 1.21068 6.96125 1.5857 6.58623C1.96072 6.21121 2.46936 6.00052 2.99972 6.00052H16.9978C17.5281 6.00052 18.0368 6.21121 18.4118 6.58623C18.7868 6.96125 18.9975 7.46989 18.9975 8.00024C18.9975 8.5306 18.7868 9.03924 18.4118 9.41426C18.0368 9.78928 17.5281 9.99996 16.9978 9.99996M2.99972 9.99996V16.999C2.99972 17.5293 3.2104 18.038 3.58543 18.413C3.96045 18.788 4.46908 18.9987 4.99944 18.9987H14.998C15.5284 18.9987 16.037 18.788 16.4121 18.413C16.7871 18.038 16.9978 17.5293 16.9978 16.999V9.99996M9.99874 6.00052V4.0008C9.99874 3.6053 10.116 3.21867 10.3358 2.88982C10.5555 2.56097 10.8678 2.30466 11.2332 2.1533C11.5986 2.00195 12.0007 1.96235 12.3886 2.03951C12.7765 2.11667 13.1328 2.30712 13.4125 2.58679C13.6921 2.86645 13.8826 3.22277 13.9598 3.61068C14.0369 3.99858 13.9973 4.40066 13.846 4.76606C13.6946 5.13146 13.4383 5.44378 13.1094 5.66351C12.7806 5.88324 12.394 6.00052 11.9985 6.00052H9.99874ZM9.99874 6.00052V3.50087C9.99874 3.00649 9.85214 2.52321 9.57748 2.11214C9.30281 1.70108 8.91242 1.38069 8.45567 1.1915C7.99892 1.0023 7.49632 0.952802 7.01143 1.04925C6.52655 1.1457 6.08115 1.38377 5.73157 1.73335C5.38199 2.08294 5.14392 2.52833 5.04747 3.01322C4.95102 3.4981 5.00052 4.0007 5.18972 4.45745C5.37891 4.9142 5.6993 5.30459 6.11036 5.57926C6.52143 5.85392 7.00471 6.00052 7.49909 6.00052H9.99874Z",
        stroke: $props.stroke,
        "stroke-width": "1.5",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      }, null, 8, _hoisted_2$h)
    ], 12, _hoisted_1$k);
  }
  var Present = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
  var formatClickAndCollectAddress = (location) => {
    const fullAddress = [
      location.address,
      location.city,
      location.county,
      location.postcode
    ];
    const removedEmpty = fullAddress.filter((addressLine) => addressLine);
    return removedEmpty.join(", ");
  };
  const _sfc_main$j = {
    name: "ClickAndCollectLocation",
    components: {
      ArrowDown,
      ArrowUp,
      Present,
      LinkComponent,
      TextField
    },
    props: {
      location: {
        type: Object,
        default: () => {
        }
      }
    },
    data() {
      return {
        infoOpen: false
      };
    },
    computed: {
      ...mapState(useConfigStore, ["countryCode"]),
      formattedMiles() {
        return this.location.miles.toFixed(2);
      },
      formattedLat() {
        return parseFloat(this.location.lat);
      },
      formattedLng() {
        return parseFloat(this.location.long);
      },
      formattedAddress() {
        return formatClickAndCollectAddress(this.location);
      }
    },
    methods: {
      ...mapActions(useCustomerStore, ["setAddress"]),
      ...mapActions(useShippingMethodsStore, ["setAsClickAndCollect", "setClickAndCollectLocation"]),
      async selectAddress(location) {
        await this.setAsClickAndCollect(location.site_number);
        const newAddress = {
          id: "clickAndCollect",
          company: location.siteName,
          street: [location.address],
          city: location.city,
          country_id: this.countryCode,
          region: location.county,
          region_id: 0,
          postcode: location.postcode
        };
        this.setAddress(newAddress, "shipping");
        this.setClickAndCollectLocation(location);
      }
    }
  };
  const _hoisted_1$j = { class: "click-and-collect-location" };
  const _hoisted_2$g = { class: "click-and-collect-title click-and-collect-semibold" };
  const _hoisted_3$d = { class: "click-and-collect-title" };
  const _hoisted_4$8 = { key: 0 };
  const _hoisted_5$7 = { class: "click-and-collect-opening-times" };
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Present = resolveComponent("Present");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    const _component_LinkComponent = resolveComponent("LinkComponent");
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", _hoisted_1$j, [
      createBaseVNode("div", null, [
        createBaseVNode("span", _hoisted_2$g, toDisplayString$1($props.location.site_name) + " - ", 1),
        createBaseVNode("span", _hoisted_3$d, toDisplayString$1(_ctx.$t("yourDetailsSection.deliverySection.addressForm.collectionDistance", { distance: $options.formattedMiles })), 1)
      ]),
      createBaseVNode("p", null, toDisplayString$1($options.formattedAddress), 1),
      createBaseVNode("div", {
        class: "click-and-collect-map-title",
        onClick: _cache[0] || (_cache[0] = ($event) => $data.infoOpen = !$data.infoOpen),
        onKeydown: _cache[1] || (_cache[1] = ($event) => $data.infoOpen = !$data.infoOpen)
      }, [
        createVNode(_component_Present),
        createTextVNode(" " + toDisplayString$1(_ctx.$t("yourDetailsSection.deliverySection.addressForm.viewMapAndHours")) + " ", 1),
        $data.infoOpen ? (openBlock(), createBlock(_component_ArrowUp, {
          key: 0,
          height: "9",
          stroke: "black",
          width: "12"
        })) : (openBlock(), createBlock(_component_ArrowDown, {
          key: 1,
          height: "9",
          stroke: "black",
          width: "12"
        }))
      ], 32),
      createBaseVNode("div", null, [
        createVNode(_component_LinkComponent, {
          class: "click-and-collect-select",
          label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.selectLocation"),
          onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $options.selectAddress($props.location), ["prevent"]))
        }, null, 8, ["label"])
      ]),
      $data.infoOpen ? (openBlock(), createElementBlock("div", _hoisted_4$8, [
        createVNode(_component_TextField, {
          class: "click-and-collect-title click-and-collect-semibold",
          text: _ctx.$t("yourDetailsSection.deliverySection.clickandCollectOpeningTimes")
        }, null, 8, ["text"]),
        createBaseVNode("div", _hoisted_5$7, [
          createVNode(_component_TextField, {
            text: _ctx.$t("days.monday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.monday_open} - ${$props.location.monday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.tuesday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.tuesday_open} - ${$props.location.tuesday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.wednesday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.wednesday_open} - ${$props.location.wednesday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.thursday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.thursday_open} - ${$props.location.thursday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.friday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.friday_open} - ${$props.location.friday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.saturday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.saturday_open} - ${$props.location.saturday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.sunday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.sunday_open} - ${$props.location.sunday_close}`
          }, null, 8, ["text"])
        ])
      ])) : createCommentVNode("", true)
    ]);
  }
  var ClickAndCollectLocation = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j], ["__scopeId", "data-v-450a2f20"]]);
  var getClickAndCollectLocations = (search) => {
    const url = "https://api.collectplus.yodel.co.uk/api/v1/agentlocator/skatehut/AgentLocator.json";
    const query = `?searchCriteria=${search}&maxRecords=20`;
    return axios.get(`${url}${query}`).then((response) => response.data);
  };
  var getUsersPostcode = () => new Promise((resolve2) => {
    if (navigator.geolocation) {
      const options = {
        enableHighAccuracy: false,
        timeout: 5e3,
        maximumAge: 0
      };
      const success = async (position) => {
        const { custom: { googleMapKey } } = useConfigStore();
        const { coords = {} } = position;
        const { latitude, longitude } = coords;
        const latLng = `${latitude},${longitude}`;
        const url = "https://maps.googleapis.com/maps/api/geocode/json";
        const addressData = await axios.get(`${url}?key=${googleMapKey}&latlng=${encodeURIComponent(latLng)}`, {
          method: "GET",
          cache: "no-cache"
        }).then((response) => response.data);
        const { results = [] } = addressData;
        const postcode = results.reduce((prev, curr) => {
          if (prev) {
            return prev;
          }
          const { address_components: addressComponents = [] } = curr;
          return addressComponents.find((component) => component.types.includes("postal_code") && component.short_name).short_name;
        }, null);
        resolve2(postcode);
      };
      const error = (err) => {
        console.warn(`ERROR(${err.code}): ${err.message}`);
        resolve2(null);
      };
      navigator.geolocation.getCurrentPosition(success, error, options);
    } else {
      resolve2(null);
    }
  });
  const _sfc_main$i = {
    name: "ClickAndCollect",
    components: {
      ClickAndCollectLocation,
      LinkComponent,
      Search,
      TextField,
      TextInput,
      NameFields,
      MyButton,
      AddressBlock,
      AddressList,
      BillingForm,
      Loader
    },
    data() {
      return {
        query: "",
        foundLocations: [],
        customerInfoValidation: false,
        customInfoSubmitted: false,
        isAddressBlockVisible: true,
        queryTimeout: null,
        loading: false,
        postcodeError: false,
        postcodeErrorMessage: ""
      };
    },
    computed: {
      ...mapState(useCustomerStore, [
        "customer",
        "selected"
      ]),
      ...mapState(useShippingMethodsStore, ["clickAndCollectLocation", "setClickAndCollectLocation"])
    },
    async mounted() {
      this.customInfoSubmitted = this.selected.shipping.firstname && this.selected.shipping.lastname;
      if (this.selected.shipping.id && !Object.keys(this.clickAndCollectLocation).length) {
        const locations = await getClickAndCollectLocations(this.selected.shipping.postcode);
        if (locations.agents.length) {
          const [location] = locations.agents;
          this.setClickAndCollectLocation(location);
        }
      }
    },
    methods: {
      ...mapActions(useCustomerStore, ["setAddress", "setEditing"]),
      ...mapActions(useShippingMethodsStore, ["clearShippingMethodCache", "submitShippingInfo"]),
      ...mapActions(useStepsStore, ["goToShipping"]),
      async useMyLocation() {
        this.postcodeError = false;
        this.postcodeErrorMessage = "";
        this.loading = true;
        const postcode = await getUsersPostcode();
        if (postcode) {
          this.query = postcode;
          this.getLocations();
        } else {
          this.postcodeError = true;
          this.postcodeErrorMessage = this.$t("errorMessages.postcodeLookup");
          this.loading = false;
        }
      },
      editShippingAdress() {
        const emptyAddress = getEmptyAddress();
        const newAddress = Object.assign(emptyAddress, {
          firstname: this.selected.shipping.firstname,
          lastname: this.selected.shipping.lastname,
          telephone: this.selected.shipping.telephone
        });
        this.setAddress(newAddress, "shipping");
      },
      getLocations() {
        if (this.queryTimeout) {
          clearTimeout(this.queryTimeout);
        }
        this.postcodeError = false;
        this.postcodeErrorMessage = "";
        this.queryTimeout = setTimeout(async () => {
          if (this.query) {
            const locations = await getClickAndCollectLocations(this.query);
            this.foundLocations = locations.agents;
            this.loading = false;
          }
          this.queryTimeout = null;
        }, 1e3);
      },
      showAddressBlock(value) {
        this.isAddressBlockVisible = value;
      },
      isCustomerInfoFull(value) {
        this.customerInfoValidation = value;
      },
      submitCollectionDetails() {
        this.customInfoSubmitted = true;
      },
      async submitClickAndCollect() {
        this.clearShippingMethodCache();
        this.goToShipping();
      }
    }
  };
  const _hoisted_1$i = { class: "click-and-collect-container" };
  const _hoisted_2$f = { class: "click-and-collect-title-container" };
  const _hoisted_3$c = { key: 1 };
  const _hoisted_4$7 = { class: "click-and-collect-input" };
  const _hoisted_5$6 = {
    key: 0,
    class: "click-and-collect-container"
  };
  const _hoisted_6$5 = { class: "click-and-collect-locations" };
  const _hoisted_7$4 = {
    key: 4,
    class: "click-and-collect-container"
  };
  const _hoisted_8$4 = { class: "click-and-collect-title-container" };
  const _hoisted_9$4 = { key: 0 };
  const _hoisted_10$4 = { key: 1 };
  const _hoisted_11$3 = {
    key: 5,
    class: "click-and-collect-container"
  };
  const _hoisted_12$3 = { class: "click-and-collect-billing" };
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_TextField = resolveComponent("TextField");
    const _component_LinkComponent = resolveComponent("LinkComponent");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_Search = resolveComponent("Search");
    const _component_ClickAndCollectLocation = resolveComponent("ClickAndCollectLocation");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_NameFields = resolveComponent("NameFields");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_AddressList = resolveComponent("AddressList");
    const _component_BillingForm = resolveComponent("BillingForm");
    return openBlock(), createElementBlock("div", _hoisted_1$i, [
      $data.loading ? (openBlock(), createBlock(_component_Loader, { key: 0 })) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_2$f, [
        createVNode(_component_TextField, {
          class: "click-and-collect-title click-and-collect-semibold",
          text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.collectLocations")
        }, null, 8, ["text"]),
        _ctx.selected.shipping.id ? (openBlock(), createBlock(_component_LinkComponent, {
          key: 0,
          label: _ctx.$t("yourDetailsSection.editButton"),
          onClick: withModifiers($options.editShippingAdress, ["prevent"])
        }, null, 8, ["label", "onClick"])) : createCommentVNode("", true)
      ]),
      !_ctx.selected.shipping.id ? (openBlock(), createElementBlock("div", _hoisted_3$c, [
        createBaseVNode("div", _hoisted_4$7, [
          createVNode(_component_TextInput, {
            modelValue: $data.query,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.query = $event),
            type: "text",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.label"),
            required: "",
            error: $data.postcodeError,
            "error-message": $data.postcodeErrorMessage,
            onInput: $options.getLocations
          }, null, 8, ["modelValue", "placeholder", "label", "error", "error-message", "onInput"]),
          createVNode(_component_Search, { stroke: "black" })
        ]),
        createVNode(_component_LinkComponent, {
          label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.useMyLocation"),
          class: "click-and-collect-use-location",
          onClick: withModifiers($options.useMyLocation, ["prevent"])
        }, null, 8, ["label", "onClick"]),
        $data.query && !$data.queryTimeout ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
          createVNode(_component_TextField, {
            class: "click-and-collect-title click-and-collect-semibold",
            text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.closestLocations")
          }, null, 8, ["text"]),
          createBaseVNode("div", _hoisted_6$5, [
            !$data.foundLocations.length ? (openBlock(), createBlock(_component_TextField, {
              key: 0,
              text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.noLocations")
            }, null, 8, ["text"])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.foundLocations, (location) => {
              return openBlock(), createBlock(_component_ClickAndCollectLocation, {
                key: location.site_number,
                location
              }, null, 8, ["location"]);
            }), 128))
          ])
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true),
      _ctx.selected.shipping.id ? (openBlock(), createBlock(_component_TextField, {
        key: 2,
        text: `${_ctx.clickAndCollectLocation.site_name} -
        ${_ctx.$t("yourDetailsSection.deliverySection.addressForm.collectionDistance", { distance: _ctx.clickAndCollectLocation.miles.toFixed(2) })}`
      }, null, 8, ["text"])) : createCommentVNode("", true),
      _ctx.selected.shipping.id ? (openBlock(), createBlock(_component_AddressBlock, {
        key: 3,
        class: "click-and-collect-address",
        "show-name-fields": false,
        address_type: `shipping`,
        address: _ctx.selected.shipping
      }, null, 8, ["address"])) : createCommentVNode("", true),
      _ctx.selected.shipping.id ? (openBlock(), createElementBlock("div", _hoisted_7$4, [
        createBaseVNode("div", _hoisted_8$4, [
          createVNode(_component_TextField, {
            class: "click-and-collect-title click-and-collect-semibold",
            text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.collectionName")
          }, null, 8, ["text"]),
          _ctx.selected.shipping.id && $data.customInfoSubmitted ? (openBlock(), createBlock(_component_LinkComponent, {
            key: 0,
            label: _ctx.$t("yourDetailsSection.editButton"),
            onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $data.customInfoSubmitted = false, ["prevent"]))
          }, null, 8, ["label"])) : createCommentVNode("", true)
        ]),
        !$data.customInfoSubmitted ? (openBlock(), createElementBlock("div", _hoisted_9$4, [
          createVNode(_component_NameFields, {
            address_type: "shipping",
            onIsCustomerInfoFull: $options.isCustomerInfoFull
          }, null, 8, ["onIsCustomerInfoFull"]),
          createVNode(_component_MyButton, {
            class: "click-and-collect-container",
            type: "submit",
            primary: "",
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.submitCollectionDetails"),
            disabled: !$data.customerInfoValidation,
            onClick: $options.submitCollectionDetails
          }, null, 8, ["label", "disabled", "onClick"])
        ])) : (openBlock(), createElementBlock("div", _hoisted_10$4, [
          createVNode(_component_TextField, {
            text: `${_ctx.selected.shipping.firstname} ${_ctx.selected.shipping.lastname}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.selected.shipping.telephone
          }, null, 8, ["text"])
        ]))
      ])) : createCommentVNode("", true),
      _ctx.selected.shipping.id && $data.customInfoSubmitted ? (openBlock(), createElementBlock("div", _hoisted_11$3, [
        createVNode(_component_TextField, {
          class: "click-and-collect-title click-and-collect-semibold",
          text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.collectionBillingTitle")
        }, null, 8, ["text"]),
        createBaseVNode("div", _hoisted_12$3, [
          _ctx.customer.addresses.length ? (openBlock(), createBlock(_component_AddressList, {
            key: 0,
            "display-title": false,
            "address-type": "billing",
            onShowAddressBlock: $options.showAddressBlock
          }, null, 8, ["onShowAddressBlock"])) : createCommentVNode("", true),
          createVNode(_component_BillingForm, {
            "show-checkbox": false,
            class: "click-and-collect-address"
          })
        ]),
        !_ctx.selected.billing.editing ? (openBlock(), createBlock(_component_MyButton, {
          key: 0,
          disabled: !_ctx.selected.billing.id,
          class: "click-and-collect-container",
          type: "submit",
          primary: "",
          label: _ctx.$t("yourDetailsSection.deliverySection.toShippingButton"),
          onClick: _cache[2] || (_cache[2] = ($event) => {
            $options.submitClickAndCollect();
          })
        }, null, 8, ["disabled", "label"])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ]);
  }
  var ClickAndCollect = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i], ["__scopeId", "data-v-04b82cda"]]);
  const _sfc_main$h = {
    name: "YourDetailComponent",
    components: {
      TextField,
      PayWith,
      YourDetails,
      DividerComponent,
      Locate,
      Loqate,
      NameFields,
      ShippingForm,
      AddressBlock,
      Edit,
      EmailAddress,
      LinkComponent,
      AddressList,
      AdyenGooglePay,
      AdyenApplePay,
      ErrorMessage,
      BillingForm,
      Newsletter,
      MyButton,
      ClickAndCollect,
      Loader
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    data() {
      return {
        isAddressBlockVisible: true,
        customerInfoValidation: false,
        billingInfoValidation: false,
        addressFormErrorMessage: false,
        storedKey: 0,
        isExpressPaymentsVisible: true,
        instantCheckoutText: "",
        instantCheckoutTextId: "gene-bettercheckout-instantcheckout-text",
        proceedToPayText: "",
        proceedToPayTextId: "gene-bettercheckout-proceedtopay-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["cartEmitter", "subtotalInclTax", "isItemRequiringDelivery"]),
      ...mapState(useConfigStore, ["custom"]),
      ...mapState(useCustomerStore, [
        "customer",
        "isLoggedIn",
        "emailEntered",
        "selected",
        "isUsingSavedShippingAddress"
      ]),
      ...mapState(useShippingMethodsStore, ["isClickAndCollect", "loadingShippingMethods"])
    },
    async mounted() {
      var _a, _b;
      await this.getStoreConfig();
      this.instantCheckoutText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.instantCheckoutTextId]) || this.$t("instantCheckout");
      this.proceedToPayText = ((_b = window.geneCheckout) == null ? void 0 : _b[this.proceedToPayTextId]) || this.$t("shippingStep.proceedToPay");
      document.addEventListener(this.instantCheckoutTextId, this.setInstantCheckoutText);
      document.addEventListener(this.proceedToPayTextId, this.setProceedToPayText);
    },
    unmounted() {
      document.removeEventListener(this.instantCheckoutTextId, this.setInstantCheckoutText);
      document.addEventListener(this.proceedToPayTextId, this.setProceedToPayText);
    },
    methods: {
      ...mapActions(useCartStore, ["getCart", "getCartData"]),
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      ...mapActions(useCustomerStore, [
        "setAddressAsCustom",
        "setEditing",
        "validateAddress",
        "validateNameField",
        "validatePhone",
        "validatePostcode",
        "setAddress"
      ]),
      ...mapActions(usePaymentStore, ["getPaymentMethodsResponse"]),
      ...mapActions(useShippingMethodsStore, ["clearShippingMethodCache", "setClickAndCollect", "setNotClickAndCollect"]),
      ...mapActions(useStepsStore, ["goToShipping", "goToPayment"]),
      expressPaymentsVisible(value) {
        this.isExpressPaymentsVisible = value;
      },
      submitShippingOption() {
        const isValid = this.validateAddress(this.address_type, true) && this.validatePostcode(this.address_type, true);
        if (isValid) {
          if (this.selected.billing.same_as_shipping) {
            const clonedAddress = deepClone(this.selected.shipping);
            this.setAddress(clonedAddress, "billing");
          }
          this.clearShippingMethodCache();
          this.goToShipping();
        }
      },
      editAddress() {
        this.setEditing(this.address_type, true);
        this.setAddressAsCustom(this.address_type);
      },
      showAddressBlock(value) {
        this.isAddressBlockVisible = value;
      },
      isCustomerInfoFull(value) {
        this.customerInfoValidation = value;
      },
      billingInfoFull(value) {
        this.billingInfoValidation = value;
      },
      formatPrice(price) {
        return formatPrice(price);
      },
      setInstantCheckoutText(event) {
        this.instantCheckoutText = (event == null ? void 0 : event.detail) || this.$t("instantCheckout");
      },
      setProceedToPayText(event) {
        this.proceedToPayText = (event == null ? void 0 : event.detail) || this.$t("shippingStep.proceedToPay");
      }
    }
  };
  const _hoisted_1$h = { class: "details-form" };
  const _hoisted_2$e = { class: "details-form-header" };
  const _hoisted_3$b = { class: "instantCheckout-block" };
  const _hoisted_4$6 = { class: "instant-payment-buttons" };
  const _hoisted_5$5 = {
    key: 1,
    class: "shipping-type-toggle"
  };
  const _hoisted_6$4 = { key: 2 };
  const _hoisted_7$3 = {
    key: 4,
    class: "additional-detail-form"
  };
  const _hoisted_8$3 = { class: "delivery-section" };
  const _hoisted_9$3 = { class: "details-form-title" };
  const _hoisted_10$3 = {
    key: 0,
    class: "delivery-section-title"
  };
  const _hoisted_11$2 = { class: "delivery-section-title-text" };
  const _hoisted_12$2 = {
    key: 5,
    class: "address-block"
  };
  const _hoisted_13$2 = { class: "address-block__item" };
  const _hoisted_14$1 = { class: "address-form-error-message" };
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_TextField = resolveComponent("TextField");
    const _component_AdyenGooglePay = resolveComponent("AdyenGooglePay");
    const _component_AdyenApplePay = resolveComponent("AdyenApplePay");
    const _component_DividerComponent = resolveComponent("DividerComponent");
    const _component_PayWith = resolveComponent("PayWith");
    const _component_EmailAddress = resolveComponent("EmailAddress");
    const _component_Newsletter = resolveComponent("Newsletter");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_ClickAndCollect = resolveComponent("ClickAndCollect");
    const _component_AddressList = resolveComponent("AddressList");
    const _component_YourDetails = resolveComponent("YourDetails");
    const _component_NameFields = resolveComponent("NameFields");
    const _component_Locate = resolveComponent("Locate");
    const _component_Loqate = resolveComponent("Loqate");
    const _component_ShippingForm = resolveComponent("ShippingForm");
    const _component_LinkComponent = resolveComponent("LinkComponent");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_Edit = resolveComponent("Edit");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_BillingForm = resolveComponent("BillingForm");
    return openBlock(), createElementBlock(Fragment, null, [
      _ctx.loadingShippingMethods ? (openBlock(), createBlock(_component_Loader, { key: 0 })) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_1$h, [
        createBaseVNode("div", _hoisted_2$e, [
          withDirectives(createBaseVNode("div", _hoisted_3$b, [
            createVNode(_component_TextField, { text: $data.instantCheckoutText }, null, 8, ["text"])
          ], 512), [
            [vShow, $data.isExpressPaymentsVisible]
          ]),
          createBaseVNode("div", _hoisted_4$6, [
            (openBlock(), createBlock(_component_AdyenGooglePay, {
              onExpressPaymentsLoad: $options.expressPaymentsVisible,
              key: `adyenGooglePay-${$data.storedKey}`
            }, null, 8, ["onExpressPaymentsLoad"])),
            (openBlock(), createBlock(_component_AdyenApplePay, {
              onExpressPaymentsLoad: $options.expressPaymentsVisible,
              key: `adyenApplePay-${$data.storedKey}`
            }, null, 8, ["onExpressPaymentsLoad"]))
          ]),
          createVNode(_component_DividerComponent),
          !_ctx.emailEntered ? (openBlock(), createBlock(_component_PayWith, {
            key: 0,
            "is-express-payments-visible": $data.isExpressPaymentsVisible
          }, null, 8, ["is-express-payments-visible"])) : createCommentVNode("", true)
        ]),
        createVNode(_component_EmailAddress),
        _ctx.emailEntered && !_ctx.customer.id ? (openBlock(), createBlock(_component_Newsletter, { key: 0 })) : createCommentVNode("", true),
        _ctx.custom.clickandcollectEnabled && _ctx.emailEntered && _ctx.isItemRequiringDelivery ? (openBlock(), createElementBlock("div", _hoisted_5$5, [
          createVNode(_component_MyButton, {
            label: _ctx.$t("yourDetailsSection.deliverySection.shippingButton"),
            primary: !_ctx.isClickAndCollect,
            tertiary: _ctx.isClickAndCollect,
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.setNotClickAndCollect())
          }, null, 8, ["label", "primary", "tertiary"]),
          createVNode(_component_MyButton, {
            label: _ctx.$t("yourDetailsSection.deliverySection.clickandCollectButton"),
            tertiary: !_ctx.isClickAndCollect,
            primary: _ctx.isClickAndCollect,
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.setClickAndCollect())
          }, null, 8, ["label", "tertiary", "primary"])
        ])) : createCommentVNode("", true),
        _ctx.emailEntered && _ctx.isClickAndCollect ? (openBlock(), createElementBlock("div", _hoisted_6$4, [
          _ctx.subtotalInclTax >= _ctx.custom.clickandcollectMin && _ctx.subtotalInclTax <= _ctx.custom.clickandcollectMax ? (openBlock(), createBlock(_component_ClickAndCollect, { key: 0 })) : _ctx.subtotalInclTax < _ctx.custom.clickandcollectMin ? (openBlock(), createBlock(_component_TextField, {
            key: 1,
            class: "click-and-collect-unavilable",
            text: _ctx.$t("yourDetailsSection.deliverySection.clickandCollectThresholdLow", { price: $options.formatPrice(_ctx.custom.clickandcollectMin) })
          }, null, 8, ["text"])) : (openBlock(), createBlock(_component_TextField, {
            key: 2,
            class: "click-and-collect-unavilable",
            text: _ctx.$t("yourDetailsSection.deliverySection.clickandCollectThresholdHigh", { price: $options.formatPrice(_ctx.custom.clickandcollectMax) })
          }, null, 8, ["text"]))
        ])) : createCommentVNode("", true),
        _ctx.emailEntered && _ctx.customer.addresses.length && !_ctx.isClickAndCollect && _ctx.isItemRequiringDelivery ? (openBlock(), createBlock(_component_AddressList, {
          key: 3,
          "address-type": "shipping",
          onShowAddressBlock: $options.showAddressBlock
        }, null, 8, ["onShowAddressBlock"])) : createCommentVNode("", true),
        _ctx.emailEntered && (!_ctx.selected[$props.address_type].id || _ctx.selected[$props.address_type].id === "custom" && _ctx.selected[$props.address_type].editing) && !_ctx.isClickAndCollect && _ctx.isItemRequiringDelivery ? (openBlock(), createElementBlock("div", _hoisted_7$3, [
          createBaseVNode("div", _hoisted_8$3, [
            createBaseVNode("div", _hoisted_9$3, [
              createVNode(_component_YourDetails, { fill: "black" }),
              createVNode(_component_TextField, {
                text: _ctx.$t("yourDetailsSection.title")
              }, null, 8, ["text"])
            ]),
            createVNode(_component_NameFields, {
              address_type: $props.address_type,
              onIsCustomerInfoFull: $options.isCustomerInfoFull
            }, null, 8, ["address_type", "onIsCustomerInfoFull"]),
            $data.isAddressBlockVisible ? (openBlock(), createElementBlock("div", _hoisted_10$3, [
              createVNode(_component_Locate),
              createBaseVNode("div", _hoisted_11$2, [
                createVNode(_component_TextField, {
                  text: _ctx.$t("yourDetailsSection.deliverySection.title")
                }, null, 8, ["text"])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", null, [
              createBaseVNode("div", {
                class: normalizeClass(!$data.customerInfoValidation ? "disabled" : "")
              }, [
                !_ctx.selected[$props.address_type].id || _ctx.selected[$props.address_type].id === "custom" && _ctx.selected[$props.address_type].editing ? (openBlock(), createBlock(_component_Loqate, { key: 0 })) : createCommentVNode("", true)
              ], 2)
            ]),
            _ctx.selected[$props.address_type].editing ? (openBlock(), createBlock(_component_ShippingForm, { key: 1 })) : createCommentVNode("", true),
            !_ctx.selected[$props.address_type].id && !_ctx.selected[$props.address_type].editing && $props.address_type === "shipping" ? (openBlock(), createBlock(_component_LinkComponent, {
              key: 2,
              class: normalizeClass(["manually-button", !$data.customerInfoValidation ? "disabled" : ""]),
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.linkText"),
              onClick: withModifiers($options.editAddress, ["prevent"])
            }, null, 8, ["class", "label", "onClick"])) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true),
        _ctx.emailEntered && !_ctx.selected[$props.address_type].editing && _ctx.selected[$props.address_type].postcode && !_ctx.isUsingSavedShippingAddress && !_ctx.isClickAndCollect && _ctx.isItemRequiringDelivery ? (openBlock(), createElementBlock("div", _hoisted_12$2, [
          createVNode(_component_TextField, {
            class: "address-block__title",
            text: _ctx.$t("yourDetailsSection.deliverySection.deliveryAddressTitle")
          }, null, 8, ["text"]),
          createBaseVNode("div", _hoisted_13$2, [
            createBaseVNode("article", null, [
              createVNode(_component_AddressBlock, {
                address_type: `shipping`,
                address: _ctx.selected[$props.address_type]
              }, null, 8, ["address"])
            ])
          ]),
          _ctx.selected[$props.address_type].id ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "address-block__edit",
            onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"])),
            onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"]), ["enter"]))
          }, [
            createVNode(_component_Edit)
          ], 32)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_14$1, [
          !$data.customerInfoValidation && $data.addressFormErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 0,
            message: _ctx.$t("errorMessages.addressFormErrorMessage")
          }, null, 8, ["message"])) : createCommentVNode("", true)
        ]),
        _ctx.emailEntered && !_ctx.isClickAndCollect ? (openBlock(), createBlock(_component_BillingForm, {
          key: 6,
          onBillingInfoFull: $options.billingInfoFull
        }, null, 8, ["onBillingInfoFull"])) : createCommentVNode("", true),
        _ctx.emailEntered && !_ctx.selected[$props.address_type].editing && !_ctx.selected.billing.editing && !_ctx.isClickAndCollect && _ctx.isItemRequiringDelivery ? (openBlock(), createBlock(_component_MyButton, {
          key: 7,
          type: "submit",
          primary: "",
          label: _ctx.$t("yourDetailsSection.deliverySection.toShippingButton"),
          disabled: !_ctx.selected.shipping.id || !_ctx.customer.id && !$data.customerInfoValidation || !_ctx.selected.billing.id,
          onClick: _cache[4] || (_cache[4] = ($event) => {
            $options.submitShippingOption();
          })
        }, null, 8, ["label", "disabled"])) : createCommentVNode("", true),
        _ctx.emailEntered && !_ctx.selected.billing.editing && !_ctx.isClickAndCollect && !_ctx.isItemRequiringDelivery ? (openBlock(), createBlock(_component_MyButton, {
          key: 8,
          type: "submit",
          primary: "",
          label: $data.proceedToPayText,
          disabled: !_ctx.selected.billing.id || !_ctx.customer.id && !$data.billingInfoValidation,
          onClick: _cache[5] || (_cache[5] = ($event) => {
            _ctx.goToPayment();
          })
        }, null, 8, ["label", "disabled"])) : createCommentVNode("", true)
      ])
    ], 64);
  }
  var DetailsPage = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h], ["__scopeId", "data-v-19dca034"]]);
  const _sfc_main$g = {
    name: "AddressBlock",
    props: {
      address_type: {
        type: String,
        default: "shipping"
      },
      address: {
        default: {
          street: ["", ""],
          city: "",
          region: "",
          country_id: "",
          postcode: "",
          company: "",
          telephone: "",
          firstname: "",
          lastname: ""
        }
      }
    },
    computed: {
      showRegion() {
        const { region } = this.address;
        return region && typeof region === "string";
      }
    }
  };
  const _hoisted_1$g = { class: "address-block__address" };
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$g, [
      createBaseVNode("div", null, [
        createBaseVNode("p", null, [
          createTextVNode(toDisplayString$1($props.address.firstname) + " " + toDisplayString$1($props.address.lastname) + ", " + toDisplayString$1($props.address.street[0]) + " ", 1),
          $props.address.street[1] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString$1($props.address.street[1]), 1)
          ], 64)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString$1($props.address.city) + " ", 1),
          $options.showRegion ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString$1($props.address.region), 1)
          ], 64)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString$1($props.address.postcode) + " " + toDisplayString$1($props.address.telephone), 1)
        ])
      ])
    ]);
  }
  var AddressBlockShort = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g], ["__scopeId", "data-v-046e528f"]]);
  const _sfc_main$f = {
    name: "SavedDeliveryAddress",
    components: {
      TextField,
      AddressBlockShort,
      YourDetails,
      Edit
    },
    data() {
      return {
        detailStepText: "",
        detailStepTextId: "gene-bettercheckout-detailstep-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["isItemRequiringDelivery"]),
      ...mapState(useCustomerStore, ["selected"])
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.detailStepText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.detailStepTextId]) || this.$t("yourDetailsSection.title");
      document.addEventListener(this.detailStepTextId, this.setDetailStepText);
    },
    unmounted() {
      document.removeEventListener(this.detailStepTextId, this.setDetailStepText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setDetailStepText(event) {
        this.detailStepText = (event == null ? void 0 : event.detail) || this.$t("yourDetailsSection.title");
      },
      setDetailsStepActive() {
      }
    }
  };
  const _hoisted_1$f = { class: "delivery-address" };
  const _hoisted_2$d = { class: "details-title-section" };
  const _hoisted_3$a = { class: "details-title-section-image" };
  const _hoisted_4$5 = { class: "details-title-section-title" };
  const _hoisted_5$4 = { class: "address-block__edit proceed-to-details" };
  const _hoisted_6$3 = ["aria-label"];
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_YourDetails = resolveComponent("YourDetails");
    const _component_TextField = resolveComponent("TextField");
    const _component_AddressBlockShort = resolveComponent("AddressBlockShort");
    const _component_Edit = resolveComponent("Edit");
    return openBlock(), createElementBlock("div", _hoisted_1$f, [
      createBaseVNode("a", {
        class: "delivery-address-link",
        "aria-label": "proceed-to-details-link",
        to: "/",
        onClick: _cache[0] || (_cache[0] = ($event) => {
          $options.setDetailsStepActive();
        })
      }, [
        createBaseVNode("div", _hoisted_2$d, [
          createBaseVNode("div", _hoisted_3$a, [
            createVNode(_component_YourDetails, { fill: "black" })
          ]),
          createBaseVNode("div", _hoisted_4$5, [
            createVNode(_component_TextField, { text: $data.detailStepText }, null, 8, ["text"])
          ])
        ]),
        createVNode(_component_AddressBlockShort, {
          class: "shipping-billing-steps",
          address_type: _ctx.isItemRequiringDelivery ? `shipping` : `billing`,
          address: _ctx.isItemRequiringDelivery ? _ctx.selected.shipping : _ctx.selected.billing
        }, null, 8, ["address_type", "address"]),
        createBaseVNode("div", _hoisted_5$4, [
          createBaseVNode("button", {
            class: "button--blank edit-details-button",
            "aria-label": _ctx.$t("yourDetailsSection.editDetailsButtonLabel")
          }, [
            createVNode(_component_TextField, {
              class: "edit-button-title",
              text: _ctx.$t("yourDetailsSection.editButton")
            }, null, 8, ["text"]),
            createVNode(_component_Edit)
          ], 8, _hoisted_6$3)
        ])
      ])
    ]);
  }
  var SavedDeliveryAddress = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-e338ca24"]]);
  const _sfc_main$e = {
    name: "Calendar",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$e = ["role", "aria-label"];
  const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("path", {
    d: "M1.755 10.346h21.388m-5.37 4.688h.011m-5.334 0h.01m-5.347 0h.01m10.65 4.662h.011m-5.334 0h.01m-5.347 0h.01M17.296 1.46v3.95M7.602 1.46v3.95",
    stroke: "#252F3B",
    "stroke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_3$9 = /* @__PURE__ */ createBaseVNode("path", {
    "clip-rule": "evenodd",
    d: "M17.529 3.355H7.369c-3.525 0-5.726 1.964-5.726 5.572v10.86c0 3.665 2.201 5.673 5.725 5.673h10.15c3.535 0 5.725-1.974 5.725-5.582V8.928c.011-3.61-2.179-5.573-5.714-5.573Z",
    stroke: "#252F3B",
    "stroke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_4$4 = [
    _hoisted_2$c,
    _hoisted_3$9
  ];
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "27",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_4$4, 12, _hoisted_1$e);
  }
  var Calendar = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
  const _sfc_main$d = {
    name: "ArrowLeft",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$d = ["role", "aria-label"];
  const _hoisted_2$b = /* @__PURE__ */ createBaseVNode("path", {
    d: "M13.5 1L1.5 13L13.5 25",
    stroke: "",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_3$8 = [
    _hoisted_2$b
  ];
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "15",
      height: "26",
      viewBox: "0 0 15 26",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$8, 12, _hoisted_1$d);
  }
  var ArrowLeft = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
  const _sfc_main$c = {
    name: "ArrowRight",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$c = ["role", "aria-label"];
  const _hoisted_2$a = /* @__PURE__ */ createBaseVNode("path", {
    d: "M1.5 25L13.5 13L1.5 1",
    stroke: "",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_3$7 = [
    _hoisted_2$a
  ];
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "15",
      height: "26",
      viewBox: "0 0 15 26",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$7, 12, _hoisted_1$c);
  }
  var ArrowRight = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
  const _sfc_main$b = {
    name: "NominatedDay",
    components: {
      Loader,
      TextField,
      Calendar,
      ArrowLeft,
      ArrowRight
    },
    props: {
      item: {
        type: Object,
        default() {
          return {
            method_code: "",
            carrier_code: ""
          };
        }
      }
    },
    data() {
      return {
        showCalender: false,
        isKeyboard: false,
        day: null,
        month: null,
        year: null,
        loadingNominatedDay: false,
        emptyDays: 0,
        weekdays: [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ]
      };
    },
    computed: {
      ...mapWritableState(useShippingMethodsStore, ["nominatedSelectedMethod", "nominatedSelectedDate", "nominatedSelectedDateFormatted"]),
      ...mapState(useShippingMethodsStore, ["nominatedDates"]),
      today() {
        return new Date();
      },
      disablePrevArrow() {
        return this.month <= this.today.getMonth();
      },
      disableNextArrow() {
        return this.month >= this.today.getMonth() + 1;
      }
    },
    mounted() {
      const { today } = this;
      this.day = today.getDate();
      this.month = today.getMonth();
      this.year = today.getFullYear();
    },
    methods: {
      ...mapActions(useShippingMethodsStore, ["selectShippingMethod", "submitShippingInfo"]),
      openCalendar() {
        this.showCalender = true;
      },
      closeCalendar() {
        this.showCalender = false;
      },
      getMonth(month = false) {
        const months = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ];
        return month ? months[month] : months[this.month];
      },
      formatedSelectedDate(date) {
        const day = date.getDate() + (date.getDate() % 10 === 1 && date.getDate() !== 11 ? "st" : date.getDate() % 10 === 2 && date.getDate() !== 12 ? "nd" : date.getDate() % 10 === 3 && date.getDate() !== 13 ? "rd" : "th");
        const weekday = this.weekdays[date.getDay()];
        return `${weekday}, ${this.getMonth()} ${day} ${this.year}`;
      },
      async selectDate(date) {
        this.loadingNominatedDay = true;
        this.nominatedSelectedDate = date;
        this.nominatedSelectedDateFormatted = this.formatedSelectedDate(date);
        this.selectShippingMethod({
          nominatedSelectedDate: this.nominatedSelectedDate,
          nominatedSelectedDateFormatted: this.nominatedSelectedDateFormatted,
          ...this.item
        });
        await this.submitShippingInfo();
        this.loadingNominatedDay = false;
        this.closeCalendar();
      },
      numberOfDaysInMonth() {
        const date = new Date(this.year, this.month, 1);
        const dates = [];
        this.emptyDays = date.getDay();
        while (date.getMonth() === this.month) {
          dates.push(new Date(date));
          date.setDate(date.getDate() + 1);
        }
        return dates;
      },
      getDateLabel(date) {
        return date.getDate();
      },
      increaseMonth() {
        if (this.month + 1 === 12) {
          this.month = 0;
          this.year++;
        } else {
          this.month++;
        }
      },
      decreaseMonth() {
        if (this.month === 0) {
          this.month = 11;
          this.year--;
        } else {
          this.month--;
        }
      },
      isDateInPast(date) {
        return date.getTime() < this.today.getTime() - 1;
      },
      isAvailableDate(currentDate) {
        if (this.isDateInPast(currentDate)) {
          return false;
        }
        return this.nominatedDates.filter((method) => {
          if (method) {
            const date = new Date(method);
            return date.getTime() === currentDate.getTime();
          }
        }).length > 0;
      },
      compareDates(firstDate, secondDate) {
        firstDate = new Date(firstDate);
        return firstDate.getTime() === secondDate.getTime();
      }
    }
  };
  const _withScopeId = (n) => (pushScopeId("data-v-2cce7578"), n = n(), popScopeId(), n);
  const _hoisted_1$b = { class: "nominated-container" };
  const _hoisted_2$9 = ["aria-modal"];
  const _hoisted_3$6 = { class: "calendar-header" };
  const _hoisted_4$3 = ["disabled"];
  const _hoisted_5$3 = { class: "calendar-header-date" };
  const _hoisted_6$2 = ["disabled"];
  const _hoisted_7$2 = { class: "calendar-week" };
  const _hoisted_8$2 = ["textContent"];
  const _hoisted_9$2 = { class: "calendar" };
  const _hoisted_10$2 = ["onClick"];
  const _hoisted_11$1 = { class: "calendar-radio-label" };
  const _hoisted_12$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "calendar-button-symbol" }, null, -1));
  const _hoisted_13$1 = {
    key: 1,
    class: "calendar-span"
  };
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_Calendar = resolveComponent("Calendar");
    const _component_Loader = resolveComponent("Loader");
    const _component_ArrowLeft = resolveComponent("ArrowLeft");
    const _component_ArrowRight = resolveComponent("ArrowRight");
    return openBlock(), createElementBlock("section", _hoisted_1$b, [
      createBaseVNode("button", {
        ref: "nominated",
        class: "nominated-select",
        type: "button",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.openCalendar && $options.openCalendar(...args), ["prevent"]))
      }, [
        _ctx.nominatedSelectedDate ? (openBlock(), createBlock(_component_TextField, {
          key: 0,
          text: $options.formatedSelectedDate(_ctx.nominatedSelectedDate),
          class: "nominated-select-textfield"
        }, null, 8, ["text"])) : (openBlock(), createBlock(_component_TextField, {
          key: 1,
          text: _ctx.$t("shippingStep.nominatedDelivery"),
          class: "nominated-select-textfield"
        }, null, 8, ["text"])),
        createVNode(_component_Calendar, { stroke: "black" })
      ], 512),
      withDirectives(createVNode(Transition, { name: "fade" }, {
        default: withCtx(() => [
          createBaseVNode("button", {
            class: "nominated-overlay",
            onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.closeCalendar && $options.closeCalendar(...args), ["prevent"]))
          })
        ]),
        _: 1
      }, 512), [
        [vShow, $data.showCalender]
      ]),
      createVNode(Transition, { name: "slide-mobile" }, {
        default: withCtx(() => [
          withDirectives((openBlock(), createElementBlock("div", {
            id: "nominated-calendar",
            key: _ctx.selectedView,
            class: "calendar-container",
            role: "dialog",
            "aria-labelledby": "calendar-tile",
            "aria-describedby": "calendar-description",
            "aria-modal": $data.showCalender,
            onKeyup: _cache[4] || (_cache[4] = withKeys(($event) => $options.closeCalendar(), ["esc"]))
          }, [
            withDirectives(createBaseVNode("div", null, [
              createVNode(_component_Loader)
            ], 512), [
              [vShow, $data.loadingNominatedDay]
            ]),
            createBaseVNode("header", _hoisted_3$6, [
              createBaseVNode("button", {
                type: "button",
                class: "calendar-header-button",
                disabled: $options.disablePrevArrow,
                onClick: _cache[2] || (_cache[2] = ($event) => $options.decreaseMonth())
              }, [
                createVNode(_component_ArrowLeft, {
                  width: "8px",
                  stroke: "black"
                })
              ], 8, _hoisted_4$3),
              createBaseVNode("p", _hoisted_5$3, toDisplayString$1($options.getMonth()) + " " + toDisplayString$1($data.year), 1),
              createBaseVNode("button", {
                type: "button",
                class: "calendar-header-button",
                disabled: $options.disableNextArrow,
                onClick: _cache[3] || (_cache[3] = ($event) => $options.increaseMonth())
              }, [
                createVNode(_component_ArrowRight, {
                  width: "8px",
                  stroke: "black"
                })
              ], 8, _hoisted_6$2)
            ]),
            createBaseVNode("ol", _hoisted_7$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.weekdays, (date) => {
                return openBlock(), createElementBlock("li", {
                  key: date,
                  class: "calendar-week-day"
                }, [
                  createBaseVNode("span", {
                    textContent: toDisplayString$1(date.substring(0, 2))
                  }, null, 8, _hoisted_8$2)
                ]);
              }), 128))
            ]),
            createBaseVNode("ol", _hoisted_9$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.emptyDays, (date) => {
                return openBlock(), createElementBlock("li", {
                  key: date,
                  class: "calendar-day"
                });
              }), 128)),
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.numberOfDaysInMonth(), (date) => {
                return openBlock(), createElementBlock("li", {
                  key: date,
                  class: normalizeClass(["calendar-day", {
                    "calendar-day--in-past": $options.isDateInPast(date),
                    "calendar-day--available": $options.isAvailableDate(date)
                  }])
                }, [
                  $options.isAvailableDate(date) ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    type: "button",
                    class: normalizeClass(["calendar-button", {
                      "active": $options.compareDates(_ctx.nominatedSelectedDate, date)
                    }]),
                    onClick: ($event) => $options.selectDate(date)
                  }, [
                    createBaseVNode("span", _hoisted_11$1, [
                      createBaseVNode("span", null, toDisplayString$1($options.getDateLabel(date)), 1),
                      _hoisted_12$1
                    ])
                  ], 10, _hoisted_10$2)) : (openBlock(), createElementBlock("span", _hoisted_13$1, toDisplayString$1($options.getDateLabel(date)), 1))
                ], 2);
              }), 128))
            ])
          ], 40, _hoisted_2$9)), [
            [vShow, $data.showCalender]
          ])
        ]),
        _: 1
      })
    ]);
  }
  var NominatedDay = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-2cce7578"]]);
  const _sfc_main$a = {
    name: "ShippingMethod",
    components: {
      TextField,
      Loader,
      Shipping,
      NominatedDay,
      MyButton
    },
    props: {
      buttonText: {
        type: String,
        default: "Continue to Payment"
      }
    },
    data() {
      return {
        nominatedId: "nominated_delivery",
        hasSubmitted: false,
        shippingStepText: "",
        shippingStepTextId: "gene-bettercheckout-shippingstep-text",
        proceedToPayText: "",
        proceedToPayTextId: "gene-bettercheckout-proceedtopay-text"
      };
    },
    computed: {
      ...mapState(useConfigStore, ["taxCartDisplayShipping"]),
      ...mapState(useCustomerStore, ["selected"]),
      ...mapState(useShippingMethodsStore, [
        "loadingShippingMethods",
        "getError",
        "nominatedDayEnabled",
        "nominatedPrice",
        "shippingMethods",
        "selectedMethod"
      ])
    },
    async created() {
      var _a, _b;
      await this.getStoreConfig();
      this.shippingStepText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.shippingStepTextId]) || this.$t("shippingStep.stepTitle");
      this.proceedToPayText = ((_b = window.geneCheckout) == null ? void 0 : _b[this.proceedToPayTextId]) || this.$t("shippingStep.proceedToPay");
      document.addEventListener(this.shippingStepTextId, this.setShippingStepText);
      document.addEventListener(this.proceedToPayTextId, this.setProceedToPayText);
    },
    unmounted() {
      document.removeEventListener(this.shippingStepTextId, this.setShippingStepText);
      document.addEventListener(this.proceedToPayTextId, this.setProceedToPayText);
    },
    methods: {
      ...mapActions(useShippingMethodsStore, [
        "submitShippingInfo",
        "selectShippingMethod",
        "setShippingMethodTitle",
        "clearSubmitShippingInfoCache"
      ]),
      ...mapActions(usePaymentStore, ["setPaymentMethods"]),
      ...mapActions(useCartStore, ["getCartTotals"]),
      ...mapActions(useStepsStore, ["goToPayment"]),
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setShippingStepText(event) {
        this.shippingStepText = (event == null ? void 0 : event.detail) || this.$t("shippingStep.stepTitle");
      },
      setProceedToPayText(event) {
        this.proceedToPayText = (event == null ? void 0 : event.detail) || this.$t("shippingStep.proceedToPay");
      },
      formatPrice(price) {
        if (price === 0) {
          return "FREE";
        }
        return formatPrice(price);
      },
      async handleChange(item) {
      },
      async checkChangedAddress() {
      }
    }
  };
  const _hoisted_1$a = { class: "checkout-section checkout-shipping" };
  const _hoisted_2$8 = { key: 0 };
  const _hoisted_3$5 = { class: "checkout-shipping-methods" };
  const _hoisted_4$2 = { class: "checkout-shipping-methods__title" };
  const _hoisted_5$2 = { class: "checkout-shipping-methods__title-icon" };
  const _hoisted_6$1 = { class: "title" };
  const _hoisted_7$1 = { key: 0 };
  const _hoisted_8$1 = ["for"];
  const _hoisted_9$1 = { class: "shipping-method__input" };
  const _hoisted_10$1 = ["id", "checked", "onChange"];
  const _hoisted_11 = { class: "shipping-method__content" };
  const _hoisted_12 = ["for"];
  const _hoisted_13 = { class: "shipping-method__input" };
  const _hoisted_14 = ["id", "checked", "onChange"];
  const _hoisted_15 = { class: "shipping-method__content" };
  const _hoisted_16 = ["innerHTML"];
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_Shipping = resolveComponent("Shipping");
    const _component_TextField = resolveComponent("TextField");
    const _component_NominatedDay = resolveComponent("NominatedDay");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock("section", null, [
      createBaseVNode("div", _hoisted_1$a, [
        _ctx.loadingShippingMethods ? (openBlock(), createElementBlock("div", _hoisted_2$8, [
          createVNode(_component_Loader)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$5, [
          createBaseVNode("div", _hoisted_4$2, [
            createBaseVNode("div", _hoisted_5$2, [
              createVNode(_component_Shipping, { fill: "black" })
            ]),
            createBaseVNode("div", _hoisted_6$1, [
              createVNode(_component_TextField, {
                class: "main-text",
                text: $data.shippingStepText
              }, null, 8, ["text"])
            ])
          ]),
          _ctx.shippingMethods.length ? (openBlock(), createElementBlock("ul", _hoisted_7$1, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shippingMethods, (item) => {
              return openBlock(), createElementBlock("li", {
                key: item.carrier_code,
                class: "shipping-method"
              }, [
                item.method_code !== $data.nominatedId ? (openBlock(), createElementBlock("label", {
                  key: 0,
                  for: item.method_code,
                  class: "shipping-method__label"
                }, [
                  createBaseVNode("span", _hoisted_9$1, [
                    createBaseVNode("input", {
                      id: item.method_code,
                      checked: item.method_code === _ctx.selectedMethod.method_code,
                      type: "radio",
                      name: "shipping-option",
                      onChange: ($event) => $options.handleChange(item)
                    }, null, 40, _hoisted_10$1)
                  ]),
                  createBaseVNode("span", _hoisted_11, [
                    createVNode(_component_TextField, {
                      text: item.method_title
                    }, null, 8, ["text"]),
                    createVNode(_component_TextField, {
                      text: item.carrier_title
                    }, null, 8, ["text"])
                  ])
                ], 8, _hoisted_8$1)) : (openBlock(), createElementBlock("label", {
                  key: 1,
                  for: $data.nominatedId,
                  class: "shipping-method__label"
                }, [
                  createBaseVNode("span", _hoisted_13, [
                    createBaseVNode("input", {
                      id: $data.nominatedId,
                      checked: item.method_code === _ctx.selectedMethod.method_code,
                      type: "radio",
                      name: "shipping-option",
                      onChange: ($event) => $options.handleChange(item)
                    }, null, 40, _hoisted_14)
                  ]),
                  createBaseVNode("span", _hoisted_15, [
                    createVNode(_component_TextField, {
                      text: item.method_title
                    }, null, 8, ["text"]),
                    createVNode(_component_TextField, {
                      text: item.carrier_title
                    }, null, 8, ["text"])
                  ])
                ], 8, _hoisted_12)),
                _ctx.taxCartDisplayShipping ? (openBlock(), createBlock(_component_TextField, {
                  key: 2,
                  text: $options.formatPrice(item.price_incl_tax)
                }, null, 8, ["text"])) : (openBlock(), createBlock(_component_TextField, {
                  key: 3,
                  text: $options.formatPrice(item.price_excl_tax)
                }, null, 8, ["text"])),
                item.carrier_code === $data.nominatedId && _ctx.nominatedDayEnabled && _ctx.selectedMethod.carrier_code === $data.nominatedId ? (openBlock(), createBlock(_component_NominatedDay, {
                  key: 4,
                  item
                }, null, 8, ["item"])) : createCommentVNode("", true)
              ]);
            }), 128))
          ])) : !_ctx.shippingMethods.length ? (openBlock(), createBlock(_component_TextField, {
            key: 1,
            class: "checkout-shipping-methods__error",
            text: _ctx.$t("errorMessages.noShippingMethods")
          }, null, 8, ["text"])) : _ctx.getError ? (openBlock(), createElementBlock("span", {
            key: 2,
            innerHTML: _ctx.getError
          }, null, 8, _hoisted_16)) : createCommentVNode("", true)
        ]),
        createVNode(_component_MyButton, {
          type: "submit",
          primary: "",
          label: $data.proceedToPayText,
          disabled: !_ctx.shippingMethods.length || !_ctx.selectedMethod.method_code || _ctx.loadingShippingMethods,
          onClick: _cache[0] || (_cache[0] = ($event) => {
            $options.checkChangedAddress();
          })
        }, null, 8, ["label", "disabled"])
      ])
    ]);
  }
  var ShippingMethod = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-6273b31b"]]);
  const _sfc_main$9 = {
    name: "ShippingPage",
    components: {
      SavedDeliveryAddress,
      ShippingMethod
    },
    computed: {
      ...mapState(useConfigStore, ["storeCode"])
    },
    async created() {
      if (!this.storeCode) {
        await this.getStoreConfig();
      }
    },
    methods: {
      ...mapActions(useCartStore, ["getCart", "getCartData"]),
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      ...mapActions(useShippingMethodsStore, ["getShippingMethods"]),
      ...mapActions(useGtmStore, ["trackStep"])
    }
  };
  const _hoisted_1$9 = { class: "shipping-step" };
  const _hoisted_2$7 = { class: "shipping-form" };
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_SavedDeliveryAddress = resolveComponent("SavedDeliveryAddress");
    const _component_ShippingMethod = resolveComponent("ShippingMethod");
    return openBlock(), createElementBlock("div", _hoisted_1$9, [
      createVNode(_component_SavedDeliveryAddress),
      createBaseVNode("div", _hoisted_2$7, [
        createVNode(_component_ShippingMethod)
      ])
    ]);
  }
  var ShippingPage = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-64d4e8ac"]]);
  const _sfc_main$8 = {
    name: "AdyenDropIn",
    components: {
      Payment,
      TextField
    },
    data() {
      return {
        errorMessage: "",
        orderId: null,
        storedPaymentsId: "adyen-dropin-container-stored",
        adyenKey: 0,
        storedKey: 0,
        paymentStepText: "",
        paymentStepTextId: "gene-bettercheckout-paymentstep-text"
      };
    },
    computed: {
      ...mapState(usePaymentStore, ["loadingPaymentMethods"]),
      ...mapState(useCartStore, ["cartEmitter"]),
      ...mapState(useCustomerStore, [
        "customer",
        "getSelectedBillingAddress",
        "getSelectedShippingAddress",
        "isLoggedIn"
      ]),
      ...mapState(useConfigStore, ["currencyCode", "locale", "adyenVaultEnabled"])
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.paymentStepText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.paymentStepTextId]) || this.$t("paymentStep.title");
      document.addEventListener(this.paymentStepTextId, this.setPaymentStepText);
    },
    unmounted() {
      document.removeEventListener(this.paymentStepTextId, this.setPaymentStepText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setPaymentStepText(event) {
        this.paymentStepText = (event == null ? void 0 : event.detail) || this.$t("paymentStep.title");
      }
    }
  };
  const _hoisted_1$8 = { class: "adyen-payment__title" };
  const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("div", { id: "adyen-dropin-container-new" }, [
    /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__dropin adyen-checkout__dropin--ready" }, [
      /* @__PURE__ */ createBaseVNode("ul", {
        class: "DropinComponent-module_adyen-checkout__payment-methods-list__mAjAm adyen-checkout__payment-methods-list",
        role: "radiogroup",
        "aria-label": "Choose a payment method",
        required: "true"
      }, [
        /* @__PURE__ */ createBaseVNode("li", { class: "adyen-checkout__payment-method DropinComponent-module_adyen-checkout__payment-method__nWdwg adyen-checkout__payment-method--card adyen-checkout__payment-method--credit adyen-checkout__payment-method--selected DropinComponent-module_adyen-checkout__payment-method--selected__6egZF scheme-c77cc0a4-8978-4717-a3d6-b439d66d539b" }, [
          /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__payment-method__header" }, [
            /* @__PURE__ */ createBaseVNode("button", {
              class: "adyen-checkout__payment-method__header__title",
              id: "button-scheme-c77cc0a4-8978-4717-a3d6-b439d66d539b",
              role: "radio",
              type: "button",
              "aria-checked": "true"
            }, [
              /* @__PURE__ */ createBaseVNode("span", {
                class: "adyen-checkout__payment-method__radio adyen-checkout__payment-method__radio--selected",
                "aria-hidden": "true"
              }),
              /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__payment-method__image__wrapper DropinComponent-module_adyen-checkout__payment-method__image__wrapper__6NWzA adyen-checkout__payment-method__image__wrapper--outline" }, [
                /* @__PURE__ */ createBaseVNode("img", {
                  class: "adyen-checkout__payment-method__image DropinComponent-module_adyen-checkout__payment-method__image__nB80V adyen-checkout__image adyen-checkout__image--loaded",
                  src: "https://checkoutshopper-test.adyen.com/checkoutshopper/images/logos/card.svg",
                  alt: "Credit or debit card"
                })
              ]),
              /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__payment-method__name adyen-checkout__payment-method__name--selected" }, "Credit or debit card")
            ])
          ]),
          /* @__PURE__ */ createBaseVNode("div", {
            class: "adyen-checkout__payment-method__details DropinComponent-module_adyen-checkout__payment-method__details__-rsW7",
            id: "container-scheme-c77cc0a4-8978-4717-a3d6-b439d66d539b",
            role: "region",
            "aria-labelledby": "button-scheme-c77cc0a4-8978-4717-a3d6-b439d66d539b"
          }, [
            /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__payment-method__details__content" }, [
              /* @__PURE__ */ createBaseVNode("div", {
                class: "adyen-checkout__card-input CardInput-module_card-input__wrapper__wXSCw adyen-checkout__card-input--credit",
                role: "form",
                "aria-describedby": "creditCardErrors"
              }, [
                /* @__PURE__ */ createBaseVNode("div", { style: { "position": "relative" } }, [
                  /* @__PURE__ */ createBaseVNode("div", { class: "LoadingWrapper-module_loading-input__spinner__GxA51" }, [
                    /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__spinner__wrapper" }, [
                      /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__spinner adyen-checkout__spinner--large" })
                    ])
                  ]),
                  /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__loading-input__form LoadingWrapper-module_loading-input__form__ffCKa" }, [
                    /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__card__form" }, [
                      /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__field adyen-checkout__field--cardNumber" }, [
                        /* @__PURE__ */ createBaseVNode("label", {
                          class: "adyen-checkout__label",
                          for: "adyen-checkout-encryptedCardNumber-1705503916981"
                        }, [
                          /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__label__text" }, "Card number"),
                          /* @__PURE__ */ createBaseVNode("div", {
                            class: "adyen-checkout__input-wrapper",
                            dir: "ltr"
                          }, [
                            /* @__PURE__ */ createBaseVNode("span", {
                              "data-cse": "encryptedCardNumber",
                              "data-uid": "adyen-checkout-encryptedCardNumber-1705503916981",
                              class: "adyen-checkout__input adyen-checkout__input--large adyen-checkout__card__cardNumber__input CardInput-module_adyen-checkout__input__11tlB"
                            }, [
                              /* @__PURE__ */ createBaseVNode("img", {
                                class: "CardInput-module_card-input__icon__3Cz5M adyen-checkout__card__cardNumber__brandIcon",
                                alt: "card",
                                src: "https://checkoutshopper-test.adyen.com/checkoutshopper/images/logos/nocard.svg",
                                "aria-hidden": "true"
                              })
                            ])
                          ])
                        ])
                      ]),
                      /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__card__brands" }, [
                        /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__card__brands__brand-wrapper" }, [
                          /* @__PURE__ */ createBaseVNode("img", {
                            src: "https://checkoutshopper-test.adyen.com/checkoutshopper/images/logos/visa.svg",
                            alt: "",
                            class: "adyen-checkout__image adyen-checkout__image--loaded"
                          })
                        ]),
                        /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__card__brands__brand-wrapper" }, [
                          /* @__PURE__ */ createBaseVNode("img", {
                            src: "https://checkoutshopper-test.adyen.com/checkoutshopper/images/logos/mc.svg",
                            alt: "",
                            class: "adyen-checkout__image adyen-checkout__image--loaded"
                          })
                        ])
                      ]),
                      /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__card__exp-cvc adyen-checkout__field-wrapper" }, [
                        /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__field adyen-checkout__field--50 adyen-checkout__field__exp-date adyen-checkout__field--expiryDate" }, [
                          /* @__PURE__ */ createBaseVNode("label", {
                            class: "adyen-checkout__label",
                            for: "adyen-checkout-encryptedExpiryDate-1705503916982"
                          }, [
                            /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__label__text" }, "Expiry date"),
                            /* @__PURE__ */ createBaseVNode("div", {
                              class: "adyen-checkout__input-wrapper",
                              dir: "ltr"
                            }, [
                              /* @__PURE__ */ createBaseVNode("span", {
                                "data-cse": "encryptedExpiryDate",
                                "data-uid": "adyen-checkout-encryptedExpiryDate-1705503916982",
                                class: "adyen-checkout__input adyen-checkout__input--small adyen-checkout__card__exp-date__input CardInput-module_adyen-checkout__input__11tlB"
                              }),
                              /* @__PURE__ */ createBaseVNode("div", {
                                class: "adyen-checkout__field__exp-date_hint_wrapper",
                                uniqueid: "adyen-checkout-encryptedExpiryDate-1705503916982"
                              }, [
                                /* @__PURE__ */ createBaseVNode("img", {
                                  src: "https://checkoutshopper-test.adyen.com/checkoutshopper/images/components/expiry_date_hint.svg",
                                  class: "adyen-checkout__field__exp-date_hint",
                                  alt: "Expiry date"
                                })
                              ])
                            ])
                          ])
                        ]),
                        /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__field adyen-checkout__field--50 adyen-checkout__field__cvc adyen-checkout__field--securityCode" }, [
                          /* @__PURE__ */ createBaseVNode("label", {
                            class: "adyen-checkout__label",
                            for: "adyen-checkout-encryptedSecurityCode-1705503916983"
                          }, [
                            /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__label__text" }, "CVC / CVV"),
                            /* @__PURE__ */ createBaseVNode("div", {
                              class: "adyen-checkout__input-wrapper",
                              dir: "ltr"
                            }, [
                              /* @__PURE__ */ createBaseVNode("span", {
                                "data-cse": "encryptedSecurityCode",
                                "data-uid": "adyen-checkout-encryptedSecurityCode-1705503916983",
                                class: "adyen-checkout__input adyen-checkout__input--small adyen-checkout__card__cvc__input CardInput-module_adyen-checkout__input__11tlB"
                              }),
                              /* @__PURE__ */ createBaseVNode("div", {
                                class: "adyen-checkout__card__cvc__hint__wrapper adyen-checkout__field__cvc--back-hint",
                                "aria-hidden": "true"
                              }, [
                                /* @__PURE__ */ createBaseVNode("svg", {
                                  class: "adyen-checkout__card__cvc__hint adyen-checkout__card__cvc__hint--front",
                                  width: "27",
                                  height: "18",
                                  viewBox: "0 0 27 18",
                                  fill: "none",
                                  xmlns: "http://www.w3.org/2000/svg"
                                }, [
                                  /* @__PURE__ */ createBaseVNode("path", {
                                    d: "M0 3C0 1.34315 1.34315 0 3 0H24C25.6569 0 27 1.34315 27 3V15C27 16.6569 25.6569 18 24 18H3C1.34315 18 0 16.6569 0 15V3Z",
                                    fill: "#E6E9EB"
                                  }),
                                  /* @__PURE__ */ createBaseVNode("rect", {
                                    x: "4",
                                    y: "12",
                                    width: "19",
                                    height: "2",
                                    fill: "#B9C4C9"
                                  }),
                                  /* @__PURE__ */ createBaseVNode("rect", {
                                    x: "4",
                                    y: "4",
                                    width: "4",
                                    height: "4",
                                    rx: "1",
                                    fill: "white"
                                  }),
                                  /* @__PURE__ */ createBaseVNode("rect", {
                                    class: "adyen-checkout__card__cvc__hint__location",
                                    x: "16.5",
                                    y: "4.5",
                                    width: "7",
                                    height: "5",
                                    rx: "2.5",
                                    stroke: "#C12424"
                                  })
                                ]),
                                /* @__PURE__ */ createBaseVNode("svg", {
                                  class: "adyen-checkout__card__cvc__hint adyen-checkout__card__cvc__hint--back",
                                  width: "27",
                                  height: "18",
                                  viewBox: "0 0 27 18",
                                  fill: "none",
                                  xmlns: "http://www.w3.org/2000/svg"
                                }, [
                                  /* @__PURE__ */ createBaseVNode("path", {
                                    d: "M27 4.00001V3.37501C27 2.4799 26.6444 1.62146 26.0115 0.988518C25.3786 0.355581 24.5201 0 23.625 0H3.375C2.47989 0 1.62145 0.355581 0.988514 0.988518C0.355579 1.62146 0 2.4799 0 3.37501V4.00001H27Z",
                                    fill: "#E6E9EB"
                                  }),
                                  /* @__PURE__ */ createBaseVNode("path", {
                                    d: "M0 6.99994V14.6666C0 15.5507 0.355579 16.3985 0.988514 17.0237C1.62145 17.6488 2.47989 18 3.375 18H23.625C24.5201 18 25.3786 17.6488 26.0115 17.0237C26.6444 16.3985 27 15.5507 27 14.6666V6.99994H0Z",
                                    fill: "#E6E9EB"
                                  }),
                                  /* @__PURE__ */ createBaseVNode("rect", {
                                    y: "4.00012",
                                    width: "27",
                                    height: "3.00001",
                                    fill: "#687282"
                                  }),
                                  /* @__PURE__ */ createBaseVNode("path", {
                                    d: "M4 11C4 10.4477 4.44772 10 5 10H21C22.1046 10 23 10.8954 23 12C23 13.1046 22.1046 14 21 14H5C4.44771 14 4 13.5523 4 13V11Z",
                                    fill: "white"
                                  }),
                                  /* @__PURE__ */ createBaseVNode("rect", {
                                    class: "adyen-checkout__card__cvc__hint__location",
                                    x: "16.5",
                                    y: "9.5",
                                    width: "7",
                                    height: "5",
                                    rx: "2.5",
                                    stroke: "#C12424"
                                  })
                                ])
                              ])
                            ])
                          ])
                        ])
                      ])
                    ])
                  ])
                ])
              ]),
              /* @__PURE__ */ createBaseVNode("button", {
                class: "adyen-checkout__button adyen-checkout__button--pay",
                type: "button"
              }, [
                /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__button__content" }, [
                  /* @__PURE__ */ createBaseVNode("img", {
                    class: "adyen-checkout__button__icon",
                    src: "https://checkoutshopper-test.adyen.com/checkoutshopper/images/components/lock.svg",
                    alt: "",
                    "aria-hidden": "true"
                  }),
                  /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__button__text" }, "Pay \xA315.94")
                ])
              ])
            ])
          ])
        ]),
        /* @__PURE__ */ createBaseVNode("li", { class: "adyen-checkout__payment-method DropinComponent-module_adyen-checkout__payment-method__nWdwg adyen-checkout__payment-method--paypal adyen-checkout__payment-method--credit paypal-3ff5b853-2413-48f1-a3cb-a55cef56ee7d" }, [
          /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__payment-method__header" }, [
            /* @__PURE__ */ createBaseVNode("button", {
              class: "adyen-checkout__payment-method__header__title",
              id: "button-paypal-3ff5b853-2413-48f1-a3cb-a55cef56ee7d",
              role: "radio",
              type: "button",
              "aria-checked": "false"
            }, [
              /* @__PURE__ */ createBaseVNode("span", {
                class: "adyen-checkout__payment-method__radio",
                "aria-hidden": "true"
              }),
              /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__payment-method__image__wrapper DropinComponent-module_adyen-checkout__payment-method__image__wrapper__6NWzA adyen-checkout__payment-method__image__wrapper--outline" }, [
                /* @__PURE__ */ createBaseVNode("img", {
                  class: "adyen-checkout__payment-method__image DropinComponent-module_adyen-checkout__payment-method__image__nB80V adyen-checkout__image adyen-checkout__image--loaded",
                  src: "https://checkoutshopper-test.adyen.com/checkoutshopper/images/logos/paypal.svg",
                  alt: "PayPal"
                })
              ]),
              /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__payment-method__name" }, "PayPal")
            ])
          ]),
          /* @__PURE__ */ createBaseVNode("div", {
            class: "adyen-checkout__payment-method__details DropinComponent-module_adyen-checkout__payment-method__details__-rsW7",
            id: "container-paypal-3ff5b853-2413-48f1-a3cb-a55cef56ee7d",
            role: "region",
            "aria-labelledby": "button-paypal-3ff5b853-2413-48f1-a3cb-a55cef56ee7d"
          })
        ]),
        /* @__PURE__ */ createBaseVNode("li", { class: "adyen-checkout__payment-method DropinComponent-module_adyen-checkout__payment-method__nWdwg adyen-checkout__payment-method--googlepay adyen-checkout__payment-method--credit paywithgoogle-ba457938-6181-48b7-b553-9022f0807344" }, [
          /* @__PURE__ */ createBaseVNode("div", { class: "adyen-checkout__payment-method__header" }, [
            /* @__PURE__ */ createBaseVNode("button", {
              class: "adyen-checkout__payment-method__header__title",
              id: "button-paywithgoogle-ba457938-6181-48b7-b553-9022f0807344",
              role: "radio",
              type: "button",
              "aria-checked": "false"
            }, [
              /* @__PURE__ */ createBaseVNode("span", {
                class: "adyen-checkout__payment-method__radio",
                "aria-hidden": "true"
              }),
              /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__payment-method__image__wrapper DropinComponent-module_adyen-checkout__payment-method__image__wrapper__6NWzA" }, [
                /* @__PURE__ */ createBaseVNode("img", {
                  class: "adyen-checkout__payment-method__image DropinComponent-module_adyen-checkout__payment-method__image__nB80V adyen-checkout__image adyen-checkout__image--loaded",
                  src: "https://checkoutshopper-test.adyen.com/checkoutshopper/images/logos/googlepay.svg",
                  alt: "Google Pay"
                })
              ]),
              /* @__PURE__ */ createBaseVNode("span", { class: "adyen-checkout__payment-method__name" }, "Google Pay")
            ])
          ]),
          /* @__PURE__ */ createBaseVNode("div", {
            class: "adyen-checkout__payment-method__details DropinComponent-module_adyen-checkout__payment-method__details__-rsW7",
            id: "container-paywithgoogle-ba457938-6181-48b7-b553-9022f0807344",
            role: "region",
            "aria-labelledby": "button-paywithgoogle-ba457938-6181-48b7-b553-9022f0807344"
          })
        ])
      ])
    ])
  ], -1);
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Payment = resolveComponent("Payment");
    const _component_TextField = resolveComponent("TextField");
    const _component_AdyenPaymentMethods = resolveComponent("AdyenPaymentMethods");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$8, [
        createVNode(_component_Payment, {
          class: "adyen-payment__icon",
          fill: "black"
        }),
        !_ctx.storedPayments ? (openBlock(), createBlock(_component_TextField, {
          key: 0,
          class: "adyen-payment__header",
          text: $data.paymentStepText
        }, null, 8, ["text"])) : createCommentVNode("", true)
      ]),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.loadingPaymentMethods ? "text-loading" : "")
      }, [
        _ctx.isLoggedIn && _ctx.adyenVaultEnabled ? (openBlock(), createBlock(_component_AdyenPaymentMethods, {
          id: $data.storedPaymentsId,
          key: `storePayments-${$data.storedKey}`,
          "stored-payments": true
        }, null, 8, ["id"])) : createCommentVNode("", true),
        _hoisted_2$6
      ], 2)
    ], 64);
  }
  var AdyenDropIn = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
  const _sfc_main$7 = {
    name: "SavedShippingMethod",
    components: {
      TextField,
      Shipping,
      Price,
      Edit
    },
    data() {
      return {
        shippingStepCompletedText: "",
        shippingStepCompletedTextId: "gene-bettercheckout-shippingstepcompleted-text"
      };
    },
    async created() {
      var _a;
      await this.getStoreConfig();
      this.shippingStepCompletedText = ((_a = window.geneCheckout) == null ? void 0 : _a[this.shippingStepCompletedTextId]) || this.$t("shippingStep.stepCompleteTitle");
      document.addEventListener(this.shippingStepCompletedTextId, this.setShippingStepText);
    },
    unmounted() {
      document.removeEventListener(this.shippingStepCompletedTextId, this.setShippingStepText);
    },
    computed: {
      ...mapState(useCartStore, ["totalSegments", "shippingPrice"]),
      ...mapState(useShippingMethodsStore, ["selectedMethod"])
    },
    methods: {
      ...mapActions(useConfigStore, ["getStoreConfig"]),
      setShippingStepText(event) {
        this.shippingStepCompletedText = (event == null ? void 0 : event.detail) || this.$t("shippingStep.stepCompleteTitle");
      },
      setDetailsStepActive() {
      }
    }
  };
  const _hoisted_1$7 = { class: "saved-shipping" };
  const _hoisted_2$5 = { class: "saved-shipping__title" };
  const _hoisted_3$4 = { class: "order-total" };
  const _hoisted_4$1 = { class: "total__row" };
  const _hoisted_5$1 = { class: "saved-shipping__icon" };
  const _hoisted_6 = { class: "saved-shipping__icon-image" };
  const _hoisted_7 = { class: "title" };
  const _hoisted_8 = { class: "shipping-method-title" };
  const _hoisted_9 = { class: "proceed-to-shipping" };
  const _hoisted_10 = ["aria-label"];
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Shipping = resolveComponent("Shipping");
    const _component_TextField = resolveComponent("TextField");
    const _component_Price = resolveComponent("Price");
    const _component_Edit = resolveComponent("Edit");
    return openBlock(), createElementBlock("div", _hoisted_1$7, [
      createBaseVNode("a", {
        class: "saved-shipping-link",
        "aria-label": "proceed-to-shipping-link",
        to: "/shipping",
        onClick: _cache[0] || (_cache[0] = ($event) => {
          $options.setDetailsStepActive();
        })
      }, [
        createBaseVNode("div", _hoisted_2$5, [
          createBaseVNode("div", _hoisted_3$4, [
            createBaseVNode("div", _hoisted_4$1, [
              createBaseVNode("div", _hoisted_5$1, [
                createBaseVNode("div", _hoisted_6, [
                  createVNode(_component_Shipping, { fill: "black" })
                ]),
                createBaseVNode("div", _hoisted_7, [
                  createVNode(_component_TextField, { text: $data.shippingStepCompletedText }, null, 8, ["text"])
                ])
              ]),
              createBaseVNode("div", _hoisted_8, [
                createVNode(_component_TextField, {
                  text: `${_ctx.selectedMethod.method_title}, `
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "shipping-method-value",
                  value: _ctx.shippingPrice
                }, null, 8, ["value"])
              ]),
              createBaseVNode("div", _hoisted_9, [
                createBaseVNode("button", {
                  class: "button--blank edit-shipping-button",
                  "aria-label": _ctx.$t("yourDetailsSection.editShippingButtonLabel")
                }, [
                  createVNode(_component_TextField, {
                    class: "edit-button-title",
                    text: _ctx.$t("yourDetailsSection.editButton")
                  }, null, 8, ["text"]),
                  createVNode(_component_Edit)
                ], 8, _hoisted_10)
              ])
            ])
          ])
        ])
      ])
    ]);
  }
  var SavedShippingMethod = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-5bb29fe1"]]);
  const _sfc_main$6 = {
    name: "Rewards",
    components: {
      MyButton
    },
    computed: {
      ...mapState(useCartStore, ["rewards"]),
      ...mapState(useCustomerStore, ["customer"])
    },
    async created() {
      await this.getAvailableRewardPoints();
    },
    methods: {
      ...mapActions(useCartStore, ["useRewardPoints", "removeRewardPoints"]),
      ...mapActions(useCustomerStore, ["getAvailableRewardPoints"]),
      getFormattedPrice() {
        return formatPrice(this.customer.reward_points.balance.money.value);
      }
    }
  };
  const _hoisted_1$6 = {
    key: 0,
    class: "reward-points"
  };
  const _hoisted_2$4 = { class: "reward-points-available" };
  const _hoisted_3$3 = {
    key: 1,
    class: "reward-points"
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_MyButton = resolveComponent("MyButton");
    return _ctx.customer.reward_points && _ctx.customer.reward_points.balance.points && !_ctx.rewards.used ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
      createBaseVNode("div", null, [
        createBaseVNode("span", null, toDisplayString$1(_ctx.$t("rewards.youHave")), 1),
        createBaseVNode("span", _hoisted_2$4, toDisplayString$1(_ctx.$t("rewards.rewardPoints", {
          points: _ctx.customer.reward_points.balance.points
        })), 1),
        createBaseVNode("span", null, toDisplayString$1(_ctx.$t("rewards.available")), 1),
        createBaseVNode("span", null, "(" + toDisplayString$1($options.getFormattedPrice()) + ")", 1)
      ]),
      createVNode(_component_MyButton, {
        label: _ctx.$t("rewards.applyButton"),
        secondary: "",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.useRewardPoints())
      }, null, 8, ["label"])
    ])) : _ctx.customer.reward_points && _ctx.rewards.used ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
      createBaseVNode("span", null, toDisplayString$1(_ctx.$t("rewards.applied")), 1),
      createVNode(_component_MyButton, {
        label: _ctx.$t("rewards.removeButton"),
        secondary: "",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.removeRewardPoints())
      }, null, 8, ["label"])
    ])) : createCommentVNode("", true);
  }
  var Rewards = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-1e6ec09c"]]);
  const _sfc_main$5 = {
    name: "RadioButton",
    props: {
      text: {
        type: String
      },
      subtext: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      },
      checked: {
        type: Boolean,
        default: false
      },
      subtextShow: {
        type: Boolean,
        default: false
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      },
      fontStyle: {
        type: String
      },
      ariaChecked: {
        type: String
      },
      role: {
        type: String
      },
      changeHandler: {
        type: Function,
        default: () => {
        }
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          fontSize: reactiveProps.fontSize,
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontStyle: reactiveProps.fontStyle
        }))
      };
    }
  };
  const _hoisted_1$5 = {
    class: "radio-button",
    for: "radio-input"
  };
  const _hoisted_2$3 = ["disabled", "checked", "aria-checked", "role"];
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("label", _hoisted_1$5, [
        createBaseVNode("input", {
          id: "radio-input",
          type: "radio",
          disabled: $props.disabled,
          checked: $props.checked,
          "aria-checked": $props.ariaChecked,
          role: $props.role,
          onChange: _cache[0] || (_cache[0] = (...args) => $props.changeHandler && $props.changeHandler(...args))
        }, null, 40, _hoisted_2$3),
        renderSlot(_ctx.$slots, "icon", {}, void 0, true),
        createBaseVNode("span", {
          style: normalizeStyle($setup.style)
        }, toDisplayString$1($props.text), 5)
      ]),
      withDirectives(createBaseVNode("p", null, toDisplayString$1($props.subtext), 513), [
        [vShow, $props.subtextShow]
      ])
    ]);
  }
  var RadioButton = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-56ca64aa"]]);
  const _sfc_main$4 = {
    name: "FreePayment",
    components: { MyButton, RadioButton },
    data() {
      return {
        buttonDisabled: false
      };
    },
    computed: {
      ...mapState(useCartStore, ["cartEmitter"]),
      ...mapState(useCustomerStore, [
        "customer",
        "getSelectedBillingAddress"
      ])
    },
    methods: {
      ...mapActions(useCartStore, ["getCart", "getCartData", "getCartTotals"]),
      createPayment() {
        const data2 = {
          billingAddress: this.getSelectedBillingAddress,
          paymentMethod: this.getPaymentMethod(),
          email: this.customer.email
        };
        this.buttonDisabled = true;
        createPayment(data2).then(this.redirectToSuccess).catch((error) => {
          if (error.response && error.response.data && error.response.data.message) {
            this.errorMessage = error.response.data.message;
          }
          this.buttonDisabled = false;
          throw Error(error);
        });
      },
      getPaymentMethod() {
        return {
          method: "free",
          additional_data: {},
          extension_attributes: getPaymentExtensionAttributes()
        };
      },
      redirectToSuccess() {
        window.location.href = getSuccessPageUrl();
      }
    }
  };
  const _hoisted_1$4 = { class: "free-payment" };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_RadioButton = resolveComponent("RadioButton");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock("div", _hoisted_1$4, [
      createVNode(_component_RadioButton, {
        checked: true,
        text: _ctx.$t("paymentStep.freePayment")
      }, null, 8, ["text"]),
      createVNode(_component_MyButton, {
        class: "free-payment-button",
        label: _ctx.$t("paymentStep.freeButton"),
        primary: "",
        disabled: $data.buttonDisabled,
        onClick: _cache[0] || (_cache[0] = ($event) => $options.createPayment())
      }, null, 8, ["label", "disabled"])
    ]);
  }
  var FreePayment = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-5b47acc4"]]);
  const _sfc_main$3 = {
    name: "Modal",
    props: {
      visible: {
        type: Boolean,
        default: false
      },
      classes: {
        type: String,
        default: ""
      },
      header: {
        type: Boolean,
        default: true
      },
      footer: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      getModalClasses() {
        return `${this.classes} modal`;
      }
    },
    methods: {
      close() {
        this.$emit("close");
      },
      focus() {
        this.$emit("focus");
      }
    }
  };
  const _hoisted_1$3 = {
    key: 0,
    id: "modalTitle",
    class: "modal-header"
  };
  const _hoisted_2$2 = {
    id: "modalDescription",
    class: "modal-body"
  };
  const _hoisted_3$2 = {
    key: 1,
    class: "modal-footer"
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(Transition, { name: "fade" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: "modal-backdrop",
            ref: "backdrop",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.close && $options.close(...args)),
            onKeydown: _cache[1] || (_cache[1] = (...args) => $options.focus && $options.focus(...args))
          }, null, 544), [
            [vShow, $props.visible]
          ])
        ]),
        _: 1
      }),
      createVNode(Transition, {
        name: "slide",
        appear: ""
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: normalizeClass($options.getModalClasses),
            role: "dialog",
            "aria-labelledby": "modalTitle",
            "aria-describedby": "modalDescription",
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop"]))
          }, [
            $props.header ? (openBlock(), createElementBlock("header", _hoisted_1$3, [
              renderSlot(_ctx.$slots, "header", {}, void 0, true)
            ])) : createCommentVNode("", true),
            createBaseVNode("section", _hoisted_2$2, [
              renderSlot(_ctx.$slots, "body", {}, () => [
                createTextVNode(" This is the default body! ")
              ], true)
            ]),
            $props.footer ? (openBlock(), createElementBlock("footer", _hoisted_3$2, [
              renderSlot(_ctx.$slots, "footer", {}, void 0, true)
            ])) : createCommentVNode("", true)
          ], 2), [
            [vShow, $props.visible]
          ])
        ]),
        _: 3
      })
    ], 64);
  }
  var Modal = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-69121848"]]);
  const _sfc_main$2 = {
    name: "IframeComponent",
    props: {
      src: {
        type: String,
        default: ""
      },
      id: {
        type: String,
        default: null
      },
      title: {
        type: String,
        default: null
      },
      width: {
        type: Number,
        default: null
      },
      height: {
        type: Number,
        default: null
      }
    }
  };
  const _hoisted_1$2 = ["id", "title", "width", "height", "src"];
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("iframe", {
      id: $props.id,
      title: $props.title,
      width: $props.width,
      height: $props.height,
      src: $props.src
    }, null, 8, _hoisted_1$2);
  }
  var IframeComponent = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
  var getRvvupPaymentMethods = () => {
    const { customer: { tokenType } } = useCustomerStore();
    const { maskedId } = useCartStore();
    const guestUrl = `${getBaseRestUrl()}/rvvup/vue-config/${maskedId}`;
    const authUrl = `${getBaseRestUrl()}/rvvup/vue-config/mine`;
    const request3 = tokenType === tokenTypes.guestUser ? authenticatedRequest().get(guestUrl) : authenticatedRequest().get(authUrl);
    return request3.then((response) => response.data);
  };
  var getRvvupPaymentActions = () => {
    const { customer: { tokenType } } = useCustomerStore();
    const { id, maskedId } = useCartStore();
    const guestUrl = `${getBaseRestUrl()}/rvvup/payments/${maskedId}/payment-actions`;
    const authUrl = `${getBaseRestUrl()}/rvvup/payments/mine/${id}/payment-actions`;
    const payload = {};
    const request3 = tokenType === tokenTypes.guestUser ? authenticatedRequest().get(guestUrl, { payload }) : authenticatedRequest().get(authUrl, { payload });
    return request3.then((response) => response.data);
  };
  var rvvupPaymentSvg = "/adminhtml/Magento/spectrum/en_US/Gene_BetterCheckout/js/checkout/dist/rvvup-payment.svg";
  const _sfc_main$1 = {
    name: "RvvupPayByBank",
    components: {
      Modal,
      IframeComponent,
      Loader
    },
    props: {
      method: {
        type: Object,
        default: () => {
        }
      }
    },
    data() {
      return {
        isPayByBankActive: false,
        payByBankDescriptionSrc: "",
        isMethodSelected: false,
        showPaymentModal: false,
        loading: false,
        frameWidth: null,
        frameHeight: null,
        orderId: null,
        iframeUrl: "",
        cancellationUrl: ""
      };
    },
    computed: {
      ...mapState(useCustomerStore, [
        "customer",
        "getSelectedBillingAddress"
      ]),
      ...mapState(useCartStore, [
        "maskedId"
      ]),
      ...mapState(usePaymentStore, [
        "paymentEmitter"
      ]),
      getRvvupIcon() {
        return `${getStaticUrl(rvvupPaymentSvg)}`;
      },
      getCancelActionUrl() {
        return this.cancelActions ? this.cancelActions.value : "";
      }
    },
    mounted() {
      window.addEventListener("message", (event) => {
        if (!this.isMethodSelected) {
          return;
        }
        const eventData = event.data;
        const eventType = eventData.type;
        if (eventType === "rvvup-payment-modal|close") {
          this.cancelRvvupPayment();
        }
        if (eventType === "rvvup-payment-modal|resize") {
          const height = eventData.hasOwnProperty("height") ? eventData.height : null;
          const width = eventData.hasOwnProperty("width") ? eventData.width : null;
          const windowHeight = window.innerHeight;
          const windowWidth = window.innerWidth;
          const chosenWidth = width > windowWidth ? windowWidth - 100 : width;
          const chosenHeight = height > windowHeight ? windowHeight - 100 : height;
          this.frameHeight = chosenHeight;
          this.frameWidth = chosenWidth;
        }
      });
    },
    async created() {
      this.setPaymentErrors();
      const availablePaymentMethods = await getRvvupPaymentMethods();
      const payByBank = this.getPayByBankMethod(availablePaymentMethods);
      this.isPayByBankActive = !!payByBank;
      this.payByBankDescriptionSrc = payByBank.summary_url;
      this.paymentEmitter.on("paymentMethodSelected", ({ id }) => {
        if (id !== "rvvup_yapily") {
          this.isMethodSelected = false;
        }
      });
      this.paymentEmitter.on("adyenPaymentDisplayingError", ({ isDisplaying }) => {
        this.isPayByBankActive = !isDisplaying;
      });
    },
    methods: {
      ...mapActions(usePaymentStore, ["setRvvupErrorMessage"]),
      removeUrlErrorParam(key, sourceURL) {
        let rtn = sourceURL.split("?")[0];
        let param;
        let paramsArr = [];
        const queryString = sourceURL.indexOf("?") !== -1 ? sourceURL.split("?")[1] : "";
        if (queryString !== "") {
          paramsArr = queryString.split("&");
          for (let i = paramsArr.length - 1; i >= 0; i -= 1) {
            [param] = paramsArr[i].split("=");
            if (param === key) {
              paramsArr.splice(i, 1);
            }
          }
          if (paramsArr.length)
            rtn = `${rtn}?${paramsArr.join("&")}`;
        }
        return rtn;
      },
      getPayByBankMethod(paymentMethodsResponse) {
        return paymentMethodsResponse.find((method) => method.code === "rvvup_yapily");
      },
      selectPaymentCard() {
        this.isMethodSelected = true;
        this.paymentEmitter.emit("paymentMethodSelected", {
          id: "rvvup_yapily",
          type: "rvvup_yapily"
        });
      },
      openModal() {
        document.body.classList.add("no-scrollable");
        this.showPaymentModal = true;
      },
      closeModal() {
        document.body.classList.remove("no-scrollable");
        this.showPaymentModal = false;
      },
      setIframeUrl(url) {
        this.iframeUrl = url;
      },
      setCancellationUrl(url) {
        this.cancellationUrl = url;
      },
      setPaymentErrors() {
        const { href } = window.location;
        const params = href.split("?")[1];
        if (params && params !== "") {
          const result = params.split("&").reduce((res, item) => {
            const [key, value] = item.split("=");
            return { ...res, [key]: value };
          }, {});
          let message;
          Object.keys(result).forEach((objectKey) => {
            if (result[objectKey] === "cancelled") {
              message = this.$t("errorMessages.rvvupPayment.cancelled");
            } else if (result[objectKey] === "unexpected") {
              message = this.$t("errorMessages.rvvupPayment.unexpected");
            } else if (result[objectKey] === "declined") {
              message = this.$t("errorMessages.rvvupPayment.declined");
            } else if (result[objectKey] === "expired") {
              message = this.$t("errorMessages.rvvupPayment.expired");
            } else if (result[objectKey] === "failed") {
              message = this.$t("errorMessages.rvvupPayment.failed");
            } else {
              message = this.$t("errorMessages.rvvupPayment.other");
            }
          });
          this.setRvvupErrorMessage(message);
          setTimeout(() => {
            const alteredURL = this.removeUrlErrorParam("status", href);
            window.history.replaceState(null, "", alteredURL);
            this.setRvvupErrorMessage("");
          }, 1e4);
        }
      },
      startRvvupPayment() {
        this.loading = true;
        const paymentMethod = { method: "rvvup_YAPILY" };
        const data2 = {
          billingAddress: this.getSelectedBillingAddress,
          paymentMethod,
          email: this.customer.email,
          cartId: this.maskedId
        };
        createPayment(data2).then((response) => {
          this.orderId = response;
          this.rvvupPaymentActions();
        }).catch((error) => {
          setTimeout(() => {
            this.setRvvupErrorMessage(this.$t("errorMessages.rvvupPayment.qtyNotAvailable"));
            this.isMethodSelected = false;
            throw Error(error);
          }, 5e3);
        });
        setTimeout(() => {
          this.setRvvupErrorMessage("");
        }, 2e4);
      },
      async rvvupPaymentActions() {
        await getRvvupPaymentActions().then((response) => {
          const authorization = response.find((method) => method.type === "authorization");
          const cancel = response.find((method) => method.type === "cancel");
          if (authorization && authorization.value) {
            this.loading = false;
            this.setIframeUrl(authorization.value);
            this.setCancellationUrl(cancel.value);
            this.openModal();
          }
        }).catch((error) => {
          throw Error(error);
        });
      },
      cancelRvvupPayment() {
        if (this.cancellationUrl) {
          this.setIframeUrl(this.cancellationUrl);
        }
      }
    }
  };
  const _hoisted_1$1 = { key: 0 };
  const _hoisted_2$1 = ["aria-label"];
  const _hoisted_3$1 = ["src", "alt"];
  const _hoisted_4 = { class: "payment-method-name" };
  const _hoisted_5 = {
    key: 0,
    class: "rvvup-loader"
  };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_IframeComponent = resolveComponent("IframeComponent");
    const _component_modal = resolveComponent("modal");
    return $data.isPayByBankActive ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
      createBaseVNode("button", {
        class: "rvvup-button payment-method",
        "aria-label": _ctx.$t("rvvup.rvvupPaymentLabel"),
        type: "button",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.selectPaymentCard && $options.selectPaymentCard(...args))
      }, [
        createBaseVNode("span", {
          class: normalizeClass(["payment-method-radio", { "selected": $data.isMethodSelected }]),
          "aria-hidden": "true"
        }, null, 2),
        createBaseVNode("img", {
          src: $options.getRvvupIcon,
          alt: $options.getRvvupIcon
        }, null, 8, _hoisted_3$1),
        createBaseVNode("span", _hoisted_4, toDisplayString$1(_ctx.$t("rvvup.payByBankLabel")), 1)
      ], 8, _hoisted_2$1),
      createBaseVNode("div", {
        class: normalizeClass([{ "rvvup-method-visible": $data.isMethodSelected }, "rvvup-method"])
      }, [
        $data.loading ? (openBlock(), createElementBlock("div", _hoisted_5, [
          createVNode(_component_Loader, { overlay: false })
        ])) : createCommentVNode("", true),
        $data.payByBankDescriptionSrc && $data.isMethodSelected ? (openBlock(), createBlock(_component_IframeComponent, {
          key: 1,
          title: "Rvvup payment modal",
          width: 400,
          height: 480,
          src: $data.payByBankDescriptionSrc
        }, null, 8, ["src"])) : createCommentVNode("", true),
        createBaseVNode("button", {
          class: "button button--primary button--checkout button--full",
          type: "button",
          onClick: _cache[1] || (_cache[1] = (...args) => $options.startRvvupPayment && $options.startRvvupPayment(...args))
        }, [
          createBaseVNode("span", null, toDisplayString$1(_ctx.$t("rvvup.payByBankButton")), 1)
        ]),
        createVNode(_component_modal, {
          visible: $data.showPaymentModal,
          classes: "rvvup-modal",
          header: false,
          footer: false,
          onClose: $options.cancelRvvupPayment
        }, {
          body: withCtx(() => [
            $data.iframeUrl ? (openBlock(), createBlock(_component_IframeComponent, {
              key: 0,
              title: "Rvvup payment modal",
              width: $data.frameWidth,
              height: $data.frameHeight,
              src: $data.iframeUrl
            }, null, 8, ["width", "height", "src"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["visible", "onClose"])
      ], 2)
    ])) : createCommentVNode("", true);
  }
  var RvvupPayByBank = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-b6a95134"]]);
  const _sfc_main = {
    name: "PaymentPage",
    components: {
      SavedDeliveryAddress,
      SavedShippingMethod,
      AdyenDropIn,
      Rewards,
      FreePayment,
      RvvupPayByBank,
      ErrorMessage
    },
    computed: {
      ...mapState(useConfigStore, ["storeCode", "rewardsEnabled", "rvvupPaymentsActive"]),
      ...mapState(usePaymentStore, ["rvvupErrorMessage"]),
      ...mapState(useCartStore, ["cartGrandTotal", "isItemRequiringDelivery"])
    },
    methods: {
      ...mapActions(useCartStore, ["getCart", "getCartData"]),
      ...mapActions(useConfigStore, ["getStoreConfig", "getRvvupConfig"]),
      ...mapActions(useGtmStore, ["trackStep"]),
      setDetailsStepActive() {
        const element = document.getElementById("progress-bar");
        element.classList.add("details-active");
      }
    }
  };
  const _hoisted_1 = { class: "payment-step" };
  const _hoisted_2 = { class: "payment-page" };
  const _hoisted_3 = { class: "payment-form" };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_SavedDeliveryAddress = resolveComponent("SavedDeliveryAddress");
    const _component_SavedShippingMethod = resolveComponent("SavedShippingMethod");
    const _component_Rewards = resolveComponent("Rewards");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_AdyenDropIn = resolveComponent("AdyenDropIn");
    const _component_RvvupPayByBank = resolveComponent("RvvupPayByBank");
    const _component_FreePayment = resolveComponent("FreePayment");
    return openBlock(), createElementBlock("div", _hoisted_1, [
      createVNode(_component_SavedDeliveryAddress),
      _ctx.isItemRequiringDelivery ? (openBlock(), createBlock(_component_SavedShippingMethod, { key: 0 })) : createCommentVNode("", true),
      _ctx.rewardsEnabled ? (openBlock(), createBlock(_component_Rewards, { key: 1 })) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_2, [
        createBaseVNode("div", _hoisted_3, [
          _ctx.cartGrandTotal ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _ctx.rvvupErrorMessage !== "" ? (openBlock(), createBlock(_component_ErrorMessage, {
              key: 0,
              message: _ctx.rvvupErrorMessage
            }, null, 8, ["message"])) : createCommentVNode("", true),
            createVNode(_component_AdyenDropIn),
            _ctx.rvvupPaymentsActive ? (openBlock(), createBlock(_component_RvvupPayByBank, { key: 1 })) : createCommentVNode("", true)
          ], 64)) : (openBlock(), createBlock(_component_FreePayment, { key: 1 }))
        ])
      ])
    ]);
  }
  var PaymentPage = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-fc742d8c"]]);
  const routes = [
    {
      path: "/",
      alias: [
        "/checkout"
      ],
      name: "DetailsPage",
      component: DetailsPage,
      meta: {
        depth: 0
      }
    },
    {
      path: "/shipping",
      name: "ShippingPage",
      component: ShippingPage,
      meta: {
        depth: 1
      }
    },
    {
      path: "/payments",
      name: "PaymentPage",
      component: PaymentPage,
      meta: {
        depth: 2
      }
    },
    {
      path: "/*",
      redirect: "/",
      meta: {
        depth: 0
      }
    }
  ];
  const router = createRouter({
    history: createMemoryHistory(),
    routes
  });
  var enTranslations = {
    header: {
      text: "Secure Checkout"
    },
    dividerText: "or",
    payNoExpressWithBlockTitle: " ",
    payWithBlockTitle: "Pay With",
    orderSummary: {
      applyBtn: "Apply",
      removeBtn: "Remove",
      modalHeader: "Order Summary",
      mobileDiscountText: "Or add a discount code",
      backBtn: "Back",
      grandTotalTitle: "Total to Pay",
      inclTaxTitle: "Tax",
      exclTaxTitle: "Tax",
      discountTitle: "Discount",
      subtotalTitle: "Subtotal",
      removeItemButton: "remove item",
      removeItemButtonLabel: "remove item",
      minusOneItem: "minus one item",
      plusOneItem: "plus one item",
      couponDiscountTitle: "Apply Promotional Code",
      couponDiscount: {
        placeholder: "Enter promotional code",
        successMessage: 'Successfully applied code "{code}".'
      },
      giftDiscountTitle: "Redeem Gift Card",
      giftCardDiscount: {
        placeholder: "Enter Gift Card Code",
        successMessage: 'Successfully applied code "{code}".'
      },
      freeShippingAvailable: "Good news: your order will be delivered for Free.",
      couponCodeTitle: "For another",
      couponCodeTitleBottom: "you can get a",
      couponCodeTitleFreeShipping: "free standard delivery",
      couponCode: {
        placeholder: "Enter promotional code"
      },
      addToCart: "Add to Basket",
      promoTitle: "Often bought together",
      rewardsTitle: "Reward Points"
    },
    progressBar: {
      detailStepTitle: "Your details",
      shippingStepTitle: "Shipping",
      paymentStepTitle: "Payment"
    },
    yourDetailsSection: {
      title: "Your details",
      selectPlaceholder: "Please select your country",
      showPassLabel: "Show or hide password",
      phoneField: {
        infoMessage: "For delivery questions",
        placeholder: "Enter your phone number",
        label: "Phone number"
      },
      emailAddress: {
        placeholder: "Enter your email address",
        label: "Email address",
        span: "Email"
      },
      passwordField: {
        placeholder: "Password",
        label: "Your Password"
      },
      firstName: {
        placeholder: "First name",
        label: "First name"
      },
      lastName: {
        placeholder: "Last name",
        label: "Last name"
      },
      deliverySection: {
        toShippingButton: "Choose your shipping method",
        title: "Where should we deliver it to?",
        savedAddressesTitle: "Select your saved {addressType} address",
        shipHere: "Ship here",
        deliveryAddressTitle: "Delivery Address",
        billingAddressTitle: "Billing Address",
        shippingButton: "SHIPPING ADDRESS",
        clickandCollectButton: "CLICK & COLLLECT",
        clickandCollectOpeningTimes: "Opening Times",
        clickandCollectThresholdHigh: "Unfortunately, your basket value is too high for Click and Collect. If you want to collect from a store near you, your basket must be less than {price}.",
        clickandCollectThresholdLow: "Unfortunately, your basket value is too low for Click and Collect. If you want to collect from a store near you, your basket must be more than {price}.",
        addressFinder: {
          title: "Address Finder",
          placeholder: "Search by street name or postcode",
          label: "Street name/postcode"
        },
        addressForm: {
          saveAddressButton: "Use this address",
          linkText: "Enter your address manually",
          useMyLocation: "Use My Location",
          collectLocations: "Where would you like to collect it?",
          closestLocations: "Nearest Collection Locations",
          noLocations: "No locations found for current search.",
          collectionName: "Who is collecting the order?",
          collectionBillingTitle: "Billing Details",
          submitCollectionDetails: "Submit collection details",
          collectionDistance: "{distance} miles",
          viewMapAndHours: "View map and opening hours",
          selectLocation: "SELECT LOCATION",
          addressField: {
            placeholder: "Address (line 1)",
            unrequired: "Address (line 2)",
            label: "Address (line 1)",
            unrequiredLabel: "Address (line 2)"
          },
          cityField: {
            label: "City",
            placeholder: "City"
          },
          countryField: {
            label: "Country",
            placeholder: "Country"
          },
          postCodeField: {
            label: "Postcode",
            placeholder: "Postcode"
          },
          regionField: {
            label: "County",
            placeholder: "County"
          }
        }
      },
      editButton: "Edit",
      editDetailsButtonLabel: "Edit Your Details",
      editShippingButtonLabel: "Edit Your Shipping Details"
    },
    errorMessages: {
      firstNameErrorMessage: "Please enter a valid firstname",
      lastNameErrorMessage: "Please enter a valid lastname",
      emailErrorMessage: "Please enter a valid email address",
      phoneErrorMessage: "Not a valid Phone Number",
      passwordHelpText: "Minimum 8 characters and must include at least three character classes (lowercase letter, uppercase letter, number or special characters).",
      passwordErrorMessage: "Please enter a valid password",
      addressFormErrorMessage: "Please make sure that all required fields are filled",
      postCodeErrorMessage: "Please enter a valid postcode for",
      countryErrorMessage: "Please choose your country",
      streetErrorMessage: "Please enter a valid address and use a maximum of 75 characters for your street address",
      streetCharacterLimit: "Please use a maximum of 75 characters for your street address",
      cityErrorMessage: "Please enter a valid city",
      regionErrorMessage: "Please enter a valid county",
      googlePayShippingError: "The shipping method is missing. Please select the shipping method and try again.",
      googlePayNominatedDayError: "Unfortunately we cannot offer Express Payment on orders with Nominated Day Delivery.",
      noShippingMethods: "No shipping methods found for the selected address.",
      googlePayNoShippingMethods: "No shipping methods found for the selected address.",
      unexpectedPaymentError: "An unexpected error occurred",
      applePayNoShippingMethods: "No shipping methods found for the selected address.",
      postcodeLookup: "Unable to get your location.",
      rvvupPayment: {
        cancelled: "Payment Cancelled.",
        unexpected: "An error occurred while processing your payment. Please contact us.",
        declined: "Payment Declined.",
        other: "An error occurred while processing your payment. Please contact us.",
        expired: "Payment Expired.",
        failed: "Payment Failed.",
        qtyNotAvailable: "The requested qty is not available."
      }
    },
    welcomeMessages: {
      accountBody: "Sign in to your account to checkout or continue as a guest.",
      accountTitle: "Welcome back!",
      getStarted: "Enter your email to get started.",
      guestBody: "Looks like you're new here! Continue to checkout as a guest with the option to create an account once you've placed your order.",
      guestTitle: "Hello"
    },
    signInButton: "Sign In",
    noAccountGuestButton: "Continue as a Guest",
    accountGuestButton: "Or Continue as a Guest",
    continueButton: "Continue",
    forgotPass: "Forgot your Password",
    updateButton: "Update",
    billingForm: {
      notSameAddress: "My billing and shipping address are the same"
    },
    shippingStep: {
      proceedToPay: "Proceed to payment",
      stepTitle: "Select a shipping method",
      stepCompleteTitle: "Shipping",
      nominatedDelivery: "Choose a day that suits you.",
      tbc: "Calculated at next step"
    },
    addNewAddressBtn: "+ Add new address",
    saveNewAddress: "Save in address book",
    paymentStep: {
      title: "Select a payment method",
      freePayment: "No Payment Information Required",
      freeButton: "Pay Now",
      storedPayments: "Your Saved Payments",
      creditDebitCard: "Credit or debit card"
    },
    productOptionsTrigger: "Product options",
    instantCheckout: "Instant Checkout",
    adyen: {
      applePayTotal: "Grand Total",
      applePayNoShippingMethods: "There are no shipping methods available for you right now. Please try again or use an alternative payment method.",
      cardNumber: "Card Number",
      expiry: "Expiry",
      storedPaymentLabel: "{name} Stored card ends in {lastFour}",
      paymentSuccessful: "Payment Successful"
    },
    rvvup: {
      payByBankLabel: "Pay by Bank",
      payByBankButton: "Continue to Pay by Bank with Rvvup",
      rvvupPaymentLabel: "Rvvup Pay By Bank"
    },
    agreements: {
      label: "I confirm that I have read and accept the",
      errorMessage: "This is a required field.",
      paymentErrorMessage: "Agreements have not been accepted. Please check the agreements and try again."
    },
    privacyPolicy: {
      content: "Your data will be handled as set out in our ",
      link: "Privacy Policy"
    },
    termsServices: {
      content: 'By clicking on the "order now" button, you hereby agree to our ',
      generalLink: "General Terms & Conditions, ",
      privacyLink: " our Privacy Policy",
      withdrawLink: "and our Withdrawal Policy."
    },
    newsletter: {
      label: "Subscribe to the newsletter"
    },
    rewards: {
      applied: "Reward points have been applied.",
      applyButton: "Apply Points",
      available: " available ",
      removeButton: "Remove Points",
      rewardPoints: "{points} Reward Points",
      youHave: "You have "
    },
    payWith: {
      masterCard: "pay with master card",
      visa: "pay with visa",
      americanExpress: "pay with american express",
      clearPay: "pay with clear pay",
      klarna: "pay with klarna"
    },
    giftMessage: {
      to: "To:",
      from: "From:",
      message: "Message:"
    },
    days: {
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday",
      sunday: "Sunday"
    }
  };
  var frTranslations = {
    header: {
      text: "Paiement s\xE9curis\xE9"
    },
    dividerText: "ou",
    payNoExpressWithBlockTitle: " ",
    payWithBlockTitle: "Payer avec",
    orderSummary: {
      applyBtn: "Utiliser",
      removeBtn: "Supprimer",
      modalHeader: "R\xE9capitulatif de la commande",
      mobileDiscountText: "Entrez votre code de r\xE9duction",
      backBtn: "Retour",
      grandTotalTitle: "Total \xE0 payer",
      inclTaxTitle: "TTC",
      exclTaxTitle: "HT",
      discountTitle: "Remise",
      subtotalTitle: "Sous-total",
      removeItemButton: "Supprimer l'article",
      removeItemButtonLabel: "Supprimer l'article",
      minusOneItem: "Moins un article",
      plusOneItem: "Plus un article",
      giftDiscountTitle: "Entrez votre code to r\xE9duction",
      giftCardDiscount: {
        placeholder: "Entrez le code",
        successMessage: 'Coupon appliqu\xE9 "{code}".'
      },
      freeShippingAvailable: "Bonne nouvelle: votre commande sera livr\xE9e gratuitement",
      couponCodeTitle: "D\xE9pensez",
      couponCodeTitleBottom: "plus pour profiter",
      couponCodeTitleFreeShipping: "de la livraison gratuite",
      couponCode: {
        placeholder: "Entrez le code"
      },
      addToCart: "Ajouter au panier",
      promoTitle: "Produits fr\xE9quemment achet\xE9s ensemble",
      rewardsTitle: "Points de fid\xE9lit\xE9"
    },
    progressBar: {
      detailStepTitle: "Vos coordonn\xE9es",
      shippingStepTitle: "Livraison",
      paymentStepTitle: "Paiement"
    },
    yourDetailsSection: {
      title: "Vos coordonn\xE9es",
      selectPlaceholder: "Pays",
      showPassLabel: "Afficher ou masquer le mot de passe",
      phoneField: {
        infoMessage: "Pour les questions de livraison",
        placeholder: "Num\xE9ro de t\xE9l\xE9phone",
        label: "T\xE9l\xE9phone"
      },
      emailAddress: {
        placeholder: "Saisissez votre email",
        label: "L'adresse e-mail",
        span: "Email"
      },
      passwordField: {
        placeholder: "Passe",
        label: "Votre mot de passe"
      },
      firstName: {
        placeholder: "Pr\xE9nom",
        label: "Pr\xE9nom"
      },
      lastName: {
        placeholder: "Nom",
        label: "Nom"
      },
      deliverySection: {
        toShippingButton: "Options de livraison",
        title: "Ou devons-nous livrer votre commande?",
        savedAddressesTitle: "Vos adresses enregistr\xE9es",
        shipHere: "Livrer ici",
        deliveryAddressTitle: "Adresse de livraison",
        billingAddressTitle: "Adresse de facturation",
        addressFinder: {
          title: "Recherche d'adresse",
          placeholder: "Cherchez par nom de rue ou code postal",
          label: "Soci\xE9t\xE9"
        },
        addressForm: {
          saveAddressButton: "Exp\xE9dier ici",
          linkText: "Entrez votre addresse manuellement",
          addressField: {
            placeholder: "Adresse 1",
            unrequired: "Adresse 2",
            label: "Adresse 1",
            unrequiredLabel: "Adresse 2"
          },
          cityField: {
            label: "Ville",
            placeholder: "Ville"
          },
          countryField: {
            label: "Pays",
            placeholder: "Pays"
          },
          postCodeField: {
            label: "Code postal",
            placeholder: "Code postal"
          },
          regionField: {
            label: "\xC9tat/Province",
            placeholder: "\xC9tat/Province"
          }
        }
      },
      editButton: "\xC9diter",
      editDetailsButtonLabel: "Modifier vos coordonn\xE9es",
      editShippingButtonLabel: "Modifier votre adresse de livraison"
    },
    errorMessages: {
      firstNameErrorMessage: "Veuillez entrer votre pr\xE9nom",
      lastNameErrorMessage: "Veuillez entrer votre nom",
      emailErrorMessage: "Veuillez entrer votre e-mail",
      phoneErrorMessage: "Num\xE9ro de t\xE9l\xE9phone non valide",
      passwordHelpText: "Minimum 8 caract\xE8res et doit inclure au moins trois types de caract\xE8res(lettre minuscule, lettre majuscule, chiffre ou caract\xE8res sp\xE9ciaux)",
      passwordErrorMessage: "Entrer un mot de passe valide",
      addressFormErrorMessage: "Veuillez vous assurez que tous les champs obligatoires sont remplis",
      postCodeErrorMessage: "Entrez votre code postal",
      countryErrorMessage: "Selectionnez votre pays",
      streetErrorMessage: "Veuillez ajouter votre adresse postale (Maximum 75 caract\xE8res)",
      streetCharacterLimit: "Veuillez utiliser un maximum de 75 caract\xE8res pour votre adresse postale",
      cityErrorMessage: "Veuillez entrer votre ville",
      regionErrorMessage: "Please enter a valid \xE9tat/Province",
      googlePayShippingError: "Le mode de livraison est manquant. Veuillez s\xE9lectionner lle mode de livraison et r\xE9essayer.",
      googlePayNominatedDayError: "Malheureusement, nous ne pouvons pas proposer le paiement express sur les commandes avec livraison le jour d\xE9sign\xE9.",
      noShippingMethods: "Aucun mode de livraison trouv\xE9 pour l'adresse s\xE9lectionn\xE9e.",
      googlePayNoShippingMethods: "Aucun mode de livraison trouv\xE9 pour l'adresse s\xE9lectionn\xE9e.",
      unexpectedPaymentError: "Une erreur inattendue s'est produite",
      applePayNoShippingMethods: "Aucun mode de livraison trouv\xE9 pour l'adresse s\xE9lectionn\xE9e.",
      rvvupPayment: {
        cancelled: "Payment Cancelled.",
        unexpected: "An error occurred while processing your payment. Please contact us.",
        declined: "Payment Declined.",
        other: "An error occurred while processing your payment. Please contact us.",
        expired: "Payment Expired.",
        failed: "Payment Failed.",
        qtyNotAvailable: "The requested qty is not available."
      }
    },
    welcomeMessages: {
      accountBody: "Connectez-vous \xE0 votre compte pour payer ou continuer en tant qu'invit\xE9.",
      accountTitle: "Content de vous revoir!",
      getStarted: "Entrez votre e-mail pour commencer",
      guestBody: "On dirait que vous \xEAtes nouvelle / nouveau ici ! Passez \xE0 la caisse en tant qu'invit\xE9",
      guestTitle: "Bonjour"
    },
    signInButton: "Se connecter",
    noAccountGuestButton: "Continuer en tant qu'invit\xE9",
    accountGuestButton: "Ou continuer en tant qu'invit\xE9",
    continueButton: "Continuer",
    forgotPass: "Mot de passe oubli\xE9",
    updateButton: "Mettre \xE0 jour",
    billingForm: {
      notSameAddress: "Mes adresses de livraison et de facturation sont identiques"
    },
    shippingStep: {
      proceedToPay: "Proc\xE9der au paiement",
      stepTitle: "S\xE9lectionnez un mode de livraison",
      stepCompleteTitle: "Livraison",
      nominatedDelivery: "Choisissez un jour qui vous convient.",
      tbc: "Calcul\xE9 \xE0 l'\xE9tape suivante"
    },
    addNewAddressBtn: "+ Ajouter une nouvelle adresse",
    saveNewAddress: "Enregistrer dans le carnet d'adresses",
    paymentStep: {
      title: "S\xE9lectionnez un mode de paiement",
      freePayment: "Aucune information de paiement requise",
      freeButton: "Payez maintenant",
      storedPayments: "Vos paiements enregistr\xE9s",
      creditDebitCard: "Carte de cr\xE9dit ou de d\xE9bit"
    },
    productOptionsTrigger: "S\xE9lectionner le produit",
    instantCheckout: "Passage en caisse rapide",
    adyen: {
      applePayTotal: "Montant global",
      applePayNoShippingMethods: "Il n'y a pas de m\xE9thode de livraison disponible pour vous en ce moment. Veuillez r\xE9essayer ou utiliser un autre mode de paiement.",
      cardNumber: "Num\xE9ro de carte",
      expiry: "D'expiration",
      storedPaymentLabel: "{name} La carte enregistr\xE9e se termine par {lastFour}",
      paymentSuccessful: "Payment Successful"
    },
    rvvup: {
      payByBankLabel: "Pay by Bank",
      payByBankButton: "Continue to Pay by Bank with Rvvup",
      rvvupPaymentLabel: "Rvvup Pay By Bank"
    },
    agreements: {
      label: "Je confirme avoir lu et accept\xE9 les",
      errorMessage: "C'est un champ obligatoire.",
      paymentErrorMessage: "Les accords n'ont pas \xE9t\xE9 accept\xE9s. Veuillez v\xE9rifier les accords et r\xE9essayer."
    },
    privacyPolicy: {
      content: "Vos donn\xE9es seront trait\xE9es comme indiqu\xE9 dans notre ",
      link: "Politique de confidentialit\xE9"
    },
    termsServices: {
      content: 'En cliquant sur "Commander", vous acceptez ',
      generalLink: "notre CGV, ",
      privacyLink: " notre clause de confidentialit\xE9",
      withdrawLink: "nos directives de r\xE9tractation."
    },
    newsletter: {
      label: "Abonnez-vous \xE0 notre newsletter"
    },
    rewards: {
      applied: "Des points de r\xE9compense ont \xE9t\xE9 appliqu\xE9s.",
      applyButton: "Appliquer des points",
      available: " disponible ",
      removeButton: "Supprimer des points",
      rewardPoints: "{points} Points de r\xE9compense",
      youHave: "Vous avez "
    },
    payWith: {
      masterCard: "payer avec mastercard",
      visa: "payer avec visa",
      americanExpress: "payer avec american express",
      clearPay: "payer avec un clearpay",
      klarna: "payer avec klarna"
    },
    giftMessage: {
      to: "\xC0 :",
      from: "De:",
      message: "Message:"
    }
  };
  var ieTranslations = {
    header: {
      text: "Secure Checkout"
    },
    dividerText: "or",
    payNoExpressWithBlockTitle: " ",
    payWithBlockTitle: "Pay With",
    orderSummary: {
      applyBtn: "Apply",
      removeBtn: "Remove",
      modalHeader: "Order Summary",
      mobileDiscountText: "Or add a discount code",
      backBtn: "Back",
      grandTotalTitle: "Total to Pay",
      inclTaxTitle: "Tax",
      exclTaxTitle: "Tax",
      discountTitle: "Discount",
      subtotalTitle: "Subtotal",
      removeItemButton: "remove item",
      removeItemButtonLabel: "remove item",
      minusOneItem: "minus one item",
      plusOneItem: "plus one item",
      giftDiscountTitle: "Apply Promotional Code",
      giftCardDiscount: {
        placeholder: "Enter promotional code",
        successMessage: 'Successfully applied code "{code}".'
      },
      freeShippingAvailable: "Good news: your order will be delivered for Free.",
      couponCodeTitle: "For another",
      couponCodeTitleBottom: "you can get a",
      couponCodeTitleFreeShipping: "free standard delivery",
      couponCode: {
        placeholder: "Enter promotional code"
      },
      addToCart: "Add to Basket",
      promoTitle: "Often bought together",
      rewardsTitle: "Reward Points"
    },
    progressBar: {
      detailStepTitle: "Your details",
      shippingStepTitle: "Shipping",
      paymentStepTitle: "Payment"
    },
    yourDetailsSection: {
      title: "Your details",
      selectPlaceholder: "Please select your country",
      showPassLabel: "Show or hide password",
      phoneField: {
        infoMessage: "For delivery questions",
        placeholder: "Enter your phone number",
        label: "Phone number"
      },
      emailAddress: {
        placeholder: "Enter your email address",
        label: "Email address",
        span: "Email"
      },
      passwordField: {
        placeholder: "Password",
        label: "Your Password"
      },
      firstName: {
        placeholder: "First name",
        label: "First name"
      },
      lastName: {
        placeholder: "Last name",
        label: "Last name"
      },
      deliverySection: {
        toShippingButton: "Choose your shipping method",
        title: "Where should we deliver it to?",
        savedAddressesTitle: "Select your saved {addressType} address",
        shipHere: "Ship here",
        deliveryAddressTitle: "Delivery Address",
        billingAddressTitle: "Billing Address",
        shippingButton: "SHIPPING ADDRESS",
        clickandCollectButton: "CLICK & COLLLECT",
        addressFinder: {
          title: "Address Finder",
          placeholder: "Search by street name or postcode",
          label: "Street name/post code"
        },
        addressForm: {
          saveAddressButton: "Use this address",
          linkText: "Enter your address manually",
          useMyLocation: "Use My Location",
          collectLocations: "Collect Locations",
          collectionDistance: "{distance} miles",
          viewMapAndHours: "View map and opening hours",
          addressField: {
            placeholder: "Address (line 1)",
            unrequired: "Address (line 2)",
            label: "Address (line 1)",
            unrequiredLabel: "Address (line 2)"
          },
          cityField: {
            label: "City",
            placeholder: "City"
          },
          countryField: {
            label: "Country",
            placeholder: "County"
          },
          postCodeField: {
            label: "Post Code",
            placeholder: "Post Code"
          },
          regionField: {
            label: "County",
            placeholder: "County"
          }
        }
      },
      editButton: "Edit",
      editDetailsButtonLabel: "Edit Your Details",
      editShippingButtonLabel: "Edit Your Shipping Details"
    },
    errorMessages: {
      firstNameErrorMessage: "Please enter a valid firstname",
      lastNameErrorMessage: "Please enter a valid lastname",
      emailErrorMessage: "Please enter a valid email address",
      phoneErrorMessage: "Not a valid Phone Number",
      passwordHelpText: "Minimum 8 characters and must include at least three character classes (lowercase letter, uppercase letter, number or special characters).",
      passwordErrorMessage: "Please enter a valid password",
      addressFormErrorMessage: "Please make sure that all required fields are filled",
      postCodeErrorMessage: "Please enter a valid postal code for",
      countryErrorMessage: "Please choose your country",
      streetErrorMessage: "Please enter a valid address and use a maximum of 75 characters for your street address",
      cityErrorMessage: "Please enter a valid city",
      googlePayShippingError: "The shipping method is missing. Please select the shipping method and try again.",
      googlePayNominatedDayError: "Unfortunately we cannot offer Express Payment on orders with Nominated Day Delivery.",
      noShippingMethods: "No shipping methods found for the selected address.",
      googlePayNoShippingMethods: "No shipping methods found for the selected address.",
      unexpectedPaymentError: "An unexpected error occurred",
      applePayNoShippingMethods: "No shipping methods found for the selected address.",
      rvvupPayment: {
        cancelled: "Payment Cancelled.",
        unexpected: "An error occurred while processing your payment. Please contact us.",
        declined: "Payment Declined.",
        other: "An error occurred while processing your payment. Please contact us.",
        expired: "Payment Expired.",
        failed: "Payment Failed.",
        qtyNotAvailable: "The requested qty is not available."
      }
    },
    welcomeMessages: {
      accountBody: "Sign in to your account to checkout or continue as a guest.",
      accountTitle: "Welcome back!",
      getStarted: "Enter your email to get started.",
      guestBody: "Looks like you're new here! Continue to checkout as a guest with the option to create an account once you've placed your order.",
      guestTitle: "Hello"
    },
    signInButton: "Sign In",
    noAccountGuestButton: "Continue as a Guest",
    accountGuestButton: "Or Continue as a Guest",
    continueButton: "Continue",
    forgotPass: "Forgot your Password",
    updateButton: "Update",
    billingForm: {
      notSameAddress: "My billing and shipping address are the same"
    },
    shippingStep: {
      proceedToPay: "Proceed to payment",
      stepTitle: "Select a shipping method",
      stepCompleteTitle: "Shipping",
      nominatedDelivery: "Choose a day that suits you.",
      tbc: "Calculated at next step"
    },
    addNewAddressBtn: "+ Add new address",
    saveNewAddress: "Save in address book",
    paymentStep: {
      title: "Select a payment method",
      freePayment: "No Payment Information Required",
      freeButton: "Pay Now",
      storedPayments: "Your Saved Payments",
      creditDebitCard: "Credit or debit card"
    },
    productOptionsTrigger: "Product options",
    instantCheckout: "Instant Checkout",
    adyen: {
      applePayTotal: "Grand Total",
      applePayNoShippingMethods: "There are no shipping methods available for you right now. Please try again or use an alternative payment method.",
      cardNumber: "Card Number",
      expiry: "Expiry",
      storedPaymentLabel: "{name} Stored card ends in {lastFour}",
      paymentSuccessful: "Payment Successful"
    },
    rvvup: {
      payByBankLabel: "Pay by Bank",
      payByBankButton: "Continue to Pay by Bank with Rvvup",
      rvvupPaymentLabel: "Rvvup Pay By Bank"
    },
    agreements: {
      label: "I confirm that I have read and accept the",
      errorMessage: "This is a required field.",
      paymentErrorMessage: "Agreements have not been accepted. Please check the agreements and try again."
    },
    privacyPolicy: {
      content: "Your data will be handled as set out in our ",
      link: "Privacy Policy"
    },
    termsServices: {
      content: 'By clicking on the "order now" button, you hereby agree to our ',
      generalLink: "General Terms & Conditions, ",
      privacyLink: " our Privacy Policy",
      withdrawLink: "and our Withdrawal Policy."
    },
    newsletter: {
      label: "Subscribe to the newsletter"
    },
    rewards: {
      applied: "Reward points have been applied.",
      applyButton: "Apply Points",
      available: " available ",
      removeButton: "Remove Points",
      rewardPoints: "{points} Reward Points",
      youHave: "You have "
    },
    payWith: {
      masterCard: "pay with master card",
      visa: "pay with visa",
      americanExpress: "pay with american express",
      clearPay: "pay with clear pay",
      klarna: "pay with klarna"
    },
    giftMessage: {
      to: "To:",
      from: "From:",
      message: "Message:"
    }
  };
  var usTranslations = {
    header: {
      text: "Secure Checkout"
    },
    dividerText: "or",
    payNoExpressWithBlockTitle: " ",
    payWithBlockTitle: "Pay With",
    orderSummary: {
      applyBtn: "Apply",
      removeBtn: "Remove",
      modalHeader: "Order Summary",
      mobileDiscountText: "Or add a discount code",
      backBtn: "Back",
      grandTotalTitle: "Total to Pay",
      inclTaxTitle: "Tax",
      exclTaxTitle: "Tax",
      discountTitle: "Discount",
      subtotalTitle: "Subtotal",
      removeItemButton: "remove item",
      removeItemButtonLabel: "remove item",
      minusOneItem: "minus one item",
      plusOneItem: "plus one item",
      couponDiscountTitle: "Apply Coupon Code",
      couponDiscount: {
        placeholder: "Enter coupon code",
        successMessage: 'Successfully applied code "{code}".'
      },
      giftDiscountTitle: "Apply Gift Card Code",
      giftCardDiscount: {
        placeholder: "Enter gift card code",
        successMessage: 'Successfully applied code "{code}".'
      },
      freeShippingAvailable: "Good news: your order will be delivered for Free.",
      couponCodeTitle: "For another",
      couponCodeTitleBottom: "you can get a",
      couponCodeTitleFreeShipping: "free standard delivery",
      couponCode: {
        placeholder: "Enter promotional code"
      },
      addToCart: "Add to Basket",
      promoTitle: "Often bought together",
      rewardsTitle: "Reward Points"
    },
    progressBar: {
      detailStepTitle: "Your details",
      shippingStepTitle: "Shipping",
      paymentStepTitle: "Payment"
    },
    yourDetailsSection: {
      title: "Your details",
      selectPlaceholder: "Please select your country",
      showPassLabel: "Show or hide password",
      phoneField: {
        infoMessage: "For delivery questions",
        placeholder: "Enter your phone number",
        label: "Phone number"
      },
      emailAddress: {
        placeholder: "Enter your email address",
        label: "Email address",
        span: "Email"
      },
      passwordField: {
        placeholder: "Password",
        label: "Your Password"
      },
      firstName: {
        placeholder: "First name",
        label: "First name"
      },
      lastName: {
        placeholder: "Last name",
        label: "Last name"
      },
      deliverySection: {
        toShippingButton: "Choose your shipping method",
        title: "Where should we deliver it to?",
        savedAddressesTitle: "Select your saved {addressType} address",
        shipHere: "Ship here",
        deliveryAddressTitle: "Delivery Address",
        billingAddressTitle: "Billing Address",
        addressFinder: {
          title: "Address Finder",
          placeholder: "Search by street name or postcode",
          label: "Street name/postcode"
        },
        addressForm: {
          saveAddressButton: "Use this address",
          linkText: "Enter your address manually",
          addressField: {
            placeholder: "Address (line 1)",
            unrequired: "Address (line 2)",
            label: "Address (line 1)",
            unrequiredLabel: "Address (line 2)"
          },
          cityField: {
            label: "City",
            placeholder: "City"
          },
          countryField: {
            label: "Country",
            placeholder: "County"
          },
          postCodeField: {
            label: "Postcode",
            placeholder: "Postcode"
          },
          regionField: {
            label: "County",
            placeholder: "County"
          }
        }
      },
      editButton: "Edit",
      editDetailsButtonLabel: "Edit Your Details",
      editShippingButtonLabel: "Edit Your Shipping Details"
    },
    errorMessages: {
      firstNameErrorMessage: "Please enter a valid firstname",
      lastNameErrorMessage: "Please enter a valid lastname",
      emailErrorMessage: "Please enter a valid email address",
      phoneErrorMessage: "Not a valid Phone Number",
      passwordHelpText: "Minimum 8 characters and must include at least three character classes (lowercase letter, uppercase letter, number or special characters).",
      passwordErrorMessage: "Please enter a valid password",
      addressFormErrorMessage: "Please make sure that all required fields are filled",
      postCodeErrorMessage: "Please enter a valid postcode for",
      countryErrorMessage: "Please choose your country",
      streetErrorMessage: "Please enter a valid address and use a maximum of 75 characters for your street address",
      streetCharacterLimit: "Please use a maximum of 75 characters for your street address",
      cityErrorMessage: "Please enter a valid city",
      googlePayShippingError: "The shipping method is missing. Please select the shipping method and try again.",
      googlePayNominatedDayError: "Unfortunately we cannot offer Express Payment on orders with Nominated Day Delivery.",
      noShippingMethods: "No shipping methods found for the selected address.",
      googlePayNoShippingMethods: "No shipping methods found for the selected address.",
      unexpectedPaymentError: "An unexpected error occurred",
      applePayNoShippingMethods: "No shipping methods found for the selected address.",
      rvvupPayment: {
        cancelled: "Payment Cancelled.",
        unexpected: "An error occurred while processing your payment. Please contact us.",
        declined: "Payment Declined.",
        other: "An error occurred while processing your payment. Please contact us.",
        expired: "Payment Expired.",
        failed: "Payment Failed.",
        qtyNotAvailable: "The requested qty is not available."
      }
    },
    welcomeMessages: {
      accountBody: "Sign in to your account to checkout or continue as a guest.",
      accountTitle: "Welcome back!",
      getStarted: "Enter your email to get started.",
      guestBody: "Looks like you're new here! Continue to checkout as a guest with the option to create an account once you've placed your order.",
      guestTitle: "Hello"
    },
    signInButton: "Sign In",
    noAccountGuestButton: "Continue as a Guest",
    accountGuestButton: "Or Continue as a Guest",
    continueButton: "Continue",
    forgotPass: "Forgot your Password",
    updateButton: "Update",
    billingForm: {
      notSameAddress: "My billing and shipping address are the same"
    },
    shippingStep: {
      proceedToPay: "Proceed to payment",
      stepTitle: "Select a shipping method",
      stepCompleteTitle: "Shipping",
      nominatedDelivery: "Choose a day that suits you.",
      tbc: "Calculated at next step"
    },
    addNewAddressBtn: "+ Add new address",
    saveNewAddress: "Save in address book",
    paymentStep: {
      title: "Select a payment method",
      freePayment: "No Payment Information Required",
      freeButton: "Pay Now",
      storedPayments: "Your Saved Payments",
      creditDebitCard: "Credit or debit card"
    },
    productOptionsTrigger: "Product options",
    instantCheckout: "Instant Checkout",
    adyen: {
      applePayTotal: "Grand Total",
      applePayNoShippingMethods: "There are no shipping methods available for you right now. Please try again or use an alternative payment method.",
      cardNumber: "Card Number",
      expiry: "Expiry",
      storedPaymentLabel: "{name} Stored card ends in {lastFour}",
      paymentSuccessful: "Payment Successful"
    },
    rvvup: {
      payByBankLabel: "Pay by Bank",
      payByBankButton: "Continue to Pay by Bank with Rvvup",
      rvvupPaymentLabel: "Rvvup Pay By Bank"
    },
    agreements: {
      label: "I confirm that I have read and accept the",
      errorMessage: "This is a required field.",
      paymentErrorMessage: "Agreements have not been accepted. Please check the agreements and try again."
    },
    privacyPolicy: {
      content: "Your data will be handled as set out in our ",
      link: "Privacy Policy"
    },
    termsServices: {
      content: 'By clicking on the "order now" button, you hereby agree to our ',
      generalLink: "General Terms & Conditions, ",
      privacyLink: " our Privacy Policy",
      withdrawLink: "and our Withdrawal Policy."
    },
    newsletter: {
      label: "Subscribe to the newsletter"
    },
    rewards: {
      applied: "Reward points have been applied.",
      applyButton: "Apply Points",
      available: " available ",
      removeButton: "Remove Points",
      rewardPoints: "{points} Reward Points",
      youHave: "You have "
    },
    payWith: {
      masterCard: "pay with master card",
      visa: "pay with visa",
      americanExpress: "pay with american express",
      clearPay: "pay with clear pay",
      klarna: "pay with klarna"
    },
    giftMessage: {
      to: "To:",
      from: "From:",
      message: "Message:"
    }
  };
  var auTranslations = {
    header: {
      text: "Secure Checkout"
    },
    dividerText: "or",
    payNoExpressWithBlockTitle: " ",
    payWithBlockTitle: "Pay With",
    orderSummary: {
      applyBtn: "Apply",
      removeBtn: "Remove",
      modalHeader: "Order Summary",
      mobileDiscountText: "Or add a discount code",
      backBtn: "Back",
      grandTotalTitle: "Total to Pay",
      inclTaxTitle: "Tax",
      exclTaxTitle: "Tax",
      discountTitle: "Discount",
      subtotalTitle: "Subtotal",
      removeItemButton: "remove item",
      removeItemButtonLabel: "remove item",
      minusOneItem: "minus one item",
      plusOneItem: "plus one item",
      giftDiscountTitle: "Apply Promotional Code",
      giftCardDiscount: {
        placeholder: "Enter promotional code",
        successMessage: 'Successfully applied code "{code}".'
      },
      freeShippingAvailable: "Good news: your order will be delivered for Free.",
      couponCodeTitle: "For another",
      couponCodeTitleBottom: "you can get a",
      couponCodeTitleFreeShipping: "free standard delivery",
      couponCode: {
        placeholder: "Enter promotional code"
      },
      addToCart: "Add to Basket",
      promoTitle: "Often bought together",
      rewardsTitle: "Reward Points"
    },
    progressBar: {
      detailStepTitle: "Your details",
      shippingStepTitle: "Shipping",
      paymentStepTitle: "Payment"
    },
    yourDetailsSection: {
      title: "Your details",
      selectPlaceholder: "Please select your country",
      showPassLabel: "Show or hide password",
      phoneField: {
        infoMessage: "For delivery questions",
        placeholder: "Enter your phone number",
        label: "Phone number"
      },
      emailAddress: {
        placeholder: "Enter your email address",
        label: "Email address",
        span: "Email"
      },
      passwordField: {
        placeholder: "Password",
        label: "Your Password"
      },
      firstName: {
        placeholder: "First name",
        label: "First name"
      },
      lastName: {
        placeholder: "Last name",
        label: "Last name"
      },
      deliverySection: {
        toShippingButton: "Choose your shipping method",
        title: "Where should we deliver it to?",
        savedAddressesTitle: "Select your saved {addressType} address",
        shipHere: "Ship here",
        deliveryAddressTitle: "Delivery Address",
        billingAddressTitle: "Billing Address",
        addressFinder: {
          title: "Address Finder",
          placeholder: "Search by street name or postcode",
          label: "Street name/postcode"
        },
        addressForm: {
          saveAddressButton: "Use this address",
          linkText: "Enter your address manually",
          addressField: {
            placeholder: "Address (line 1)",
            unrequired: "Address (line 2)",
            label: "Address (line 1)",
            unrequiredLabel: "Address (line 2)"
          },
          cityField: {
            label: "City",
            placeholder: "City"
          },
          countryField: {
            label: "Country",
            placeholder: "Country"
          },
          postCodeField: {
            label: "Postcode",
            placeholder: "Postcode"
          },
          regionField: {
            label: "County",
            placeholder: "County"
          }
        }
      },
      editButton: "Edit",
      editDetailsButtonLabel: "Edit Your Details",
      editShippingButtonLabel: "Edit Your Shipping Details"
    },
    errorMessages: {
      firstNameErrorMessage: "Please enter a valid firstname",
      lastNameErrorMessage: "Please enter a valid lastname",
      emailErrorMessage: "Please enter a valid email address",
      phoneErrorMessage: "Not a valid Phone Number",
      passwordHelpText: "Minimum 8 characters and must include at least three character classes (lowercase letter, uppercase letter, number or special characters).",
      passwordErrorMessage: "Please enter a valid password",
      addressFormErrorMessage: "Please make sure that all required fields are filled",
      postCodeErrorMessage: "Please enter a valid postcode for",
      countryErrorMessage: "Please choose your country",
      streetErrorMessage: "Please enter a valid address and use a maximum of 75 characters for your street address",
      streetCharacterLimit: "Please use a maximum of 75 characters for your street address",
      cityErrorMessage: "Please enter a valid city",
      regionErrorMessage: "Please enter a valid county",
      googlePayShippingError: "The shipping method is missing. Please select the shipping method and try again.",
      googlePayNominatedDayError: "Unfortunately we cannot offer Express Payment on orders with Nominated Day Delivery.",
      googlePayNoShippingMethods: "No shipping methods found for the selected address.",
      unexpectedPaymentError: "An unexpected error occurred",
      applePayNoShippingMethods: "No shipping methods found for the selected address.",
      rvvupPayment: {
        cancelled: "Payment Cancelled.",
        unexpected: "An error occurred while processing your payment. Please contact us.",
        declined: "Payment Declined.",
        other: "An error occurred while processing your payment. Please contact us.",
        expired: "Payment Expired.",
        failed: "Payment Failed.",
        qtyNotAvailable: "The requested qty is not available."
      }
    },
    welcomeMessages: {
      accountBody: "Sign in to your account to checkout or continue as a guest.",
      accountTitle: "Welcome back!",
      getStarted: "Enter your email to get started.",
      guestBody: "Looks like you're new here! Continue to checkout as a guest with the option to create an account once you've placed your order.",
      guestTitle: "Hello"
    },
    signInButton: "Sign In",
    noAccountGuestButton: "Continue as a Guest",
    accountGuestButton: "Or Continue as a Guest",
    continueButton: "Continue",
    forgotPass: "Forgot your Password",
    updateButton: "Update",
    billingForm: {
      notSameAddress: "My billing and shipping address are the same"
    },
    shippingStep: {
      proceedToPay: "Proceed to payment",
      stepTitle: "Select a shipping method",
      stepCompleteTitle: "Shipping",
      nominatedDelivery: "Choose a day that suits you.",
      tbc: "Calculated at next step"
    },
    addNewAddressBtn: "+ Add new address",
    saveNewAddress: "Save in address book",
    paymentStep: {
      title: "Select a payment method",
      freePayment: "No Payment Information Required",
      freeButton: "Pay Now",
      storedPayments: "Your Saved Payments",
      creditDebitCard: "Credit or debit card"
    },
    productOptionsTrigger: "Product options",
    instantCheckout: "Instant Checkout",
    adyen: {
      applePayTotal: "Grand Total",
      applePayNoShippingMethods: "There are no shipping methods available for you right now. Please try again or use an alternative payment method.",
      cardNumber: "Card Number",
      expiry: "Expiry",
      storedPaymentLabel: "{name} Stored card ends in {lastFour}",
      paymentSuccessful: "Payment Successful"
    },
    rvvup: {
      payByBankLabel: "Pay by Bank",
      payByBankButton: "Continue to Pay by Bank with Rvvup",
      rvvupPaymentLabel: "Rvvup Pay By Bank"
    },
    agreements: {
      label: "I confirm that I have read and accept the",
      errorMessage: "This is a required field.",
      paymentErrorMessage: "Agreements have not been accepted. Please check the agreements and try again."
    },
    privacyPolicy: {
      content: "Your data will be handled as set out in our ",
      link: "Privacy Policy"
    },
    termsServices: {
      content: 'By clicking on the "order now" button, you hereby agree to our ',
      generalLink: "General Terms & Conditions, ",
      privacyLink: " our Privacy Policy",
      withdrawLink: "and our Withdrawal Policy."
    },
    newsletter: {
      label: "Subscribe to the newsletter"
    },
    rewards: {
      applied: "Reward points have been applied.",
      applyButton: "Apply Points",
      available: " available ",
      removeButton: "Remove Points",
      rewardPoints: "{points} Reward Points",
      youHave: "You have "
    },
    payWith: {
      masterCard: "pay with master card",
      visa: "pay with visa",
      americanExpress: "pay with american express",
      clearPay: "pay with clear pay",
      klarna: "pay with klarna"
    },
    giftMessage: {
      to: "To:",
      from: "From:",
      message: "Message:"
    }
  };
  var dkTranslations = {
    header: {
      text: "Sikker bestilling"
    },
    dividerText: "Eller indtast din e-mailadresse for betaling med kredit- eller betalingskort",
    payNoExpressWithBlockTitle: "Indtast din e-mailadresse for betaling med kredit- eller betalingskort",
    orderSummary: {
      applyBtn: "Anvend",
      removeBtn: "Fjern",
      modalHeader: "Bestillingsoversigt",
      mobileDiscountText: "",
      backBtn: "Tilbage",
      grandTotalTitle: "Pris i alt",
      inclTaxTitle: "Moms",
      exclTaxTitle: "plus moms",
      discountTitle: "Rabat",
      subtotalTitle: "Subtotal",
      removeItemButton: "Fjern",
      removeItemButtonLabel: "Fjern artikel",
      minusOneItem: "minus en artikel",
      plusOneItem: "plus en artikel",
      giftDiscountTitle: "Indtast Promo kode",
      giftCardDiscount: {
        placeholder: "Indtast kode",
        successMessage: 'koden er indtastet "{code}".'
      },
      couponCodeTitle: "Bestil for yderligere",
      couponCodeTitleBottom: "for en",
      couponCodeTitleFreeShipping: "gratis forsendelse",
      couponCode: {
        placeholder: "Indtast koden"
      },
      addToCart: "L\xE6g i indk\xF8bskurv",
      promoTitle: "Afslut din ordre med...",
      closeButton: "Luk ordreoversigten",
      mixedShipping: "Dette vil blive leveret separat",
      heliumItem: "Leveres oppustet",
      skuNumber: "SKU nr:",
      supplierStockNumber: "Leverand\xF8rens lager nr:"
    },
    progressBar: {
      detailStepTitle: "Dine oplysninger",
      shippingStepTitle: "Forsendelse",
      paymentStepTitle: "Betaling"
    },
    yourDetailsSection: {
      title: "Dine oplysninger",
      selectPlaceholder: "V\xE6lg venligst et land",
      showPassLabel: "Vis eller skjul adgangskode",
      phoneField: {
        infoMessage: "Vi vil kun bruge dette nummer til at kontakte dig ang\xE5ende din levering.",
        placeholder: "Indtast telefonnummer",
        label: "Telefonnummer"
      },
      emailAddress: {
        placeholder: "Indtast e-mail-adresse",
        label: "E-mail-adresse",
        span: "E-mail"
      },
      passwordField: {
        placeholder: "Indtast adgangskode",
        label: "Din adgangskode"
      },
      firstName: {
        placeholder: "Indtast fornavn",
        label: "Fornavn"
      },
      lastName: {
        placeholder: "Indtast efternavn",
        label: "Efternavn"
      },
      deliverySection: {
        toShippingButton: "V\xE6lg forsendelsesmetoder",
        title: "Leveringsadresse",
        savedAddressesTitle: "V\xE6lg din gemte leveringsadresse",
        shipHere: "Send her",
        info: "Hvor skal vi sende til?",
        billingAddressTitle: "Faktureringsadresse",
        deliveryAddressTitle: "Leveringsadresse",
        addressFinder: {
          title: "S\xF8g efter adresse",
          placeholder: "S\xF8g efter gade eller postnummer",
          label: "Gade eller postnummer"
        },
        addressForm: {
          saveAddressButton: "Brug denne adresse",
          linkText: "Indtast adresse manuelt",
          addressField: {
            placeholder: "Indtast f\xF8rste adresselinje",
            unrequired: "Indtast adresse (linje 2)",
            label: "F\xF8rste adresselinje",
            unrequiredLabel: "Adresse (linje 2)"
          },
          cityField: {
            label: "By",
            placeholder: "Indtast by"
          },
          countryField: {
            label: "Land",
            placeholder: "Indtast land"
          },
          postCodeField: {
            label: "Postnummer",
            placeholder: "Indtast postnummer"
          },
          regionField: {
            label: "Region",
            placeholder: "Indtast region"
          }
        }
      }
    },
    editButton: "\xC6ndre",
    editButtonLabel: "\xC6ndre e-mailadresse",
    editDetailsButtonLabel: "\xC6ndre oplysninger",
    editShippingButtonLabel: "\xC6ndre forsendelsesoplysninger",
    errorMessages: {
      firstNameErrorMessage: "Indtast venligst et gyldigt fornavn",
      lastNameErrorMessage: "Indtast venligst et gyldigt efternavn",
      emailErrorMessage: "Indtast venligst en gyldig e-mailadresse",
      phoneErrorMessage: "Intet gyldigt telefonnummer",
      passwordHelpText: "Skal indeholde mindst 8 tegn og mindst 3 tegntyper",
      passwordErrorMessage: "Indtast venligst en gyldig e-mailadresse og adgangskode",
      addressFormErrorMessage: "S\xF8rg for, at alle obligatoriske felter er udfyldt",
      postCodeErrorMessage: "Indtast venligst et gyldigt postnummer for",
      countryErrorMessage: "V\xE6lg venligst land",
      streetErrorMessage: "Indtast en gyldig adresse, og brug h\xF8jst 75 tegn",
      cityErrorMessage: "Indtast venligst en gyldig by",
      regionErrorMessage: "Indtast venligst gyldigt land",
      googlePayShippingError: "Ingen forsendelsesmetoder valgt. V\xE6lg forsendelsesmetoder, og pr\xF8v igen.",
      googlePayNominatedDayError: "Vi kan desv\xE6rre ikke tilbyde ekspresbetaling p\xE5 ordrer med \xF8nsket leveringsdato.",
      oosErrorMessage: "Varen er udsolgt",
      noShippingMethods: "Ingen forsendelsesmetoder fundet for den valgte adresse",
      googlePayNoShippingMethods: "Ingen forsendelsesmetoder fundet for den valgte adresse",
      unexpectedPaymentError: "Der opstod en uventet fejl"
    },
    welcomeMessages: {
      accountBody: "Log ind med kundekonto eller forts\xE6t som g\xE6st",
      accountTitle: "Velkommen tilbage!",
      getStarted: "Indtast e-mail for at starte",
      guestBody: "Det ser ud til, at du er ny her! Forts\xE6t din bestilling som g\xE6st; du har mulighed for at oprette en konto, n\xE5r du har gennemf\xF8rt din bestilling.",
      guestTitle: "Hej med dig"
    },
    signInButton: "Log ind",
    noAccountGuestButton: "Forts\xE6t som g\xE6st",
    accountGuestButton: "Eller forts\xE6t som g\xE6st",
    continueButton: "Forts\xE6t",
    forgotPass: "Har du glemt din adgangskode?",
    updateButton: "Opdatering",
    billingForm: {
      notSameAddress: "Min fakturerings- og leveringsadresse er den samme"
    },
    shippingStep: {
      proceedToPay: "Forts\xE6t til betaling",
      stepTitle: "V\xE6lg forsendelsesmetode",
      stepCompleteTitle: "Forsendelse",
      stepTitleSubText: "V\xE6lg forsendelsesmetode",
      nominatedDelivery: "V\xE6lg den \xF8nskede dato",
      tbc: "Beregnes i n\xE6ste trin",
      methodLabel: "Modtaget af",
      noDeliveryDate: "V\xE6lg leveringsdato"
    },
    addNewAddressBtn: "Tilf\xF8j ny adresse",
    saveNewAddress: "Gem i adressebogen",
    paymentStep: {
      title: "V\xE6lg betalingsmetode",
      freePayment: "Ingen betalingsoplysninger p\xE5kr\xE6vet",
      freeButton: "Betal nu",
      storedPayments: "Dine gemte betalinger",
      creditDebitCard: "Kredit- eller betalingskort"
    },
    productOptionsTrigger: "Artikeloption",
    instantCheckout: "Hurtig betaling",
    checkoutTitle: "Bestilling",
    adyen: {
      applePayTotal: "Pris i alt",
      applePayNoShippingMethods: "Der er i \xF8jeblikket ingen forsendelsesmetoder tilg\xE6ngelige for dig. Pr\xF8v igen eller brug en anden betalingsmetode",
      cardNumber: "Kortnummer",
      expiry: "Udl\xF8bsdato",
      storedPaymentLabel: "{name} Gemt kort udl\xF8ber den {lastFour}."
    },
    agreements: {
      label: "Jeg accepterer",
      errorMessage: "Dette er et p\xE5kr\xE6vet felt"
    },
    privacyPolicy: {
      content: "Du kan l\xE6se om, hvordan vi h\xE5ndterer dine data i vores",
      link: "Privatlivspolitik"
    },
    termsServices: {
      content: "Med din ordre, du fort\xE6ller dig selv med vores vilk\xE5r",
      generalLink: "og Handelsbetingelser, ",
      privacyLink: "Databeskyttelsepolitik",
      withdrawLink: "og tilbagekaldelse enige."
    },
    newsletter: {
      label: "Tilmeld dig nyhedsbrevet"
    },
    donation: {
      donateText: "Don\xE9r",
      removeDonation: "Fjern donation",
      donateTitle: "Don\xE9r dine cent",
      charityLogo: "Velg\xF8renhed Logo",
      penniesLogo: "Pennies Logo"
    },
    payWith: {
      masterCard: "Betal med Master Card",
      visa: "Betal med Visa",
      paypal: "Betal med PayPal",
      clearPay: "Betal med Clearpay",
      klarna: "Betal med Klarna"
    },
    giftMessage: {
      to: "Til:",
      from: "Fra:",
      message: "Besked:"
    },
    inflatableBalloons: {
      title: "Levering af balloner",
      description: "Din(e) oppustede ballon(er) vil blive leveret p\xE5 den dato, der er valgt nedenfor, alle andre varer i din ordre vil blive leveret i henhold til din valgte leveringsmetode.",
      openBtnText: "V\xE6lg en leveringsdag.",
      savedMethod: "Levering af oppustede balloner.",
      message: "* Den dag, du valgte, er ikke l\xE6ngere tilg\xE6ngelig. V\xE6lg venligst en anden dato."
    },
    months: [
      "Januar",
      "Februar",
      "Marts",
      "April",
      "Maj",
      "Juni",
      "Juli",
      "August",
      "September",
      "Oktober",
      "November",
      "December"
    ],
    weekdays: [
      "Mandag",
      "Tirsdag",
      "Onsdag",
      "Torsdag",
      "Fredag",
      "L\xF8rdag",
      "S\xF8ndag"
    ]
  };
  var atTranslations = {
    header: {
      text: "Sichere Bestellung"
    },
    dividerText: "Oder gib deine E-Mailadresse ein f\xFCr eine Zahlung per Kredit- oder Bankkarte",
    payNoExpressWithBlockTitle: "Gib deine E-Mailadresse ein f\xFCr eine Zahlung per Kredit- oder Bankkarte",
    orderSummary: {
      applyBtn: "Anwenden",
      removeBtn: "Entfernen",
      modalHeader: "Bestell\xFCbersicht",
      mobileDiscountText: "",
      backBtn: "Zur\xFCck",
      grandTotalTitle: "Gesamtsumme",
      inclTaxTitle: "MwSt.",
      exclTaxTitle: "zzgl. MwSt.",
      discountTitle: "Rabatt",
      subtotalTitle: "Summe",
      removeItemButton: "Entfernen",
      removeItemButtonLabel: "Artikel entfernen",
      minusOneItem: "Ein Artikel weniger",
      plusOneItem: "Ein Artikel mehr",
      giftDiscountTitle: "Promo Code eingeben",
      giftCardDiscount: {
        placeholder: "Code eingeben",
        successMessage: 'Code erfolgreich eingegeben "{code}".'
      },
      couponCodeTitle: "Bestelle f\xFCr weitere",
      couponCodeTitleBottom: "f\xFCr einen",
      couponCodeTitleFreeShipping: "Gratisversand",
      couponCode: {
        placeholder: "Code eingeben"
      },
      addToCart: "In den Warenkorb",
      promoTitle: "Schlie\xDFe deine Bestellung ab mit...",
      closeButton: "Bestell\xFCbersicht schlie\xDFen",
      mixedShipping: "Getrennt versendet",
      heliumItem: "Bef\xFCllt versendet",
      skuNumber: "SKU Nr.:",
      supplierStockNumber: "Lieferant Lager Nr.:"
    },
    progressBar: {
      detailStepTitle: "Deine Informationen",
      shippingStepTitle: "Versand",
      paymentStepTitle: "Zahlung"
    },
    yourDetailsSection: {
      title: "Deine Informationen",
      selectPlaceholder: "Bitte w\xE4hle ein Land",
      showPassLabel: "Passwort zeigen oder verstecken",
      phoneField: {
        infoMessage: "Wir werden diese Nummer nur nutzen, um dich bez\xFCglich deiner Lieferung zu kontaktieren.",
        placeholder: "Telefonnummer eingeben",
        label: "Telefonnummer"
      },
      emailAddress: {
        placeholder: "E-Mail Adresse eingeben",
        label: "E-Mail Adresse",
        span: "E-Mail"
      },
      passwordField: {
        placeholder: "Passwort eingeben",
        label: "Dein Passwort"
      },
      firstName: {
        placeholder: "Vorname eingeben",
        label: "Vorname"
      },
      lastName: {
        placeholder: "Nachname eingeben",
        label: "Nachname"
      },
      deliverySection: {
        toShippingButton: "Versandoption w\xE4hlen",
        title: "Lieferadresse",
        savedAddressesTitle: "W\xE4hle deine gespeicherte Lieferadresse",
        shipHere: "Hierhin versenden",
        info: "Wohin sollen wir versenden?",
        billingAddressTitle: "Rechnungsadresse",
        deliveryAddressTitle: "Lieferadresse",
        addressFinder: {
          title: "Adressenfinder",
          placeholder: "Nach Stra\xDFe oder PLZ suchen",
          label: "Stra\xDFe oder PLZ"
        },
        addressForm: {
          saveAddressButton: "Diese Adresse verwenden",
          linkText: "Adresse manuell eingeben",
          addressField: {
            placeholder: "Erste Adresszeile eingeben",
            unrequired: "Adresse eingeben (Zeile 2)",
            label: "Erste Adresszeile",
            unrequiredLabel: "Adresse (Zeile 2)"
          },
          cityField: {
            label: "Stadt",
            placeholder: "Stadt eingeben"
          },
          countryField: {
            label: "Land",
            placeholder: "Land eingeben"
          },
          postCodeField: {
            label: "PLZ",
            placeholder: "PLZ eingeben"
          },
          regionField: {
            label: "Bundesland",
            placeholder: "Bundesland eingeben"
          }
        }
      }
    },
    editButton: "Bearbeiten",
    editButtonLabel: "E-Mail Adresse bearbeiten",
    editDetailsButtonLabel: "Informationen bearbeiten",
    editShippingButtonLabel: "Versandinformationen bearbeiten",
    errorMessages: {
      firstNameErrorMessage: "Bitte g\xFCltigen Vornamen eingeben",
      lastNameErrorMessage: "Bitte g\xFCltigen Nachnamen eingeben",
      emailErrorMessage: "Bitte g\xFCltige E-Mailadresse eingeben",
      phoneErrorMessage: "Keine g\xFCltige Telefonnummer",
      passwordHelpText: "Muss mindestens 8 Zeichen und mindestens 3 Zeichentypen beinhalten",
      passwordErrorMessage: "Bitte g\xFCltige E-Mailadresse und Passwort eingeben",
      addressFormErrorMessage: "Bitte sicherstellen, dass alle Pflichtfelder ausgef\xFCllt sind",
      postCodeErrorMessage: "Bitte g\xFCltige PLZ eingeben f\xFCr",
      countryErrorMessage: "Bitte Land w\xE4hlen",
      streetErrorMessage: "Bitte g\xFCltige Adresse eingeben und maximal 75 Zeichen verwenden",
      cityErrorMessage: "Bitte g\xFCltige Stadt eingeben",
      regionErrorMessage: "Bitte g\xFCltiges Land eingeben",
      googlePayShippingError: "Keine Versandoption gew\xE4hlt. Bitte Versandoption w\xE4hlen und erneut versuchen.",
      googlePayNominatedDayError: "Leider k\xF6nnen wir keine Expresszahlung bei Bestellungen mit Wunschlieferdatum anbieten",
      oosErrorMessage: "Artikel leider ausverkauft",
      noShippingMethods: "Keine Versandoptionen f\xFCr gew\xE4hlte Adresse gefunden",
      googlePayNoShippingMethods: "Keine Versandoptionen f\xFCr gew\xE4hlte Adresse gefunden",
      unexpectedPaymentError: "Es ist ein unerwarteter Fehler aufgetreten"
    },
    welcomeMessages: {
      accountBody: "Mit Kundenkonto anmelden oder als Gast fortfahren",
      accountTitle: "Willkommen zur\xFCck!",
      getStarted: "E-Mail eingeben, um zu starten",
      guestBody: "Sieht aus, als w\xE4rst du neu hier! Setze deine Bestellung als Gast fort; du hast die M\xF6glichkeit ein Kundenkonto zu erstellen, sobald du die Bestellung abgeschlossen hast.",
      guestTitle: "Hallo"
    },
    signInButton: "Anmelden",
    noAccountGuestButton: "Als Gast fortfahren",
    accountGuestButton: "Oder als Gast fortfahren",
    continueButton: "Fortfahren",
    forgotPass: "Passwort vergessen?",
    updateButton: "Aktualisieren",
    billingForm: {
      notSameAddress: "Meine Rechnungs- und Lieferadresse sind gleich"
    },
    shippingStep: {
      proceedToPay: "Weiter zur Zahlung",
      stepTitle: "Versandoption w\xE4hlen",
      stepCompleteTitle: "Versand",
      stepTitleSubText: "Versandoption w\xE4hlen",
      nominatedDelivery: "Wunschdatum w\xE4hlen",
      tbc: "Im n\xE4chsten Schritt berechnet",
      methodLabel: "Erhalten bis zum",
      noDeliveryDate: "Lieferdatum w\xE4hlen"
    },
    addNewAddressBtn: "+ Neue Adresse hinzuf\xFCgen",
    saveNewAddress: "In Adressbuch speichern",
    paymentStep: {
      title: "Zahlungsart w\xE4hlen",
      freePayment: "Keine Zahlungsinformationen ben\xF6tigt",
      freeButton: "Jetzt bezahlen",
      storedPayments: "Deine gespeicherten Zahlungen",
      creditDebitCard: "Kredit- oder Bankkarte"
    },
    productOptionsTrigger: "Artikeloptionen",
    instantCheckout: "Express Zahlung",
    checkoutTitle: "Bestellung",
    adyen: {
      applePayTotal: "Gesamtsumme",
      applePayNoShippingMethods: "Derzeit sind keine Versandoptionen f\xFCr dich verf\xFCgbar. Bitte versuche es erneut oder nutze eine andere Zahlungsart",
      cardNumber: "Kartennummer",
      expiry: "Ablaufdatum",
      storedPaymentLabel: "{name} Gespeicherte Karte endet auf {lastFour}"
    },
    agreements: {
      label: "Ich akzeptiere die",
      errorMessage: "Dies ist ein Pflichtfeld"
    },
    privacyPolicy: {
      content: "Wie deine Daten von uns behandelt werden, kannst du nachlesen in unserer",
      link: "Datenschutzerkl\xE4rung"
    },
    termsServices: {
      content: "Mit deiner Bestellung erkl\xE4rst du dich mit ",
      generalLink: "unseren AGB,",
      privacyLink: " Datenschutzbestimmungen",
      withdrawLink: "und der Widerrufsbelehrung einverstanden."
    },
    newsletter: {
      label: "F\xFCr Newsletter anmelden"
    },
    donation: {
      donateText: "Spenden",
      removeDonation: "Spende entfernen",
      donateTitle: "Spende deine Cents",
      charityLogo: "Wohlt\xE4tigkeit Logo",
      penniesLogo: "Pennies Logo"
    },
    payWith: {
      masterCard: "mit Master Card zahlen",
      visa: "mit Visa zahlen",
      paypal: "mit PayPal zahlen",
      clearPay: "mit Clearpay zahlen",
      klarna: "mit Klarna zahlen"
    },
    giftMessage: {
      to: "An:",
      from: "Von:",
      message: "Nachricht:"
    },
    inflatableBalloons: {
      title: "Ballonlieferung",
      description: "Dein(e) voraufgeblasene(r) Ballon(s) wird (werden) an dem unten ausgew\xE4hlten Datum geliefert, alle anderen Artikel in deiner Bestellung werden entsprechend der von dir gew\xE4hlten Lieferoption geliefert.",
      openBtnText: "W\xE4hle einen Liefertag.",
      savedMethod: "Versand bef\xFCllte Ballons",
      message: "* Der von dir gew\xE4hlte Tag ist nicht mehr verf\xFCgbar. Bitte w\xE4hle ein anderes Datum."
    },
    months: [
      "Januar",
      "Februar",
      "M\xE4rz",
      "April",
      "Mai",
      "Juni",
      "Juli",
      "August",
      "September",
      "Oktober",
      "November",
      "Dezember"
    ],
    weekdays: [
      "Montag",
      "Dienstag",
      "Mittwoch",
      "Donnerstag",
      "Freitag",
      "Samstag",
      "Sonntag"
    ]
  };
  var chTranslations = {
    header: {
      text: "S\xE4ker best\xE4llning"
    },
    dividerText: "Eller ange din e-postadress f\xF6r att betala med kredit-/betalkort",
    payNoExpressWithBlockTitle: "Ange din e-postadress f\xF6r att betala med kredit-/betalkort",
    orderSummary: {
      applyBtn: "Till\xE4mpa",
      removeBtn: "Ta bort",
      modalHeader: "Sammanfattning av best\xE4llningen",
      mobileDiscountText: "",
      backBtn: "Tillbaka till",
      grandTotalTitle: "Summa totalt",
      inclTaxTitle: "Moms",
      exclTaxTitle: "plus moms",
      discountTitle: "Rabatt",
      subtotalTitle: "Delsumma",
      removeItemButton: "Ta bort",
      removeItemButtonLabel: "Ta bort artikel",
      minusOneItem: "minus ett artikel",
      plusOneItem: "plus en artikel",
      giftDiscountTitle: "L\xE4gg till en promo kod",
      giftCardDiscount: {
        placeholder: "Ange koden h\xE4r",
        successMessage: 'Koden "{code}" har matats in.'
      },
      couponCodeTitle: "F\xF6r en annan",
      couponCodeTitleBottom: "kan du f\xE5 en",
      couponCodeTitleFreeShipping: "fri leverans",
      couponCode: {
        placeholder: "Ange kod h\xE4r"
      },
      addToCart: "L\xE4gg i varukorgen",
      promoTitle: "Slutf\xF6r din best\xE4llning med...",
      closeButton: "St\xE4ng order\xF6versikt",
      mixedShipping: "Detta kommer att levereras separat",
      heliumItem: "Levereras uppbl\xE5st",
      skuNumber: "SKU-nr:",
      supplierStockNumber: "Leverant\xF6r Lager nr:"
    },
    progressBar: {
      detailStepTitle: "Din information",
      shippingStepTitle: "Frakt",
      paymentStepTitle: "Betalning"
    },
    yourDetailsSection: {
      title: "Din information",
      selectPlaceholder: "V\xE4nligen v\xE4lj ett land",
      showPassLabel: "Visa eller d\xF6lj l\xF6senord",
      phoneField: {
        infoMessage: "Vi kommer endast att anv\xE4nda detta nummer om vi beh\xF6ver kontakta dig ang\xE5ende din leverans.",
        placeholder: "Ange ditt telefonnummer",
        label: "Ditt telefonnummer"
      },
      emailAddress: {
        placeholder: "Ange din e-postadress",
        label: "E-postadress",
        span: "E-post"
      },
      passwordField: {
        placeholder: "Ange ditt l\xF6senord",
        label: "Ditt l\xF6senord"
      },
      firstName: {
        placeholder: "Ange ditt f\xF6rnamn",
        label: "F\xF6rnamn"
      },
      lastName: {
        placeholder: "Ange ditt efternamn",
        label: "Efternamn"
      },
      deliverySection: {
        toShippingButton: "V\xE4lj din fraktmetod",
        title: "Leveransadress",
        savedAddressesTitle: "V\xE4lj din sparade leveransadress",
        shipHere: "Skicka h\xE4r",
        info: "Vart ska vi leverera den till?",
        billingAddressTitle: "Faktureringsadress",
        deliveryAddressTitle: "Leveransadress",
        addressFinder: {
          title: "S\xF6k efter adress",
          placeholder: "S\xF6k efter gatunamn eller postnummer",
          label: "Gatunamn eller postnummer"
        },
        addressForm: {
          saveAddressButton: "Anv\xE4nd denna adress",
          linkText: "Ange din adress manuellt",
          addressField: {
            placeholder: "Ange f\xF6rsta raden i adressen",
            unrequired: "Ange adress (rad 2)",
            label: "F\xF6rsta raden i adressen",
            unrequiredLabel: "Adress (rad 2)"
          },
          cityField: {
            label: "Stad",
            placeholder: "Ange stad"
          },
          countryField: {
            label: "Land",
            placeholder: "Ange land"
          },
          postCodeField: {
            label: "Postnummer",
            placeholder: "Ange postnummer"
          },
          regionField: {
            label: "L\xE4n",
            placeholder: "Ange l\xE4n"
          }
        }
      },
      editButton: "Redigera",
      editButtonLabel: "Redigera e-postadress",
      editDetailsButtonLabel: "Redigera information",
      editShippingButtonLabel: "Redigera leveransinformation"
    },
    errorMessages: {
      firstNameErrorMessage: "V\xE4nligen ange giltigt f\xF6rnamn",
      lastNameErrorMessage: "V\xE4nligen ange giltigt efternamn",
      emailErrorMessage: "Ange giltig e-postadress",
      phoneErrorMessage: "Inget giltigt telefonnummer",
      passwordHelpText: "M\xE5ste inneh\xE5lla minst 8 tecken och minst 3 teckentyper",
      passwordErrorMessage: "Ange giltig e-postadress och l\xF6senord",
      addressFormErrorMessage: "Se till att alla obligatoriska f\xE4lt \xE4r ifyllda",
      postCodeErrorMessage: "Ange en giltig postkod f\xF6r",
      countryErrorMessage: "V\xE4nligen v\xE4lj land",
      streetErrorMessage: "Ange giltig adress och anv\xE4nd h\xF6gst 75 tecken",
      cityErrorMessage: "V\xE4nligen ange giltig stad",
      regionErrorMessage: "V\xE4nligen ange giltigt land",
      googlePayShippingError: "Inget leveransalternativ valt. V\xE4lj fraktalternativ och f\xF6rs\xF6k igen.",
      googlePayNominatedDayError: "Tyv\xE4rr kan vi inte erbjuda expressbetalning f\xF6r best\xE4llningar med \xF6nskat leveransdatum",
      oosErrorMessage: "Tyv\xE4rr \xE4r denna artikel slut i lager.",
      noShippingMethods: "Inga leveransmetoder hittades f\xF6r den valda adressen.",
      googlePayNoShippingMethods: "Inga leveransmetoder hittades f\xF6r den valda adressen.",
      unexpectedPaymentError: "Es ist ein unerwarteter Fehler aufgetreten"
    },
    welcomeMessages: {
      accountBody: "Logga in p\xE5 ditt konto f\xF6r att betala eller forts\xE4tt som g\xE4st.",
      accountTitle: "V\xE4lkommen tillbaka!",
      getStarted: "Ange din e-postadress f\xF6r att komma ig\xE5ng.",
      guestBody: "Ser ut som du \xE4r ny h\xE4r! Forts\xE4tt till kassan som g\xE4st med m\xF6jlighet att skapa ett konto n\xE4r du har lagt din best\xE4llning",
      guestTitle: "Hej"
    },
    signInButton: "Logga in",
    noAccountGuestButton: "Forts\xE4tt som g\xE4st",
    accountGuestButton: "Eller Forts\xE4tt som g\xE4st",
    continueButton: "Forts\xE4tt",
    forgotPass: "Har du gl\xF6mt ditt l\xF6senord?",
    updateButton: "Uppdatering",
    billingForm: {
      notSameAddress: "Min fakturerings- och leveransadress \xE4r samma"
    },
    shippingStep: {
      proceedToPay: "Forts\xE4tt till betalning",
      stepTitle: "V\xE4lj leveransmetod",
      stepCompleteTitle: "Frakt",
      stepTitleSubText: "V\xE4lj frakts\xE4tt",
      nominatedDelivery: "V\xE4lj en dag som passar dig.",
      tbc: "Ber\xE4knas i n\xE4sta steg",
      methodLabel: "H\xE4mta det genom",
      noDeliveryDate: "V\xE4lj leveransdatum"
    },
    addNewAddressBtn: "L\xE4gg till ny adress",
    saveNewAddress: "Spara i adressbok",
    paymentStep: {
      title: "V\xE4lj en betalningsmetod",
      freePayment: "Ingen betalningsinformation kr\xE4vs",
      freeButton: "Betala nu",
      storedPayments: "Dina sparade betalningar",
      creditDebitCard: "Kredit- eller betalkort"
    },
    productOptionsTrigger: "Alternativ f\xF6r objekt",
    instantCheckout: "Expressbetalning",
    checkoutTitle: "Best\xE4llning",
    adyen: {
      applePayTotal: "Totalt",
      applePayNoShippingMethods: "Det finns inga tillg\xE4ngliga fraktmetoder f\xF6r dig just nu. F\xF6rs\xF6k igen eller anv\xE4nd en annan betalningsmetod.",
      cardNumber: "Kortnummer",
      expiry: "F\xF6rfallodag",
      storedPaymentLabel: "{namn} Lagrat kort upph\xF6r att g\xE4lla {sistaFj\xE4rde}"
    },
    agreements: {
      label: "Jag bekr\xE4ftar att jag har l\xE4st och accepterar",
      errorMessage: "Detta \xE4r ett obligatoriskt f\xE4lt."
    },
    privacyPolicy: {
      content: "Dina uppgifter kommer att hanteras enligt vad som anges i v\xE5r",
      link: "integritetspolicy"
    },
    termsServices: {
      content: "Mit deiner Bestellung erkl\xE4rst du dich mit ",
      generalLink: "unseren AGB,",
      privacyLink: " Datenschutzbestimmungen",
      withdrawLink: "und der Widerrufsbelehrung einverstanden."
    },
    newsletter: {
      label: "Prenumerera p\xE5 nyhetsbrevet"
    },
    donation: {
      donateText: "Donera",
      removeDonation: "Ta bort donation",
      donateTitle: "Donera dina pennies",
      charityLogo: "Charity Logo",
      penniesLogo: "Pennies Logo"
    },
    payWith: {
      masterCard: "betala med Master Card",
      visa: "betala med Visa",
      paypal: "betala med PayPal",
      clearPay: "betala med Clearpay",
      klarna: "betala med Klarna"
    },
    giftMessage: {
      to: "Till:",
      from: "Fr\xE5n:",
      message: "Meddelande:"
    },
    inflatableBalloons: {
      title: "Leverans av ballonger",
      description: "Din(a) f\xF6ruppbl\xE5sta ballong(er) kommer att levereras p\xE5 det datum som valts nedan, alla andra artiklar i din best\xE4llning kommer att levereras enligt ditt valda leveransalternativ.",
      openBtnText: "V\xE4lj en dag som passar dig.",
      savedMethod: "Uppbl\xE5sta ballonger Leverans.",
      message: "* Ditt valda datum \xE4r inte l\xE4ngre tillg\xE4ngligt. V\xE4nligen v\xE4lj ett annat datum."
    },
    months: [
      "Januari",
      "Februari",
      "Mars",
      "April",
      "Maj",
      "Juni",
      "Juli",
      "Augusti",
      "September",
      "Oktober",
      "November",
      "December"
    ],
    weekdays: [
      "M\xE5ndag",
      "Tisdag",
      "Onsdag",
      "Torsdag",
      "Fredag",
      "L\xF6rdag",
      "S\xF6ndag"
    ]
  };
  var deTranslations = {
    header: {
      text: "Sichere Bestellung"
    },
    dividerText: "Oder gib deine E-Mailadresse ein f\xFCr eine Zahlung per Kredit- oder Bankkarte",
    payNoExpressWithBlockTitle: "Gib deine E-Mailadresse ein f\xFCr eine Zahlung per Kredit- oder Bankkarte",
    orderSummary: {
      applyBtn: "Anwenden",
      removeBtn: "Entfernen",
      modalHeader: "Bestell\xFCbersicht",
      mobileDiscountText: "",
      backBtn: "Zur\xFCck",
      grandTotalTitle: "Gesamtsumme",
      inclTaxTitle: "MwSt.",
      exclTaxTitle: "zzgl. MwSt.",
      discountTitle: "Rabatt",
      subtotalTitle: "Summe",
      removeItemButton: "Entfernen",
      removeItemButtonLabel: "Artikel entfernen",
      minusOneItem: "Ein Artikel weniger",
      plusOneItem: "Ein Artikel mehr",
      giftDiscountTitle: "Promo Code eingeben",
      giftCardDiscount: {
        placeholder: "Code eingeben",
        successMessage: 'Code erfolgreich eingegeben "{code}".'
      },
      couponCodeTitle: "Bestelle f\xFCr weitere",
      couponCodeTitleBottom: "f\xFCr einen",
      couponCodeTitleFreeShipping: "Gratisversand",
      couponCode: {
        placeholder: "Code eingeben"
      },
      addToCart: "In den Warenkorb",
      promoTitle: "Schlie\xDFe deine Bestellung ab mit...",
      closeButton: "Bestell\xFCbersicht schlie\xDFen",
      mixedShipping: "Getrennt versendet",
      heliumItem: "Bef\xFCllt versendet",
      skuNumber: "SKU Nr.:",
      supplierStockNumber: "Lieferant Lager Nr.:"
    },
    progressBar: {
      detailStepTitle: "Deine Informationen",
      shippingStepTitle: "Versand",
      paymentStepTitle: "Zahlung"
    },
    yourDetailsSection: {
      title: "Deine Informationen",
      selectPlaceholder: "Bitte w\xE4hle ein Land",
      showPassLabel: "Passwort zeigen oder verstecken",
      phoneField: {
        infoMessage: "Wir werden diese Nummer nur nutzen, um dich bez\xFCglich deiner Lieferung zu kontaktieren.",
        placeholder: "Telefonnummer eingeben",
        label: "Telefonnummer"
      },
      emailAddress: {
        placeholder: "E-Mail Adresse eingeben",
        label: "E-Mail Adresse",
        span: "E-Mail"
      },
      passwordField: {
        placeholder: "Passwort eingeben",
        label: "Dein Passwort"
      },
      firstName: {
        placeholder: "Vorname eingeben",
        label: "Vorname"
      },
      lastName: {
        placeholder: "Nachname eingeben",
        label: "Nachname"
      },
      deliverySection: {
        toShippingButton: "Versandoption w\xE4hlen",
        title: "Lieferadresse",
        savedAddressesTitle: "W\xE4hle deine gespeicherte Lieferadresse",
        shipHere: "Hierhin versenden",
        info: "Wohin sollen wir versenden?",
        billingAddressTitle: "Rechnungsadresse",
        deliveryAddressTitle: "Lieferadresse",
        addressFinder: {
          title: "Adressenfinder",
          placeholder: "Nach Stra\xDFe oder PLZ suchen",
          label: "Stra\xDFe oder PLZ"
        },
        addressForm: {
          saveAddressButton: "Diese Adresse verwenden",
          linkText: "Adresse manuell eingeben",
          addressField: {
            placeholder: "Erste Adresszeile eingeben",
            unrequired: "Adresse eingeben (Zeile 2)",
            label: "Erste Adresszeile",
            unrequiredLabel: "Adresse (Zeile 2)"
          },
          cityField: {
            label: "Stadt",
            placeholder: "Stadt eingeben"
          },
          countryField: {
            label: "Land",
            placeholder: "Land eingeben"
          },
          postCodeField: {
            label: "PLZ",
            placeholder: "PLZ eingeben"
          },
          regionField: {
            label: "Bundesland",
            placeholder: "Bundesland eingeben"
          }
        }
      }
    },
    editButton: "Bearbeiten",
    editButtonLabel: "E-Mail Adresse bearbeiten",
    editDetailsButtonLabel: "Informationen bearbeiten",
    editShippingButtonLabel: "Versandinformationen bearbeiten",
    errorMessages: {
      firstNameErrorMessage: "Bitte g\xFCltigen Vornamen eingeben",
      lastNameErrorMessage: "Bitte g\xFCltigen Nachnamen eingeben",
      emailErrorMessage: "Bitte g\xFCltige E-Mailadresse eingeben",
      phoneErrorMessage: "Keine g\xFCltige Telefonnummer",
      passwordHelpText: "Muss mindestens 8 Zeichen und mindestens 3 Zeichentypen beinhalten",
      passwordErrorMessage: "Bitte g\xFCltige E-Mailadresse und Passwort eingeben",
      addressFormErrorMessage: "Bitte sicherstellen, dass alle Pflichtfelder ausgef\xFCllt sind",
      postCodeErrorMessage: "Bitte g\xFCltige PLZ eingeben f\xFCr",
      countryErrorMessage: "Bitte Land w\xE4hlen",
      streetErrorMessage: "Bitte g\xFCltige Adresse eingeben und maximal 75 Zeichen verwenden",
      cityErrorMessage: "Bitte g\xFCltige Stadt eingeben",
      regionErrorMessage: "Bitte g\xFCltiges Land eingeben",
      googlePayShippingError: "Keine Versandoption gew\xE4hlt. Bitte Versandoption w\xE4hlen und erneut versuchen.",
      googlePayNominatedDayError: "Leider k\xF6nnen wir keine Expresszahlung bei Bestellungen mit Wunschlieferdatum anbieten",
      oosErrorMessage: "Artikel leider ausverkauft",
      noShippingMethods: "Keine Versandoptionen f\xFCr gew\xE4hlte Adresse gefunden",
      googlePayNoShippingMethods: "Keine Versandoptionen f\xFCr gew\xE4hlte Adresse gefunden",
      unexpectedPaymentError: "Es ist ein unerwarteter Fehler aufgetreten"
    },
    welcomeMessages: {
      accountBody: "Mit Kundenkonto anmelden oder als Gast fortfahren",
      accountTitle: "Willkommen zur\xFCck!",
      getStarted: "E-Mail eingeben, um zu starten",
      guestBody: "Sieht aus, als w\xE4rst du neu hier! Setze deine Bestellung als Gast fort; du hast die M\xF6glichkeit ein Kundenkonto zu erstellen, sobald du die Bestellung abgeschlossen hast.",
      guestTitle: "Hallo"
    },
    signInButton: "Anmelden",
    noAccountGuestButton: "Als Gast fortfahren",
    accountGuestButton: "Oder als Gast fortfahren",
    continueButton: "Fortfahren",
    forgotPass: "Passwort vergessen?",
    updateButton: "Aktualisieren",
    billingForm: {
      notSameAddress: "Meine Rechnungs- und Lieferadresse sind gleich"
    },
    shippingStep: {
      proceedToPay: "Weiter zur Zahlung",
      stepTitle: "Versandoption w\xE4hlen",
      stepCompleteTitle: "Versand",
      stepTitleSubText: "Versandoption w\xE4hlen",
      nominatedDelivery: "Wunschdatum w\xE4hlen",
      tbc: "Im n\xE4chsten Schritt berechnet",
      methodLabel: "Erhalten bis zum",
      noDeliveryDate: "Lieferdatum w\xE4hlen"
    },
    addNewAddressBtn: "+ Neue Adresse hinzuf\xFCgen",
    saveNewAddress: "In Adressbuch speichern",
    paymentStep: {
      title: "Zahlungsart w\xE4hlen",
      freePayment: "Keine Zahlungsinformationen ben\xF6tigt",
      freeButton: "Jetzt bezahlen",
      storedPayments: "Deine gespeicherten Zahlungen",
      creditDebitCard: "Kredit- oder Bankkarte"
    },
    productOptionsTrigger: "Artikeloptionen",
    instantCheckout: "Express Zahlung",
    checkoutTitle: "Bestellung",
    adyen: {
      applePayTotal: "Gesamtsumme",
      applePayNoShippingMethods: "Derzeit sind keine Versandoptionen f\xFCr dich verf\xFCgbar. Bitte versuche es erneut oder nutze eine andere Zahlungsart",
      cardNumber: "Kartennummer",
      expiry: "Ablaufdatum",
      storedPaymentLabel: "{name} Gespeicherte Karte endet auf {lastFour}"
    },
    agreements: {
      label: "Ich akzeptiere die",
      errorMessage: "Dies ist ein Pflichtfeld"
    },
    privacyPolicy: {
      content: "Wie deine Daten von uns behandelt werden, kannst du nachlesen in unserer",
      link: "Datenschutzerkl\xE4rung"
    },
    termsServices: {
      content: "Mit deiner Bestellung erkl\xE4rst du dich mit ",
      generalLink: "unseren AGB,",
      privacyLink: " Datenschutzbestimmungen",
      withdrawLink: "und der Widerrufsbelehrung einverstanden."
    },
    newsletter: {
      label: "F\xFCr Newsletter anmelden"
    },
    donation: {
      donateText: "Spenden",
      removeDonation: "Spende entfernen",
      donateTitle: "Spende deine Cents",
      charityLogo: "Wohlt\xE4tigkeit Logo",
      penniesLogo: "Pennies Logo"
    },
    payWith: {
      masterCard: "mit Master Card zahlen",
      visa: "mit Visa zahlen",
      paypal: "mit PayPal zahlen",
      clearPay: "mit Clearpay zahlen",
      klarna: "mit Klarna zahlen"
    },
    giftMessage: {
      to: "An:",
      from: "Von:",
      message: "Nachricht:"
    },
    inflatableBalloons: {
      title: "Ballonlieferung",
      description: "Dein(e) voraufgeblasene(r) Ballon(s) wird (werden) an dem unten ausgew\xE4hlten Datum geliefert, alle anderen Artikel in deiner Bestellung werden entsprechend der von dir gew\xE4hlten Lieferoption geliefert.",
      openBtnText: "W\xE4hle einen Liefertag.",
      savedMethod: "Versand bef\xFCllte Ballons",
      message: "* Der von dir gew\xE4hlte Tag ist nicht mehr verf\xFCgbar. Bitte w\xE4hle ein anderes Datum."
    },
    months: [
      "Januar",
      "Februar",
      "M\xE4rz",
      "April",
      "Mai",
      "Juni",
      "Juli",
      "August",
      "September",
      "Oktober",
      "November",
      "Dezember"
    ],
    weekdays: [
      "Montag",
      "Dienstag",
      "Mittwoch",
      "Donnerstag",
      "Freitag",
      "Samstag",
      "Sonntag"
    ]
  };
  var esTranslations = {
    header: {
      text: "Pago seguro"
    },
    dividerText: "O introduzca su direcci\xF3n de correo electr\xF3nico para pagar con tarjeta de cr\xE9dito/d\xE9bito",
    payNoExpressWithBlockTitle: "Introduzca su direcci\xF3n de correo electr\xF3nico para pagar con tarjeta de cr\xE9dito/d\xE9bito",
    orderSummary: {
      applyBtn: "Solicitar",
      removeBtn: "Eliminar",
      modalHeader: "Resumen del pedido",
      mobileDiscountText: "",
      backBtn: "Volver",
      grandTotalTitle: "Total compra",
      inclTaxTitle: "IVA",
      exclTaxTitle: "Sin IVA",
      discountTitle: "Descuento",
      subtotalTitle: "Total",
      removeItemButton: "Eliminar",
      removeItemButtonLabel: "Quitar art\xEDculo",
      minusOneItem: "Un art\xEDculo menos",
      plusOneItem: "Un art\xEDculo m\xE1s",
      giftDiscountTitle: "Introducir c\xF3digo promocional",
      giftCardDiscount: {
        placeholder: "Introducir c\xF3digo",
        successMessage: 'C\xF3digo introducido con \xE9xito "{code}".'
      },
      couponCodeTitle: "Pedido de m\xE1s",
      couponCodeTitleBottom: "por uno",
      couponCodeTitleFreeShipping: "env\xEDo gratuito",
      couponCode: {
        placeholder: "Introducir c\xF3digo"
      },
      addToCart: "A\xF1adir a la cesta",
      promoTitle: "Completa tu pedido con...",
      closeButton: "Cerrar resumen del pedido",
      mixedShipping: "Enviado por separado",
      heliumItem: "Se env\xEDa lleno",
      skuNumber: "N\xBA SKU",
      supplierStockNumber: "Proveedor N\xBA de stock:"
    },
    progressBar: {
      detailStepTitle: "Su informaci\xF3n",
      shippingStepTitle: "Env\xEDo",
      paymentStepTitle: "Pago"
    },
    yourDetailsSection: {
      title: "Sus datos",
      selectPlaceholder: "Elija un pa\xEDs",
      showPassLabel: "Mostrar u ocultar contrase\xF1a",
      phoneField: {
        infoMessage: "S\xF3lo utilizaremos este n\xFAmero para ponernos en contacto con usted en relaci\xF3n con su entrega.",
        placeholder: "Introduzca el n\xFAmero de tel\xE9fono",
        label: "N\xFAmero de tel\xE9fono"
      },
      emailAddress: {
        placeholder: "Introduzca la direcci\xF3n de correo electr\xF3nico",
        label: "Direcci\xF3n de correo electr\xF3nico",
        span: "Correo electr\xF3nico"
      },
      passwordField: {
        placeholder: "Introduzca su contrase\xF1a",
        label: "Su contrase\xF1a"
      },
      firstName: {
        placeholder: "Introduzca su nombre",
        label: "Nombre"
      },
      lastName: {
        placeholder: "Introduzca sus apellidos",
        label: "Apellidos"
      },
      deliverySection: {
        toShippingButton: "Elija su m\xE9todo de env\xEDo",
        title: "Direcci\xF3n de env\xEDo",
        savedAddressesTitle: "Seleccione su direcci\xF3n de env\xEDo guardada",
        shipHere: "Enviar aqu\xED",
        info: "\xBFD\xF3nde debemos entregarlo?",
        billingAddressTitle: "Direcci\xF3n de facturaci\xF3n",
        deliveryAddressTitle: "Direcci\xF3n de env\xEDo",
        addressFinder: {
          title: "Buscador de direcciones",
          placeholder: "Buscar por nombre de calle o c\xF3digo postal",
          label: "Calle o c\xF3digo postal"
        },
        addressForm: {
          saveAddressButton: "Utilice esta direcci\xF3n",
          linkText: "Introduzca su direcci\xF3n manualmente",
          addressField: {
            placeholder: "Introduzca la primera l\xEDnea de la direcci\xF3n",
            unrequired: "Introduzca la direcci\xF3n (l\xEDnea 2)",
            label: "Primera l\xEDnea de la direcci\xF3n",
            unrequiredLabel: "Direcci\xF3n (l\xEDnea 2)"
          },
          cityField: {
            label: "Ciudad",
            placeholder: "Introduzca la ciudad"
          },
          countryField: {
            label: "Pa\xEDs",
            placeholder: "Introduzca el pa\xEDs"
          },
          postCodeField: {
            label: "C\xF3digo postal",
            placeholder: "Introduzca el c\xF3digo postal"
          },
          regionField: {
            label: "Provincia",
            placeholder: "Introduzca la provincia"
          }
        }
      },
      editButton: "Modificar",
      editButtonLabel: "Modificar direcci\xF3n de correo electr\xF3nico",
      editDetailsButtonLabel: "Modificar sus datos",
      editShippingButtonLabel: "Modificar sus datos de env\xEDo"
    },
    errorMessages: {
      firstNameErrorMessage: "Introduzca un nombre v\xE1lido",
      lastNameErrorMessage: "Introduzca un apellido v\xE1lido",
      emailErrorMessage: "Introduzca una direcci\xF3n de correo electr\xF3nico v\xE1lida",
      phoneErrorMessage: "N\xFAmero de tel\xE9fono no v\xE1lido",
      passwordHelpText: "M\xEDnimo 8 caracteres y debe incluir al menos tres clases de caracteres",
      passwordErrorMessage: "Introduzca una direcci\xF3n de correo electr\xF3nico y una contrase\xF1a v\xE1lidas.",
      addressFormErrorMessage: "Aseg\xFArese de rellenar todos los campos obligatorios",
      postCodeErrorMessage: "Introduzca un c\xF3digo postal v\xE1lido para",
      countryErrorMessage: "Seleccione su pa\xEDs",
      streetErrorMessage: "Introduzca una direcci\xF3n v\xE1lida con un m\xE1ximo de 75 caracteres.",
      cityErrorMessage: "Introduzca una ciudad v\xE1lida",
      regionErrorMessage: "Introduzca una pa\xEDs v\xE1lido",
      googlePayShippingError: "Falta el m\xE9todo de env\xEDo. Seleccione el m\xE9todo de env\xEDo e int\xE9ntelo de nuevo.",
      googlePayNominatedDayError: "Lamentablemente, no podemos ofrecer el pago expr\xE9s en pedidos con entrega en d\xEDa se\xF1alado.",
      oosErrorMessage: "Lo sentimos, este art\xEDculo est\xE1 agotado.",
      noShippingMethods: "No se han encontrado m\xE9todos de env\xEDo para la direcci\xF3n seleccionada.",
      googlePayNoShippingMethods: "No se han encontrado m\xE9todos de env\xEDo para la direcci\xF3n seleccionada.",
      unexpectedPaymentError: "Ha ocurrido un error inesperado"
    },
    welcomeMessages: {
      accountBody: "Acceda a su cuenta para pagar o contin\xFAe como invitado.",
      accountTitle: "Bienvenido",
      getStarted: "Introduce tu correo electr\xF3nico para empezar.",
      guestBody: "\xA1Parece que eres nuevo aqu\xED! Continuar con el pago como invitado con la opci\xF3n de crear una cuenta una vez que haya realizado su pedido",
      guestTitle: "Hola"
    },
    signInButton: "Conectarse",
    noAccountGuestButton: "Continuar como invitado",
    accountGuestButton: "O continuar como invitado",
    continueButton: "Continuar",
    forgotPass: "\xBFHa olvidado su contrase\xF1a?",
    updateButton: "Actualizar",
    billingForm: {
      notSameAddress: "Mi direcci\xF3n de facturaci\xF3n y de env\xEDo coinciden"
    },
    shippingStep: {
      proceedToPay: "Continuar con el pago",
      stepTitle: "Seleccione la opci\xF3n de env\xEDo",
      stepCompleteTitle: "Env\xEDo",
      stepTitleSubText: "Seleccione la opci\xF3n de env\xEDo",
      nominatedDelivery: "Seleccione la fecha deseada",
      tbc: "Calculado en el siguiente paso",
      methodLabel: "Recibido antes de",
      noDeliveryDate: "Seleccione la fecha de entrega"
    },
    addNewAddressBtn: "A\xF1adir nueva direcci\xF3n",
    saveNewAddress: "Guardar en la libreta de direcciones",
    paymentStep: {
      title: "Seleccione el m\xE9todo de pago",
      freePayment: "No se requieren datos de pago",
      freeButton: "Pagar ahora",
      storedPayments: "Sus pagos guardados",
      creditDebitCard: "Tarjeta de cr\xE9dito o d\xE9bito"
    },
    productOptionsTrigger: "Opciones de art\xEDculo",
    instantCheckout: "Pago expr\xE9s",
    checkoutTitle: "Pedido",
    adyen: {
      applePayTotal: "Total compra",
      applePayNoShippingMethods: "Actualmente no hay opciones de env\xEDo disponibles para usted. Por favor, int\xE9ntelo de nuevo o utilice otro m\xE9todo de pago",
      cardNumber: "N\xFAmero de tarjeta",
      expiry: "Fecha de caducidad",
      storedPaymentLabel: "{name} Tarjeta guardada caduca el {lastFour}"
    },
    agreements: {
      label: "Acepto la",
      errorMessage: "Este campo es obligatorio"
    },
    privacyPolicy: {
      content: "Puede consultar c\xF3mo tratamos sus datos en nuestra",
      link: "Pol\xEDtica de privacidad"
    },
    termsServices: {
      content: "Al realizar su pedido en nuestra web, acepta los ",
      generalLink: "T\xE9rminos y las Condiciones,",
      privacyLink: " cumplimiento de la Pol\xEDtica de Privacidad",
      withdrawLink: "y la Pol\xEDtica de Cambios y Devoluciones."
    },
    newsletter: {
      label: "Inscribirse en el bolet\xEDn"
    },
    donation: {
      donateText: "Donar",
      removeDonation: "Eliminar donaci\xF3n",
      donateTitle: "Done sus c\xE9ntimos",
      charityLogo: "Logotipo ben\xE9fico",
      penniesLogo: "Logotipo de Pennies"
    },
    payWith: {
      masterCard: "pagar con Master Card",
      visa: "pagar con Visa",
      paypal: "pague con PayPal",
      clearPay: "pague con Clearpay",
      klarna: "pague con Klarna"
    },
    giftMessage: {
      to: "Para:",
      from: "De:",
      message: "Mensaje:"
    },
    inflatableBalloons: {
      title: "Entrega de globos",
      description: "Su(s) globo(s) preinflado(s) ser\xE1(n) entregado(s) en la fecha seleccionada a continuaci\xF3n, todos los dem\xE1s art\xEDculos de su pedido ser\xE1n entregados seg\xFAn el m\xE9todo de env\xEDo elegido.",
      openBtnText: "Elija un d\xEDa de entrega.",
      savedMethod: "Entrega de globos inflados.",
      message: "* La fecha seleccionada ya no est\xE1 disponible. Por favor, elija otra fecha.",
      months: [
        "Enero",
        "Febrero",
        "Marzo",
        "Abril",
        "Mayo",
        "Junio",
        "Julio",
        "Agosto",
        "Septiembre",
        "Octubre",
        "Noviembre",
        "Diciembre"
      ],
      weekdays: [
        "Lunes",
        "Martes",
        "Mi\xE9rcoles",
        "Jueves",
        "Viernes",
        "S\xE1bado",
        "Domingo"
      ]
    }
  };
  var beTranslations = {
    header: {
      text: "Paiement s\xE9curis\xE9"
    },
    dividerText: "Ou saisissez votre adresse e-mail pour payer par carte de cr\xE9dit/d\xE9bit",
    payNoExpressWithBlockTitle: "Saisissez votre adresse e-mail pour payer par carte de cr\xE9dit/d\xE9bit",
    orderSummary: {
      applyBtn: "Appliquer",
      removeBtn: "Supprimer",
      modalHeader: "R\xE9capitulatif de votre commande",
      mobileDiscountText: "",
      backBtn: "Retour",
      grandTotalTitle: "Montant total",
      inclTaxTitle: "TVA",
      exclTaxTitle: "Hors taxe",
      discountTitle: "Remise",
      subtotalTitle: "Sous-total",
      removeItemButton: "Supprimer",
      removeItemButtonLabel: "Supprimer l'article",
      minusOneItem: "Un article en moins",
      plusOneItem: "Un article en plus",
      giftDiscountTitle: "Ajouter un code promotionnel",
      giftCardDiscount: {
        placeholder: "Saisir le code ici",
        successMessage: 'Le code "{code}" a bien \xE9t\xE9 pris en compte'
      },
      couponCodeTitle: "Encore...",
      couponCodeTitleBottom: "pour b\xE9n\xE9ficier",
      couponCodeTitleFreeShipping: "de la livraison gratuite",
      couponCode: {
        placeholder: "Saisir le code ici"
      },
      addToCart: "Ajouter au panier",
      promoTitle: "Finalisez votre commande avec...",
      closeButton: "Fermer le r\xE9capitulatif de commande",
      mixedShipping: "Ce produit sera exp\xE9di\xE9 s\xE9par\xE9ment",
      heliumItem: "Livr\xE9 gonfl\xE9",
      skuNumber: "N\xB0 SKU",
      supplierStockNumber: "N\xB0 de stock fournisseur"
    },
    progressBar: {
      detailStepTitle: "Vos coordonn\xE9es",
      shippingStepTitle: "Exp\xE9dition",
      paymentStepTitle: "Paiement"
    },
    yourDetailsSection: {
      title: "Vos coordonn\xE9es",
      selectPlaceholder: "Veuillez s\xE9lectionner votre pays",
      showPassLabel: "Afficher ou masquer le mot de passe",
      phoneField: {
        infoMessage: "Nous n'utiliserons ce num\xE9ro que si nous devons vous contacter au sujet de votre livraison.",
        placeholder: "Saisissez votre num\xE9ro de t\xE9l\xE9phone",
        label: "Num\xE9ro de t\xE9l\xE9phone"
      },
      emailAddress: {
        placeholder: "Saisissez votre adresse e-mail",
        label: "Adresse e-mail",
        span: "E-mail"
      },
      passwordField: {
        placeholder: "Saisissez votre mot de passe",
        label: "Votre mot de passe"
      },
      firstName: {
        placeholder: "Saisissez votre pr\xE9nom",
        label: "Pr\xE9nom"
      },
      lastName: {
        placeholder: "Saisissez votre nom",
        label: "Nom"
      },
      deliverySection: {
        toShippingButton: "Choisissez votre mode d'exp\xE9dition",
        title: "Adresse de livraison",
        savedAddressesTitle: "S\xE9lectionnez une adresse de livraison d\xE9j\xE0 enregistr\xE9e.",
        shipHere: "Exp\xE9dier ici",
        info: "O\xF9 devons-nous le livrer ?",
        billingAddressTitle: "Adresse de facturation",
        deliveryAddressTitle: "Adresse de livraison",
        addressFinder: {
          title: "Recherche d'adresse",
          placeholder: "Recherche par nom de rue ou code postal",
          label: "Nom de la rue ou code postal"
        },
        addressForm: {
          saveAddressButton: "Utiliser cette adresse",
          linkText: "Saisissez votre adresse manuellement",
          addressField: {
            placeholder: "Saisir la premi\xE8re ligne de l'adresse",
            unrequired: "Saisir l'adresse (ligne 2)",
            label: "Premi\xE8re ligne de l'adresse",
            unrequiredLabel: "Adresse (ligne 2)"
          },
          cityField: {
            label: "Ville",
            placeholder: "Saisir la ville"
          },
          countryField: {
            label: "Pays",
            placeholder: "Saisir le pays"
          },
          postCodeField: {
            label: "Code postal",
            placeholder: "Saisir le code postal"
          },
          regionField: {
            label: "D\xE9partement",
            placeholder: "Saisir le d\xE9partement"
          }
        }
      },
      editButton: "Modifier",
      editButtonLabel: "Modifier votre adresse e-mail",
      editDetailsButtonLabel: "Modifier vos coordonn\xE9es",
      editShippingButtonLabel: "Modifier votre adresse d'exp\xE9dition"
    },
    errorMessages: {
      firstNameErrorMessage: "Veuillez saisir un pr\xE9nom valide",
      lastNameErrorMessage: "Veuillez saisir un nom valide",
      emailErrorMessage: "Veuillez saisir une adresse e-mail valide",
      phoneErrorMessage: "Num\xE9ro de t\xE9l\xE9phone non valide",
      passwordHelpText: "Doit contenir minimum 8 caract\xE8res et inclure au moins trois types de caract\xE8res",
      passwordErrorMessage: "Veuillez saisir une adresse e-mail et un mot de passe valides.",
      addressFormErrorMessage: "Veuillez vous assurer que tous les champs obligatoires sont bien remplis.",
      postCodeErrorMessage: "Veuillez saisir un code postal valide pour",
      countryErrorMessage: "Veuillez s\xE9lectionner votre pays",
      streetErrorMessage: "Veuillez saisir une adresse valide et utiliser un maximum de 75 caract\xE8res.",
      cityErrorMessage: "Veuillez saisir une ville valide",
      regionErrorMessage: "Veuillez saisir un d\xE9partement valide",
      googlePayShippingError: "Vous n'avez pas s\xE9lectionn\xE9 de mode d'exp\xE9dition. Veuillez s\xE9lectionner le mode d'exp\xE9dition d\xE9sir\xE9 et r\xE9essayer.",
      googlePayNominatedDayError: "Malheureusement, nous ne pouvons pas offrir le paiement express pour les commandes avec livraison le jour d\xE9sign\xE9.",
      oosErrorMessage: "D\xE9sol\xE9, cet article n'est plus en stock.",
      noShippingMethods: "Aucune mode d'exp\xE9dition n'a \xE9t\xE9 trouv\xE9 pour l'adresse s\xE9lectionn\xE9e.",
      googlePayNoShippingMethods: "Aucune mode d'exp\xE9dition n'a \xE9t\xE9 trouv\xE9 pour l'adresse s\xE9lectionn\xE9e.",
      unexpectedPaymentError: "Une erreur inattendue s'est produite"
    },
    welcomeMessages: {
      accountBody: "Connectez-vous \xE0 votre compte pour passer \xE0 la caisse ou continuez en tant qu'invit\xE9.",
      accountTitle: "Bienvenue \xE0 nouveau !",
      getStarted: "Saisissez votre e-mail pour commencer.",
      guestBody: "Il semble que vous soyez nouveau ici ! Poursuivez votre commande en tant qu'invit\xE9 avec l'option de cr\xE9er un compte une fois que vous aurez pass\xE9 votre commande.",
      guestTitle: "Bonjour"
    },
    signInButton: "Se connecter",
    noAccountGuestButton: "Continuer en tant qu'invit\xE9",
    accountGuestButton: "Ou continuer en tant qu'invit\xE9",
    continueButton: "Continuer",
    forgotPass: "Vous avez oubli\xE9 votre mot de passe ?",
    updateButton: "Actualiser",
    billingForm: {
      notSameAddress: "Mes adresses de facturation et de livraison sont les m\xEAmes"
    },
    shippingStep: {
      proceedToPay: "Passer au paiement",
      stepTitle: "S\xE9lectionner un mode d'exp\xE9dition",
      stepCompleteTitle: "Exp\xE9dition",
      stepTitleSubText: "S\xE9lectionnez un mode d'exp\xE9dition",
      nominatedDelivery: "Choisissez le jour qui vous convient.",
      tbc: "Calcul\xE9 \xE0 l'\xE9tape suivante",
      methodLabel: "Recevoir avant le",
      noDeliveryDate: "Choisir la date de livraison"
    },
    addNewAddressBtn: "Ajouter une autre adresse",
    saveNewAddress: "Enregistrer dans le carnet d'adresses",
    paymentStep: {
      title: "S\xE9lectionnez un mode de paiement",
      freePayment: "Aucune information de paiement n'est requise",
      freeButton: "Payer maintenant",
      storedPayments: "Vos paiements enregistr\xE9s",
      creditDebitCard: "Carte de cr\xE9dit ou de d\xE9bit"
    },
    productOptionsTrigger: "Options de produit",
    instantCheckout: "Paiement instantan\xE9",
    checkoutTitle: "Paiement",
    adyen: {
      applePayTotal: "Montant total",
      applePayNoShippingMethods: "Aucun mode d'exp\xE9dition n'est actuellement disponible pour vous.  Veuillez r\xE9essayer ou utiliser un autre mode de paiement.",
      cardNumber: "Num\xE9ro de carte",
      expiry: "Date d'expiration",
      storedPaymentLabel: "{name} La carte enregistr\xE9e expire le {lastFour}"
    },
    agreements: {
      label: "Je confirme que j'ai lu et que j'accepte les",
      errorMessage: "Ce champ est obligatoire."
    },
    privacyPolicy: {
      content: "Vos donn\xE9es seront trait\xE9es comme indiqu\xE9 dans notre",
      link: "politique de confidentialit\xE9"
    },
    termsServices: {
      content: 'En cliquant sur "Commander", vous acceptez ',
      generalLink: "notre CGV, ",
      privacyLink: " notre clause de confidentialit\xE9",
      withdrawLink: "nos directives de r\xE9tractation."
    },
    newsletter: {
      label: "S'abonner \xE0 la lettre d'information"
    },
    donation: {
      donateText: "Faire un don",
      removeDonation: "Supprimer le don",
      donateTitle: "Donnez vos centimes",
      charityLogo: "Logo de l'association caritative",
      penniesLogo: "Logo de Pennies"
    },
    payWith: {
      masterCard: "Payer avec une Master Card",
      visa: "Payer avec une Visa",
      paypal: "Payer avec PayPal",
      clearPay: "Payer avec Clearpay",
      klarna: "Payer avec Klarna"
    },
    giftMessage: {
      to: "A :",
      from: "De :",
      message: "Message :"
    },
    inflatableBalloons: {
      title: "Livraison des ballons",
      description: "Votre (vos) ballon(s) pr\xE9-gonfl\xE9(s) sera (seront) livr\xE9(s) \xE0 la date s\xE9lectionn\xE9e ci-dessous. Les autres articles de votre commande seront livr\xE9s selon l'option de livraison que vous aurez choisie.",
      openBtnText: "S\xE9lectionnez le jour qui vous convient.",
      savedMethod: "Livraison de ballons gonfl\xE9s.",
      message: "* Le jour que vous avez s\xE9lectionn\xE9 n'est plus disponible. Veuillez choisir une autre date."
    },
    months: [
      "janvier",
      "f\xE9vrier",
      "mars",
      "avril",
      "mai",
      "juin",
      "juillet",
      "ao\xFBt",
      "septembre",
      "octobre",
      "novembre",
      "d\xE9cembre"
    ],
    weekdays: [
      "lundi",
      "mardi",
      "mercredi",
      "jeudi",
      "vendredi",
      "samedi",
      "dimanche"
    ]
  };
  var frChTranslations = {
    header: {
      text: "Paiement s\xE9curis\xE9"
    },
    dividerText: "Ou saisissez votre adresse e-mail pour payer par carte de cr\xE9dit/d\xE9bit",
    payNoExpressWithBlockTitle: "Saisissez votre adresse e-mail pour payer par carte de cr\xE9dit/d\xE9bit",
    orderSummary: {
      applyBtn: "Appliquer",
      removeBtn: "Supprimer",
      modalHeader: "R\xE9capitulatif de votre commande",
      mobileDiscountText: "",
      backBtn: "Retour",
      grandTotalTitle: "Montant total",
      inclTaxTitle: "TVA",
      exclTaxTitle: "Hors taxe",
      discountTitle: "Remise",
      subtotalTitle: "Sous-total",
      removeItemButton: "Supprimer",
      removeItemButtonLabel: "Supprimer l'article",
      minusOneItem: "Un article en moins",
      plusOneItem: "Un article en plus",
      giftDiscountTitle: "Ajouter un code promotionnel",
      giftCardDiscount: {
        placeholder: "Saisir le code ici",
        successMessage: 'Le code "{code}" a bien \xE9t\xE9 pris en compte'
      },
      couponCodeTitle: "Encore...",
      couponCodeTitleBottom: "pour b\xE9n\xE9ficier",
      couponCodeTitleFreeShipping: "de la livraison gratuite",
      couponCode: {
        placeholder: "Saisir le code ici"
      },
      addToCart: "Ajouter au panier",
      promoTitle: "Finalisez votre commande avec...",
      closeButton: "Fermer le r\xE9capitulatif de commande",
      mixedShipping: "Ce produit sera exp\xE9di\xE9 s\xE9par\xE9ment",
      heliumItem: "Livr\xE9 gonfl\xE9",
      skuNumber: "N\xB0 SKU",
      supplierStockNumber: "N\xB0 de stock fournisseur"
    },
    progressBar: {
      detailStepTitle: "Vos coordonn\xE9es",
      shippingStepTitle: "Exp\xE9dition",
      paymentStepTitle: "Paiement"
    },
    yourDetailsSection: {
      title: "Vos coordonn\xE9es",
      selectPlaceholder: "Veuillez s\xE9lectionner votre pays",
      showPassLabel: "Afficher ou masquer le mot de passe",
      phoneField: {
        infoMessage: "Nous n'utiliserons ce num\xE9ro que si nous devons vous contacter au sujet de votre livraison.",
        placeholder: "Saisissez votre num\xE9ro de t\xE9l\xE9phone",
        label: "Num\xE9ro de t\xE9l\xE9phone"
      },
      emailAddress: {
        placeholder: "Saisissez votre adresse e-mail",
        label: "Adresse e-mail",
        span: "E-mail"
      },
      passwordField: {
        placeholder: "Saisissez votre mot de passe",
        label: "Votre mot de passe"
      },
      firstName: {
        placeholder: "Saisissez votre pr\xE9nom",
        label: "Pr\xE9nom"
      },
      lastName: {
        placeholder: "Saisissez votre nom",
        label: "Nom"
      },
      deliverySection: {
        toShippingButton: "Choisissez votre mode d'exp\xE9dition",
        title: "Adresse de livraison",
        savedAddressesTitle: "S\xE9lectionnez une adresse de livraison d\xE9j\xE0 enregistr\xE9e.",
        shipHere: "Exp\xE9dier ici",
        info: "O\xF9 devons-nous le livrer ?",
        billingAddressTitle: "Adresse de facturation",
        deliveryAddressTitle: "Adresse de livraison",
        addressFinder: {
          title: "Recherche d'adresse",
          placeholder: "Recherche par nom de rue ou code postal",
          label: "Nom de la rue ou code postal"
        },
        addressForm: {
          saveAddressButton: "Utiliser cette adresse",
          linkText: "Saisissez votre adresse manuellement",
          addressField: {
            placeholder: "Saisir la premi\xE8re ligne de l'adresse",
            unrequired: "Saisir l'adresse (ligne 2)",
            label: "Premi\xE8re ligne de l'adresse",
            unrequiredLabel: "Adresse (ligne 2)"
          },
          cityField: {
            label: "Ville",
            placeholder: "Saisir la ville"
          },
          countryField: {
            label: "Pays",
            placeholder: "Saisir le pays"
          },
          postCodeField: {
            label: "Code postal",
            placeholder: "Saisir le code postal"
          },
          regionField: {
            label: "D\xE9partement",
            placeholder: "Saisir le d\xE9partement"
          }
        }
      },
      editButton: "Modifier",
      editButtonLabel: "Modifier votre adresse e-mail",
      editDetailsButtonLabel: "Modifier vos coordonn\xE9es",
      editShippingButtonLabel: "Modifier votre adresse d'exp\xE9dition"
    },
    errorMessages: {
      firstNameErrorMessage: "Veuillez saisir un pr\xE9nom valide",
      lastNameErrorMessage: "Veuillez saisir un nom valide",
      emailErrorMessage: "Veuillez saisir une adresse e-mail valide",
      phoneErrorMessage: "Num\xE9ro de t\xE9l\xE9phone non valide",
      passwordHelpText: "Doit contenir minimum 8 caract\xE8res et inclure au moins trois types de caract\xE8res",
      passwordErrorMessage: "Veuillez saisir une adresse e-mail et un mot de passe valides.",
      addressFormErrorMessage: "Veuillez vous assurer que tous les champs obligatoires sont bien remplis.",
      postCodeErrorMessage: "Veuillez saisir un code postal valide pour",
      countryErrorMessage: "Veuillez s\xE9lectionner votre pays",
      streetErrorMessage: "Veuillez saisir une adresse valide et utiliser un maximum de 75 caract\xE8res.",
      cityErrorMessage: "Veuillez saisir une ville valide",
      regionErrorMessage: "Veuillez saisir un d\xE9partement valide",
      googlePayShippingError: "Vous n'avez pas s\xE9lectionn\xE9 de mode d'exp\xE9dition. Veuillez s\xE9lectionner le mode d'exp\xE9dition d\xE9sir\xE9 et r\xE9essayer.",
      googlePayNominatedDayError: "Malheureusement, nous ne pouvons pas offrir le paiement express pour les commandes avec livraison le jour d\xE9sign\xE9.",
      oosErrorMessage: "D\xE9sol\xE9, cet article n'est plus en stock.",
      noShippingMethods: "Aucune mode d'exp\xE9dition n'a \xE9t\xE9 trouv\xE9 pour l'adresse s\xE9lectionn\xE9e.",
      googlePayNoShippingMethods: "Aucune mode d'exp\xE9dition n'a \xE9t\xE9 trouv\xE9 pour l'adresse s\xE9lectionn\xE9e.",
      unexpectedPaymentError: "Une erreur inattendue s'est produite"
    },
    welcomeMessages: {
      accountBody: "Connectez-vous \xE0 votre compte pour passer \xE0 la caisse ou continuez en tant qu'invit\xE9.",
      accountTitle: "Bienvenue \xE0 nouveau !",
      getStarted: "Saisissez votre e-mail pour commencer.",
      guestBody: "Il semble que vous soyez nouveau ici ! Poursuivez votre commande en tant qu'invit\xE9 avec l'option de cr\xE9er un compte une fois que vous aurez pass\xE9 votre commande.",
      guestTitle: "Bonjour"
    },
    signInButton: "Se connecter",
    noAccountGuestButton: "Continuer en tant qu'invit\xE9",
    accountGuestButton: "Ou continuer en tant qu'invit\xE9",
    continueButton: "Continuer",
    forgotPass: "Vous avez oubli\xE9 votre mot de passe ?",
    updateButton: "Actualiser",
    billingForm: {
      notSameAddress: "Mes adresses de facturation et de livraison sont les m\xEAmes"
    },
    shippingStep: {
      proceedToPay: "Passer au paiement",
      stepTitle: "S\xE9lectionner un mode d'exp\xE9dition",
      stepCompleteTitle: "Exp\xE9dition",
      stepTitleSubText: "S\xE9lectionnez un mode d'exp\xE9dition",
      nominatedDelivery: "Choisissez le jour qui vous convient.",
      tbc: "Calcul\xE9 \xE0 l'\xE9tape suivante",
      methodLabel: "Recevoir avant le",
      noDeliveryDate: "Choisir la date de livraison"
    },
    addNewAddressBtn: "Ajouter une autre adresse",
    saveNewAddress: "Enregistrer dans le carnet d'adresses",
    paymentStep: {
      title: "S\xE9lectionnez un mode de paiement",
      freePayment: "Aucune information de paiement n'est requise",
      freeButton: "Payer maintenant",
      storedPayments: "Vos paiements enregistr\xE9s",
      creditDebitCard: "Carte de cr\xE9dit ou de d\xE9bit"
    },
    productOptionsTrigger: "Options de produit",
    instantCheckout: "Paiement instantan\xE9",
    checkoutTitle: "Paiement",
    adyen: {
      applePayTotal: "Montant total",
      applePayNoShippingMethods: "Aucun mode d'exp\xE9dition n'est actuellement disponible pour vous.  Veuillez r\xE9essayer ou utiliser un autre mode de paiement.",
      cardNumber: "Num\xE9ro de carte",
      expiry: "Date d'expiration",
      storedPaymentLabel: "{name} La carte enregistr\xE9e expire le {lastFour}"
    },
    agreements: {
      label: "Je confirme que j'ai lu et que j'accepte les",
      errorMessage: "Ce champ est obligatoire."
    },
    privacyPolicy: {
      content: "Vos donn\xE9es seront trait\xE9es comme indiqu\xE9 dans notre",
      link: "politique de confidentialit\xE9"
    },
    termsServices: {
      content: 'En cliquant sur "Commander", vous acceptez ',
      generalLink: "notre CGV, ",
      privacyLink: " notre clause de confidentialit\xE9",
      withdrawLink: "nos directives de r\xE9tractation."
    },
    newsletter: {
      label: "S'abonner \xE0 la lettre d'information"
    },
    donation: {
      donateText: "Faire un don",
      removeDonation: "Supprimer le don",
      donateTitle: "Donnez vos centimes",
      charityLogo: "Logo de l'association caritative",
      penniesLogo: "Logo de Pennies"
    },
    payWith: {
      masterCard: "Payer avec une Master Card",
      visa: "Payer avec une Visa",
      paypal: "Payer avec PayPal",
      clearPay: "Payer avec Clearpay",
      klarna: "Payer avec Klarna"
    },
    giftMessage: {
      to: "A :",
      from: "De :",
      message: "Message :"
    },
    inflatableBalloons: {
      title: "Livraison des ballons",
      description: "Votre (vos) ballon(s) pr\xE9-gonfl\xE9(s) sera (seront) livr\xE9(s) \xE0 la date s\xE9lectionn\xE9e ci-dessous. Les autres articles de votre commande seront livr\xE9s selon l'option de livraison que vous aurez choisie.",
      openBtnText: "S\xE9lectionnez le jour qui vous convient.",
      savedMethod: "Livraison de ballons gonfl\xE9s.",
      message: "* Le jour que vous avez s\xE9lectionn\xE9 n'est plus disponible. Veuillez choisir une autre date."
    },
    months: [
      "janvier",
      "f\xE9vrier",
      "mars",
      "avril",
      "mai",
      "juin",
      "juillet",
      "ao\xFBt",
      "septembre",
      "octobre",
      "novembre",
      "d\xE9cembre"
    ],
    weekdays: [
      "lundi",
      "mardi",
      "mercredi",
      "jeudi",
      "vendredi",
      "samedi",
      "dimanche"
    ]
  };
  var itTranslations = {
    header: {
      text: "Pagamento sicuro"
    },
    dividerText: "Oppure inserisci il tuo indirizzo e-mail per pagare con carta di credito/debito",
    payNoExpressWithBlockTitle: "Inserisci il tuo indirizzo e-mail per pagare con carta di credito/debito",
    orderSummary: {
      applyBtn: "Utilizza",
      removeBtn: "Rimuovi",
      modalHeader: "Riepilogo ordine",
      mobileDiscountText: "",
      backBtn: "Indietro",
      grandTotalTitle: "Importo Totale",
      inclTaxTitle: "IVA",
      exclTaxTitle: "pi\xF9 IVA.",
      discountTitle: "Sconto",
      subtotalTitle: "Totale",
      removeItemButton: "Elimina",
      removeItemButtonLabel: "Elimina articolo",
      minusOneItem: "Un articolo in meno",
      plusOneItem: "Un articolo in pi\xF9",
      giftDiscountTitle: "Inserisci il codice promozionale",
      giftCardDiscount: {
        placeholder: "Inserisci il codice",
        successMessage: 'Il codice "{code}" \xE8 stato inserito correttamente'
      },
      couponCodeTitle: "Continua a ordinare",
      couponCodeTitleBottom: "\xE8 possibile ottenere",
      couponCodeTitleFreeShipping: "consegna gratuita",
      couponCode: {
        placeholder: "Inserisci il codice"
      },
      addToCart: "Aggiungi al carrello",
      promoTitle: "Completa il tuo ordine con...",
      closeButton: "Riepilogo ordine",
      mixedShipping: "Questo artivolo sar\xE0 spedito separatamente",
      heliumItem: "Spedito gonfiato",
      skuNumber: "N. SKU",
      supplierStockNumber: "N\xB0 di magazzino"
    },
    progressBar: {
      detailStepTitle: "I tuoi recapiti",
      shippingStepTitle: "Spedizione",
      paymentStepTitle: "Pagamento"
    },
    yourDetailsSection: {
      title: "I tuoi recapiti",
      selectPlaceholder: "Scegli un paese",
      showPassLabel: "Mostra o nascondi la password",
      phoneField: {
        infoMessage: "Utilizzeremo questo numero solo se avremo bisogno di contattarti per la consegna.",
        placeholder: "Inserisci il numero di telefono",
        label: "Numero di telefono"
      },
      emailAddress: {
        placeholder: "Inserisci l'indirizzo e-mail",
        label: "Indirizzo e-mail",
        span: "E-mail"
      },
      passwordField: {
        placeholder: "Inserisci la tua password",
        label: "La tua password"
      },
      firstName: {
        placeholder: "Inserisci il tuo nome",
        label: "Nome"
      },
      lastName: {
        placeholder: "Inserisci il tuo cognome",
        label: "Cognome"
      },
      deliverySection: {
        toShippingButton: "Scegli il metodo di spedizione",
        title: "Indirizzo di spedizione",
        savedAddressesTitle: "Scegli un indirizzo di consegna gi\xE0 salvato",
        shipHere: "Spedire qui",
        info: "Dove dobbiamo consegnare?",
        billingAddressTitle: "Indirizzo di fatturazione",
        deliveryAddressTitle: "Indirizzo di spedizione",
        addressFinder: {
          title: "Cerca indirizzo",
          placeholder: "Cerca per nome o codice postale",
          label: "Strada o codice postale"
        },
        addressForm: {
          saveAddressButton: "Utilizza questo indirizzo",
          linkText: "Inserisci manualmente l'indirizzo",
          addressField: {
            placeholder: "Inserisci la prima riga dell'indirizzo",
            unrequired: "Inserisci l'indirizzo (riga 2)",
            label: "Prima riga dell'indirizzo",
            unrequiredLabel: "Indirizzo (riga 2)"
          },
          cityField: {
            label: "Citt\xE0",
            placeholder: "Inserisci la citt\xE0"
          },
          countryField: {
            label: "Paese",
            placeholder: "Inserisci il paese"
          },
          postCodeField: {
            label: "Codice postale",
            placeholder: "Inserisci il codice postale"
          },
          regionField: {
            label: "Provincia",
            placeholder: "Inserisci la provincia"
          }
        }
      },
      editButton: "Modifica",
      editButtonLabel: "Modifica l'indirizzo e-mail",
      editDetailsButtonLabel: "Modifica informazioni",
      editShippingButtonLabel: "Modifica informazioni di spedizione"
    },
    errorMessages: {
      firstNameErrorMessage: "Inserisci un nome valido",
      lastNameErrorMessage: "Inserisci un cognome valido",
      emailErrorMessage: "Inserisci un indirizzo e-mail valido",
      phoneErrorMessage: "Numero di telefono non valido",
      passwordHelpText: "Minimo 8 caratteri e almeno tre tipi di carattere.",
      passwordErrorMessage: "Inserisci un indirizzo e-mail e una password validi",
      addressFormErrorMessage: "Assicurarti che tutti i campi obbligatori siano compilati",
      postCodeErrorMessage: "Inserisci un CAP valido per",
      countryErrorMessage: "Seleziona il paese",
      streetErrorMessage: "Inserisci un indirizzo valido e utilizza massimo 75 caratteri",
      cityErrorMessage: "Inserisci una citt\xE0 valida",
      regionErrorMessage: "Inserisci un paese valido",
      googlePayShippingError: "Nessun metodo di spedizione selezionato. Scegli un metodo di spedizione e riprova.",
      googlePayNominatedDayError: "Purtroppo non \xE8 possibile scegliere la spedizione express con la data di consegna richiesta",
      oosErrorMessage: "Purtroppo l'articolo \xE8 esaurito",
      noShippingMethods: "Nessun metodo di spedizione trovato per l'indirizzo selezionato",
      googlePayNoShippingMethods: "Nessun metodo di spedizione trovato per l'indirizzo selezionato",
      unexpectedPaymentError: "Si \xE8 verificato un errore"
    },
    welcomeMessages: {
      accountBody: "Accedi con un account cliente o continua come ospite",
      accountTitle: "Bentornato!",
      getStarted: "Inserisci l'e-mail per iniziare",
      guestBody: "Vai al checkout come ospite; avrai la possibilit\xE0 di creare un account dopo aver effettuato l'ordine",
      guestTitle: "Ciao"
    },
    signInButton: "Registrati",
    noAccountGuestButton: "Procedi come ospite",
    accountGuestButton: "Oppure continua come ospite",
    continueButton: "Avanti",
    forgotPass: "Hai dimenticato la password?",
    updateButton: "Aggiorna",
    billingForm: {
      notSameAddress: "L'indirizzo di fatturazione e l'indirizzo di spedizione sono uguali"
    },
    shippingStep: {
      proceedToPay: "Vai al pagamento",
      stepTitle: "Scegli il metodo di spedizione",
      stepCompleteTitle: "Spedizione",
      stepTitleSubText: "Scegli il metodo di spedizione",
      nominatedDelivery: "Scegli il giorno che preferisci",
      tbc: "Calcolato nel passaggio successivo",
      methodLabel: "Ricevi entro",
      noDeliveryDate: "Scegli la data di consegna"
    },
    addNewAddressBtn: "Aggiungi un nuovo indirizzo",
    saveNewAddress: "Salva in rubrica",
    paymentStep: {
      title: "Scegli il metodo di pagamento",
      freePayment: "Non sono richieste informazioni di pagamento",
      freeButton: "Paga ora",
      storedPayments: "I pagamenti effettuati",
      creditDebitCard: "Carta di credito o di debito"
    },
    productOptionsTrigger: "Opzioni articolo",
    instantCheckout: "Checkout immediato",
    checkoutTitle: "Checkout",
    adyen: {
      applePayTotal: "Importo totale",
      applePayNoShippingMethods: "Al momento non ci sono metodi di spedizione disponibili. Riprova o utilizza un altro metodo di pagamento.",
      cardNumber: "Numero di carta",
      expiry: "Data di scadenza",
      storedPaymentLabel: "{name} La carta scade il {lastFour}"
    },
    agreements: {
      label: "Confermo di aver letto e accetto il/la",
      errorMessage: "Questo campo \xE8 obbligatorio"
    },
    privacyPolicy: {
      content: "I tuoi dati saranno trattati come descritto nella nostra",
      link: "politica sulla privacy"
    },
    termsServices: {
      content: "Completando l'ordine accetti i termini e ",
      generalLink: "le condizioni,",
      privacyLink: " le norme sulla protezione dei dati",
      withdrawLink: "e le istruzioni di revoca."
    },
    newsletter: {
      label: "Iscriviti alla newsletter"
    },
    donation: {
      donateText: "Dona",
      removeDonation: "Rimuovi la donazione",
      donateTitle: "Dona i centesimi",
      charityLogo: "Logo di Beneficenza",
      penniesLogo: "Logo di Pennies"
    },
    payWith: {
      masterCard: "Paga con Master Card",
      visa: "Paga con Visa",
      paypal: "Paga con Paypal",
      clearPay: "Paga con Clearpay",
      klarna: "Paga con Klarna"
    },
    giftMessage: {
      to: "A:",
      from: "Da:",
      message: "Messaggio:"
    },
    inflatableBalloons: {
      title: "Consegna palloncini",
      description: "I tuoi palloncini pre-gonfiati verranno consegnati nella data selezionata di seguito, il tuo ordine arriver\xE0 in base all'opzione di consegna scelta.",
      openBtnText: "Seleziona il giorno che preferisci",
      savedMethod: "Consegna palloncini gonfiati.",
      message: "* La data selezionata non \xE8 pi\xF9 disponibile. Si prega di scegliere un'altra data.",
      months: [
        "Gennaio",
        "Febbraio",
        "Marzo",
        "Aprile",
        "Maggio",
        "Giugno",
        "Luglio",
        "Agosto",
        "Settembre",
        "Ottobre",
        "Novembre",
        "Dicembre"
      ],
      weekdays: [
        "Lunedi",
        "Marted\xEC",
        "Mercoled\xEC",
        "Gioved\xEC",
        "Venerd\xEC",
        "Sabato",
        "Domenica"
      ]
    }
  };
  var itCHTranslations = {
    header: {
      text: "Pagamento sicuro"
    },
    dividerText: "Oppure inserisci il tuo indirizzo e-mail per pagare con carta di credito/debito",
    payNoExpressWithBlockTitle: "Inserisci il tuo indirizzo e-mail per pagare con carta di credito/debito",
    orderSummary: {
      applyBtn: "Utilizza",
      removeBtn: "Rimuovi",
      modalHeader: "Riepilogo ordine",
      mobileDiscountText: "",
      backBtn: "Indietro",
      grandTotalTitle: "Importo Totale",
      inclTaxTitle: "IVA",
      exclTaxTitle: "pi\xF9 IVA.",
      discountTitle: "Sconto",
      subtotalTitle: "Totale",
      removeItemButton: "Elimina",
      removeItemButtonLabel: "Elimina articolo",
      minusOneItem: "Un articolo in meno",
      plusOneItem: "Un articolo in pi\xF9",
      giftDiscountTitle: "Inserisci il codice promozionale",
      giftCardDiscount: {
        placeholder: "Inserisci il codice",
        successMessage: 'Il codice "{code}" \xE8 stato inserito correttamente'
      },
      couponCodeTitle: "Continua a ordinare",
      couponCodeTitleBottom: "\xE8 possibile ottenere",
      couponCodeTitleFreeShipping: "consegna gratuita",
      couponCode: {
        placeholder: "Inserisci il codice"
      },
      addToCart: "Aggiungi al carrello",
      promoTitle: "Completa il tuo ordine con...",
      closeButton: "Riepilogo ordine",
      mixedShipping: "Questo artivolo sar\xE0 spedito separatamente",
      heliumItem: "Spedito gonfiato",
      skuNumber: "N. SKU",
      supplierStockNumber: "N\xB0 di magazzino"
    },
    progressBar: {
      detailStepTitle: "I tuoi recapiti",
      shippingStepTitle: "Spedizione",
      paymentStepTitle: "Pagamento"
    },
    yourDetailsSection: {
      title: "I tuoi recapiti",
      selectPlaceholder: "Scegli un paese",
      showPassLabel: "Mostra o nascondi la password",
      phoneField: {
        infoMessage: "Utilizzeremo questo numero solo se avremo bisogno di contattarti per la consegna.",
        placeholder: "Inserisci il numero di telefono",
        label: "Numero di telefono"
      },
      emailAddress: {
        placeholder: "Inserisci l'indirizzo e-mail",
        label: "Indirizzo e-mail",
        span: "E-mail"
      },
      passwordField: {
        placeholder: "Inserisci la tua password",
        label: "La tua password"
      },
      firstName: {
        placeholder: "Inserisci il tuo nome",
        label: "Nome"
      },
      lastName: {
        placeholder: "Inserisci il tuo cognome",
        label: "Cognome"
      },
      deliverySection: {
        toShippingButton: "Scegli il metodo di spedizione",
        title: "Indirizzo di spedizione",
        savedAddressesTitle: "Scegli un indirizzo di consegna gi\xE0 salvato",
        shipHere: "Spedire qui",
        info: "Dove dobbiamo consegnare?",
        billingAddressTitle: "Indirizzo di fatturazione",
        deliveryAddressTitle: "Indirizzo di spedizione",
        addressFinder: {
          title: "Cerca indirizzo",
          placeholder: "Cerca per nome o codice postale",
          label: "Strada o codice postale"
        },
        addressForm: {
          saveAddressButton: "Utilizza questo indirizzo",
          linkText: "Inserisci manualmente l'indirizzo",
          addressField: {
            placeholder: "Inserisci la prima riga dell'indirizzo",
            unrequired: "Inserisci l'indirizzo (riga 2)",
            label: "Prima riga dell'indirizzo",
            unrequiredLabel: "Indirizzo (riga 2)"
          },
          cityField: {
            label: "Citt\xE0",
            placeholder: "Inserisci la citt\xE0"
          },
          countryField: {
            label: "Paese",
            placeholder: "Inserisci il paese"
          },
          postCodeField: {
            label: "Codice postale",
            placeholder: "Inserisci il codice postale"
          },
          regionField: {
            label: "Provincia",
            placeholder: "Inserisci la provincia"
          }
        }
      },
      editButton: "Modifica",
      editButtonLabel: "Modifica l'indirizzo e-mail",
      editDetailsButtonLabel: "Modifica informazioni",
      editShippingButtonLabel: "Modifica informazioni di spedizione"
    },
    errorMessages: {
      firstNameErrorMessage: "Inserisci un nome valido",
      lastNameErrorMessage: "Inserisci un cognome valido",
      emailErrorMessage: "Inserisci un indirizzo e-mail valido",
      phoneErrorMessage: "Numero di telefono non valido",
      passwordHelpText: "Minimo 8 caratteri e almeno tre tipi di carattere.",
      passwordErrorMessage: "Inserisci un indirizzo e-mail e una password validi",
      addressFormErrorMessage: "Assicurarti che tutti i campi obbligatori siano compilati",
      postCodeErrorMessage: "Inserisci un CAP valido per",
      countryErrorMessage: "Seleziona il paese",
      streetErrorMessage: "Inserisci un indirizzo valido e utilizza massimo 75 caratteri",
      cityErrorMessage: "Inserisci una citt\xE0 valida",
      regionErrorMessage: "Inserisci un paese valido",
      googlePayShippingError: "Nessun metodo di spedizione selezionato. Scegli un metodo di spedizione e riprova.",
      googlePayNominatedDayError: "Purtroppo non \xE8 possibile scegliere la spedizione express con la data di consegna richiesta",
      oosErrorMessage: "Purtroppo l'articolo \xE8 esaurito",
      noShippingMethods: "Nessun metodo di spedizione trovato per l'indirizzo selezionato",
      googlePayNoShippingMethods: "Nessun metodo di spedizione trovato per l'indirizzo selezionato",
      unexpectedPaymentError: "Si \xE8 verificato un errore"
    },
    welcomeMessages: {
      accountBody: "Accedi con un account cliente o continua come ospite",
      accountTitle: "Bentornato!",
      getStarted: "Inserisci l'e-mail per iniziare",
      guestBody: "Vai al checkout come ospite; avrai la possibilit\xE0 di creare un account dopo aver effettuato l'ordine",
      guestTitle: "Ciao"
    },
    signInButton: "Registrati",
    noAccountGuestButton: "Procedi come ospite",
    accountGuestButton: "Oppure continua come ospite",
    continueButton: "Avanti",
    forgotPass: "Hai dimenticato la password?",
    updateButton: "Aggiorna",
    billingForm: {
      notSameAddress: "L'indirizzo di fatturazione e l'indirizzo di spedizione sono uguali"
    },
    shippingStep: {
      proceedToPay: "Vai al pagamento",
      stepTitle: "Scegli il metodo di spedizione",
      stepCompleteTitle: "Spedizione",
      stepTitleSubText: "Scegli il metodo di spedizione",
      nominatedDelivery: "Scegli il giorno che preferisci",
      tbc: "Calcolato nel passaggio successivo",
      methodLabel: "Ricevi entro",
      noDeliveryDate: "Scegli la data di consegna"
    },
    addNewAddressBtn: "Aggiungi un nuovo indirizzo",
    saveNewAddress: "Salva in rubrica",
    paymentStep: {
      title: "Scegli il metodo di pagamento",
      freePayment: "Non sono richieste informazioni di pagamento",
      freeButton: "Paga ora",
      storedPayments: "I pagamenti effettuati",
      creditDebitCard: "Carta di credito o di debito"
    },
    productOptionsTrigger: "Opzioni articolo",
    instantCheckout: "Checkout immediato",
    checkoutTitle: "Checkout",
    adyen: {
      applePayTotal: "Importo totale",
      applePayNoShippingMethods: "Al momento non ci sono metodi di spedizione disponibili. Riprova o utilizza un altro metodo di pagamento.",
      cardNumber: "Numero di carta",
      expiry: "Data di scadenza",
      storedPaymentLabel: "{name} La carta scade il {lastFour}"
    },
    agreements: {
      label: "Confermo di aver letto e accetto il/la",
      errorMessage: "Questo campo \xE8 obbligatorio"
    },
    privacyPolicy: {
      content: "I tuoi dati saranno trattati come descritto nella nostra",
      link: "politica sulla privacy"
    },
    termsServices: {
      content: "Completando l'ordine accetti i termini e ",
      generalLink: "le condizioni,",
      privacyLink: " le norme sulla protezione dei dati",
      withdrawLink: "e le istruzioni di revoca."
    },
    newsletter: {
      label: "Iscriviti alla newsletter"
    },
    donation: {
      donateText: "Dona",
      removeDonation: "Rimuovi la donazione",
      donateTitle: "Dona i centesimi",
      charityLogo: "Logo di Beneficenza",
      penniesLogo: "Logo di Pennies"
    },
    payWith: {
      masterCard: "Paga con Master Card",
      visa: "Paga con Visa",
      paypal: "Paga con Paypal",
      clearPay: "Paga con Clearpay",
      klarna: "Paga con Klarna"
    },
    giftMessage: {
      to: "A:",
      from: "Da:",
      message: "Messaggio:"
    },
    inflatableBalloons: {
      title: "Consegna palloncini",
      description: "I tuoi palloncini pre-gonfiati verranno consegnati nella data selezionata di seguito, il tuo ordine arriver\xE0 in base all'opzione di consegna scelta.",
      openBtnText: "Seleziona il giorno che preferisci",
      savedMethod: "Consegna palloncini gonfiati.",
      message: "* La data selezionata non \xE8 pi\xF9 disponibile. Si prega di scegliere un'altra data.",
      months: [
        "Gennaio",
        "Febbraio",
        "Marzo",
        "Aprile",
        "Maggio",
        "Giugno",
        "Luglio",
        "Agosto",
        "Settembre",
        "Ottobre",
        "Novembre",
        "Dicembre"
      ],
      weekdays: [
        "Lunedi",
        "Marted\xEC",
        "Mercoled\xEC",
        "Gioved\xEC",
        "Venerd\xEC",
        "Sabato",
        "Domenica"
      ]
    }
  };
  var nlTranslations = {
    header: {
      text: "Veilig betalen"
    },
    dividerText: "Of voer je e-mailadres in om met een creditcard/debetkaart te betalen",
    payNoExpressWithBlockTitle: "Voer je e-mailadres in om met een creditcard/debetkaart te betalen",
    orderSummary: {
      applyBtn: "Gebruiken",
      removeBtn: "Verwijderen",
      modalHeader: "Besteloverzicht",
      mobileDiscountText: "",
      backBtn: "Terug",
      grandTotalTitle: "Totaal",
      inclTaxTitle: "BTW",
      exclTaxTitle: "plus BTW",
      discountTitle: "Korting",
      subtotalTitle: "Bedrag",
      removeItemButton: "Verwijderen",
      removeItemButtonLabel: "Artikel verwijderen",
      minusOneItem: "Een artikel minder",
      plusOneItem: "Een artikel meer",
      giftDiscountTitle: "Kortingscode invoeren",
      giftCardDiscount: {
        placeholder: "Code invoeren",
        successMessage: 'Code succesvol ingevoerd "{code}".'
      },
      couponCodeTitle: "Bestel voor nog eens",
      couponCodeTitleBottom: "voor een",
      couponCodeTitleFreeShipping: "gratis levering",
      couponCode: {
        placeholder: "Voer hier een code in"
      },
      addToCart: "In de winkelmand",
      promoTitle: "Voltooi je bestelling met...",
      closeButton: "Besteloverzicht sluiten",
      mixedShipping: "Dit wordt apart geleverd",
      heliumItem: "Opgeblazen geleverd",
      skuNumber: "SKU-nr.:",
      supplierStockNumber: "Leverancier Voorraadnr."
    },
    progressBar: {
      detailStepTitle: "Jouw informatie",
      shippingStepTitle: "Verzending",
      paymentStepTitle: "Betaling"
    },
    yourDetailsSection: {
      title: "Jouw informatie",
      selectPlaceholder: "Kies een land",
      showPassLabel: "Wachtwoord tonen of verbergen",
      phoneField: {
        infoMessage: "We gebruiken dit nummer alleen om contact met je op te nemen over je levering.",
        placeholder: "Voer telefoonnummer in",
        label: "Telefoonnummer"
      },
      emailAddress: {
        placeholder: "E-mailadres invoeren",
        label: "E-mailadres",
        span: "E-mail"
      },
      passwordField: {
        placeholder: "Wachtwoord",
        label: "Jouw wachtwoord"
      },
      firstName: {
        placeholder: "Voornaam invoeren",
        label: "Voornaam"
      },
      lastName: {
        placeholder: "Achternaam invoeren",
        label: "Achternaam"
      },
      deliverySection: {
        toShippingButton: "Verzendmethode selecteren",
        title: "Leveringsadres",
        savedAddressesTitle: "Selecteer je opgeslagen leveringsadres",
        shipHere: "Hier verzenden",
        info: "Waar moeten we naartoe verzenden?",
        billingAddressTitle: "Factuuradres",
        deliveryAddressTitle: "Leveringsadres",
        addressFinder: {
          title: "Adres zoeken",
          placeholder: "Zoeken op straat of postcode",
          label: "Straat of postcode"
        },
        addressForm: {
          saveAddressButton: "Gebruik dit adres",
          linkText: "Adres handmatig invoeren",
          addressField: {
            placeholder: "Eerste adresregel invoeren",
            unrequired: "Adres invoeren (regel 2)",
            label: "Eerste adresregel",
            unrequiredLabel: "Adres (regel 2)"
          },
          cityField: {
            label: "Stad",
            placeholder: "Stad invoeren"
          },
          countryField: {
            label: "Land",
            placeholder: "Land invoeren"
          },
          postCodeField: {
            label: "Postcode",
            placeholder: "Postcode invoeren"
          },
          regionField: {
            label: "Staat",
            placeholder: "Staat invoeren"
          }
        }
      },
      editButton: "Wijzigen",
      editButtonLabel: "E-mailadres wijzigen",
      editDetailsButtonLabel: "Informatie wijzigen",
      editShippingButtonLabel: "Verzendgegevens wijzigen"
    },
    errorMessages: {
      firstNameErrorMessage: "Voer een geldige voornaam in",
      lastNameErrorMessage: "Voer een geldige achternaam in",
      emailErrorMessage: "Voer een geldig e-mailadres in",
      phoneErrorMessage: "Geen geldig telefoonnummer",
      passwordHelpText: "Moet minstens 8 karakters en minstens 3 karaktersoorten bevatten",
      passwordErrorMessage: "Voer een geldig e-mailadres en wachtwoord in",
      addressFormErrorMessage: "Zorg ervoor dat alle verplichte velden zijn ingevuld",
      postCodeErrorMessage: "Voer een geldige postcode in voor",
      countryErrorMessage: "Land selecteren",
      streetErrorMessage: "Voer een geldig adres in en gebruik maximaal 75 tekens",
      cityErrorMessage: "Voer een geldige stad in",
      regionErrorMessage: "Voer een geldig land in",
      googlePayShippingError: "Geen verzendmethode geselecteerd. Selecteer een verzendmethode en probeer het opnieuw.",
      googlePayNominatedDayError: "Helaas kunnen we geen express betaling aanbieden voor bestellingen met een gevraagde leverdatum",
      oosErrorMessage: "Artikel uitverkocht",
      noShippingMethods: "Geen verzendopties gevonden voor het geselecteerde adres",
      googlePayNoShippingMethods: "Geen verzendopties gevonden voor het geselecteerde adres",
      unexpectedPaymentError: "Er is een onverwachte fout opgetreden"
    },
    welcomeMessages: {
      accountBody: "Log in met klantaccount of ga verder als gast",
      accountTitle: "Welkom terug!",
      getStarted: "Voer e-mail in om te beginnen",
      guestBody: "Het lijkt erop dat je hier nieuw bent! Ga verder met je bestelling als gast; je krijgt de optie om een account aan te maken zodra je je bestelling hebt afgerond.",
      guestTitle: "Hallo"
    },
    signInButton: "Inloggen",
    noAccountGuestButton: "Doorgaan als gast",
    accountGuestButton: "Of doorgaan als gast",
    continueButton: "Doorgaan",
    forgotPass: "Wachtwoord vergeten?",
    updateButton: "Bijwerken",
    billingForm: {
      notSameAddress: "Mijn factuuradres en leveradres zijn hetzelfde"
    },
    shippingStep: {
      proceedToPay: "Doorgaan naar betaling",
      stepTitle: "Selecteer verzendmethode",
      stepCompleteTitle: "Verzenden",
      stepTitleSubText: "Selecteer verzendmethode",
      nominatedDelivery: "Selecteer de gewenste datum",
      tbc: "Berekend in de volgende stap",
      methodLabel: "Ontvangen door",
      noDeliveryDate: "Selecteer leveringsdatum"
    },
    addNewAddressBtn: "Nieuw adres toevoegen",
    saveNewAddress: "Opslaan in adresboek",
    paymentStep: {
      title: "Selecteer betaalmethode",
      freePayment: "Geen betalingsgegevens nodig",
      freeButton: "Nu betalen",
      storedPayments: "Je opgeslagen betalingen",
      creditDebitCard: "Creditcard of bankpas"
    },
    productOptionsTrigger: "Artikel opties",
    instantCheckout: "Express betaling",
    checkoutTitle: "Bestelling",
    adyen: {
      applePayTotal: "Totaal",
      applePayNoShippingMethods: "Er zijn momenteel geen verzendmethoden beschikbaar. Probeer het opnieuw of gebruik een andere betaalmethode.",
      cardNumber: "Kaartnummer",
      expiry: "Vervaldatum",
      storedPaymentLabel: "{name} Opgeslagen kaart verloopt op {lastFour}"
    },
    agreements: {
      label: "Ik accepteer de",
      errorMessage: "Dit is een verplicht veld"
    },
    privacyPolicy: {
      content: "U kunt lezen hoe we met uw gegevens omgaan in ons",
      link: "Privacybeleid"
    },
    termsServices: {
      content: "Met jouw bestelling verklaar je dat je akkoord bent met",
      generalLink: "onze Algemene voorwaarden ",
      privacyLink: " Privacy verklaring",
      withdrawLink: "en het Herroepingsbeleid."
    },
    newsletter: {
      label: "Aanmelden voor nieuwsbrief"
    },
    donation: {
      donateText: "Doneer",
      removeDonation: "Donatie verwijderen",
      donateTitle: "Doneer je centen",
      charityLogo: "Liefdadigheids Logo",
      penniesLogo: "Pennies Logo"
    },
    payWith: {
      masterCard: "betalen met Master Card",
      visa: "betalen met Visa",
      paypal: "betalen met PayPal",
      clearPay: "betalen met Clearpay",
      klarna: "betalen met Klarna"
    },
    giftMessage: {
      to: "Naar:",
      from: "Van:",
      message: "Boodschap:"
    },
    inflatableBalloons: {
      title: "Levering van ballonnen",
      description: "Je voorgeblazen ballon(nen) worden geleverd op de hieronder geselecteerde datum, alle andere artikelen in je bestelling worden geleverd volgens de door jou gekozen verzendmethode.",
      openBtnText: "Kies een bezorgdag.",
      savedMethod: "Opgeblazen ballonnen levering.",
      message: "* Je geselecteerde datum is niet langer beschikbaar. Kies een andere datum.",
      months: [
        "Januari",
        "Februari",
        "Maart",
        "April",
        "Mei",
        "Juni",
        "Juli",
        "Augustus",
        "September",
        "Oktober",
        "November",
        "December"
      ],
      weekdays: [
        "Maandag",
        "Dinsdag",
        "Woensdag",
        "Donderdag",
        "Vrijdag",
        "Zaterdag",
        "Zondag"
      ]
    }
  };
  var nlBeTranslations = {
    header: {
      text: "Veilig betalen"
    },
    dividerText: "Of voer je e-mailadres in om met een creditcard/debetkaart te betalen",
    payNoExpressWithBlockTitle: "Voer je e-mailadres in om met een creditcard/debetkaart te betalen",
    orderSummary: {
      applyBtn: "Gebruiken",
      removeBtn: "Verwijderen",
      modalHeader: "Besteloverzicht",
      mobileDiscountText: "",
      backBtn: "Terug",
      grandTotalTitle: "Totaal",
      inclTaxTitle: "BTW",
      exclTaxTitle: "plus BTW",
      discountTitle: "Korting",
      subtotalTitle: "Bedrag",
      removeItemButton: "Verwijderen",
      removeItemButtonLabel: "Artikel verwijderen",
      minusOneItem: "Een artikel minder",
      plusOneItem: "Een artikel meer",
      giftDiscountTitle: "Kortingscode invoeren",
      giftCardDiscount: {
        placeholder: "Code invoeren",
        successMessage: 'Code succesvol ingevoerd "{code}".'
      },
      couponCodeTitle: "Bestel voor nog eens",
      couponCodeTitleBottom: "voor een",
      couponCodeTitleFreeShipping: "gratis levering",
      couponCode: {
        placeholder: "Voer hier een code in"
      },
      addToCart: "In de winkelmand",
      promoTitle: "Voltooi je bestelling met...",
      closeButton: "Besteloverzicht sluiten",
      mixedShipping: "Dit wordt apart geleverd",
      heliumItem: "Opgeblazen geleverd",
      skuNumber: "SKU-nr.:",
      supplierStockNumber: "Leverancier Voorraadnr."
    },
    progressBar: {
      detailStepTitle: "Jouw informatie",
      shippingStepTitle: "Verzending",
      paymentStepTitle: "Betaling"
    },
    yourDetailsSection: {
      title: "Jouw informatie",
      selectPlaceholder: "Kies een land",
      showPassLabel: "Wachtwoord tonen of verbergen",
      phoneField: {
        infoMessage: "We gebruiken dit nummer alleen om contact met je op te nemen over je levering.",
        placeholder: "Voer telefoonnummer in",
        label: "Telefoonnummer"
      },
      emailAddress: {
        placeholder: "E-mailadres invoeren",
        label: "E-mailadres",
        span: "E-mail"
      },
      passwordField: {
        placeholder: "Wachtwoord",
        label: "Jouw wachtwoord"
      },
      firstName: {
        placeholder: "Voornaam invoeren",
        label: "Voornaam"
      },
      lastName: {
        placeholder: "Achternaam invoeren",
        label: "Achternaam"
      },
      deliverySection: {
        toShippingButton: "Verzendmethode selecteren",
        title: "Leveringsadres",
        savedAddressesTitle: "Selecteer je opgeslagen leveringsadres",
        shipHere: "Hier verzenden",
        info: "Waar moeten we naartoe verzenden?",
        billingAddressTitle: "Factuuradres",
        deliveryAddressTitle: "Leveringsadres",
        addressFinder: {
          title: "Adres zoeken",
          placeholder: "Zoeken op straat of postcode",
          label: "Straat of postcode"
        },
        addressForm: {
          saveAddressButton: "Gebruik dit adres",
          linkText: "Adres handmatig invoeren",
          addressField: {
            placeholder: "Eerste adresregel invoeren",
            unrequired: "Adres invoeren (regel 2)",
            label: "Eerste adresregel",
            unrequiredLabel: "Adres (regel 2)"
          },
          cityField: {
            label: "Stad",
            placeholder: "Stad invoeren"
          },
          countryField: {
            label: "Land",
            placeholder: "Land invoeren"
          },
          postCodeField: {
            label: "Postcode",
            placeholder: "Postcode invoeren"
          },
          regionField: {
            label: "Staat",
            placeholder: "Staat invoeren"
          }
        }
      },
      editButton: "Wijzigen",
      editButtonLabel: "E-mailadres wijzigen",
      editDetailsButtonLabel: "Informatie wijzigen",
      editShippingButtonLabel: "Verzendgegevens wijzigen"
    },
    errorMessages: {
      firstNameErrorMessage: "Voer een geldige voornaam in",
      lastNameErrorMessage: "Voer een geldige achternaam in",
      emailErrorMessage: "Voer een geldig e-mailadres in",
      phoneErrorMessage: "Geen geldig telefoonnummer",
      passwordHelpText: "Moet minstens 8 karakters en minstens 3 karaktersoorten bevatten",
      passwordErrorMessage: "Voer een geldig e-mailadres en wachtwoord in",
      addressFormErrorMessage: "Zorg ervoor dat alle verplichte velden zijn ingevuld",
      postCodeErrorMessage: "Voer een geldige postcode in voor",
      countryErrorMessage: "Land selecteren",
      streetErrorMessage: "Voer een geldig adres in en gebruik maximaal 75 tekens",
      cityErrorMessage: "Voer een geldige stad in",
      regionErrorMessage: "Voer een geldig land in",
      googlePayShippingError: "Geen verzendmethode geselecteerd. Selecteer een verzendmethode en probeer het opnieuw.",
      googlePayNominatedDayError: "Helaas kunnen we geen express betaling aanbieden voor bestellingen met een gevraagde leverdatum",
      oosErrorMessage: "Artikel uitverkocht",
      noShippingMethods: "Geen verzendopties gevonden voor het geselecteerde adres",
      googlePayNoShippingMethods: "Geen verzendopties gevonden voor het geselecteerde adres",
      unexpectedPaymentError: "Er is een onverwachte fout opgetreden"
    },
    welcomeMessages: {
      accountBody: "Log in met klantaccount of ga verder als gast",
      accountTitle: "Welkom terug!",
      getStarted: "Voer e-mail in om te beginnen",
      guestBody: "Het lijkt erop dat je hier nieuw bent! Ga verder met je bestelling als gast; je krijgt de optie om een account aan te maken zodra je je bestelling hebt afgerond.",
      guestTitle: "Hallo"
    },
    signInButton: "Inloggen",
    noAccountGuestButton: "Doorgaan als gast",
    accountGuestButton: "Of doorgaan als gast",
    continueButton: "Doorgaan",
    forgotPass: "Wachtwoord vergeten?",
    updateButton: "Bijwerken",
    billingForm: {
      notSameAddress: "Mijn factuuradres en leveradres zijn hetzelfde"
    },
    shippingStep: {
      proceedToPay: "Doorgaan naar betaling",
      stepTitle: "Selecteer verzendmethode",
      stepCompleteTitle: "Verzenden",
      stepTitleSubText: "Selecteer verzendmethode",
      nominatedDelivery: "Selecteer de gewenste datum",
      tbc: "Berekend in de volgende stap",
      methodLabel: "Ontvangen door",
      noDeliveryDate: "Selecteer leveringsdatum"
    },
    addNewAddressBtn: "Nieuw adres toevoegen",
    saveNewAddress: "Opslaan in adresboek",
    paymentStep: {
      title: "Selecteer betaalmethode",
      freePayment: "Geen betalingsgegevens nodig",
      freeButton: "Nu betalen",
      storedPayments: "Je opgeslagen betalingen",
      creditDebitCard: "Creditcard of bankpas"
    },
    productOptionsTrigger: "Artikel opties",
    instantCheckout: "Express betaling",
    checkoutTitle: "Bestelling",
    adyen: {
      applePayTotal: "Totaal",
      applePayNoShippingMethods: "Er zijn momenteel geen verzendmethoden beschikbaar. Probeer het opnieuw of gebruik een andere betaalmethode.",
      cardNumber: "Kaartnummer",
      expiry: "Vervaldatum",
      storedPaymentLabel: "{name} Opgeslagen kaart verloopt op {lastFour}"
    },
    agreements: {
      label: "Ik accepteer de",
      errorMessage: "Dit is een verplicht veld"
    },
    privacyPolicy: {
      content: "U kunt lezen hoe we met uw gegevens omgaan in ons",
      link: "Privacybeleid"
    },
    termsServices: {
      content: "Met jouw bestelling verklaar je dat je akkoord bent met",
      generalLink: "onze Algemene voorwaarden ",
      privacyLink: " Privacy verklaring",
      withdrawLink: "en het Herroepingsbeleid."
    },
    newsletter: {
      label: "Aanmelden voor nieuwsbrief"
    },
    donation: {
      donateText: "Doneer",
      removeDonation: "Donatie verwijderen",
      donateTitle: "Doneer je centen",
      charityLogo: "Liefdadigheids Logo",
      penniesLogo: "Pennies Logo"
    },
    payWith: {
      masterCard: "betalen met Master Card",
      visa: "betalen met Visa",
      paypal: "betalen met PayPal",
      clearPay: "betalen met Clearpay",
      klarna: "betalen met Klarna"
    },
    giftMessage: {
      to: "Naar:",
      from: "Van:",
      message: "Boodschap:"
    },
    inflatableBalloons: {
      title: "Levering van ballonnen",
      description: "Je voorgeblazen ballon(nen) worden geleverd op de hieronder geselecteerde datum, alle andere artikelen in je bestelling worden geleverd volgens de door jou gekozen verzendmethode.",
      openBtnText: "Kies een bezorgdag.",
      savedMethod: "Opgeblazen ballonnen levering.",
      message: "* Je geselecteerde datum is niet langer beschikbaar. Kies een andere datum.",
      months: [
        "Januari",
        "Februari",
        "Maart",
        "April",
        "Mei",
        "Juni",
        "Juli",
        "Augustus",
        "September",
        "Oktober",
        "November",
        "December"
      ],
      weekdays: [
        "Maandag",
        "Dinsdag",
        "Woensdag",
        "Donderdag",
        "Vrijdag",
        "Zaterdag",
        "Zondag"
      ]
    }
  };
  var plTranslations = {
    header: {
      text: "Bezpieczne zam\xF3wienie"
    },
    dividerText: "Lub wprowad\u017A sw\xF3j adres e-mail, aby zap\u0142aci\u0107 kart\u0105 kredytow\u0105/debetow\u0105",
    payNoExpressWithBlockTitle: "Wprowad\u017A sw\xF3j adres e-mail, aby zap\u0142aci\u0107 kart\u0105 kredytow\u0105/debetow\u0105",
    orderSummary: {
      applyBtn: "Zastosuj",
      removeBtn: "Usu\u0144",
      modalHeader: "Podsumowanie zam\xF3wienia",
      mobileDiscountText: "",
      backBtn: "Powr\xF3t",
      grandTotalTitle: "Suma do zap\u0142aty",
      inclTaxTitle: "VAT",
      exclTaxTitle: "Bez podatku",
      discountTitle: "Rabat",
      subtotalTitle: "Suma cz\u0119\u015Bciowa",
      removeItemButton: "Usu\u0144",
      removeItemButtonLabel: "usu\u0144 przedmiot",
      minusOneItem: "minus jedna pozycja",
      plusOneItem: "plus jedna pozycja",
      giftDiscountTitle: "Dodaj kod promocyjny",
      giftCardDiscount: {
        placeholder: "Wprowad\u017A kod tutaj",
        successMessage: 'Pomy\u015Blnie zastosowano kod "{code}".'
      },
      couponCodeTitle: "Dla innego",
      couponCodeTitleBottom: "mo\u017Cesz otrzyma\u0107",
      couponCodeTitleFreeShipping: "darmow\u0105 dostaw\u0119",
      couponCode: {
        placeholder: "Wprowad\u017A kod tutaj"
      },
      addToCart: "Do koszyka",
      promoTitle: "Uzupe\u0142nij swoje zam\xF3wienie o...",
      closeButton: "Podsumowanie zamkni\u0119tego zam\xF3wienia",
      mixedShipping: "Zostanie to dostarczone osobno",
      heliumItem: "Dostarczane nadmuchane",
      skuNumber: "Nr SKU:",
      supplierStockNumber: "Nr magazynowy dostawcy:"
    },
    progressBar: {
      detailStepTitle: "Twoje dane",
      shippingStepTitle: "Wysy\u0142ka",
      paymentStepTitle: "P\u0142atno\u015B\u0107"
    },
    yourDetailsSection: {
      title: "Twoje dane",
      selectPlaceholder: "Wybierz sw\xF3j kraj",
      showPassLabel: "Poka\u017C lub ukryj has\u0142o",
      phoneField: {
        infoMessage: "U\u017Cyjemy tego numeru tylko wtedy, gdy b\u0119dziemy musieli skontaktowa\u0107 si\u0119 z Tob\u0105 w sprawie dostawy.",
        placeholder: "Wprowad\u017A sw\xF3j numer telefonu",
        label: "Numer telefonu"
      },
      emailAddress: {
        placeholder: "Wprowad\u017A sw\xF3j adres e-mail",
        label: "Adres e-mail",
        span: "E-mail"
      },
      passwordField: {
        placeholder: "Wprowad\u017A has\u0142o",
        label: "Twoje has\u0142o"
      },
      firstName: {
        placeholder: "Wprowad\u017A swoje imi\u0119",
        label: "Imi\u0119"
      },
      lastName: {
        placeholder: "Wpisz swoje nazwisko",
        label: "Nazwisko"
      },
      deliverySection: {
        toShippingButton: "Wybierz metod\u0119 wysy\u0142ki",
        title: "Adres do dostawy",
        savedAddressesTitle: "Wybierz zapisany adres wysy\u0142ki",
        shipHere: "Wy\u015Blij tutaj",
        info: "Gdzie mamy to dostarczy\u0107?",
        billingAddressTitle: "Adres do faktury",
        deliveryAddressTitle: "Adres do dostawy",
        addressFinder: {
          title: "Wyszukiwarka adres\xF3w",
          placeholder: "Szukaj wed\u0142ug nazwy ulicy lub kodu pocztowego",
          label: "Nazwa ulicy lub kod pocztowy"
        },
        addressForm: {
          saveAddressButton: "U\u017Cyj tego adresu",
          linkText: "Wprowad\u017A sw\xF3j adres r\u0119cznie",
          addressField: {
            placeholder: "Wprowad\u017A pierwszy wiersz adresu",
            unrequired: "Wprowad\u017A adres (wiersz 2)",
            label: "Pierwszy wiersz adresu",
            unrequiredLabel: "Adres (wiersz 2)"
          },
          cityField: {
            label: "Miasto",
            placeholder: "Wpisz miasto"
          },
          countryField: {
            label: "Kraj",
            placeholder: "Wpisz kraj"
          },
          postCodeField: {
            label: "Kod pocztowy",
            placeholder: "Wprowad\u017A kod pocztowy"
          },
          regionField: {
            label: "Hrabstwo",
            placeholder: "Wprowad\u017A hrabstwo"
          }
        }
      },
      editButton: "Edytuj",
      editButtonLabel: "Edytuj adres e-mail",
      editDetailsButtonLabel: "Edytuj swoje dane",
      editShippingButtonLabel: "Edytuj szczeg\xF3\u0142y wysy\u0142ki"
    },
    errorMessages: {
      firstNameErrorMessage: "Wprowad\u017A prawid\u0142owe imi\u0119",
      lastNameErrorMessage: "Wprowad\u017A prawid\u0142owe nazwisko",
      emailErrorMessage: "Wprowad\u017A prawid\u0142owy adres e-mail",
      phoneErrorMessage: "Nieprawid\u0142owy numer telefonu",
      passwordHelpText: "Minimum 8 znak\xF3w i musi zawiera\u0107 co najmniej trzy klasy znak\xF3w",
      passwordErrorMessage: "Wprowad\u017A prawid\u0142owy adres e-mail i has\u0142o.",
      addressFormErrorMessage: "Upewnij si\u0119, \u017Ce wszystkie wymagane pola s\u0105 wype\u0142nione",
      postCodeErrorMessage: "Wprowad\u017A prawid\u0142owy kod pocztowy dla",
      countryErrorMessage: "Wybierz sw\xF3j kraj",
      streetErrorMessage: "Wprowad\u017A prawid\u0142owy adres i u\u017Cyj maksymalnie 75 znak\xF3w dla adresu ulicy.",
      cityErrorMessage: "Wprowad\u017A prawid\u0142owe miasto",
      regionErrorMessage: "Wprowad\u017A prawid\u0142owe wojew\xF3dztwo",
      googlePayShippingError: "Brakuje metody wysy\u0142ki. Wybierz metod\u0119 wysy\u0142ki i spr\xF3buj ponownie.",
      googlePayNominatedDayError: "Niestety nie mo\u017Cemy zaoferowa\u0107 p\u0142atno\u015Bci ekspresowej w przypadku zam\xF3wie\u0144 z dostaw\u0105 w wyznaczonym dniu.",
      oosErrorMessage: "Przepraszamy, ten produkt jest niedost\u0119pny.",
      noShippingMethods: "Nie znaleziono metod wysy\u0142ki dla wybranego adresu.",
      googlePayNoShippingMethods: "Nie znaleziono metod wysy\u0142ki dla wybranego adresu.",
      unexpectedPaymentError: "Wyst\u0105pi\u0142 nieoczekiwany b\u0142\u0105d"
    },
    welcomeMessages: {
      accountBody: "Zaloguj si\u0119 na swoje konto, aby przej\u015B\u0107 do kasy lub kontynuowa\u0107 jako go\u015B\u0107.",
      accountTitle: "Witamy ponownie!",
      getStarted: "Wprowad\u017A sw\xF3j adres e-mail, aby rozpocz\u0105\u0107.",
      guestBody: "Wygl\u0105da na to, \u017Ce jeste\u015B tu nowy! Przejd\u017A do kasy jako go\u015B\u0107 z opcj\u0105 utworzenia konta po z\u0142o\u017Ceniu zam\xF3wienia.",
      guestTitle: "Witaj"
    },
    signInButton: "Zaloguj si\u0119",
    noAccountGuestButton: "Kontynuuj jako go\u015B\u0107",
    accountGuestButton: "Lub Kontynuuj jako go\u015B\u0107",
    continueButton: "Kontynuuj",
    forgotPass: "Zapomnia\u0142e\u015B has\u0142a?",
    updateButton: "Aktualizacja",
    billingForm: {
      notSameAddress: "M\xF3j adres rozliczeniowy i adres wysy\u0142ki s\u0105 takie same"
    },
    shippingStep: {
      proceedToPay: "Przejd\u017A do p\u0142atno\u015Bci",
      stepTitle: "Wybierz metod\u0119 wysy\u0142ki",
      stepCompleteTitle: "Wysy\u0142ka",
      stepTitleSubText: "Wybierz metod\u0119 wysy\u0142ki",
      nominatedDelivery: "Wybierz dzie\u0144, kt\xF3ry Ci odpowiada.",
      tbc: "Obliczone w nast\u0119pnym kroku",
      methodLabel: "Pobierz do",
      noDeliveryDate: "Wybierz dat\u0119 dostawy"
    },
    addNewAddressBtn: "Dodaj nowy adres",
    saveNewAddress: "Zapisz w ksi\u0105\u017Cce adresowej",
    paymentStep: {
      title: "Wybierz metod\u0119 p\u0142atno\u015Bci",
      freePayment: "Informacje o p\u0142atno\u015Bci nie s\u0105 wymagane",
      freeButton: "Zap\u0142a\u0107 teraz",
      storedPayments: "Zapisane p\u0142atno\u015Bci",
      creditDebitCard: "Karta kredytowa lub debetowa"
    },
    productOptionsTrigger: "Opcje produktu",
    instantCheckout: "Express p\u0142atno\u015B\u0107",
    checkoutTitle: "Do kasy",
    adyen: {
      applePayTotal: "Razem:",
      applePayNoShippingMethods: "W tej chwili nie s\u0105 dost\u0119pne \u017Cadne metody wysy\u0142ki. Spr\xF3buj ponownie lub skorzystaj z alternatywnej metody p\u0142atno\u015Bci.",
      cardNumber: "Numer karty",
      expiry: "Data wa\u017Cno\u015Bci",
      storedPaymentLabel: "{name} Przechowywana karta ko\u0144czy si\u0119 na {lastFour}."
    },
    agreements: {
      label: "Potwierdzam, \u017Ce przeczyta\u0142em i akceptuj\u0119",
      errorMessage: "To pole jest wymagane."
    },
    privacyPolicy: {
      content: "Dane u\u017Cytkownika b\u0119d\u0105 przetwarzane w spos\xF3b okre\u015Blony w naszej",
      link: "Polityka prywatno\u015Bci"
    },
    termsServices: {
      content: "Sk\u0142adaj\u0105c zam\xF3wienie, o\u015Bwiadczasz \u017Ce ",
      generalLink: "akceptujesz nasze warunki, ",
      privacyLink: " Polityk\u0119 Prywatno\u015Bci",
      withdrawLink: "oraz Polityk\u0119 Wyp\u0142aty."
    },
    newsletter: {
      label: "Zapisz si\u0119 do newslettera"
    },
    donation: {
      donateText: "Darowizna",
      removeDonation: "Usu\u0144 darowizn\u0119",
      donateTitle: "Przeka\u017C swoje grosze",
      charityLogo: "Charity Logo",
      penniesLogo: "Pennies Logo"
    },
    payWith: {
      masterCard: "zap\u0142a\u0107 kart\u0105 master card",
      visa: "zap\u0142a\u0107 kart\u0105 visa",
      paypal: "zap\u0142a\u0107 za pomoc\u0105 payPal",
      clearPay: "zap\u0142a\u0107 z clear pay",
      klarna: "zap\u0142a\u0107 z klarna"
    },
    giftMessage: {
      to: "Do:",
      from: "Od:",
      message: "Wiadomo\u015B\u0107:"
    },
    inflatableBalloons: {
      title: "Dostawa balon\xF3w",
      description: "Wst\u0119pnie napompowane balony zostan\u0105 dostarczone w dniu wybranym poni\u017Cej, a pozosta\u0142e elementy zam\xF3wienia zostan\u0105 dostarczone zgodnie z wybran\u0105 opcj\u0105 dostawy.",
      openBtnText: "Wybierz dogodny dla siebie dzie\u0144.",
      savedMethod: "Dostawa nadmuchanych balon\xF3w.",
      message: "* Wybrana data nie jest ju\u017C dost\u0119pna. Wybierz inn\u0105 dat\u0119.",
      months: [
        "Stycze\u0144",
        "Luty",
        "Marzec",
        "Kwiecie\u0144",
        "Maj",
        "Czerwiec",
        "Lipiec",
        "Sierpie\u0144",
        "Wrzesie\u0144",
        "Pa\u017Adziernik",
        "Listopad",
        "Grudzie\u0144"
      ],
      weekdays: [
        "Poniedzia\u0142ek",
        "Wtorek",
        "\u015Aroda",
        "Czwartek",
        "Pi\u0105tek",
        "Sobota",
        "Niedziela"
      ]
    }
  };
  var blankTranslations = {
    header: {
      text: " "
    },
    payWithBlockTitle: " ",
    orderSummary: {
      applyBtn: " ",
      removeBtn: " ",
      modalHeader: " ",
      mobileDiscountText: " ",
      backBtn: " ",
      grandTotalTitle: " ",
      inclTaxTitle: " ",
      exclTaxTitle: " ",
      discountTitle: " ",
      subtotalTitle: " ",
      removeItemButton: " ",
      couponDiscountTitle: " ",
      couponDiscount: {
        placeholder: " ",
        successMessage: " "
      },
      giftDiscountTitle: " ",
      giftCardDiscount: {
        placeholder: " ",
        successMessage: " "
      },
      freeShippingAvailable: " ",
      couponCodeTitle: " ",
      couponCodeTitleBottom: " ",
      couponCodeTitleFreeShipping: " ",
      addToCart: " ",
      promoTitle: " ",
      rewardsTitle: " "
    },
    progressBar: {
      detailStepTitle: " ",
      shippingStepTitle: " ",
      paymentStepTitle: " "
    },
    yourDetailsSection: {
      title: " ",
      selectPlaceholder: " ",
      phoneField: {
        infoMessage: " ",
        placeholder: " ",
        label: " "
      },
      emailAddress: {
        placeholder: " ",
        label: " "
      },
      passwordField: {
        placeholder: " ",
        label: " "
      },
      firstName: {
        placeholder: " ",
        label: " "
      },
      lastName: {
        placeholder: " ",
        label: " "
      },
      deliverySection: {
        toShippingButton: " ",
        title: " ",
        savedAddressesTitle: " ",
        shipHere: " ",
        deliveryAddressTitle: " ",
        billingAddressTitle: " ",
        addressFinder: {
          title: " ",
          placeholder: " ",
          label: " "
        },
        addressForm: {
          saveAddressButton: " ",
          linkText: " ",
          addressField: {
            placeholder: " ",
            unrequired: " ",
            label: " ",
            unrequiredLabel: " "
          },
          cityField: {
            placeholder: " "
          },
          countryField: {
            placeholder: " "
          },
          postCodeField: {
            placeholder: " "
          },
          regionField: {
            placeholder: " "
          }
        }
      },
      editButton: " "
    },
    errorMessages: {
      firstNameErrorMessage: " ",
      lastNameErrorMessage: " ",
      emailErrorMessage: " ",
      phoneErrorMessage: " ",
      passwordHelpText: " ",
      passwordErrorMessage: " ",
      addressFormErrorMessage: " ",
      postCodeErrorMessage: " ",
      countryErrorMessage: " ",
      streetErrorMessage: " ",
      cityErrorMessage: " ",
      regionErrorMessage: " ",
      googlePayNoShippingMethods: " ",
      unexpectedPaymentError: " ",
      applePayNoShippingMethods: " ",
      noShippingMethods: " ",
      postcodeLookup: " "
    },
    welcomeMessages: {
      accountBody: "",
      accountTitle: "",
      getStarted: "",
      guestBody: "",
      guestTitle: ""
    },
    signInButton: " ",
    guestButton: " ",
    continueButton: " ",
    forgotPass: " ",
    updateButton: " ",
    billingForm: {
      notSameAddress: " "
    },
    shippingStep: {
      proceedToPay: " ",
      stepTitle: " ",
      stepCompleteTitle: " ",
      nominatedDelivery: " ",
      tbc: " "
    },
    addNewAddressBtn: " ",
    saveNewAddress: " ",
    paymentStep: {
      title: " ",
      freePayment: " ",
      freeButton: " "
    },
    productOptionsTrigger: " ",
    instantCheckout: " ",
    adyen: {
      applePayTotal: " ",
      applePayNoShippingMethods: " ",
      cardNumber: " "
    },
    agreements: {
      label: " ",
      errorMessage: " ",
      paymentErrorMessage: " "
    },
    privacyPolicy: {
      content: " ",
      link: " "
    },
    newsletter: {
      label: " "
    },
    rewards: {
      applied: " ",
      applyButton: " ",
      available: " ",
      removeButton: " ",
      rewardPoints: " ",
      youHave: " "
    },
    days: {
      monday: " ",
      tuesday: " ",
      wednesday: " ",
      thursday: " ",
      friday: " ",
      saturday: " ",
      sunday: " "
    }
  };
  var messages = {
    "en-GB": {
      ...enTranslations
    },
    "fr-FR": {
      ...frTranslations
    },
    "en-IE": {
      ...ieTranslations
    },
    "en-US": {
      ...usTranslations
    },
    "en-AU": {
      ...auTranslations
    },
    "da-DK": {
      ...dkTranslations
    },
    "de-AT": {
      ...atTranslations
    },
    "de-CH": {
      ...chTranslations
    },
    "de-DE": {
      ...deTranslations
    },
    "es-ES": {
      ...esTranslations
    },
    "fr-BE": {
      ...beTranslations
    },
    "fr-CH": {
      ...frChTranslations
    },
    "it-IT": {
      ...itTranslations
    },
    "it-CH": {
      ...itCHTranslations
    },
    "nl-NL": {
      ...nlTranslations
    },
    "nl-BE": {
      ...nlBeTranslations
    },
    "pl-PL": {
      ...plTranslations
    },
    blank: {
      ...blankTranslations
    }
  };
  const i18n = createI18n({
    locale: "blank",
    fallbackLocale: "en",
    messages
  });
  const pinia = createPinia();
  pinia.use(({ store }) => {
    store.$router = markRaw(router);
    store.$i18n = markRaw(i18n);
  });
  const app = createApp(App);
  app.use(i18n);
  app.use(pinia);
  app.use(router);
  app.mount("#vue-checkout-root");
})();

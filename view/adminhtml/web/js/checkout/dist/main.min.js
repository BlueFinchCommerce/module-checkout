(() => {
  function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const onRE = /^on[^a-z]/;
  const isOn = (key) => onRE.test(key);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend$1 = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
  const isArray$2 = Array.isArray;
  const isMap = (val) => toTypeString$1(val) === "[object Map]";
  const isSet = (val) => toTypeString$1(val) === "[object Set]";
  const isFunction$2 = (val) => typeof val === "function";
  const isString$3 = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject$4 = (val) => val !== null && typeof val === "object";
  const isPromise$1 = (val) => {
    return isObject$4(val) && isFunction$2(val.then) && isFunction$2(val.catch);
  };
  const objectToString$2 = Object.prototype.toString;
  const toTypeString$1 = (value) => objectToString$2.call(value);
  const toRawType = (value) => {
    return toTypeString$1(value).slice(8, -1);
  };
  const isPlainObject$3 = (val) => toTypeString$1(val) === "[object Object]";
  const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
  const cacheStringFunction = (fn) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache2[str];
      return hit || (cache2[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
  const capitalize$1 = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize$1(str)}` : ``);
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](arg);
    }
  };
  const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  const toNumber$1 = (val) => {
    const n = isString$3(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  let _globalThis$1;
  const getGlobalThis$1 = () => {
    return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray$2(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString$3(value)) {
      return value;
    } else if (isObject$4(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$3(value)) {
      res = value;
    } else if (isArray$2(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$4(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  const toDisplayString$1 = (val) => {
    return isString$3(val) ? val : val == null ? "" : isArray$2(val) || isObject$4(val) && (val.toString === objectToString$2 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (val && val.__v_isRef) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce((entries2, [key, val2]) => {
          entries2[`${key} =>`] = val2;
          return entries2;
        }, {})
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()]
      };
    } else if (isObject$4(val) && !isArray$2(val) && !isPlainObject$3(val)) {
      return String(val);
    }
    return val;
  };
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
      }
    }
    get active() {
      return this._active;
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    on() {
      activeEffectScope = this;
    }
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
      scope.effects.push(effect);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    }
  }
  const createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
  };
  const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
  const newTracked = (dep) => (dep.n & trackOpBit) > 0;
  const initDepMarkers = ({ deps }) => {
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].w |= trackOpBit;
      }
    }
  };
  const finalizeDepMarkers = (effect) => {
    const { deps } = effect;
    if (deps.length) {
      let ptr = 0;
      for (let i = 0; i < deps.length; i++) {
        const dep = deps[i];
        if (wasTracked(dep) && !newTracked(dep)) {
          dep.delete(effect);
        } else {
          deps[ptr++] = dep;
        }
        dep.w &= ~trackOpBit;
        dep.n &= ~trackOpBit;
      }
      deps.length = ptr;
    }
  };
  const targetMap = /* @__PURE__ */ new WeakMap();
  let effectTrackDepth = 0;
  let trackOpBit = 1;
  const maxMarkerBits = 30;
  let activeEffect;
  const ITERATE_KEY = Symbol("");
  const MAP_KEY_ITERATE_KEY = Symbol("");
  class ReactiveEffect {
    constructor(fn, scheduler = null, scope) {
      this.fn = fn;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      this.parent = void 0;
      recordEffectScope(this, scope);
    }
    run() {
      if (!this.active) {
        return this.fn();
      }
      let parent = activeEffect;
      let lastShouldTrack = shouldTrack;
      while (parent) {
        if (parent === this) {
          return;
        }
        parent = parent.parent;
      }
      try {
        this.parent = activeEffect;
        activeEffect = this;
        shouldTrack = true;
        trackOpBit = 1 << ++effectTrackDepth;
        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this);
        } else {
          cleanupEffect(this);
        }
        return this.fn();
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this);
        }
        trackOpBit = 1 << --effectTrackDepth;
        activeEffect = this.parent;
        shouldTrack = lastShouldTrack;
        this.parent = void 0;
        if (this.deferStop) {
          this.stop();
        }
      }
    }
    stop() {
      if (activeEffect === this) {
        this.deferStop = true;
      } else if (this.active) {
        cleanupEffect(this);
        if (this.onStop) {
          this.onStop();
        }
        this.active = false;
      }
    }
  }
  function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect2);
      }
      deps.length = 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (shouldTrack && activeEffect) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = createDep());
      }
      trackEffects(dep);
    }
  }
  function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
      if (!newTracked(dep)) {
        dep.n |= trackOpBit;
        shouldTrack2 = !wasTracked(dep);
      }
    } else {
      shouldTrack2 = !dep.has(activeEffect);
    }
    if (shouldTrack2) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray$2(target)) {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newLength) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    if (deps.length === 1) {
      if (deps[0]) {
        {
          triggerEffects(deps[0]);
        }
      }
    } else {
      const effects = [];
      for (const dep of deps) {
        if (dep) {
          effects.push(...dep);
        }
      }
      {
        triggerEffects(createDep(effects));
      }
    }
  }
  function triggerEffects(dep, debuggerEventExtraInfo) {
    const effects = isArray$2(dep) ? dep : [...dep];
    for (const effect2 of effects) {
      if (effect2.computed) {
        triggerEffect(effect2);
      }
    }
    for (const effect2 of effects) {
      if (!effect2.computed) {
        triggerEffect(effect2);
      }
    }
  }
  function triggerEffect(effect2, debuggerEventExtraInfo) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
      if (effect2.scheduler) {
        effect2.scheduler();
      } else {
        effect2.run();
      }
    }
  }
  function getDepFromReactive(object, key) {
    var _a;
    return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1));
  const get$1 = /* @__PURE__ */ createGetter();
  const shallowGet = /* @__PURE__ */ createGetter(false, true);
  const readonlyGet = /* @__PURE__ */ createGetter(true);
  const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function hasOwnProperty$1(key) {
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  function createGetter(isReadonly2 = false, shallow = false) {
    return function get2(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return shallow;
      } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray$2(target);
      if (!isReadonly2) {
        if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty$1;
        }
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$4(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    };
  }
  const set$1 = /* @__PURE__ */ createSetter();
  const shallowSet = /* @__PURE__ */ createSetter(true);
  function createSetter(shallow = false) {
    return function set2(target, key, value, receiver) {
      let oldValue = target[key];
      if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
        return false;
      }
      if (!shallow) {
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  function has$1(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  const mutableHandlers = {
    get: get$1,
    set: set$1,
    deleteProperty,
    has: has$1,
    ownKeys
  };
  const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      return true;
    },
    deleteProperty(target, key) {
      return true;
    }
  };
  const shallowReactiveHandlers = /* @__PURE__ */ extend$1({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
  });
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function get(target, key, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (key !== rawKey) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (key !== rawKey) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach3(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get(this, key);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  const [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn$1(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$4(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    def(value, "__v_skip", true);
    return value;
  }
  const toReactive = (value) => isObject$4(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
  function trackRefValue(ref2) {
    if (shouldTrack && activeEffect) {
      ref2 = toRaw(ref2);
      {
        trackEffects(ref2.dep || (ref2.dep = createDep()));
      }
    }
  }
  function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) {
      {
        triggerEffects(dep);
      }
    }
  }
  function isRef(r) {
    return !!(r && r.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, __v_isShallow) {
      this.__v_isShallow = __v_isShallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = __v_isShallow ? value : toRaw(value);
      this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
      newVal = useDirectValue ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = useDirectValue ? newVal : toReactive(newVal);
        triggerRefValue(this);
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    const ret = isArray$2(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this.__v_isRef = true;
    }
    get value() {
      const val = this._object[this._key];
      return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  function propertyToRef(source2, key, defaultValue) {
    const val = source2[key];
    return isRef(val) ? val : new ObjectRefImpl(source2, key, defaultValue);
  }
  class ComputedRefImpl {
    constructor(getter, _setter, isReadonly2, isSSR) {
      this._setter = _setter;
      this.dep = void 0;
      this.__v_isRef = true;
      this["__v_isReadonly"] = false;
      this._dirty = true;
      this.effect = new ReactiveEffect(getter, () => {
        if (!this._dirty) {
          this._dirty = true;
          triggerRefValue(this);
        }
      });
      this.effect.computed = this;
      this.effect.active = this._cacheable = !isSSR;
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw(this);
      trackRefValue(self2);
      if (self2._dirty || !self2._cacheable) {
        self2._dirty = false;
        self2._value = self2.effect.run();
      }
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction$2(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    return cRef;
  }
  function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
      res = args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
    return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction$2(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise$1(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = type;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
    {
      console.error(err);
    }
  }
  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJobId = getId(queue[middle]);
      middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
  }
  function queueJob(job) {
    if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
      queue.splice(i, 1);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$2(cb)) {
      if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
        pendingPostFlushCbs.push(cb);
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(seen2, i = isFlushing ? flushIndex + 1 : 0) {
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.pre) {
        queue.splice(i, 1);
        i--;
        cb();
      }
    }
  }
  function flushPostFlushCbs(seen2) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)];
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? Infinity : job.id;
  const comparator = (a, b) => {
    const diff = getId(a) - getId(b);
    if (diff === 0) {
      if (a.pre && !b.pre)
        return -1;
      if (b.pre && !a.pre)
        return 1;
    }
    return diff;
  };
  function flushJobs(seen2) {
    isFlushPending = false;
    isFlushing = true;
    queue.sort(comparator);
    const check = NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (false)
            ;
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs();
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
      return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modelArg = isModelListener2 && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
      if (trim2) {
        args = rawArgs.map((a) => isString$3(a) ? a.trim() : a);
      }
      if (number2) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(handler, instance, 6, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.emitsCache;
    const cached = cache2.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$2(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend$1(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$4(comp)) {
        cache2.set(comp, null);
      }
      return null;
    }
    if (isArray$2(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend$1(normalized, raw);
    }
    if (isObject$4(comp)) {
      cache2.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      props,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render,
      renderCache,
      data: data2,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data2, ctx));
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component;
        if (false)
          ;
        result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
          get attrs() {
            markAttrsAccessed();
            return attrs;
          },
          slots,
          emit: emit2
        } : { attrs, slots, emit: emit2 }) : render2(props, null));
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root2 = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root2;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
          }
          root2 = cloneVNode(root2, fallthroughAttrs);
        }
      }
    }
    if (vnode.dirs) {
      root2 = cloneVNode(root2);
      root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      root2.transition = vnode.transition;
    }
    {
      result = root2;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent && parent.subTree === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    }
  }
  const isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$2(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const INITIAL_WATCHER_VALUE = {};
  function watch(source2, cb, options) {
    return doWatch(source2, cb, options);
  }
  function doWatch(source2, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
    var _a;
    const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source2)) {
      getter = () => source2.value;
      forceTrigger = isShallow(source2);
    } else if (isReactive(source2)) {
      getter = () => source2;
      deep = true;
    } else if (isArray$2(source2)) {
      isMultiSource = true;
      forceTrigger = source2.some((s) => isReactive(s) || isShallow(s));
      getter = () => source2.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return traverse(s);
        } else if (isFunction$2(s)) {
          return callWithErrorHandling(s, instance, 2);
        } else
          ;
      });
    } else if (isFunction$2(source2)) {
      if (cb) {
        getter = () => callWithErrorHandling(source2, instance, 2);
      } else {
        getter = () => {
          if (instance && instance.isUnmounted) {
            return;
          }
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(source2, instance, 3, [onCleanup]);
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
      cleanup = effect.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
      };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else {
        return NOOP;
      }
    }
    let oldValue = isMultiSource ? new Array(source2.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect.active) {
        return;
      }
      if (cb) {
        const newValue = effect.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      job.pre = true;
      if (instance)
        job.id = instance.uid;
      scheduler = () => queueJob(job);
    }
    const effect = new ReactiveEffect(getter, scheduler);
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    } else {
      effect.run();
    }
    const unwatch = () => {
      effect.stop();
      if (instance && instance.scope) {
        remove(instance.scope.effects, effect);
      }
    };
    if (ssrCleanup)
      ssrCleanup.push(unwatch);
    return unwatch;
  }
  function instanceWatch(source2, value, options) {
    const publicThis = this.proxy;
    const getter = isString$3(source2) ? source2.includes(".") ? createPathGetter(publicThis, source2) : () => publicThis[source2] : source2.bind(publicThis, publicThis);
    let cb;
    if (isFunction$2(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
      setCurrentInstance(cur);
    } else {
      unsetCurrentInstance();
    }
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse(value, seen2) {
    if (!isObject$4(value) || value["__v_skip"]) {
      return value;
    }
    seen2 = seen2 || /* @__PURE__ */ new Set();
    if (seen2.has(value)) {
      return value;
    }
    seen2.add(value);
    if (isRef(value)) {
      traverse(value.value, seen2);
    } else if (isArray$2(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], seen2);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, seen2);
      });
    } else if (isPlainObject$3(value)) {
      for (const key in value) {
        traverse(value[key], seen2);
      }
    }
    return value;
  }
  function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
      return vnode;
    }
    const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction$2(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevTransitionKey;
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        let child = children[0];
        if (children.length > 1) {
          for (const c of children) {
            if (c.type !== Comment) {
              child = c;
              break;
            }
          }
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        let transitionKeyChanged = false;
        const { getTransitionKey } = innerChild.type;
        if (getTransitionKey) {
          const key = getTransitionKey();
          if (prevTransitionKey === void 0) {
            prevTransitionKey = key;
          } else if (key !== prevTransitionKey) {
            prevTransitionKey = key;
            transitionKeyChanged = true;
          }
        }
        if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
          const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in") {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (instance.update.active !== false) {
                instance.update();
              }
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el._leaveCb = () => {
                earlyRemove();
                el._leaveCb = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$2(hook)) {
        if (hook.every((hook2) => hook2.length <= 1))
          done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el._leaveCb) {
          el._leaveCb(true);
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
          leavingVNode.el._leaveCb();
        }
        callHook2(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el._enterCb = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el._enterCb = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key2 = String(vnode.key);
        if (el._enterCb) {
          el._enterCb(true);
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        let called = false;
        const done = el._leaveCb = (cancelled) => {
          if (called)
            return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el._leaveCb = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  function defineComponent(options, extraOptions) {
    return isFunction$2(options) ? /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))() : options;
  }
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  function defineAsyncComponent(source2) {
    if (isFunction$2(source2)) {
      source2 = { loader: source2 };
    }
    const {
      loader,
      loadingComponent,
      errorComponent,
      delay = 200,
      timeout,
      suspensible = true,
      onError: userOnError
    } = source2;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
      retries++;
      pendingRequest = null;
      return load();
    };
    const load = () => {
      let thisRequest;
      return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
        err = err instanceof Error ? err : new Error(String(err));
        if (userOnError) {
          return new Promise((resolve2, reject) => {
            const userRetry = () => resolve2(retry());
            const userFail = () => reject(err);
            userOnError(err, userRetry, userFail, retries + 1);
          });
        } else {
          throw err;
        }
      }).then((comp) => {
        if (thisRequest !== pendingRequest && pendingRequest) {
          return pendingRequest;
        }
        if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
          comp = comp.default;
        }
        resolvedComp = comp;
        return comp;
      }));
    };
    return defineComponent({
      name: "AsyncComponentWrapper",
      __asyncLoader: load,
      get __asyncResolved() {
        return resolvedComp;
      },
      setup() {
        const instance = currentInstance;
        if (resolvedComp) {
          return () => createInnerComp(resolvedComp, instance);
        }
        const onError = (err) => {
          pendingRequest = null;
          handleError(err, instance, 13, !errorComponent);
        };
        if (suspensible && instance.suspense || isInSSRComponentSetup) {
          return load().then((comp) => {
            return () => createInnerComp(comp, instance);
          }).catch((err) => {
            onError(err);
            return () => errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          });
        }
        const loaded = ref(false);
        const error = ref();
        const delayed = ref(!!delay);
        if (delay) {
          setTimeout(() => {
            delayed.value = false;
          }, delay);
        }
        if (timeout != null) {
          setTimeout(() => {
            if (!loaded.value && !error.value) {
              const err = new Error(`Async component timed out after ${timeout}ms.`);
              onError(err);
              error.value = err;
            }
          }, timeout);
        }
        load().then(() => {
          loaded.value = true;
          if (instance.parent && isKeepAlive(instance.parent.vnode)) {
            queueJob(instance.parent.update);
          }
        }).catch((err) => {
          onError(err);
          error.value = err;
        });
        return () => {
          if (loaded.value && resolvedComp) {
            return createInnerComp(resolvedComp, instance);
          } else if (error.value && errorComponent) {
            return createVNode(errorComponent, {
              error: error.value
            });
          } else if (loadingComponent && !delayed.value) {
            return createVNode(loadingComponent);
          }
        };
      }
    });
  }
  function createInnerComp(comp, parent) {
    const { ref: ref2, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref2;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
  }
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        unsetCurrentInstance();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook("bu");
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook("bum");
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook("sp");
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString$3(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(Component, false);
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
          return Component;
        }
      }
      const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
      if (!res && maybeSelfReference) {
        return Component;
      }
      return res;
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
  }
  function renderList(source2, renderItem, cache2, index) {
    let ret;
    const cached = cache2 && cache2[index];
    if (isArray$2(source2) || isString$3(source2)) {
      ret = new Array(source2.length);
      for (let i = 0, l = source2.length; i < l; i++) {
        ret[i] = renderItem(source2[i], i, void 0, cached && cached[i]);
      }
    } else if (typeof source2 === "number") {
      ret = new Array(source2);
      for (let i = 0; i < source2; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
      }
    } else if (isObject$4(source2)) {
      if (source2[Symbol.iterator]) {
        ret = Array.from(source2, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
      } else {
        const keys = Object.keys(source2);
        ret = new Array(keys.length);
        for (let i = 0, l = keys.length; i < l; i++) {
          const key = keys[i];
          ret[i] = renderItem(source2[key], key, i, cached && cached[i]);
        }
      }
    } else {
      ret = [];
    }
    if (cache2) {
      cache2[index] = ret;
    }
    return ret;
  }
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
      if (name !== "default")
        props.name = name;
      return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
      key: props.key || validSlotContent && validSlotContent.key || `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode$1(child))
        return true;
      if (child.type === Comment)
        return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  const getPublicInstance = (i) => {
    if (!i)
      return null;
    if (isStatefulComponent(i))
      return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  });
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data2[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
          accessCache[key] = 2;
          return data2[key];
        } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)) {
        {
          return globalProperties[key];
        }
      } else
        ;
    },
    set({ _: instance }, key, value) {
      const { data: data2, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
        data2[key] = value;
        return true;
      } else if (hasOwn$1(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data2 !== EMPTY_OBJ && hasOwn$1(data2, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn$1(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  function normalizePropsOrEmits(props) {
    return isArray$2(props) ? props.reduce((normalized, p2) => (normalized[p2] = null, normalized), {}) : props;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    const {
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      expose,
      inheritAttrs,
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$2(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data2 = dataOptions.call(publicThis, publicThis);
      if (!isObject$4(data2))
        ;
      else {
        instance.data = reactive(data2);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c = computed({
          get: get2,
          set: set2
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$2(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$2(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$2(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject$4(opt)) {
        if ("default" in opt) {
          injected = inject(opt.from || key, opt.default, true);
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
  }
  function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString$3(raw)) {
      const handler = ctx[raw];
      if (isFunction$2(handler)) {
        watch(getter, handler);
      }
    } else if (isFunction$2(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject$4(raw)) {
      if (isArray$2(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$2(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else
      ;
  }
  function resolveMergedOptions(instance) {
    const base2 = instance.type;
    const { mixins, extends: extendsOptions } = base2;
    const {
      mixins: globalMixins,
      optionsCache: cache2,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache2.get(base2);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base2;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach((m) => mergeOptions$1(resolved, m, optionMergeStrategies, true));
      }
      mergeOptions$1(resolved, base2, optionMergeStrategies);
    }
    if (isObject$4(base2)) {
      cache2.set(base2, resolved);
    }
    return resolved;
  }
  function mergeOptions$1(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions$1(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach((m) => mergeOptions$1(to, m, strats, true));
    }
    for (const key in from) {
      if (asMixin && key === "expose")
        ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend$1(isFunction$2(to) ? to.call(this, this) : to, isFunction$2(from) ? from.call(this, this) : from);
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$2(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray$2(to) && isArray$2(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend$1(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$2(rootComponent)) {
        rootComponent = extend$1({}, rootComponent);
      }
      if (rootProps != null && !isObject$4(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new Set();
      let isMounted = false;
      const app2 = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin))
            ;
          else if (plugin && isFunction$2(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app2, ...options);
          } else if (isFunction$2(plugin)) {
            installedPlugins.add(plugin);
            plugin(app2, ...options);
          } else
            ;
          return app2;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app2;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app2;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app2;
        },
        mount(rootContainer, isHydrate, isSVG) {
          if (!isMounted) {
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render(vnode, rootContainer, isSVG);
            }
            isMounted = true;
            app2._container = rootContainer;
            rootContainer.__vue_app__ = app2;
            return getExposeProxy(vnode.component) || vnode.component.proxy;
          }
        },
        unmount() {
          if (isMounted) {
            render(null, app2._container);
            delete app2._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app2;
        },
        runWithContext(fn) {
          currentApp = app2;
          try {
            return fn();
          } finally {
            currentApp = null;
          }
        }
      };
      return app2;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance)
      ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else
        ;
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn$1(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || !hasOwn$1(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn$1(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance, "set", "$attrs");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn$1(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn$1(castValues, key));
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn$1(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(null, props);
            unsetCurrentInstance();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.propsCache;
    const cached = cache2.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$2(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend$1(normalized, props);
        if (keys)
          needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$4(comp)) {
        cache2.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$2(raw)) {
      for (let i = 0; i < raw.length; i++) {
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$1({}, opt);
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[0] = booleanIndex > -1;
            prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$4(comp)) {
      cache2.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$") {
      return true;
    }
    return false;
  }
  function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
    return match ? match[2] : ctor === null ? "null" : "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
    if (isArray$2(expectedTypes)) {
      return expectedTypes.findIndex((t) => isSameType(t, type));
    } else if (isFunction$2(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot$1 = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false)
        ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key))
        continue;
      const value = rawSlots[key];
      if (isFunction$2(value)) {
        slots[key] = normalizeSlot$1(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        instance.slots = toRaw(children);
        def(children, "_", type);
      } else {
        normalizeObjectSlots(children, instance.slots = {});
      }
    } else {
      instance.slots = {};
      if (children) {
        normalizeVNodeSlots(instance, children);
      }
    }
    def(instance.slots, InternalObjectKey, 1);
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          extend$1(slots, children);
          if (!optimized && type === 1) {
            delete slots._;
          }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
          delete slots[key];
        }
      }
    }
  };
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$2(rawRef)) {
      rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref2 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref2) {
      if (isString$3(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn$1(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$2(ref2)) {
      callWithErrorHandling(ref2, owner, 12, [value, refs]);
    } else {
      const _isString = isString$3(ref2);
      const _isRef = isRef(ref2);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? hasOwn$1(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
            if (isUnmount) {
              isArray$2(existing) && remove(existing, refValue);
            } else {
              if (!isArray$2(existing)) {
                if (_isString) {
                  refs[ref2] = [refValue];
                  if (hasOwn$1(setupState, ref2)) {
                    setupState[ref2] = refs[ref2];
                  }
                } else {
                  ref2.value = [refValue];
                  if (rawRef.k)
                    refs[rawRef.k] = ref2.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref2] = value;
            if (hasOwn$1(setupState, ref2)) {
              setupState[ref2] = value;
            }
          } else if (_isRef) {
            ref2.value = value;
            if (rawRef.k)
              refs[rawRef.k] = value;
          } else
            ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis$1();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref2, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, isSVG);
          }
          break;
        case Fragment:
          processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          break;
        default:
          if (shapeFlag & 1) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else
            ;
      }
      if (ref2 != null && parentComponent) {
        setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      isSVG = isSVG || n2.type === "svg";
      if (n1 == null) {
        mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { type, props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      const areChildrenSVG = isSVG && n2.type !== "foreignObject";
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      } else if (!optimized) {
        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, isSVG);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
          if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
            traverseStaticChildren(n1, n2, true);
          }
        } else {
          patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
        } else {
          mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
      const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
        return;
      }
      setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              instance.subTree = renderComponentRoot(instance);
              hydrateNode(el, instance.subTree, instance, parentSuspense, null);
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
            } else {
              hydrateSubTree();
            }
          } else {
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
          }
        }
      };
      const effect = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope);
      const update = instance.update = () => effect.run();
      update.id = instance.uid;
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs();
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
      if (oldLength > newLength) {
        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
      } else {
        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref2,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs
      } = vnode;
      if (ref2 != null) {
        setRef(ref2, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, update, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update) {
        update.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(container._vnode || null, vnode, container, null, null, null, isSVG);
      }
      flushPreFlushCbs();
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
      render,
      hydrate,
      createApp: createAppAPI(render, hydrate)
    };
  }
  function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$2(ch1) && isArray$2(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString$3(targetSelector)) {
      if (!select) {
        return null;
      } else {
        const target = select(targetSelector);
        return target;
      }
    } else {
      return targetSelector;
    }
  };
  const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (n1 == null) {
        const placeholder = n2.el = createText("");
        const mainAnchor = n2.anchor = createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = n2.targetAnchor = createText("");
        if (target) {
          insert(targetAnchor, target);
          isSVG = isSVG || isTargetSVG(target);
        }
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
        } else if (target) {
          mount(target, targetAnchor);
        }
      } else {
        n2.el = n1.el;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        isSVG = isSVG || isTargetSVG(target);
        if (dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(n2, container, mainAnchor, internals, 1);
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
            if (nextTarget) {
              moveTeleport(n2, nextTarget, null, internals, 0);
            }
          } else if (wasDisabled) {
            moveTeleport(n2, target, targetAnchor, internals, 1);
          }
        }
      }
      updateCssVars(n2);
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
      if (target) {
        hostRemove(targetAnchor);
      }
      if (doRemove || !isTeleportDisabled(props)) {
        hostRemove(anchor);
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
          }
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, parentAnchor, 2);
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            targetAnchor = nextSibling(targetAnchor);
            if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
      }
      updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node = vnode.children[0].el;
      while (node !== vnode.targetAnchor) {
        if (node.nodeType === 1)
          node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
  }
  function isVNode$1(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  const InternalObjectKey = `__vInternal`;
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref2,
    ref_key,
    ref_for
  }) => {
    if (typeof ref2 === "number") {
      ref2 = "" + ref2;
    }
    return ref2 != null ? isString$3(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$3(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode$1(type)) {
      const cloned = cloneVNode(type, props, true);
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag |= -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString$3(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$4(style)) {
        if (isProxy(style) && !isArray$2(style)) {
          style = extend$1({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString$3(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$4(type) ? 4 : isFunction$2(type) ? 2 : 0;
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref: ref2, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    return cloned;
  }
  function createTextVNode(text2 = " ", flag = 0) {
    return createVNode(Text, null, text2, flag);
  }
  function createCommentVNode(text2 = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$2(child)) {
      return createVNode(Fragment, null, child.slice());
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$2(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$2(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new EffectScope(true),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let globalCurrentInstanceSetters;
  let settersKey = "__VUE_INSTANCE_SETTERS__";
  {
    if (!(globalCurrentInstanceSetters = getGlobalThis$1()[settersKey])) {
      globalCurrentInstanceSetters = getGlobalThis$1()[settersKey] = [];
    }
    globalCurrentInstanceSetters.push((i) => currentInstance = i);
    internalSetCurrentInstance = (instance) => {
      if (globalCurrentInstanceSetters.length > 1) {
        globalCurrentInstanceSetters.forEach((s) => s(instance));
      } else {
        globalCurrentInstanceSetters[0](instance);
      }
    };
  }
  const setCurrentInstance = (instance) => {
    internalSetCurrentInstance(instance);
    instance.scope.on();
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    const { setup } = Component;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
      resetTracking();
      unsetCurrentInstance();
      if (isPromise$1(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$2(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$4(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else
      ;
    finishComponentSetup(instance, isSSR);
  }
  let compile$1;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile$1 && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend$1(extend$1({
            isCustomElement,
            delimiters
          }, compilerOptions), componentCompilerOptions);
          Component.render = compile$1(template, finalCompilerOptions);
        }
      }
      instance.render = Component.render || NOOP;
    }
    {
      setCurrentInstance(instance);
      pauseTracking();
      applyOptions(instance);
      resetTracking();
      unsetCurrentInstance();
    }
  }
  function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs, {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }));
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        get attrs() {
          return getAttrsProxy(instance);
        },
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    }
  }
  function getComponentName(Component, includeInferred = true) {
    return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function isClassComponent(value) {
    return isFunction$2(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  };
  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject$4(propsOrChildren) && !isArray$2(propsOrChildren)) {
        if (isVNode$1(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode$1(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  const version = "3.3.4";
  const svgNS = "http://www.w3.org/2000/svg";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, isSVG, is, props) => {
      const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text2) => doc.createTextNode(text2),
    createComment: (text2) => doc.createComment(text2),
    setText: (node, text2) => {
      node.nodeValue = text2;
    },
    setElementText: (el, text2) => {
      el.textContent = text2;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    insertStaticContent(content, parent, anchor, isSVG, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling))
            break;
        }
      } else {
        templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
        const template = templateContainer.content;
        if (isSVG) {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        before ? before.nextSibling : parent.firstChild,
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString$3(next);
    if (next && !isCssString) {
      if (prev && !isString$3(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
      for (const key in next) {
        setStyle(style, key, next[key]);
      }
    } else {
      const currentDisplay = style.display;
      if (isCssString) {
        if (prev !== next) {
          style.cssText = next;
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
      if ("_vod" in el) {
        style.display = currentDisplay;
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray$2(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null)
        val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize$1(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      const isBoolean2 = isSpecialBooleanAttr(key);
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, isBoolean2 ? "" : value);
      }
    }
  }
  function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key] = value == null ? "" : value;
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && !tag.includes("-")) {
      el._value = value;
      const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
      const newValue = value == null ? "" : value;
      if (oldValue !== newValue) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
    }
    needRemove && el.removeAttribute(key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray$2(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
    } else {
      return value;
    }
  }
  const nativeOnRE = /^on[a-z]/;
  const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && nativeOnRE.test(key) && isFunction$2(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (nativeOnRE.test(key) && isString$3(value)) {
      return false;
    }
    return key in el;
  }
  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  Transition.props = /* @__PURE__ */ extend$1({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);
  const callHook = (hook, args = []) => {
    if (isArray$2(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend$1(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$4(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber$1(val);
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el._vtc = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
  };
  const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
      for (let i = 0; i < modifiers.length; i++) {
        const guard = modifierGuards[modifiers[i]];
        if (guard && guard(event, modifiers))
          return;
      }
      return fn(event, ...args);
    };
  };
  const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  const withKeys = (fn, modifiers) => {
    return (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
        return fn(event);
      }
    };
  };
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el._vod = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue)
        return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  function setDisplay(el, value) {
    el.style.display = value ? el._vod : "none";
  }
  const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = (...args) => {
    const app2 = ensureRenderer().createApp(...args);
    const { mount } = app2;
    app2.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app2._component;
      if (!isFunction$2(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, container instanceof SVGElement);
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app2;
  };
  function normalizeContainer(container) {
    if (isString$3(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  /*!
    * shared v9.9.0
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  const inBrowser = typeof window !== "undefined";
  const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
  const generateFormatCacheKey = (locale, key, source2) => friendlyJSONstringify({ l: locale, k: key, s: source2 });
  const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
  const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
  const isDate$1 = (val) => toTypeString(val) === "[object Date]";
  const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
  const isEmptyObject = (val) => isPlainObject$2(val) && Object.keys(val).length === 0;
  const assign$3 = Object.assign;
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function escapeHtml(rawText) {
    return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }
  const isArray$1 = Array.isArray;
  const isFunction$1 = (val) => typeof val === "function";
  const isString$2 = (val) => typeof val === "string";
  const isBoolean = (val) => typeof val === "boolean";
  const isObject$3 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return isObject$3(val) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$1.call(value);
  const isPlainObject$2 = (val) => {
    if (!isObject$3(val))
      return false;
    const proto = Object.getPrototypeOf(val);
    return proto === null || proto.constructor === Object;
  };
  const toDisplayString = (val) => {
    return val == null ? "" : isArray$1(val) || isPlainObject$2(val) && val.toString === objectToString$1 ? JSON.stringify(val, null, 2) : String(val);
  };
  function join$1(items, separator = "") {
    return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
  }
  function incrementer(code2) {
    let current = code2;
    return () => ++current;
  }
  function warn(msg, err) {
    if (typeof console !== "undefined") {
      console.warn(`[intlify] ` + msg);
      if (err) {
        console.warn(err.stack);
      }
    }
  }
  const isNotObjectOrIsArray = (val) => !isObject$3(val) || isArray$1(val);
  function deepCopy(src, des) {
    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
      throw new Error("Invalid value");
    }
    const stack = [{ src, des }];
    while (stack.length) {
      const { src: src2, des: des2 } = stack.pop();
      Object.keys(src2).forEach((key) => {
        if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
          des2[key] = src2[key];
        } else {
          stack.push({ src: src2[key], des: des2[key] });
        }
      });
    }
  }
  /*!
    * message-compiler v9.9.0
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  function createPosition(line, column, offset) {
    return { line, column, offset };
  }
  function createLocation(start, end, source2) {
    const loc = { start, end };
    if (source2 != null) {
      loc.source = source2;
    }
    return loc;
  }
  const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
  function format$1(message, ...args) {
    if (args.length === 1 && isObject$2(args[0])) {
      args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
      args = {};
    }
    return message.replace(RE_ARGS, (match, identifier) => {
      return args.hasOwnProperty(identifier) ? args[identifier] : "";
    });
  }
  const assign$2 = Object.assign;
  const isString$1 = (val) => typeof val === "string";
  const isObject$2 = (val) => val !== null && typeof val === "object";
  function join(items, separator = "") {
    return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
  }
  const CompileErrorCodes = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    __EXTEND_POINT__: 17
  };
  const errorMessages = {
    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
  };
  function createCompileError(code2, loc, options = {}) {
    const { domain, messages: messages2, args } = options;
    const msg = format$1((messages2 || errorMessages)[code2] || "", ...args || []);
    const error = new SyntaxError(String(msg));
    error.code = code2;
    if (loc) {
      error.location = loc;
    }
    error.domain = domain;
    return error;
  }
  function defaultOnError(error) {
    throw error;
  }
  const CHAR_SP = " ";
  const CHAR_CR = "\r";
  const CHAR_LF = "\n";
  const CHAR_LS = String.fromCharCode(8232);
  const CHAR_PS = String.fromCharCode(8233);
  function createScanner(str) {
    const _buf = str;
    let _index = 0;
    let _line = 1;
    let _column = 1;
    let _peekOffset = 0;
    const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
    const isLF = (index2) => _buf[index2] === CHAR_LF;
    const isPS = (index2) => _buf[index2] === CHAR_PS;
    const isLS = (index2) => _buf[index2] === CHAR_LS;
    const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
    const index = () => _index;
    const line = () => _line;
    const column = () => _column;
    const peekOffset = () => _peekOffset;
    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
    const currentChar = () => charAt(_index);
    const currentPeek = () => charAt(_index + _peekOffset);
    function next() {
      _peekOffset = 0;
      if (isLineEnd(_index)) {
        _line++;
        _column = 0;
      }
      if (isCRLF(_index)) {
        _index++;
      }
      _index++;
      _column++;
      return _buf[_index];
    }
    function peek() {
      if (isCRLF(_index + _peekOffset)) {
        _peekOffset++;
      }
      _peekOffset++;
      return _buf[_index + _peekOffset];
    }
    function reset() {
      _index = 0;
      _line = 1;
      _column = 1;
      _peekOffset = 0;
    }
    function resetPeek(offset = 0) {
      _peekOffset = offset;
    }
    function skipToPeek() {
      const target = _index + _peekOffset;
      while (target !== _index) {
        next();
      }
      _peekOffset = 0;
    }
    return {
      index,
      line,
      column,
      peekOffset,
      charAt,
      currentChar,
      currentPeek,
      next,
      peek,
      reset,
      resetPeek,
      skipToPeek
    };
  }
  const EOF = void 0;
  const DOT = ".";
  const LITERAL_DELIMITER = "'";
  const ERROR_DOMAIN$3 = "tokenizer";
  function createTokenizer(source2, options = {}) {
    const location2 = options.location !== false;
    const _scnr = createScanner(source2);
    const currentOffset = () => _scnr.index();
    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
    const _initLoc = currentPosition();
    const _initOffset = currentOffset();
    const _context = {
      currentType: 14,
      offset: _initOffset,
      startLoc: _initLoc,
      endLoc: _initLoc,
      lastType: 14,
      lastOffset: _initOffset,
      lastStartLoc: _initLoc,
      lastEndLoc: _initLoc,
      braceNest: 0,
      inLinked: false,
      text: ""
    };
    const context = () => _context;
    const { onError } = options;
    function emitError(code2, pos, offset, ...args) {
      const ctx = context();
      pos.column += offset;
      pos.offset += offset;
      if (onError) {
        const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
        const err = createCompileError(code2, loc, {
          domain: ERROR_DOMAIN$3,
          args
        });
        onError(err);
      }
    }
    function getToken(context2, type, value) {
      context2.endLoc = currentPosition();
      context2.currentType = type;
      const token = { type };
      if (location2) {
        token.loc = createLocation(context2.startLoc, context2.endLoc);
      }
      if (value != null) {
        token.value = value;
      }
      return token;
    }
    const getEndToken = (context2) => getToken(context2, 14);
    function eat(scnr, ch) {
      if (scnr.currentChar() === ch) {
        scnr.next();
        return ch;
      } else {
        emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        return "";
      }
    }
    function peekSpaces(scnr) {
      let buf = "";
      while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
        buf += scnr.currentPeek();
        scnr.peek();
      }
      return buf;
    }
    function skipSpaces(scnr) {
      const buf = peekSpaces(scnr);
      scnr.skipToPeek();
      return buf;
    }
    function isIdentifierStart(ch) {
      if (ch === EOF) {
        return false;
      }
      const cc = ch.charCodeAt(0);
      return cc >= 97 && cc <= 122 || cc >= 65 && cc <= 90 || cc === 95;
    }
    function isNumberStart(ch) {
      if (ch === EOF) {
        return false;
      }
      const cc = ch.charCodeAt(0);
      return cc >= 48 && cc <= 57;
    }
    function isNamedIdentifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ret = isIdentifierStart(scnr.currentPeek());
      scnr.resetPeek();
      return ret;
    }
    function isListIdentifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
      const ret = isNumberStart(ch);
      scnr.resetPeek();
      return ret;
    }
    function isLiteralStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 2) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === LITERAL_DELIMITER;
      scnr.resetPeek();
      return ret;
    }
    function isLinkedDotStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 8) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === ".";
      scnr.resetPeek();
      return ret;
    }
    function isLinkedModifierStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 9) {
        return false;
      }
      peekSpaces(scnr);
      const ret = isIdentifierStart(scnr.currentPeek());
      scnr.resetPeek();
      return ret;
    }
    function isLinkedDelimiterStart(scnr, context2) {
      const { currentType } = context2;
      if (!(currentType === 8 || currentType === 12)) {
        return false;
      }
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === ":";
      scnr.resetPeek();
      return ret;
    }
    function isLinkedReferStart(scnr, context2) {
      const { currentType } = context2;
      if (currentType !== 10) {
        return false;
      }
      const fn = () => {
        const ch = scnr.currentPeek();
        if (ch === "{") {
          return isIdentifierStart(scnr.peek());
        } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
          return false;
        } else if (ch === CHAR_LF) {
          scnr.peek();
          return fn();
        } else {
          return isIdentifierStart(ch);
        }
      };
      const ret = fn();
      scnr.resetPeek();
      return ret;
    }
    function isPluralStart(scnr) {
      peekSpaces(scnr);
      const ret = scnr.currentPeek() === "|";
      scnr.resetPeek();
      return ret;
    }
    function detectModuloStart(scnr) {
      const spaces = peekSpaces(scnr);
      const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
      scnr.resetPeek();
      return {
        isModulo: ret,
        hasSpace: spaces.length > 0
      };
    }
    function isTextStart(scnr, reset = true) {
      const fn = (hasSpace = false, prev = "", detectModulo = false) => {
        const ch = scnr.currentPeek();
        if (ch === "{") {
          return prev === "%" ? false : hasSpace;
        } else if (ch === "@" || !ch) {
          return prev === "%" ? true : hasSpace;
        } else if (ch === "%") {
          scnr.peek();
          return fn(hasSpace, "%", true);
        } else if (ch === "|") {
          return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
        } else if (ch === CHAR_SP) {
          scnr.peek();
          return fn(true, CHAR_SP, detectModulo);
        } else if (ch === CHAR_LF) {
          scnr.peek();
          return fn(true, CHAR_LF, detectModulo);
        } else {
          return true;
        }
      };
      const ret = fn();
      reset && scnr.resetPeek();
      return ret;
    }
    function takeChar(scnr, fn) {
      const ch = scnr.currentChar();
      if (ch === EOF) {
        return EOF;
      }
      if (fn(ch)) {
        scnr.next();
        return ch;
      }
      return null;
    }
    function takeIdentifierChar(scnr) {
      const closure = (ch) => {
        const cc = ch.charCodeAt(0);
        return cc >= 97 && cc <= 122 || cc >= 65 && cc <= 90 || cc >= 48 && cc <= 57 || cc === 95 || cc === 36;
      };
      return takeChar(scnr, closure);
    }
    function takeDigit(scnr) {
      const closure = (ch) => {
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57;
      };
      return takeChar(scnr, closure);
    }
    function takeHexDigit(scnr) {
      const closure = (ch) => {
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57 || cc >= 65 && cc <= 70 || cc >= 97 && cc <= 102;
      };
      return takeChar(scnr, closure);
    }
    function getDigits(scnr) {
      let ch = "";
      let num = "";
      while (ch = takeDigit(scnr)) {
        num += ch;
      }
      return num;
    }
    function readModulo(scnr) {
      skipSpaces(scnr);
      const ch = scnr.currentChar();
      if (ch !== "%") {
        emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      }
      scnr.next();
      return "%";
    }
    function readText(scnr) {
      let buf = "";
      while (true) {
        const ch = scnr.currentChar();
        if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
          break;
        } else if (ch === "%") {
          if (isTextStart(scnr)) {
            buf += ch;
            scnr.next();
          } else {
            break;
          }
        } else if (ch === CHAR_SP || ch === CHAR_LF) {
          if (isTextStart(scnr)) {
            buf += ch;
            scnr.next();
          } else if (isPluralStart(scnr)) {
            break;
          } else {
            buf += ch;
            scnr.next();
          }
        } else {
          buf += ch;
          scnr.next();
        }
      }
      return buf;
    }
    function readNamedIdentifier(scnr) {
      skipSpaces(scnr);
      let ch = "";
      let name = "";
      while (ch = takeIdentifierChar(scnr)) {
        name += ch;
      }
      if (scnr.currentChar() === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
      }
      return name;
    }
    function readListIdentifier(scnr) {
      skipSpaces(scnr);
      let value = "";
      if (scnr.currentChar() === "-") {
        scnr.next();
        value += `-${getDigits(scnr)}`;
      } else {
        value += getDigits(scnr);
      }
      if (scnr.currentChar() === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
      }
      return value;
    }
    function readLiteral(scnr) {
      skipSpaces(scnr);
      eat(scnr, `'`);
      let ch = "";
      let literal = "";
      const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;
      while (ch = takeChar(scnr, fn)) {
        if (ch === "\\") {
          literal += readEscapeSequence(scnr);
        } else {
          literal += ch;
        }
      }
      const current = scnr.currentChar();
      if (current === CHAR_LF || current === EOF) {
        emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
        if (current === CHAR_LF) {
          scnr.next();
          eat(scnr, `'`);
        }
        return literal;
      }
      eat(scnr, `'`);
      return literal;
    }
    function readEscapeSequence(scnr) {
      const ch = scnr.currentChar();
      switch (ch) {
        case "\\":
        case `'`:
          scnr.next();
          return `\\${ch}`;
        case "u":
          return readUnicodeEscapeSequence(scnr, ch, 4);
        case "U":
          return readUnicodeEscapeSequence(scnr, ch, 6);
        default:
          emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
          return "";
      }
    }
    function readUnicodeEscapeSequence(scnr, unicode, digits) {
      eat(scnr, unicode);
      let sequence = "";
      for (let i = 0; i < digits; i++) {
        const ch = takeHexDigit(scnr);
        if (!ch) {
          emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
          break;
        }
        sequence += ch;
      }
      return `\\${unicode}${sequence}`;
    }
    function readInvalidIdentifier(scnr) {
      skipSpaces(scnr);
      let ch = "";
      let identifiers = "";
      const closure = (ch2) => ch2 !== "{" && ch2 !== "}" && ch2 !== CHAR_SP && ch2 !== CHAR_LF;
      while (ch = takeChar(scnr, closure)) {
        identifiers += ch;
      }
      return identifiers;
    }
    function readLinkedModifier(scnr) {
      let ch = "";
      let name = "";
      while (ch = takeIdentifierChar(scnr)) {
        name += ch;
      }
      return name;
    }
    function readLinkedRefer(scnr) {
      const fn = (detect = false, buf) => {
        const ch = scnr.currentChar();
        if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
          return buf;
        } else if (ch === CHAR_SP) {
          return buf;
        } else if (ch === CHAR_LF || ch === DOT) {
          buf += ch;
          scnr.next();
          return fn(detect, buf);
        } else {
          buf += ch;
          scnr.next();
          return fn(true, buf);
        }
      };
      return fn(false, "");
    }
    function readPlural(scnr) {
      skipSpaces(scnr);
      const plural = eat(scnr, "|");
      skipSpaces(scnr);
      return plural;
    }
    function readTokenInPlaceholder(scnr, context2) {
      let token = null;
      const ch = scnr.currentChar();
      switch (ch) {
        case "{":
          if (context2.braceNest >= 1) {
            emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
          }
          scnr.next();
          token = getToken(context2, 2, "{");
          skipSpaces(scnr);
          context2.braceNest++;
          return token;
        case "}":
          if (context2.braceNest > 0 && context2.currentType === 2) {
            emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
          }
          scnr.next();
          token = getToken(context2, 3, "}");
          context2.braceNest--;
          context2.braceNest > 0 && skipSpaces(scnr);
          if (context2.inLinked && context2.braceNest === 0) {
            context2.inLinked = false;
          }
          return token;
        case "@":
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = readTokenInLinked(scnr, context2) || getEndToken(context2);
          context2.braceNest = 0;
          return token;
        default:
          let validNamedIdentifier = true;
          let validListIdentifier = true;
          let validLiteral = true;
          if (isPluralStart(scnr)) {
            if (context2.braceNest > 0) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            }
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            context2.braceNest = 0;
            return readToken(scnr, context2);
          }
          if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
            token = getToken(context2, 5, readNamedIdentifier(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
            token = getToken(context2, 6, readListIdentifier(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (validLiteral = isLiteralStart(scnr, context2)) {
            token = getToken(context2, 7, readLiteral(scnr));
            skipSpaces(scnr);
            return token;
          }
          if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
            token = getToken(context2, 13, readInvalidIdentifier(scnr));
            emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
            skipSpaces(scnr);
            return token;
          }
          break;
      }
      return token;
    }
    function readTokenInLinked(scnr, context2) {
      const { currentType } = context2;
      let token = null;
      const ch = scnr.currentChar();
      if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
        emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
      }
      switch (ch) {
        case "@":
          scnr.next();
          token = getToken(context2, 8, "@");
          context2.inLinked = true;
          return token;
        case ".":
          skipSpaces(scnr);
          scnr.next();
          return getToken(context2, 9, ".");
        case ":":
          skipSpaces(scnr);
          scnr.next();
          return getToken(context2, 10, ":");
        default:
          if (isPluralStart(scnr)) {
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
            skipSpaces(scnr);
            return readTokenInLinked(scnr, context2);
          }
          if (isLinkedModifierStart(scnr, context2)) {
            skipSpaces(scnr);
            return getToken(context2, 12, readLinkedModifier(scnr));
          }
          if (isLinkedReferStart(scnr, context2)) {
            skipSpaces(scnr);
            if (ch === "{") {
              return readTokenInPlaceholder(scnr, context2) || token;
            } else {
              return getToken(context2, 11, readLinkedRefer(scnr));
            }
          }
          if (currentType === 8) {
            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
          }
          context2.braceNest = 0;
          context2.inLinked = false;
          return readToken(scnr, context2);
      }
    }
    function readToken(scnr, context2) {
      let token = { type: 14 };
      if (context2.braceNest > 0) {
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      }
      if (context2.inLinked) {
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      }
      const ch = scnr.currentChar();
      switch (ch) {
        case "{":
          return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
        case "}":
          emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
          scnr.next();
          return getToken(context2, 3, "}");
        case "@":
          return readTokenInLinked(scnr, context2) || getEndToken(context2);
        default:
          if (isPluralStart(scnr)) {
            token = getToken(context2, 1, readPlural(scnr));
            context2.braceNest = 0;
            context2.inLinked = false;
            return token;
          }
          const { isModulo, hasSpace } = detectModuloStart(scnr);
          if (isModulo) {
            return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
          }
          if (isTextStart(scnr)) {
            return getToken(context2, 0, readText(scnr));
          }
          break;
      }
      return token;
    }
    function nextToken() {
      const { currentType, offset, startLoc, endLoc } = _context;
      _context.lastType = currentType;
      _context.lastOffset = offset;
      _context.lastStartLoc = startLoc;
      _context.lastEndLoc = endLoc;
      _context.offset = currentOffset();
      _context.startLoc = currentPosition();
      if (_scnr.currentChar() === EOF) {
        return getToken(_context, 14);
      }
      return readToken(_scnr, _context);
    }
    return {
      nextToken,
      currentOffset,
      currentPosition,
      context
    };
  }
  const ERROR_DOMAIN$2 = "parser";
  const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function fromEscapeSequence(match, codePoint4, codePoint6) {
    switch (match) {
      case `\\\\`:
        return `\\`;
      case `\\'`:
        return `'`;
      default: {
        const codePoint = parseInt(codePoint4 || codePoint6, 16);
        if (codePoint <= 55295 || codePoint >= 57344) {
          return String.fromCodePoint(codePoint);
        }
        return "\uFFFD";
      }
    }
  }
  function createParser(options = {}) {
    const location2 = options.location !== false;
    const { onError } = options;
    function emitError(tokenzer, code2, start, offset, ...args) {
      const end = tokenzer.currentPosition();
      end.offset += offset;
      end.column += offset;
      if (onError) {
        const loc = location2 ? createLocation(start, end) : null;
        const err = createCompileError(code2, loc, {
          domain: ERROR_DOMAIN$2,
          args
        });
        onError(err);
      }
    }
    function startNode(type, offset, loc) {
      const node = { type };
      if (location2) {
        node.start = offset;
        node.end = offset;
        node.loc = { start: loc, end: loc };
      }
      return node;
    }
    function endNode(node, offset, pos, type) {
      if (type) {
        node.type = type;
      }
      if (location2) {
        node.end = offset;
        if (node.loc) {
          node.loc.end = pos;
        }
      }
    }
    function parseText(tokenizer, value) {
      const context = tokenizer.context();
      const node = startNode(3, context.offset, context.startLoc);
      node.value = value;
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseList(tokenizer, index) {
      const context = tokenizer.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(5, offset, loc);
      node.index = parseInt(index, 10);
      tokenizer.nextToken();
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseNamed(tokenizer, key) {
      const context = tokenizer.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(4, offset, loc);
      node.key = key;
      tokenizer.nextToken();
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseLiteral(tokenizer, value) {
      const context = tokenizer.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(9, offset, loc);
      node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
      tokenizer.nextToken();
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseLinkedModifier(tokenizer) {
      const token = tokenizer.nextToken();
      const context = tokenizer.context();
      const { lastOffset: offset, lastStartLoc: loc } = context;
      const node = startNode(8, offset, loc);
      if (token.type !== 12) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
        node.value = "";
        endNode(node, offset, loc);
        return {
          nextConsumeToken: token,
          node
        };
      }
      if (token.value == null) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
      }
      node.value = token.value || "";
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return {
        node
      };
    }
    function parseLinkedKey(tokenizer, value) {
      const context = tokenizer.context();
      const node = startNode(7, context.offset, context.startLoc);
      node.value = value;
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseLinked(tokenizer) {
      const context = tokenizer.context();
      const linkedNode = startNode(6, context.offset, context.startLoc);
      let token = tokenizer.nextToken();
      if (token.type === 9) {
        const parsed = parseLinkedModifier(tokenizer);
        linkedNode.modifier = parsed.node;
        token = parsed.nextConsumeToken || tokenizer.nextToken();
      }
      if (token.type !== 10) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
      }
      token = tokenizer.nextToken();
      if (token.type === 2) {
        token = tokenizer.nextToken();
      }
      switch (token.type) {
        case 11:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseNamed(tokenizer, token.value || "");
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseList(tokenizer, token.value || "");
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          linkedNode.key = parseLiteral(tokenizer, token.value || "");
          break;
        default:
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
          const nextContext = tokenizer.context();
          const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
          emptyLinkedKeyNode.value = "";
          endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
          linkedNode.key = emptyLinkedKeyNode;
          endNode(linkedNode, nextContext.offset, nextContext.startLoc);
          return {
            nextConsumeToken: token,
            node: linkedNode
          };
      }
      endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
      return {
        node: linkedNode
      };
    }
    function parseMessage(tokenizer) {
      const context = tokenizer.context();
      const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
      const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
      const node = startNode(2, startOffset, startLoc);
      node.items = [];
      let nextToken = null;
      do {
        const token = nextToken || tokenizer.nextToken();
        nextToken = null;
        switch (token.type) {
          case 0:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseText(tokenizer, token.value || ""));
            break;
          case 6:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseList(tokenizer, token.value || ""));
            break;
          case 5:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseNamed(tokenizer, token.value || ""));
            break;
          case 7:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            node.items.push(parseLiteral(tokenizer, token.value || ""));
            break;
          case 8:
            const parsed = parseLinked(tokenizer);
            node.items.push(parsed.node);
            nextToken = parsed.nextConsumeToken || null;
            break;
        }
      } while (context.currentType !== 14 && context.currentType !== 1);
      const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
      const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
      endNode(node, endOffset, endLoc);
      return node;
    }
    function parsePlural(tokenizer, offset, loc, msgNode) {
      const context = tokenizer.context();
      let hasEmptyMessage = msgNode.items.length === 0;
      const node = startNode(1, offset, loc);
      node.cases = [];
      node.cases.push(msgNode);
      do {
        const msg = parseMessage(tokenizer);
        if (!hasEmptyMessage) {
          hasEmptyMessage = msg.items.length === 0;
        }
        node.cases.push(msg);
      } while (context.currentType !== 14);
      if (hasEmptyMessage) {
        emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
      }
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    function parseResource(tokenizer) {
      const context = tokenizer.context();
      const { offset, startLoc } = context;
      const msgNode = parseMessage(tokenizer);
      if (context.currentType === 14) {
        return msgNode;
      } else {
        return parsePlural(tokenizer, offset, startLoc, msgNode);
      }
    }
    function parse2(source2) {
      const tokenizer = createTokenizer(source2, assign$2({}, options));
      const context = tokenizer.context();
      const node = startNode(0, context.offset, context.startLoc);
      if (location2 && node.loc) {
        node.loc.source = source2;
      }
      node.body = parseResource(tokenizer);
      if (options.onCacheKey) {
        node.cacheKey = options.onCacheKey(source2);
      }
      if (context.currentType !== 14) {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source2[context.offset] || "");
      }
      endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
      return node;
    }
    return { parse: parse2 };
  }
  function getTokenCaption(token) {
    if (token.type === 14) {
      return "EOF";
    }
    const name = (token.value || "").replace(/\r?\n/gu, "\\n");
    return name.length > 10 ? name.slice(0, 9) + "\u2026" : name;
  }
  function createTransformer(ast, options = {}) {
    const _context = {
      ast,
      helpers: /* @__PURE__ */ new Set()
    };
    const context = () => _context;
    const helper = (name) => {
      _context.helpers.add(name);
      return name;
    };
    return { context, helper };
  }
  function traverseNodes(nodes, transformer) {
    for (let i = 0; i < nodes.length; i++) {
      traverseNode(nodes[i], transformer);
    }
  }
  function traverseNode(node, transformer) {
    switch (node.type) {
      case 1:
        traverseNodes(node.cases, transformer);
        transformer.helper("plural");
        break;
      case 2:
        traverseNodes(node.items, transformer);
        break;
      case 6:
        const linked = node;
        traverseNode(linked.key, transformer);
        transformer.helper("linked");
        transformer.helper("type");
        break;
      case 5:
        transformer.helper("interpolate");
        transformer.helper("list");
        break;
      case 4:
        transformer.helper("interpolate");
        transformer.helper("named");
        break;
    }
  }
  function transform(ast, options = {}) {
    const transformer = createTransformer(ast);
    transformer.helper("normalize");
    ast.body && traverseNode(ast.body, transformer);
    const context = transformer.context();
    ast.helpers = Array.from(context.helpers);
  }
  function optimize(ast) {
    const body = ast.body;
    if (body.type === 2) {
      optimizeMessageNode(body);
    } else {
      body.cases.forEach((c) => optimizeMessageNode(c));
    }
    return ast;
  }
  function optimizeMessageNode(message) {
    if (message.items.length === 1) {
      const item = message.items[0];
      if (item.type === 3 || item.type === 9) {
        message.static = item.value;
        delete item.value;
      }
    } else {
      const values = [];
      for (let i = 0; i < message.items.length; i++) {
        const item = message.items[i];
        if (!(item.type === 3 || item.type === 9)) {
          break;
        }
        if (item.value == null) {
          break;
        }
        values.push(item.value);
      }
      if (values.length === message.items.length) {
        message.static = join(values);
        for (let i = 0; i < message.items.length; i++) {
          const item = message.items[i];
          if (item.type === 3 || item.type === 9) {
            delete item.value;
          }
        }
      }
    }
  }
  const ERROR_DOMAIN$1 = "minifier";
  function minify(node) {
    node.t = node.type;
    switch (node.type) {
      case 0:
        const resource = node;
        minify(resource.body);
        resource.b = resource.body;
        delete resource.body;
        break;
      case 1:
        const plural = node;
        const cases = plural.cases;
        for (let i = 0; i < cases.length; i++) {
          minify(cases[i]);
        }
        plural.c = cases;
        delete plural.cases;
        break;
      case 2:
        const message = node;
        const items = message.items;
        for (let i = 0; i < items.length; i++) {
          minify(items[i]);
        }
        message.i = items;
        delete message.items;
        if (message.static) {
          message.s = message.static;
          delete message.static;
        }
        break;
      case 3:
      case 9:
      case 8:
      case 7:
        const valueNode = node;
        if (valueNode.value) {
          valueNode.v = valueNode.value;
          delete valueNode.value;
        }
        break;
      case 6:
        const linked = node;
        minify(linked.key);
        linked.k = linked.key;
        delete linked.key;
        if (linked.modifier) {
          minify(linked.modifier);
          linked.m = linked.modifier;
          delete linked.modifier;
        }
        break;
      case 5:
        const list = node;
        list.i = list.index;
        delete list.index;
        break;
      case 4:
        const named = node;
        named.k = named.key;
        delete named.key;
        break;
      default: {
        throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: ERROR_DOMAIN$1,
          args: [node.type]
        });
      }
    }
    delete node.type;
  }
  const ERROR_DOMAIN = "parser";
  function createCodeGenerator(ast, options) {
    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
    const location2 = options.location !== false;
    const _context = {
      filename,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode,
      needIndent: _needIndent,
      indentLevel: 0
    };
    if (location2 && ast.loc) {
      _context.source = ast.loc.source;
    }
    const context = () => _context;
    function push(code2, node) {
      _context.code += code2;
    }
    function _newline(n, withBreakLine = true) {
      const _breakLineCode = withBreakLine ? breakLineCode : "";
      push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
    }
    function indent(withNewLine = true) {
      const level = ++_context.indentLevel;
      withNewLine && _newline(level);
    }
    function deindent(withNewLine = true) {
      const level = --_context.indentLevel;
      withNewLine && _newline(level);
    }
    function newline() {
      _newline(_context.indentLevel);
    }
    const helper = (key) => `_${key}`;
    const needIndent = () => _context.needIndent;
    return {
      context,
      push,
      indent,
      deindent,
      newline,
      helper,
      needIndent
    };
  }
  function generateLinkedNode(generator, node) {
    const { helper } = generator;
    generator.push(`${helper("linked")}(`);
    generateNode(generator, node.key);
    if (node.modifier) {
      generator.push(`, `);
      generateNode(generator, node.modifier);
      generator.push(`, _type`);
    } else {
      generator.push(`, undefined, _type`);
    }
    generator.push(`)`);
  }
  function generateMessageNode(generator, node) {
    const { helper, needIndent } = generator;
    generator.push(`${helper("normalize")}([`);
    generator.indent(needIndent());
    const length = node.items.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator, node.items[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push("])");
  }
  function generatePluralNode(generator, node) {
    const { helper, needIndent } = generator;
    if (node.cases.length > 1) {
      generator.push(`${helper("plural")}([`);
      generator.indent(needIndent());
      const length = node.cases.length;
      for (let i = 0; i < length; i++) {
        generateNode(generator, node.cases[i]);
        if (i === length - 1) {
          break;
        }
        generator.push(", ");
      }
      generator.deindent(needIndent());
      generator.push(`])`);
    }
  }
  function generateResource(generator, node) {
    if (node.body) {
      generateNode(generator, node.body);
    } else {
      generator.push("null");
    }
  }
  function generateNode(generator, node) {
    const { helper } = generator;
    switch (node.type) {
      case 0:
        generateResource(generator, node);
        break;
      case 1:
        generatePluralNode(generator, node);
        break;
      case 2:
        generateMessageNode(generator, node);
        break;
      case 6:
        generateLinkedNode(generator, node);
        break;
      case 8:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 7:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 5:
        generator.push(`${helper("interpolate")}(${helper("list")}(${node.index}))`, node);
        break;
      case 4:
        generator.push(`${helper("interpolate")}(${helper("named")}(${JSON.stringify(node.key)}))`, node);
        break;
      case 9:
        generator.push(JSON.stringify(node.value), node);
        break;
      case 3:
        generator.push(JSON.stringify(node.value), node);
        break;
      default: {
        throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: ERROR_DOMAIN,
          args: [node.type]
        });
      }
    }
  }
  const generate = (ast, options = {}) => {
    const mode = isString$1(options.mode) ? options.mode : "normal";
    const filename = isString$1(options.filename) ? options.filename : "message.intl";
    const sourceMap = !!options.sourceMap;
    const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
    const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
    const helpers = ast.helpers || [];
    const generator = createCodeGenerator(ast, {
      mode,
      filename,
      sourceMap,
      breakLineCode,
      needIndent
    });
    generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
    generator.indent(needIndent);
    if (helpers.length > 0) {
      generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
      generator.newline();
    }
    generator.push(`return `);
    generateNode(generator, ast);
    generator.deindent(needIndent);
    generator.push(`}`);
    delete ast.helpers;
    const { code: code2, map } = generator.context();
    return {
      ast,
      code: code2,
      map: map ? map.toJSON() : void 0
    };
  };
  function baseCompile$1(source2, options = {}) {
    const assignedOptions = assign$2({}, options);
    const jit = !!assignedOptions.jit;
    const enalbeMinify = !!assignedOptions.minify;
    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
    const parser = createParser(assignedOptions);
    const ast = parser.parse(source2);
    if (!jit) {
      transform(ast, assignedOptions);
      return generate(ast, assignedOptions);
    } else {
      enambeOptimize && optimize(ast);
      enalbeMinify && minify(ast);
      return { ast, code: "" };
    }
  }
  /*!
    * core-base v9.9.0
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  function initFeatureFlags$1() {
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
      getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
      getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
  }
  const pathStateMachine = [];
  pathStateMachine[0] = {
    ["w"]: [0],
    ["i"]: [3, 0],
    ["["]: [4],
    ["o"]: [7]
  };
  pathStateMachine[1] = {
    ["w"]: [1],
    ["."]: [2],
    ["["]: [4],
    ["o"]: [7]
  };
  pathStateMachine[2] = {
    ["w"]: [2],
    ["i"]: [3, 0],
    ["0"]: [3, 0]
  };
  pathStateMachine[3] = {
    ["i"]: [3, 0],
    ["0"]: [3, 0],
    ["w"]: [1, 1],
    ["."]: [2, 1],
    ["["]: [4, 1],
    ["o"]: [7, 1]
  };
  pathStateMachine[4] = {
    ["'"]: [5, 0],
    ['"']: [6, 0],
    ["["]: [
      4,
      2
    ],
    ["]"]: [1, 3],
    ["o"]: 8,
    ["l"]: [4, 0]
  };
  pathStateMachine[5] = {
    ["'"]: [4, 0],
    ["o"]: 8,
    ["l"]: [5, 0]
  };
  pathStateMachine[6] = {
    ['"']: [4, 0],
    ["o"]: 8,
    ["l"]: [6, 0]
  };
  const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function isLiteral(exp) {
    return literalValueRE.test(exp);
  }
  function stripQuotes(str) {
    const a = str.charCodeAt(0);
    const b = str.charCodeAt(str.length - 1);
    return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
  }
  function getPathCharType(ch) {
    if (ch === void 0 || ch === null) {
      return "o";
    }
    const code2 = ch.charCodeAt(0);
    switch (code2) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return ch;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function formatSubPath(path) {
    const trimmed = path.trim();
    if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
      return false;
    }
    return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
  }
  function parse(path) {
    const keys = [];
    let index = -1;
    let mode = 0;
    let subPathDepth = 0;
    let c;
    let key;
    let newChar;
    let type;
    let transition;
    let action;
    let typeMap;
    const actions = [];
    actions[0] = () => {
      if (key === void 0) {
        key = newChar;
      } else {
        key += newChar;
      }
    };
    actions[1] = () => {
      if (key !== void 0) {
        keys.push(key);
        key = void 0;
      }
    };
    actions[2] = () => {
      actions[0]();
      subPathDepth++;
    };
    actions[3] = () => {
      if (subPathDepth > 0) {
        subPathDepth--;
        mode = 4;
        actions[0]();
      } else {
        subPathDepth = 0;
        if (key === void 0) {
          return false;
        }
        key = formatSubPath(key);
        if (key === false) {
          return false;
        } else {
          actions[1]();
        }
      }
    };
    function maybeUnescapeQuote() {
      const nextChar = path[index + 1];
      if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
        index++;
        newChar = "\\" + nextChar;
        actions[0]();
        return true;
      }
    }
    while (mode !== null) {
      index++;
      c = path[index];
      if (c === "\\" && maybeUnescapeQuote()) {
        continue;
      }
      type = getPathCharType(c);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap["l"] || 8;
      if (transition === 8) {
        return;
      }
      mode = transition[0];
      if (transition[1] !== void 0) {
        action = actions[transition[1]];
        if (action) {
          newChar = c;
          if (action() === false) {
            return;
          }
        }
      }
      if (mode === 7) {
        return keys;
      }
    }
  }
  const cache = /* @__PURE__ */ new Map();
  function resolveWithKeyValue(obj, path) {
    return isObject$3(obj) ? obj[path] : null;
  }
  function resolveValue(obj, path) {
    if (!isObject$3(obj)) {
      return null;
    }
    let hit = cache.get(path);
    if (!hit) {
      hit = parse(path);
      if (hit) {
        cache.set(path, hit);
      }
    }
    if (!hit) {
      return null;
    }
    const len = hit.length;
    let last = obj;
    let i = 0;
    while (i < len) {
      const val = last[hit[i]];
      if (val === void 0) {
        return null;
      }
      if (isFunction$1(last)) {
        return null;
      }
      last = val;
      i++;
    }
    return last;
  }
  const DEFAULT_MODIFIER = (str) => str;
  const DEFAULT_MESSAGE = (ctx) => "";
  const DEFAULT_MESSAGE_DATA_TYPE = "text";
  const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
  const DEFAULT_INTERPOLATE = toDisplayString;
  function pluralDefault(choice, choicesLength) {
    choice = Math.abs(choice);
    if (choicesLength === 2) {
      return choice ? choice > 1 ? 1 : 0 : 1;
    }
    return choice ? Math.min(choice, 2) : 0;
  }
  function getPluralIndex(options) {
    const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1;
    return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
  }
  function normalizeNamed(pluralIndex, props) {
    if (!props.count) {
      props.count = pluralIndex;
    }
    if (!props.n) {
      props.n = pluralIndex;
    }
  }
  function createMessageContext(options = {}) {
    const locale = options.locale;
    const pluralIndex = getPluralIndex(options);
    const pluralRule = isObject$3(options.pluralRules) && isString$2(locale) && isFunction$1(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
    const orgPluralRule = isObject$3(options.pluralRules) && isString$2(locale) && isFunction$1(options.pluralRules[locale]) ? pluralDefault : void 0;
    const plural = (messages2) => {
      return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
    };
    const _list = options.list || [];
    const list = (index) => _list[index];
    const _named = options.named || {};
    isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
    const named = (key) => _named[key];
    function message(key) {
      const msg = isFunction$1(options.messages) ? options.messages(key) : isObject$3(options.messages) ? options.messages[key] : false;
      return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
    }
    const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
    const normalize = isPlainObject$2(options.processor) && isFunction$1(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
    const interpolate = isPlainObject$2(options.processor) && isFunction$1(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
    const type = isPlainObject$2(options.processor) && isString$2(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
    const linked = (key, ...args) => {
      const [arg1, arg2] = args;
      let type2 = "text";
      let modifier = "";
      if (args.length === 1) {
        if (isObject$3(arg1)) {
          modifier = arg1.modifier || modifier;
          type2 = arg1.type || type2;
        } else if (isString$2(arg1)) {
          modifier = arg1 || modifier;
        }
      } else if (args.length === 2) {
        if (isString$2(arg1)) {
          modifier = arg1 || modifier;
        }
        if (isString$2(arg2)) {
          type2 = arg2 || type2;
        }
      }
      const ret = message(key)(ctx);
      const msg = type2 === "vnode" && isArray$1(ret) && modifier ? ret[0] : ret;
      return modifier ? _modifier(modifier)(msg, type2) : msg;
    };
    const ctx = {
      ["list"]: list,
      ["named"]: named,
      ["plural"]: plural,
      ["linked"]: linked,
      ["message"]: message,
      ["type"]: type,
      ["interpolate"]: interpolate,
      ["normalize"]: normalize,
      ["values"]: assign$3({}, _list, _named)
    };
    return ctx;
  }
  let devtools = null;
  function setDevToolsHook(hook) {
    devtools = hook;
  }
  function initI18nDevTools(i18n2, version2, meta) {
    devtools && devtools.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: i18n2,
      version: version2,
      meta
    });
  }
  const translateDevTools = /* @__PURE__ */ createDevToolsHook("function:translate");
  function createDevToolsHook(hook) {
    return (payloads) => devtools && devtools.emit(hook, payloads);
  }
  const CoreWarnCodes = {
    NOT_FOUND_KEY: 1,
    FALLBACK_TO_TRANSLATE: 2,
    CANNOT_FORMAT_NUMBER: 3,
    FALLBACK_TO_NUMBER_FORMAT: 4,
    CANNOT_FORMAT_DATE: 5,
    FALLBACK_TO_DATE_FORMAT: 6,
    EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7,
    __EXTEND_POINT__: 8
  };
  const code$2 = CompileErrorCodes.__EXTEND_POINT__;
  const inc$2 = incrementer(code$2);
  const CoreErrorCodes = {
    INVALID_ARGUMENT: code$2,
    INVALID_DATE_ARGUMENT: inc$2(),
    INVALID_ISO_DATE_ARGUMENT: inc$2(),
    NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
    NOT_SUPPORT_LOCALE_TYPE: inc$2(),
    __EXTEND_POINT__: inc$2()
  };
  function createCoreError(code2) {
    return createCompileError(code2, null, void 0);
  }
  function getLocale$1(context, options) {
    return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
  }
  let _resolveLocale;
  function resolveLocale(locale) {
    if (isString$2(locale)) {
      return locale;
    } else {
      if (isFunction$1(locale)) {
        if (locale.resolvedOnce && _resolveLocale != null) {
          return _resolveLocale;
        } else if (locale.constructor.name === "Function") {
          const resolve2 = locale();
          if (isPromise(resolve2)) {
            throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
          }
          return _resolveLocale = resolve2;
        } else {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
        }
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
      }
    }
  }
  function fallbackWithSimple(ctx, fallback, start) {
    return [.../* @__PURE__ */ new Set([
      start,
      ...isArray$1(fallback) ? fallback : isObject$3(fallback) ? Object.keys(fallback) : isString$2(fallback) ? [fallback] : [start]
    ])];
  }
  function fallbackWithLocaleChain(ctx, fallback, start) {
    const startLocale = isString$2(start) ? start : DEFAULT_LOCALE;
    const context = ctx;
    if (!context.__localeChainCache) {
      context.__localeChainCache = /* @__PURE__ */ new Map();
    }
    let chain = context.__localeChainCache.get(startLocale);
    if (!chain) {
      chain = [];
      let block = [start];
      while (isArray$1(block)) {
        block = appendBlockToChain(chain, block, fallback);
      }
      const defaults2 = isArray$1(fallback) || !isPlainObject$2(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
      block = isString$2(defaults2) ? [defaults2] : defaults2;
      if (isArray$1(block)) {
        appendBlockToChain(chain, block, false);
      }
      context.__localeChainCache.set(startLocale, chain);
    }
    return chain;
  }
  function appendBlockToChain(chain, block, blocks) {
    let follow = true;
    for (let i = 0; i < block.length && isBoolean(follow); i++) {
      const locale = block[i];
      if (isString$2(locale)) {
        follow = appendLocaleToChain(chain, block[i], blocks);
      }
    }
    return follow;
  }
  function appendLocaleToChain(chain, locale, blocks) {
    let follow;
    const tokens = locale.split("-");
    do {
      const target = tokens.join("-");
      follow = appendItemToChain(chain, target, blocks);
      tokens.splice(-1, 1);
    } while (tokens.length && follow === true);
    return follow;
  }
  function appendItemToChain(chain, target, blocks) {
    let follow = false;
    if (!chain.includes(target)) {
      follow = true;
      if (target) {
        follow = target[target.length - 1] !== "!";
        const locale = target.replace(/!/g, "");
        chain.push(locale);
        if ((isArray$1(blocks) || isPlainObject$2(blocks)) && blocks[locale]) {
          follow = blocks[locale];
        }
      }
    }
    return follow;
  }
  const VERSION$2 = "9.9.0";
  const NOT_REOSLVED = -1;
  const DEFAULT_LOCALE = "en-US";
  const MISSING_RESOLVE_VALUE = "";
  const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
  function getDefaultLinkedModifiers() {
    return {
      upper: (val, type) => {
        return type === "text" && isString$2(val) ? val.toUpperCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
      },
      lower: (val, type) => {
        return type === "text" && isString$2(val) ? val.toLowerCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
      },
      capitalize: (val, type) => {
        return type === "text" && isString$2(val) ? capitalize(val) : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
      }
    };
  }
  let _compiler;
  function registerMessageCompiler(compiler) {
    _compiler = compiler;
  }
  let _resolver;
  function registerMessageResolver(resolver) {
    _resolver = resolver;
  }
  let _fallbacker;
  function registerLocaleFallbacker(fallbacker) {
    _fallbacker = fallbacker;
  }
  let _additionalMeta = null;
  const setAdditionalMeta = (meta) => {
    _additionalMeta = meta;
  };
  const getAdditionalMeta = () => _additionalMeta;
  let _fallbackContext = null;
  const setFallbackContext = (context) => {
    _fallbackContext = context;
  };
  const getFallbackContext = () => _fallbackContext;
  let _cid = 0;
  function createCoreContext(options = {}) {
    const onWarn = isFunction$1(options.onWarn) ? options.onWarn : warn;
    const version2 = isString$2(options.version) ? options.version : VERSION$2;
    const locale = isString$2(options.locale) || isFunction$1(options.locale) ? options.locale : DEFAULT_LOCALE;
    const _locale = isFunction$1(locale) ? DEFAULT_LOCALE : locale;
    const fallbackLocale = isArray$1(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || isString$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
    const messages2 = isPlainObject$2(options.messages) ? options.messages : { [_locale]: {} };
    const datetimeFormats = isPlainObject$2(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
    const numberFormats = isPlainObject$2(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
    const modifiers = assign$3({}, options.modifiers || {}, getDefaultLinkedModifiers());
    const pluralRules = options.pluralRules || {};
    const missing = isFunction$1(options.missing) ? options.missing : null;
    const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    const fallbackFormat = !!options.fallbackFormat;
    const unresolving = !!options.unresolving;
    const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    const processor = isPlainObject$2(options.processor) ? options.processor : null;
    const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const escapeParameter = !!options.escapeParameter;
    const messageCompiler = isFunction$1(options.messageCompiler) ? options.messageCompiler : _compiler;
    const messageResolver = isFunction$1(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
    const localeFallbacker = isFunction$1(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
    const fallbackContext = isObject$3(options.fallbackContext) ? options.fallbackContext : void 0;
    const internalOptions = options;
    const __datetimeFormatters = isObject$3(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
    const __numberFormatters = isObject$3(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
    const __meta = isObject$3(internalOptions.__meta) ? internalOptions.__meta : {};
    _cid++;
    const context = {
      version: version2,
      cid: _cid,
      locale,
      fallbackLocale,
      messages: messages2,
      modifiers,
      pluralRules,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackFormat,
      unresolving,
      postTranslation,
      processor,
      warnHtmlMessage,
      escapeParameter,
      messageCompiler,
      messageResolver,
      localeFallbacker,
      fallbackContext,
      onWarn,
      __meta
    };
    {
      context.datetimeFormats = datetimeFormats;
      context.numberFormats = numberFormats;
      context.__datetimeFormatters = __datetimeFormatters;
      context.__numberFormatters = __numberFormatters;
    }
    if (__INTLIFY_PROD_DEVTOOLS__) {
      initI18nDevTools(context, version2, __meta);
    }
    return context;
  }
  function handleMissing(context, key, locale, missingWarn, type) {
    const { missing, onWarn } = context;
    if (missing !== null) {
      const ret = missing(context, locale, key, type);
      return isString$2(ret) ? ret : key;
    } else {
      return key;
    }
  }
  function updateFallbackLocale(ctx, locale, fallback) {
    const context = ctx;
    context.__localeChainCache = /* @__PURE__ */ new Map();
    ctx.localeFallbacker(ctx, fallback, locale);
  }
  function format(ast) {
    const msg = (ctx) => formatParts(ctx, ast);
    return msg;
  }
  function formatParts(ctx, ast) {
    const body = ast.b || ast.body;
    if ((body.t || body.type) === 1) {
      const plural = body;
      const cases = plural.c || plural.cases;
      return ctx.plural(cases.reduce((messages2, c) => [
        ...messages2,
        formatMessageParts(ctx, c)
      ], []));
    } else {
      return formatMessageParts(ctx, body);
    }
  }
  function formatMessageParts(ctx, node) {
    const _static = node.s || node.static;
    if (_static) {
      return ctx.type === "text" ? _static : ctx.normalize([_static]);
    } else {
      const messages2 = (node.i || node.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
      return ctx.normalize(messages2);
    }
  }
  function formatMessagePart(ctx, node) {
    const type = node.t || node.type;
    switch (type) {
      case 3:
        const text2 = node;
        return text2.v || text2.value;
      case 9:
        const literal = node;
        return literal.v || literal.value;
      case 4:
        const named = node;
        return ctx.interpolate(ctx.named(named.k || named.key));
      case 5:
        const list = node;
        return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
      case 6:
        const linked = node;
        const modifier = linked.m || linked.modifier;
        return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
      case 7:
        const linkedKey = node;
        return linkedKey.v || linkedKey.value;
      case 8:
        const linkedModifier = node;
        return linkedModifier.v || linkedModifier.value;
      default:
        throw new Error(`unhandled node type on format message part: ${type}`);
    }
  }
  const defaultOnCacheKey = (message) => message;
  let compileCache = /* @__PURE__ */ Object.create(null);
  const isMessageAST = (val) => isObject$3(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
  function baseCompile(message, options = {}) {
    let detectError = false;
    const onError = options.onError || defaultOnError;
    options.onError = (err) => {
      detectError = true;
      onError(err);
    };
    return { ...baseCompile$1(message, options), detectError };
  }
  function compile(message, context) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$2(message)) {
      isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
      const onCacheKey = context.onCacheKey || defaultOnCacheKey;
      const cacheKey = onCacheKey(message);
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      const { ast, detectError } = baseCompile(message, {
        ...context,
        location: false,
        jit: true
      });
      const msg = format(ast);
      return !detectError ? compileCache[cacheKey] = msg : msg;
    } else {
      const cacheKey = message.cacheKey;
      if (cacheKey) {
        const cached = compileCache[cacheKey];
        if (cached) {
          return cached;
        }
        return compileCache[cacheKey] = format(message);
      } else {
        return format(message);
      }
    }
  }
  const NOOP_MESSAGE_FUNCTION = () => "";
  const isMessageFunction = (val) => isFunction$1(val);
  function translate(context, ...args) {
    const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
    const [key, options] = parseTranslateArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
    const resolvedMessage = !!options.resolvedMessage;
    const defaultMsgOrKey = isString$2(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
    const locale = getLocale$1(context, options);
    escapeParameter && escapeParams(options);
    let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
      key,
      locale,
      messages2[locale] || {}
    ];
    let format2 = formatScope;
    let cacheBaseKey = key;
    if (!resolvedMessage && !(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
      if (enableDefaultMsg) {
        format2 = defaultMsgOrKey;
        cacheBaseKey = format2;
      }
    }
    if (!resolvedMessage && (!(isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$2(targetLocale))) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let occurred = false;
    const onError = () => {
      occurred = true;
    };
    const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
    if (occurred) {
      return format2;
    }
    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
    const msgContext = createMessageContext(ctxOptions);
    const messaged = evaluateMessage(context, msg, msgContext);
    const ret = postTranslation ? postTranslation(messaged, key) : messaged;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const payloads = {
        timestamp: Date.now(),
        key: isString$2(key) ? key : isMessageFunction(format2) ? format2.key : "",
        locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
        format: isString$2(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
        message: ret
      };
      payloads.meta = assign$3({}, context.__meta, getAdditionalMeta() || {});
      translateDevTools(payloads);
    }
    return ret;
  }
  function escapeParams(options) {
    if (isArray$1(options.list)) {
      options.list = options.list.map((item) => isString$2(item) ? escapeHtml(item) : item);
    } else if (isObject$3(options.named)) {
      Object.keys(options.named).forEach((key) => {
        if (isString$2(options.named[key])) {
          options.named[key] = escapeHtml(options.named[key]);
        }
      });
    }
  }
  function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
    const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
    const locales = localeFallbacker(context, fallbackLocale, locale);
    let message = {};
    let targetLocale;
    let format2 = null;
    const type = "translate";
    for (let i = 0; i < locales.length; i++) {
      targetLocale = locales[i];
      message = messages2[targetLocale] || {};
      if ((format2 = resolveValue2(message, key)) === null) {
        format2 = message[key];
      }
      if (isString$2(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
        break;
      }
      const missingRet = handleMissing(context, key, targetLocale, missingWarn, type);
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
    return [format2, targetLocale, message];
  }
  function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
    const { messageCompiler, warnHtmlMessage } = context;
    if (isMessageFunction(format2)) {
      const msg2 = format2;
      msg2.locale = msg2.locale || targetLocale;
      msg2.key = msg2.key || key;
      return msg2;
    }
    if (messageCompiler == null) {
      const msg2 = () => format2;
      msg2.locale = targetLocale;
      msg2.key = key;
      return msg2;
    }
    const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
    msg.locale = targetLocale;
    msg.key = key;
    msg.source = format2;
    return msg;
  }
  function evaluateMessage(context, msg, msgCtx) {
    const messaged = msg(msgCtx);
    return messaged;
  }
  function parseTranslateArgs(...args) {
    const [arg1, arg2, arg3] = args;
    const options = {};
    if (!isString$2(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
    if (isNumber$1(arg2)) {
      options.plural = arg2;
    } else if (isString$2(arg2)) {
      options.default = arg2;
    } else if (isPlainObject$2(arg2) && !isEmptyObject(arg2)) {
      options.named = arg2;
    } else if (isArray$1(arg2)) {
      options.list = arg2;
    }
    if (isNumber$1(arg3)) {
      options.plural = arg3;
    } else if (isString$2(arg3)) {
      options.default = arg3;
    } else if (isPlainObject$2(arg3)) {
      assign$3(options, arg3);
    }
    return [key, options];
  }
  function getCompileContext(context, locale, key, source2, warnHtmlMessage, onError) {
    return {
      locale,
      key,
      warnHtmlMessage,
      onError: (err) => {
        onError && onError(err);
        {
          throw err;
        }
      },
      onCacheKey: (source3) => generateFormatCacheKey(locale, key, source3)
    };
  }
  function getMessageContextOptions(context, locale, message, options) {
    const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
    const resolveMessage = (key) => {
      let val = resolveValue2(message, key);
      if (val == null && fallbackContext) {
        const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
        val = resolveValue2(message2, key);
      }
      if (isString$2(val) || isMessageAST(val)) {
        let occurred = false;
        const onError = () => {
          occurred = true;
        };
        const msg = compileMessageFormat(context, key, locale, val, key, onError);
        return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
      } else if (isMessageFunction(val)) {
        return val;
      } else {
        return NOOP_MESSAGE_FUNCTION;
      }
    };
    const ctxOptions = {
      locale,
      modifiers,
      pluralRules,
      messages: resolveMessage
    };
    if (context.processor) {
      ctxOptions.processor = context.processor;
    }
    if (options.list) {
      ctxOptions.list = options.list;
    }
    if (options.named) {
      ctxOptions.named = options.named;
    }
    if (isNumber$1(options.plural)) {
      ctxOptions.pluralIndex = options.plural;
    }
    return ctxOptions;
  }
  function datetime(context, ...args) {
    const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __datetimeFormatters } = context;
    const [key, value, options, overrides] = parseDateTimeArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale = getLocale$1(context, options);
    const locales = localeFallbacker(context, fallbackLocale, locale);
    if (!isString$2(key) || key === "") {
      return new Intl.DateTimeFormat(locale, overrides).format(value);
    }
    let datetimeFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "datetime format";
    for (let i = 0; i < locales.length; i++) {
      targetLocale = locales[i];
      datetimeFormat = datetimeFormats[targetLocale] || {};
      format2 = datetimeFormat[key];
      if (isPlainObject$2(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
    }
    if (!isPlainObject$2(format2) || !isString$2(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __datetimeFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.DateTimeFormat(targetLocale, assign$3({}, format2, overrides));
      __datetimeFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  const DATETIME_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function parseDateTimeArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    let value;
    if (isString$2(arg1)) {
      const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!matches) {
        throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
      }
      const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
      value = new Date(dateTime);
      try {
        value.toISOString();
      } catch (e) {
        throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (isDate$1(arg1)) {
      if (isNaN(arg1.getTime())) {
        throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
      }
      value = arg1;
    } else if (isNumber$1(arg1)) {
      value = arg1;
    } else {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    if (isString$2(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$2(arg2)) {
      Object.keys(arg2).forEach((key) => {
        if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
          overrides[key] = arg2[key];
        } else {
          options[key] = arg2[key];
        }
      });
    }
    if (isString$2(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$2(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$2(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearDateTimeFormat(ctx, locale, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale}__${key}`;
      if (!context.__datetimeFormatters.has(id)) {
        continue;
      }
      context.__datetimeFormatters.delete(id);
    }
  }
  function number(context, ...args) {
    const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __numberFormatters } = context;
    const [key, value, options, overrides] = parseNumberArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale = getLocale$1(context, options);
    const locales = localeFallbacker(context, fallbackLocale, locale);
    if (!isString$2(key) || key === "") {
      return new Intl.NumberFormat(locale, overrides).format(value);
    }
    let numberFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "number format";
    for (let i = 0; i < locales.length; i++) {
      targetLocale = locales[i];
      numberFormat = numberFormats[targetLocale] || {};
      format2 = numberFormat[key];
      if (isPlainObject$2(format2))
        break;
      handleMissing(context, key, targetLocale, missingWarn, type);
    }
    if (!isPlainObject$2(format2) || !isString$2(targetLocale)) {
      return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
      id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __numberFormatters.get(id);
    if (!formatter) {
      formatter = new Intl.NumberFormat(targetLocale, assign$3({}, format2, overrides));
      __numberFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
  }
  const NUMBER_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function parseNumberArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    if (!isNumber$1(arg1)) {
      throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const value = arg1;
    if (isString$2(arg2)) {
      options.key = arg2;
    } else if (isPlainObject$2(arg2)) {
      Object.keys(arg2).forEach((key) => {
        if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
          overrides[key] = arg2[key];
        } else {
          options[key] = arg2[key];
        }
      });
    }
    if (isString$2(arg3)) {
      options.locale = arg3;
    } else if (isPlainObject$2(arg3)) {
      overrides = arg3;
    }
    if (isPlainObject$2(arg4)) {
      overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
  }
  function clearNumberFormat(ctx, locale, format2) {
    const context = ctx;
    for (const key in format2) {
      const id = `${locale}__${key}`;
      if (!context.__numberFormatters.has(id)) {
        continue;
      }
      context.__numberFormatters.delete(id);
    }
  }
  {
    initFeatureFlags$1();
  }
  /*!
    * vue-i18n v9.9.0
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    */
  const VERSION$1 = "9.9.0";
  function initFeatureFlags() {
    if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
      getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
    }
    if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
      getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
      getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
      getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
  }
  const code$1 = CoreWarnCodes.__EXTEND_POINT__;
  const inc$1 = incrementer(code$1);
  ({
    FALLBACK_TO_ROOT: code$1,
    NOT_SUPPORTED_PRESERVE: inc$1(),
    NOT_SUPPORTED_FORMATTER: inc$1(),
    NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
    NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
    COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
    NOT_FOUND_PARENT_SCOPE: inc$1(),
    IGNORE_OBJ_FLATTEN: inc$1(),
    NOTICE_DROP_ALLOW_COMPOSITION: inc$1()
  });
  const code = CoreErrorCodes.__EXTEND_POINT__;
  const inc = incrementer(code);
  const I18nErrorCodes = {
    UNEXPECTED_RETURN_TYPE: code,
    INVALID_ARGUMENT: inc(),
    MUST_BE_CALL_SETUP_TOP: inc(),
    NOT_INSTALLED: inc(),
    NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
    REQUIRED_VALUE: inc(),
    INVALID_VALUE: inc(),
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
    NOT_INSTALLED_WITH_PROVIDE: inc(),
    UNEXPECTED_ERROR: inc(),
    NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
    BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
    __EXTEND_POINT__: inc()
  };
  function createI18nError(code2, ...args) {
    return createCompileError(code2, null, void 0);
  }
  const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
  const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
  const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
  const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
  makeSymbol("__intlifyMeta");
  const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
  const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
  function handleFlatJson(obj) {
    if (!isObject$3(obj)) {
      return obj;
    }
    for (const key in obj) {
      if (!hasOwn(obj, key)) {
        continue;
      }
      if (!key.includes(".")) {
        if (isObject$3(obj[key])) {
          handleFlatJson(obj[key]);
        }
      } else {
        const subKeys = key.split(".");
        const lastIndex = subKeys.length - 1;
        let currentObj = obj;
        let hasStringValue = false;
        for (let i = 0; i < lastIndex; i++) {
          if (!(subKeys[i] in currentObj)) {
            currentObj[subKeys[i]] = {};
          }
          if (!isObject$3(currentObj[subKeys[i]])) {
            hasStringValue = true;
            break;
          }
          currentObj = currentObj[subKeys[i]];
        }
        if (!hasStringValue) {
          currentObj[subKeys[lastIndex]] = obj[key];
          delete obj[key];
        }
        if (isObject$3(currentObj[subKeys[lastIndex]])) {
          handleFlatJson(currentObj[subKeys[lastIndex]]);
        }
      }
    }
    return obj;
  }
  function getLocaleMessages(locale, options) {
    const { messages: messages2, __i18n, messageResolver, flatJson } = options;
    const ret = isPlainObject$2(messages2) ? messages2 : isArray$1(__i18n) ? {} : { [locale]: {} };
    if (isArray$1(__i18n)) {
      __i18n.forEach((custom) => {
        if ("locale" in custom && "resource" in custom) {
          const { locale: locale2, resource } = custom;
          if (locale2) {
            ret[locale2] = ret[locale2] || {};
            deepCopy(resource, ret[locale2]);
          } else {
            deepCopy(resource, ret);
          }
        } else {
          isString$2(custom) && deepCopy(JSON.parse(custom), ret);
        }
      });
    }
    if (messageResolver == null && flatJson) {
      for (const key in ret) {
        if (hasOwn(ret, key)) {
          handleFlatJson(ret[key]);
        }
      }
    }
    return ret;
  }
  function getComponentOptions(instance) {
    return instance.type;
  }
  function adjustI18nResources(gl, options, componentOptions) {
    let messages2 = isObject$3(options.messages) ? options.messages : {};
    if ("__i18nGlobal" in componentOptions) {
      messages2 = getLocaleMessages(gl.locale.value, {
        messages: messages2,
        __i18n: componentOptions.__i18nGlobal
      });
    }
    const locales = Object.keys(messages2);
    if (locales.length) {
      locales.forEach((locale) => {
        gl.mergeLocaleMessage(locale, messages2[locale]);
      });
    }
    {
      if (isObject$3(options.datetimeFormats)) {
        const locales2 = Object.keys(options.datetimeFormats);
        if (locales2.length) {
          locales2.forEach((locale) => {
            gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
          });
        }
      }
      if (isObject$3(options.numberFormats)) {
        const locales2 = Object.keys(options.numberFormats);
        if (locales2.length) {
          locales2.forEach((locale) => {
            gl.mergeNumberFormat(locale, options.numberFormats[locale]);
          });
        }
      }
    }
  }
  function createTextNode(key) {
    return createVNode(Text, null, key, 0);
  }
  const DEVTOOLS_META = "__INTLIFY_META__";
  const NOOP_RETURN_ARRAY = () => [];
  const NOOP_RETURN_FALSE = () => false;
  let composerID = 0;
  function defineCoreMissingHandler(missing) {
    return (ctx, locale, key, type) => {
      return missing(locale, key, getCurrentInstance() || void 0, type);
    };
  }
  const getMetaInfo = () => {
    const instance = getCurrentInstance();
    let meta = null;
    return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
  };
  function createComposer(options = {}, VueI18nLegacy) {
    const { __root, __injectWithOption } = options;
    const _isGlobal = __root === void 0;
    const flatJson = options.flatJson;
    const _ref = inBrowser ? ref : shallowRef;
    let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
    const _locale = _ref(__root && _inheritLocale ? __root.locale.value : isString$2(options.locale) ? options.locale : DEFAULT_LOCALE);
    const _fallbackLocale = _ref(__root && _inheritLocale ? __root.fallbackLocale.value : isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);
    const _messages = _ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = _ref(isPlainObject$2(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = _ref(isPlainObject$2(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    let _fallbackFormat = !!options.fallbackFormat;
    let _missing = isFunction$1(options.missing) ? options.missing : null;
    let _runtimeMissing = isFunction$1(options.missing) ? defineCoreMissingHandler(options.missing) : null;
    let _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    let _escapeParameter = !!options.escapeParameter;
    const _modifiers = __root ? __root.modifiers : isPlainObject$2(options.modifiers) ? options.modifiers : {};
    let _pluralRules = options.pluralRules || __root && __root.pluralRules;
    let _context;
    const getCoreContext = () => {
      _isGlobal && setFallbackContext(null);
      const ctxOptions = {
        version: VERSION$1,
        locale: _locale.value,
        fallbackLocale: _fallbackLocale.value,
        messages: _messages.value,
        modifiers: _modifiers,
        pluralRules: _pluralRules,
        missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
        missingWarn: _missingWarn,
        fallbackWarn: _fallbackWarn,
        fallbackFormat: _fallbackFormat,
        unresolving: true,
        postTranslation: _postTranslation === null ? void 0 : _postTranslation,
        warnHtmlMessage: _warnHtmlMessage,
        escapeParameter: _escapeParameter,
        messageResolver: options.messageResolver,
        messageCompiler: options.messageCompiler,
        __meta: { framework: "vue" }
      };
      {
        ctxOptions.datetimeFormats = _datetimeFormats.value;
        ctxOptions.numberFormats = _numberFormats.value;
        ctxOptions.__datetimeFormatters = isPlainObject$2(_context) ? _context.__datetimeFormatters : void 0;
        ctxOptions.__numberFormatters = isPlainObject$2(_context) ? _context.__numberFormatters : void 0;
      }
      const ctx = createCoreContext(ctxOptions);
      _isGlobal && setFallbackContext(ctx);
      return ctx;
    };
    _context = getCoreContext();
    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale = computed({
      get: () => _locale.value,
      set: (val) => {
        _locale.value = val;
        _context.locale = _locale.value;
      }
    });
    const fallbackLocale = computed({
      get: () => _fallbackLocale.value,
      set: (val) => {
        _fallbackLocale.value = val;
        _context.fallbackLocale = _fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, val);
      }
    });
    const messages2 = computed(() => _messages.value);
    const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
    const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return isFunction$1(_postTranslation) ? _postTranslation : null;
    }
    function setPostTranslationHandler(handler) {
      _postTranslation = handler;
      _context.postTranslation = handler;
    }
    function getMissingHandler() {
      return _missing;
    }
    function setMissingHandler(handler) {
      if (handler !== null) {
        _runtimeMissing = defineCoreMissingHandler(handler);
      }
      _missing = handler;
      _context.missing = _runtimeMissing;
    }
    const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
      trackReactivityValues();
      let ret;
      try {
        if (__INTLIFY_PROD_DEVTOOLS__) {
          setAdditionalMeta(getMetaInfo());
        }
        if (!_isGlobal) {
          _context.fallbackContext = __root ? getFallbackContext() : void 0;
        }
        ret = fn(_context);
      } finally {
        if (__INTLIFY_PROD_DEVTOOLS__) {
          setAdditionalMeta(null);
        }
        if (!_isGlobal) {
          _context.fallbackContext = void 0;
        }
      }
      if (warnType !== "translate exists" && isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
        const [key, arg2] = argumentParser();
        return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
      } else if (successCondition(ret)) {
        return ret;
      } else {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
      }
    };
    function t(...args) {
      return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key) => key, (val) => isString$2(val));
    }
    function rt(...args) {
      const [arg1, arg2, arg3] = args;
      if (arg3 && !isObject$3(arg3)) {
        throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
      }
      return t(...[arg1, arg2, assign$3({ resolvedMessage: true }, arg3 || {})]);
    }
    function d(...args) {
      return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
    }
    function n(...args) {
      return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$2(val));
    }
    function normalize(values) {
      return values.map((val) => isString$2(val) || isNumber$1(val) || isBoolean(val) ? createTextNode(String(val)) : val);
    }
    const interpolate = (val) => val;
    const processor = {
      normalize,
      interpolate,
      type: "vnode"
    };
    function translateVNode(...args) {
      return wrapWithDeps((context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      }, () => parseTranslateArgs(...args), "translate", (root2) => root2[TranslateVNodeSymbol](...args), (key) => [createTextNode(key)], (val) => isArray$1(val));
    }
    function numberParts(...args) {
      return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => root2[NumberPartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString$2(val) || isArray$1(val));
    }
    function datetimeParts(...args) {
      return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => root2[DatetimePartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString$2(val) || isArray$1(val));
    }
    function setPluralRules(rules) {
      _pluralRules = rules;
      _context.pluralRules = _pluralRules;
    }
    function te(key, locale2) {
      return wrapWithDeps(() => {
        if (!key) {
          return false;
        }
        const targetLocale = isString$2(locale2) ? locale2 : _locale.value;
        const message = getLocaleMessage(targetLocale);
        const resolved = _context.messageResolver(message, key);
        return isMessageAST(resolved) || isMessageFunction(resolved) || isString$2(resolved);
      }, () => [key], "translate exists", (root2) => {
        return Reflect.apply(root2.te, root2, [key, locale2]);
      }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
    }
    function resolveMessages(key) {
      let messages3 = null;
      const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
      for (let i = 0; i < locales.length; i++) {
        const targetLocaleMessages = _messages.value[locales[i]] || {};
        const messageValue = _context.messageResolver(targetLocaleMessages, key);
        if (messageValue != null) {
          messages3 = messageValue;
          break;
        }
      }
      return messages3;
    }
    function tm(key) {
      const messages3 = resolveMessages(key);
      return messages3 != null ? messages3 : __root ? __root.tm(key) || {} : {};
    }
    function getLocaleMessage(locale2) {
      return _messages.value[locale2] || {};
    }
    function setLocaleMessage(locale2, message) {
      if (flatJson) {
        const _message = { [locale2]: message };
        for (const key in _message) {
          if (hasOwn(_message, key)) {
            handleFlatJson(_message[key]);
          }
        }
        message = _message[locale2];
      }
      _messages.value[locale2] = message;
      _context.messages = _messages.value;
    }
    function mergeLocaleMessage(locale2, message) {
      _messages.value[locale2] = _messages.value[locale2] || {};
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
      deepCopy(message, _messages.value[locale2]);
      _context.messages = _messages.value;
    }
    function getDateTimeFormat(locale2) {
      return _datetimeFormats.value[locale2] || {};
    }
    function setDateTimeFormat(locale2, format2) {
      _datetimeFormats.value[locale2] = format2;
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale2, format2);
    }
    function mergeDateTimeFormat(locale2, format2) {
      _datetimeFormats.value[locale2] = assign$3(_datetimeFormats.value[locale2] || {}, format2);
      _context.datetimeFormats = _datetimeFormats.value;
      clearDateTimeFormat(_context, locale2, format2);
    }
    function getNumberFormat(locale2) {
      return _numberFormats.value[locale2] || {};
    }
    function setNumberFormat(locale2, format2) {
      _numberFormats.value[locale2] = format2;
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale2, format2);
    }
    function mergeNumberFormat(locale2, format2) {
      _numberFormats.value[locale2] = assign$3(_numberFormats.value[locale2] || {}, format2);
      _context.numberFormats = _numberFormats.value;
      clearNumberFormat(_context, locale2, format2);
    }
    composerID++;
    if (__root && inBrowser) {
      watch(__root.locale, (val) => {
        if (_inheritLocale) {
          _locale.value = val;
          _context.locale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
      watch(__root.fallbackLocale, (val) => {
        if (_inheritLocale) {
          _fallbackLocale.value = val;
          _context.fallbackLocale = val;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      });
    }
    const composer = {
      id: composerID,
      locale,
      fallbackLocale,
      get inheritLocale() {
        return _inheritLocale;
      },
      set inheritLocale(val) {
        _inheritLocale = val;
        if (val && __root) {
          _locale.value = __root.locale.value;
          _fallbackLocale.value = __root.fallbackLocale.value;
          updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        }
      },
      get availableLocales() {
        return Object.keys(_messages.value).sort();
      },
      messages: messages2,
      get modifiers() {
        return _modifiers;
      },
      get pluralRules() {
        return _pluralRules || {};
      },
      get isGlobal() {
        return _isGlobal;
      },
      get missingWarn() {
        return _missingWarn;
      },
      set missingWarn(val) {
        _missingWarn = val;
        _context.missingWarn = _missingWarn;
      },
      get fallbackWarn() {
        return _fallbackWarn;
      },
      set fallbackWarn(val) {
        _fallbackWarn = val;
        _context.fallbackWarn = _fallbackWarn;
      },
      get fallbackRoot() {
        return _fallbackRoot;
      },
      set fallbackRoot(val) {
        _fallbackRoot = val;
      },
      get fallbackFormat() {
        return _fallbackFormat;
      },
      set fallbackFormat(val) {
        _fallbackFormat = val;
        _context.fallbackFormat = _fallbackFormat;
      },
      get warnHtmlMessage() {
        return _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        _warnHtmlMessage = val;
        _context.warnHtmlMessage = val;
      },
      get escapeParameter() {
        return _escapeParameter;
      },
      set escapeParameter(val) {
        _escapeParameter = val;
        _context.escapeParameter = val;
      },
      t,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      [SetPluralRulesSymbol]: setPluralRules
    };
    {
      composer.datetimeFormats = datetimeFormats;
      composer.numberFormats = numberFormats;
      composer.rt = rt;
      composer.te = te;
      composer.tm = tm;
      composer.d = d;
      composer.n = n;
      composer.getDateTimeFormat = getDateTimeFormat;
      composer.setDateTimeFormat = setDateTimeFormat;
      composer.mergeDateTimeFormat = mergeDateTimeFormat;
      composer.getNumberFormat = getNumberFormat;
      composer.setNumberFormat = setNumberFormat;
      composer.mergeNumberFormat = mergeNumberFormat;
      composer[InejctWithOptionSymbol] = __injectWithOption;
      composer[TranslateVNodeSymbol] = translateVNode;
      composer[DatetimePartsSymbol] = datetimeParts;
      composer[NumberPartsSymbol] = numberParts;
    }
    return composer;
  }
  function convertComposerOptions(options) {
    const locale = isString$2(options.locale) ? options.locale : DEFAULT_LOCALE;
    const fallbackLocale = isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
    const missing = isFunction$1(options.missing) ? options.missing : void 0;
    const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
    const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
    const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    const fallbackFormat = !!options.formatFallbackMessages;
    const modifiers = isPlainObject$2(options.modifiers) ? options.modifiers : {};
    const pluralizationRules = options.pluralizationRules;
    const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : void 0;
    const warnHtmlMessage = isString$2(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
    const escapeParameter = !!options.escapeParameterHtml;
    const inheritLocale = isBoolean(options.sync) ? options.sync : true;
    let messages2 = options.messages;
    if (isPlainObject$2(options.sharedMessages)) {
      const sharedMessages = options.sharedMessages;
      const locales = Object.keys(sharedMessages);
      messages2 = locales.reduce((messages3, locale2) => {
        const message = messages3[locale2] || (messages3[locale2] = {});
        assign$3(message, sharedMessages[locale2]);
        return messages3;
      }, messages2 || {});
    }
    const { __i18n, __root, __injectWithOption } = options;
    const datetimeFormats = options.datetimeFormats;
    const numberFormats = options.numberFormats;
    const flatJson = options.flatJson;
    return {
      locale,
      fallbackLocale,
      messages: messages2,
      flatJson,
      datetimeFormats,
      numberFormats,
      missing,
      missingWarn,
      fallbackWarn,
      fallbackRoot,
      fallbackFormat,
      modifiers,
      pluralRules: pluralizationRules,
      postTranslation,
      warnHtmlMessage,
      escapeParameter,
      messageResolver: options.messageResolver,
      inheritLocale,
      __i18n,
      __root,
      __injectWithOption
    };
  }
  function createVueI18n(options = {}, VueI18nLegacy) {
    {
      const composer = createComposer(convertComposerOptions(options));
      const { __extender } = options;
      const vueI18n = {
        id: composer.id,
        get locale() {
          return composer.locale.value;
        },
        set locale(val) {
          composer.locale.value = val;
        },
        get fallbackLocale() {
          return composer.fallbackLocale.value;
        },
        set fallbackLocale(val) {
          composer.fallbackLocale.value = val;
        },
        get messages() {
          return composer.messages.value;
        },
        get datetimeFormats() {
          return composer.datetimeFormats.value;
        },
        get numberFormats() {
          return composer.numberFormats.value;
        },
        get availableLocales() {
          return composer.availableLocales;
        },
        get formatter() {
          return {
            interpolate() {
              return [];
            }
          };
        },
        set formatter(val) {
        },
        get missing() {
          return composer.getMissingHandler();
        },
        set missing(handler) {
          composer.setMissingHandler(handler);
        },
        get silentTranslationWarn() {
          return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
        },
        set silentTranslationWarn(val) {
          composer.missingWarn = isBoolean(val) ? !val : val;
        },
        get silentFallbackWarn() {
          return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
        },
        set silentFallbackWarn(val) {
          composer.fallbackWarn = isBoolean(val) ? !val : val;
        },
        get modifiers() {
          return composer.modifiers;
        },
        get formatFallbackMessages() {
          return composer.fallbackFormat;
        },
        set formatFallbackMessages(val) {
          composer.fallbackFormat = val;
        },
        get postTranslation() {
          return composer.getPostTranslationHandler();
        },
        set postTranslation(handler) {
          composer.setPostTranslationHandler(handler);
        },
        get sync() {
          return composer.inheritLocale;
        },
        set sync(val) {
          composer.inheritLocale = val;
        },
        get warnHtmlInMessage() {
          return composer.warnHtmlMessage ? "warn" : "off";
        },
        set warnHtmlInMessage(val) {
          composer.warnHtmlMessage = val !== "off";
        },
        get escapeParameterHtml() {
          return composer.escapeParameter;
        },
        set escapeParameterHtml(val) {
          composer.escapeParameter = val;
        },
        get preserveDirectiveContent() {
          return true;
        },
        set preserveDirectiveContent(val) {
        },
        get pluralizationRules() {
          return composer.pluralRules || {};
        },
        __composer: composer,
        t(...args) {
          const [arg1, arg2, arg3] = args;
          const options2 = {};
          let list = null;
          let named = null;
          if (!isString$2(arg1)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
          }
          const key = arg1;
          if (isString$2(arg2)) {
            options2.locale = arg2;
          } else if (isArray$1(arg2)) {
            list = arg2;
          } else if (isPlainObject$2(arg2)) {
            named = arg2;
          }
          if (isArray$1(arg3)) {
            list = arg3;
          } else if (isPlainObject$2(arg3)) {
            named = arg3;
          }
          return Reflect.apply(composer.t, composer, [
            key,
            list || named || {},
            options2
          ]);
        },
        rt(...args) {
          return Reflect.apply(composer.rt, composer, [...args]);
        },
        tc(...args) {
          const [arg1, arg2, arg3] = args;
          const options2 = { plural: 1 };
          let list = null;
          let named = null;
          if (!isString$2(arg1)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
          }
          const key = arg1;
          if (isString$2(arg2)) {
            options2.locale = arg2;
          } else if (isNumber$1(arg2)) {
            options2.plural = arg2;
          } else if (isArray$1(arg2)) {
            list = arg2;
          } else if (isPlainObject$2(arg2)) {
            named = arg2;
          }
          if (isString$2(arg3)) {
            options2.locale = arg3;
          } else if (isArray$1(arg3)) {
            list = arg3;
          } else if (isPlainObject$2(arg3)) {
            named = arg3;
          }
          return Reflect.apply(composer.t, composer, [
            key,
            list || named || {},
            options2
          ]);
        },
        te(key, locale) {
          return composer.te(key, locale);
        },
        tm(key) {
          return composer.tm(key);
        },
        getLocaleMessage(locale) {
          return composer.getLocaleMessage(locale);
        },
        setLocaleMessage(locale, message) {
          composer.setLocaleMessage(locale, message);
        },
        mergeLocaleMessage(locale, message) {
          composer.mergeLocaleMessage(locale, message);
        },
        d(...args) {
          return Reflect.apply(composer.d, composer, [...args]);
        },
        getDateTimeFormat(locale) {
          return composer.getDateTimeFormat(locale);
        },
        setDateTimeFormat(locale, format2) {
          composer.setDateTimeFormat(locale, format2);
        },
        mergeDateTimeFormat(locale, format2) {
          composer.mergeDateTimeFormat(locale, format2);
        },
        n(...args) {
          return Reflect.apply(composer.n, composer, [...args]);
        },
        getNumberFormat(locale) {
          return composer.getNumberFormat(locale);
        },
        setNumberFormat(locale, format2) {
          composer.setNumberFormat(locale, format2);
        },
        mergeNumberFormat(locale, format2) {
          composer.mergeNumberFormat(locale, format2);
        },
        getChoiceIndex(choice, choicesLength) {
          return -1;
        }
      };
      vueI18n.__extender = __extender;
      return vueI18n;
    }
  }
  const baseFormatProps = {
    tag: {
      type: [String, Object]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (val) => val === "parent" || val === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  function getInterpolateArg({ slots }, keys) {
    if (keys.length === 1 && keys[0] === "default") {
      const ret = slots.default ? slots.default() : [];
      return ret.reduce((slot, current) => {
        return [
          ...slot,
          ...current.type === Fragment ? current.children : [current]
        ];
      }, []);
    } else {
      return keys.reduce((arg, key) => {
        const slot = slots[key];
        if (slot) {
          arg[key] = slot();
        }
        return arg;
      }, {});
    }
  }
  function getFragmentableTag(tag) {
    return Fragment;
  }
  const TranslationImpl = /* @__PURE__ */ defineComponent({
    name: "i18n-t",
    props: assign$3({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [Number, String],
        validator: (val) => isNumber$1(val) || !isNaN(val)
      }
    }, baseFormatProps),
    setup(props, context) {
      const { slots, attrs } = context;
      const i18n2 = props.i18n || useI18n({
        useScope: props.scope,
        __useComponent: true
      });
      return () => {
        const keys = Object.keys(slots).filter((key) => key !== "_");
        const options = {};
        if (props.locale) {
          options.locale = props.locale;
        }
        if (props.plural !== void 0) {
          options.plural = isString$2(props.plural) ? +props.plural : props.plural;
        }
        const arg = getInterpolateArg(context, keys);
        const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
        const assignedAttrs = assign$3({}, attrs);
        const tag = isString$2(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
        return h(tag, assignedAttrs, children);
      };
    }
  });
  const Translation = TranslationImpl;
  function isVNode(target) {
    return isArray$1(target) && !isString$2(target[0]);
  }
  function renderFormatter(props, context, slotKeys, partFormatter) {
    const { slots, attrs } = context;
    return () => {
      const options = { part: true };
      let overrides = {};
      if (props.locale) {
        options.locale = props.locale;
      }
      if (isString$2(props.format)) {
        options.key = props.format;
      } else if (isObject$3(props.format)) {
        if (isString$2(props.format.key)) {
          options.key = props.format.key;
        }
        overrides = Object.keys(props.format).reduce((options2, prop) => {
          return slotKeys.includes(prop) ? assign$3({}, options2, { [prop]: props.format[prop] }) : options2;
        }, {});
      }
      const parts = partFormatter(...[props.value, options, overrides]);
      let children = [options.key];
      if (isArray$1(parts)) {
        children = parts.map((part, index) => {
          const slot = slots[part.type];
          const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
          if (isVNode(node)) {
            node[0].key = `${part.type}-${index}`;
          }
          return node;
        });
      } else if (isString$2(parts)) {
        children = [parts];
      }
      const assignedAttrs = assign$3({}, attrs);
      const tag = isString$2(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
  const NumberFormatImpl = /* @__PURE__ */ defineComponent({
    name: "i18n-n",
    props: assign$3({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    setup(props, context) {
      const i18n2 = props.i18n || useI18n({
        useScope: "parent",
        __useComponent: true
      });
      return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => i18n2[NumberPartsSymbol](...args));
    }
  });
  const NumberFormat = NumberFormatImpl;
  const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
    name: "i18n-d",
    props: assign$3({
      value: {
        type: [Number, Date],
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    setup(props, context) {
      const i18n2 = props.i18n || useI18n({
        useScope: "parent",
        __useComponent: true
      });
      return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => i18n2[DatetimePartsSymbol](...args));
    }
  });
  const DatetimeFormat = DatetimeFormatImpl;
  function getComposer$2(i18n2, instance) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      return i18nInternal.__getInstance(instance) || i18n2.global;
    } else {
      const vueI18n = i18nInternal.__getInstance(instance);
      return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
    }
  }
  function vTDirective(i18n2) {
    const _process = (binding) => {
      const { instance, modifiers, value } = binding;
      if (!instance || !instance.$) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const composer = getComposer$2(i18n2, instance.$);
      const parsedValue = parseValue(value);
      return [
        Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
        composer
      ];
    };
    const register = (el, binding) => {
      const [textContent, composer] = _process(binding);
      if (inBrowser && i18n2.global === composer) {
        el.__i18nWatcher = watch(composer.locale, () => {
          binding.instance && binding.instance.$forceUpdate();
        });
      }
      el.__composer = composer;
      el.textContent = textContent;
    };
    const unregister = (el) => {
      if (inBrowser && el.__i18nWatcher) {
        el.__i18nWatcher();
        el.__i18nWatcher = void 0;
        delete el.__i18nWatcher;
      }
      if (el.__composer) {
        el.__composer = void 0;
        delete el.__composer;
      }
    };
    const update = (el, { value }) => {
      if (el.__composer) {
        const composer = el.__composer;
        const parsedValue = parseValue(value);
        el.textContent = Reflect.apply(composer.t, composer, [
          ...makeParams(parsedValue)
        ]);
      }
    };
    const getSSRProps = (binding) => {
      const [textContent] = _process(binding);
      return { textContent };
    };
    return {
      created: register,
      unmounted: unregister,
      beforeUpdate: update,
      getSSRProps
    };
  }
  function parseValue(value) {
    if (isString$2(value)) {
      return { path: value };
    } else if (isPlainObject$2(value)) {
      if (!("path" in value)) {
        throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
      }
      return value;
    } else {
      throw createI18nError(I18nErrorCodes.INVALID_VALUE);
    }
  }
  function makeParams(value) {
    const { path, locale, args, choice, plural } = value;
    const options = {};
    const named = args || {};
    if (isString$2(locale)) {
      options.locale = locale;
    }
    if (isNumber$1(choice)) {
      options.plural = choice;
    }
    if (isNumber$1(plural)) {
      options.plural = plural;
    }
    return [path, named, options];
  }
  function apply$1(app2, i18n2, ...options) {
    const pluginOptions = isPlainObject$2(options[0]) ? options[0] : {};
    const useI18nComponentName = !!pluginOptions.useI18nComponentName;
    const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
    if (globalInstall) {
      [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
      [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
      [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
    }
    {
      app2.directive("t", vTDirective(i18n2));
    }
  }
  function defineMixin(vuei18n, composer, i18n2) {
    return {
      beforeCreate() {
        const instance = getCurrentInstance();
        if (!instance) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const options = this.$options;
        if (options.i18n) {
          const optionsI18n = options.i18n;
          if (options.__i18n) {
            optionsI18n.__i18n = options.__i18n;
          }
          optionsI18n.__root = composer;
          if (this === this.$root) {
            this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
          } else {
            optionsI18n.__injectWithOption = true;
            optionsI18n.__extender = i18n2.__vueI18nExtend;
            this.$i18n = createVueI18n(optionsI18n);
            const _vueI18n = this.$i18n;
            if (_vueI18n.__extender) {
              _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
            }
          }
        } else if (options.__i18n) {
          if (this === this.$root) {
            this.$i18n = mergeToGlobal(vuei18n, options);
          } else {
            this.$i18n = createVueI18n({
              __i18n: options.__i18n,
              __injectWithOption: true,
              __extender: i18n2.__vueI18nExtend,
              __root: composer
            });
            const _vueI18n = this.$i18n;
            if (_vueI18n.__extender) {
              _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
            }
          }
        } else {
          this.$i18n = vuei18n;
        }
        if (options.__i18nGlobal) {
          adjustI18nResources(composer, options, options);
        }
        this.$t = (...args) => this.$i18n.t(...args);
        this.$rt = (...args) => this.$i18n.rt(...args);
        this.$tc = (...args) => this.$i18n.tc(...args);
        this.$te = (key, locale) => this.$i18n.te(key, locale);
        this.$d = (...args) => this.$i18n.d(...args);
        this.$n = (...args) => this.$i18n.n(...args);
        this.$tm = (key) => this.$i18n.tm(key);
        i18n2.__setInstance(instance, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const instance = getCurrentInstance();
        if (!instance) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const _vueI18n = this.$i18n;
        delete this.$t;
        delete this.$rt;
        delete this.$tc;
        delete this.$te;
        delete this.$d;
        delete this.$n;
        delete this.$tm;
        if (_vueI18n.__disposer) {
          _vueI18n.__disposer();
          delete _vueI18n.__disposer;
          delete _vueI18n.__extender;
        }
        i18n2.__deleteInstance(instance);
        delete this.$i18n;
      }
    };
  }
  function mergeToGlobal(g, options) {
    g.locale = options.locale || g.locale;
    g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
    g.missing = options.missing || g.missing;
    g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
    g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
    g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
    g.postTranslation = options.postTranslation || g.postTranslation;
    g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
    g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
    g.sync = options.sync || g.sync;
    g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
    const messages2 = getLocaleMessages(g.locale, {
      messages: options.messages,
      __i18n: options.__i18n
    });
    Object.keys(messages2).forEach((locale) => g.mergeLocaleMessage(locale, messages2[locale]));
    if (options.datetimeFormats) {
      Object.keys(options.datetimeFormats).forEach((locale) => g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
    }
    if (options.numberFormats) {
      Object.keys(options.numberFormats).forEach((locale) => g.mergeNumberFormat(locale, options.numberFormats[locale]));
    }
    return g;
  }
  const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
  function createI18n(options = {}, VueI18nLegacy) {
    const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
    const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
    const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
    const __instances = /* @__PURE__ */ new Map();
    const [globalScope, __global] = createGlobal(options, __legacyMode);
    const symbol = /* @__PURE__ */ makeSymbol("");
    function __getInstance(component) {
      return __instances.get(component) || null;
    }
    function __setInstance(component, instance) {
      __instances.set(component, instance);
    }
    function __deleteInstance(component) {
      __instances.delete(component);
    }
    {
      const i18n2 = {
        get mode() {
          return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
        },
        get allowComposition() {
          return __allowComposition;
        },
        async install(app2, ...options2) {
          app2.__VUE_I18N_SYMBOL__ = symbol;
          app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
          if (isPlainObject$2(options2[0])) {
            const opts = options2[0];
            i18n2.__composerExtend = opts.__composerExtend;
            i18n2.__vueI18nExtend = opts.__vueI18nExtend;
          }
          let globalReleaseHandler = null;
          if (!__legacyMode && __globalInjection) {
            globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
          }
          if (__VUE_I18N_FULL_INSTALL__) {
            apply$1(app2, i18n2, ...options2);
          }
          if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
            app2.mixin(defineMixin(__global, __global.__composer, i18n2));
          }
          const unmountApp = app2.unmount;
          app2.unmount = () => {
            globalReleaseHandler && globalReleaseHandler();
            i18n2.dispose();
            unmountApp();
          };
        },
        get global() {
          return __global;
        },
        dispose() {
          globalScope.stop();
        },
        __instances,
        __getInstance,
        __setInstance,
        __deleteInstance
      };
      return i18n2;
    }
  }
  function useI18n(options = {}) {
    const instance = getCurrentInstance();
    if (instance == null) {
      throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
    }
    if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
      throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
    }
    const i18n2 = getI18nInstance(instance);
    const gl = getGlobalComposer(i18n2);
    const componentOptions = getComponentOptions(instance);
    const scope = getScope(options, componentOptions);
    if (__VUE_I18N_LEGACY_API__) {
      if (i18n2.mode === "legacy" && !options.__useComponent) {
        if (!i18n2.allowComposition) {
          throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
        }
        return useI18nForLegacy(instance, scope, gl, options);
      }
    }
    if (scope === "global") {
      adjustI18nResources(gl, options, componentOptions);
      return gl;
    }
    if (scope === "parent") {
      let composer2 = getComposer(i18n2, instance, options.__useComponent);
      if (composer2 == null) {
        composer2 = gl;
      }
      return composer2;
    }
    const i18nInternal = i18n2;
    let composer = i18nInternal.__getInstance(instance);
    if (composer == null) {
      const composerOptions = assign$3({}, options);
      if ("__i18n" in componentOptions) {
        composerOptions.__i18n = componentOptions.__i18n;
      }
      if (gl) {
        composerOptions.__root = gl;
      }
      composer = createComposer(composerOptions);
      if (i18nInternal.__composerExtend) {
        composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
      }
      setupLifeCycle(i18nInternal, instance, composer);
      i18nInternal.__setInstance(instance, composer);
    }
    return composer;
  }
  function createGlobal(options, legacyMode, VueI18nLegacy) {
    const scope = effectScope();
    {
      const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
      if (obj == null) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      return [scope, obj];
    }
  }
  function getI18nInstance(instance) {
    {
      const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
      if (!i18n2) {
        throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
      }
      return i18n2;
    }
  }
  function getScope(options, componentOptions) {
    return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
  }
  function getGlobalComposer(i18n2) {
    return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
  }
  function getComposer(i18n2, target, useComponent = false) {
    let composer = null;
    const root2 = target.root;
    let current = getParentComponentInstance(target, useComponent);
    while (current != null) {
      const i18nInternal = i18n2;
      if (i18n2.mode === "composition") {
        composer = i18nInternal.__getInstance(current);
      } else {
        if (__VUE_I18N_LEGACY_API__) {
          const vueI18n = i18nInternal.__getInstance(current);
          if (vueI18n != null) {
            composer = vueI18n.__composer;
            if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
              composer = null;
            }
          }
        }
      }
      if (composer != null) {
        break;
      }
      if (root2 === current) {
        break;
      }
      current = current.parent;
    }
    return composer;
  }
  function getParentComponentInstance(target, useComponent = false) {
    if (target == null) {
      return null;
    }
    {
      return !useComponent ? target.parent : target.vnode.ctx || target.parent;
    }
  }
  function setupLifeCycle(i18n2, target, composer) {
    {
      onMounted(() => {
      }, target);
      onUnmounted(() => {
        const _composer = composer;
        i18n2.__deleteInstance(target);
        const dispose = _composer[DisposeSymbol];
        if (dispose) {
          dispose();
          delete _composer[DisposeSymbol];
        }
      }, target);
    }
  }
  function useI18nForLegacy(instance, scope, root2, options = {}) {
    const isLocalScope = scope === "local";
    const _composer = shallowRef(null);
    if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
      throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    }
    const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$2(options.locale);
    const _locale = ref(!isLocalScope || _inheritLocale ? root2.locale.value : isString$2(options.locale) ? options.locale : DEFAULT_LOCALE);
    const _fallbackLocale = ref(!isLocalScope || _inheritLocale ? root2.fallbackLocale.value : isString$2(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);
    const _messages = ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = ref(isPlainObject$2(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = ref(isPlainObject$2(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    const _missingWarn = isLocalScope ? root2.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    const _fallbackWarn = isLocalScope ? root2.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    const _fallbackRoot = isLocalScope ? root2.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    const _fallbackFormat = !!options.fallbackFormat;
    const _missing = isFunction$1(options.missing) ? options.missing : null;
    const _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
    const _warnHtmlMessage = isLocalScope ? root2.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const _escapeParameter = !!options.escapeParameter;
    const _modifiers = isLocalScope ? root2.modifiers : isPlainObject$2(options.modifiers) ? options.modifiers : {};
    const _pluralRules = options.pluralRules || isLocalScope && root2.pluralRules;
    function trackReactivityValues() {
      return [
        _locale.value,
        _fallbackLocale.value,
        _messages.value,
        _datetimeFormats.value,
        _numberFormats.value
      ];
    }
    const locale = computed({
      get: () => {
        return _composer.value ? _composer.value.locale.value : _locale.value;
      },
      set: (val) => {
        if (_composer.value) {
          _composer.value.locale.value = val;
        }
        _locale.value = val;
      }
    });
    const fallbackLocale = computed({
      get: () => {
        return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
      },
      set: (val) => {
        if (_composer.value) {
          _composer.value.fallbackLocale.value = val;
        }
        _fallbackLocale.value = val;
      }
    });
    const messages2 = computed(() => {
      if (_composer.value) {
        return _composer.value.messages.value;
      } else {
        return _messages.value;
      }
    });
    const datetimeFormats = computed(() => _datetimeFormats.value);
    const numberFormats = computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
      return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
    }
    function setPostTranslationHandler(handler) {
      if (_composer.value) {
        _composer.value.setPostTranslationHandler(handler);
      }
    }
    function getMissingHandler() {
      return _composer.value ? _composer.value.getMissingHandler() : _missing;
    }
    function setMissingHandler(handler) {
      if (_composer.value) {
        _composer.value.setMissingHandler(handler);
      }
    }
    function warpWithDeps(fn) {
      trackReactivityValues();
      return fn();
    }
    function t(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
    }
    function rt(...args) {
      return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
    }
    function d(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
    }
    function n(...args) {
      return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
    }
    function tm(key) {
      return _composer.value ? _composer.value.tm(key) : {};
    }
    function te(key, locale2) {
      return _composer.value ? _composer.value.te(key, locale2) : false;
    }
    function getLocaleMessage(locale2) {
      return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
    }
    function setLocaleMessage(locale2, message) {
      if (_composer.value) {
        _composer.value.setLocaleMessage(locale2, message);
        _messages.value[locale2] = message;
      }
    }
    function mergeLocaleMessage(locale2, message) {
      if (_composer.value) {
        _composer.value.mergeLocaleMessage(locale2, message);
      }
    }
    function getDateTimeFormat(locale2) {
      return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
    }
    function setDateTimeFormat(locale2, format2) {
      if (_composer.value) {
        _composer.value.setDateTimeFormat(locale2, format2);
        _datetimeFormats.value[locale2] = format2;
      }
    }
    function mergeDateTimeFormat(locale2, format2) {
      if (_composer.value) {
        _composer.value.mergeDateTimeFormat(locale2, format2);
      }
    }
    function getNumberFormat(locale2) {
      return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
    }
    function setNumberFormat(locale2, format2) {
      if (_composer.value) {
        _composer.value.setNumberFormat(locale2, format2);
        _numberFormats.value[locale2] = format2;
      }
    }
    function mergeNumberFormat(locale2, format2) {
      if (_composer.value) {
        _composer.value.mergeNumberFormat(locale2, format2);
      }
    }
    const wrapper = {
      get id() {
        return _composer.value ? _composer.value.id : -1;
      },
      locale,
      fallbackLocale,
      messages: messages2,
      datetimeFormats,
      numberFormats,
      get inheritLocale() {
        return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
      },
      set inheritLocale(val) {
        if (_composer.value) {
          _composer.value.inheritLocale = val;
        }
      },
      get availableLocales() {
        return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
      },
      get modifiers() {
        return _composer.value ? _composer.value.modifiers : _modifiers;
      },
      get pluralRules() {
        return _composer.value ? _composer.value.pluralRules : _pluralRules;
      },
      get isGlobal() {
        return _composer.value ? _composer.value.isGlobal : false;
      },
      get missingWarn() {
        return _composer.value ? _composer.value.missingWarn : _missingWarn;
      },
      set missingWarn(val) {
        if (_composer.value) {
          _composer.value.missingWarn = val;
        }
      },
      get fallbackWarn() {
        return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
      },
      set fallbackWarn(val) {
        if (_composer.value) {
          _composer.value.missingWarn = val;
        }
      },
      get fallbackRoot() {
        return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
      },
      set fallbackRoot(val) {
        if (_composer.value) {
          _composer.value.fallbackRoot = val;
        }
      },
      get fallbackFormat() {
        return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
      },
      set fallbackFormat(val) {
        if (_composer.value) {
          _composer.value.fallbackFormat = val;
        }
      },
      get warnHtmlMessage() {
        return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
      },
      set warnHtmlMessage(val) {
        if (_composer.value) {
          _composer.value.warnHtmlMessage = val;
        }
      },
      get escapeParameter() {
        return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
      },
      set escapeParameter(val) {
        if (_composer.value) {
          _composer.value.escapeParameter = val;
        }
      },
      t,
      getPostTranslationHandler,
      setPostTranslationHandler,
      getMissingHandler,
      setMissingHandler,
      rt,
      d,
      n,
      tm,
      te,
      getLocaleMessage,
      setLocaleMessage,
      mergeLocaleMessage,
      getDateTimeFormat,
      setDateTimeFormat,
      mergeDateTimeFormat,
      getNumberFormat,
      setNumberFormat,
      mergeNumberFormat
    };
    function sync(composer) {
      composer.locale.value = _locale.value;
      composer.fallbackLocale.value = _fallbackLocale.value;
      Object.keys(_messages.value).forEach((locale2) => {
        composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
      });
      Object.keys(_datetimeFormats.value).forEach((locale2) => {
        composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
      });
      Object.keys(_numberFormats.value).forEach((locale2) => {
        composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
      });
      composer.escapeParameter = _escapeParameter;
      composer.fallbackFormat = _fallbackFormat;
      composer.fallbackRoot = _fallbackRoot;
      composer.fallbackWarn = _fallbackWarn;
      composer.missingWarn = _missingWarn;
      composer.warnHtmlMessage = _warnHtmlMessage;
    }
    onBeforeMount(() => {
      if (instance.proxy == null || instance.proxy.$i18n == null) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
      }
      const composer = _composer.value = instance.proxy.$i18n.__composer;
      if (scope === "global") {
        _locale.value = composer.locale.value;
        _fallbackLocale.value = composer.fallbackLocale.value;
        _messages.value = composer.messages.value;
        _datetimeFormats.value = composer.datetimeFormats.value;
        _numberFormats.value = composer.numberFormats.value;
      } else if (isLocalScope) {
        sync(composer);
      }
    });
    return wrapper;
  }
  const globalExportProps = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ];
  const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
  function injectGlobalFields(app2, composer) {
    const i18n2 = /* @__PURE__ */ Object.create(null);
    globalExportProps.forEach((prop) => {
      const desc = Object.getOwnPropertyDescriptor(composer, prop);
      if (!desc) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const wrap = isRef(desc.value) ? {
        get() {
          return desc.value.value;
        },
        set(val) {
          desc.value.value = val;
        }
      } : {
        get() {
          return desc.get && desc.get();
        }
      };
      Object.defineProperty(i18n2, prop, wrap);
    });
    app2.config.globalProperties.$i18n = i18n2;
    globalExportMethods.forEach((method) => {
      const desc = Object.getOwnPropertyDescriptor(composer, method);
      if (!desc || !desc.value) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
    });
    const dispose = () => {
      delete app2.config.globalProperties.$i18n;
      globalExportMethods.forEach((method) => {
        delete app2.config.globalProperties[`$${method}`];
      });
    };
    return dispose;
  }
  {
    initFeatureFlags();
  }
  {
    registerMessageCompiler(compile);
  }
  registerMessageResolver(resolveValue);
  registerLocaleFallbacker(fallbackWithLocaleChain);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const target = getGlobalThis();
    target.__INTLIFY__ = true;
    setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  var isVue2 = false;
  /*!
   * pinia v2.1.7
   * (c) 2023 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia2) => activePinia = pinia2;
  const piniaSymbol = Symbol();
  function isPlainObject$1(o) {
    return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia2 = markRaw({
      install(app2) {
        setActivePinia(pinia2);
        {
          pinia2._a = app2;
          app2.provide(piniaSymbol, pinia2);
          app2.config.globalProperties.$pinia = pinia2;
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia2;
  }
  const noop$1 = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    }
    if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = Symbol();
  function shouldHydrate(obj) {
    return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign: assign$1 } = Object;
  function isComputed(o) {
    return !!(isRef(o) && o.effect);
  }
  function createOptionsStore(id, options, pinia2, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia2.state.value[id];
    let store;
    function setup() {
      if (!initialState && true) {
        {
          pinia2.state.value[id] = state ? state() : {};
        }
      }
      const localState = toRefs(pinia2.state.value[id]);
      return assign$1(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(computed(() => {
          setActivePinia(pinia2);
          const store2 = pinia2._s.get(id);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options, pinia2, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign$1({ actions: {} }, options);
    const $subscribeOptions = {
      deep: true
    };
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia2.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      {
        pinia2.state.value[$id] = {};
      }
    }
    ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia2.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign$1($state, newState);
      });
    } : noop$1;
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia2._s.delete($id);
    }
    function wrapAction(name, action) {
      return function() {
        setActivePinia(pinia2);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name,
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const partialStore = {
      _p: pinia2,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign$1({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(partialStore);
    pinia2._s.set($id, store);
    const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(setup)));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia2.state.value[$id][key] = prop;
          }
        }
      } else if (typeof prop === "function") {
        const actionValue = wrapAction(key, prop);
        {
          setupStore[key] = actionValue;
        }
        optionsForPlugin.actions[key] = prop;
      } else
        ;
    }
    {
      assign$1(store, setupStore);
      assign$1(toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => pinia2.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign$1($state, state);
        });
      }
    });
    pinia2._p.forEach((extender) => {
      {
        assign$1(store, scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  function defineStore(idOrOptions, setup, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
    }
    function useStore(pinia2, hot) {
      const hasContext = hasInjectionContext();
      pinia2 = pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia2)
        setActivePinia(pinia2);
      pinia2 = activePinia;
      if (!pinia2._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options, pinia2);
        } else {
          createOptionsStore(id, options, pinia2);
        }
      }
      const store = pinia2._s.get(id);
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  function mapState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
      reduced[key] = function() {
        return useStore(this.$pinia)[key];
      };
      return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
      reduced[key] = function() {
        const store = useStore(this.$pinia);
        const storeKey = keysOrMapper[key];
        return typeof storeKey === "function" ? storeKey.call(this, store) : store[storeKey];
      };
      return reduced;
    }, {});
  }
  function mapActions(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
      reduced[key] = function(...args) {
        return useStore(this.$pinia)[key](...args);
      };
      return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
      reduced[key] = function(...args) {
        return useStore(this.$pinia)[keysOrMapper[key]](...args);
      };
      return reduced;
    }, {});
  }
  function mapWritableState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {
      reduced[key] = {
        get() {
          return useStore(this.$pinia)[key];
        },
        set(value) {
          return useStore(this.$pinia)[key] = value;
        }
      };
      return reduced;
    }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {
      reduced[key] = {
        get() {
          return useStore(this.$pinia)[keysOrMapper[key]];
        },
        set(value) {
          return useStore(this.$pinia)[keysOrMapper[key]] = value;
        }
      };
      return reduced;
    }, {});
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var axios$2 = { exports: {} };
  var bind$2 = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  var bind$1 = bind$2;
  var toString = Object.prototype.toString;
  var kindOf = function(cache2) {
    return function(thing) {
      var str = toString.call(thing);
      return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
    };
  }(/* @__PURE__ */ Object.create(null));
  function kindOfTest(type) {
    type = type.toLowerCase();
    return function isKindOf(thing) {
      return kindOf(thing) === type;
    };
  }
  function isArray(val) {
    return Array.isArray(val);
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject$1(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (kindOf(val) !== "object") {
      return false;
    }
    var prototype2 = Object.getPrototypeOf(val);
    return prototype2 === null || prototype2 === Object.prototype;
  }
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject$1(val) && isFunction(val.pipe);
  }
  function isFormData(thing) {
    var pattern = "[object FormData]";
    return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
  }
  var isURLSearchParams = kindOfTest("URLSearchParams");
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  function inherits(constructor, superConstructor, props, descriptors2) {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    props && Object.assign(constructor.prototype, props);
  }
  function toFlatObject(sourceObj, destObj, filter) {
    var props;
    var i;
    var prop;
    var merged = {};
    destObj = destObj || {};
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if (!merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = Object.getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  }
  function endsWith(str, searchString, position) {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    var lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  }
  function toArray(thing) {
    if (!thing)
      return null;
    var i = thing.length;
    if (isUndefined(i))
      return null;
    var arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  }
  var isTypedArray = function(TypedArray) {
    return function(thing) {
      return TypedArray && thing instanceof TypedArray;
    };
  }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
  var utils$h = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject: isObject$1,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    isTypedArray,
    isFileList
  };
  var utils$g = utils$h;
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$2 = function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$g.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$g.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils$g.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils$g.forEach(val, function parseValue2(v) {
          if (utils$g.isDate(v)) {
            v = v.toISOString();
          } else if (utils$g.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
  var utils$f = utils$h;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  };
  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager$1.prototype.forEach = function forEach2(fn) {
    utils$f.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  };
  var InterceptorManager_1 = InterceptorManager$1;
  var utils$e = utils$h;
  var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
    utils$e.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
  var utils$d = utils$h;
  function AxiosError$5(message, code2, config, request3, response) {
    Error.call(this);
    this.message = message;
    this.name = "AxiosError";
    code2 && (this.code = code2);
    config && (this.config = config);
    request3 && (this.request = request3);
    response && (this.response = response);
  }
  utils$d.inherits(AxiosError$5, Error, {
    toJSON: function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  var prototype = AxiosError$5.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED"
  ].forEach(function(code2) {
    descriptors[code2] = { value: code2 };
  });
  Object.defineProperties(AxiosError$5, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError$5.from = function(error, code2, config, request3, response, customProps) {
    var axiosError = Object.create(prototype);
    utils$d.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    });
    AxiosError$5.call(axiosError, error.message, code2, config, request3, response);
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var AxiosError_1 = AxiosError$5;
  var transitional = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  var utils$c = utils$h;
  function toFormData$1(obj, formData) {
    formData = formData || new FormData();
    var stack = [];
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils$c.isDate(value)) {
        return value.toISOString();
      }
      if (utils$c.isArrayBuffer(value) || utils$c.isTypedArray(value)) {
        return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function build(data2, parentKey) {
      if (utils$c.isPlainObject(data2) || utils$c.isArray(data2)) {
        if (stack.indexOf(data2) !== -1) {
          throw Error("Circular reference detected in " + parentKey);
        }
        stack.push(data2);
        utils$c.forEach(data2, function each(value, key) {
          if (utils$c.isUndefined(value))
            return;
          var fullKey = parentKey ? parentKey + "." + key : key;
          var arr;
          if (value && !parentKey && typeof value === "object") {
            if (utils$c.endsWith(key, "{}")) {
              value = JSON.stringify(value);
            } else if (utils$c.endsWith(key, "[]") && (arr = utils$c.toArray(value))) {
              arr.forEach(function(el) {
                !utils$c.isUndefined(el) && formData.append(fullKey, convertValue(el));
              });
              return;
            }
          }
          build(value, fullKey);
        });
        stack.pop();
      } else {
        formData.append(parentKey, convertValue(data2));
      }
    }
    build(obj);
    return formData;
  }
  var toFormData_1 = toFormData$1;
  var AxiosError$4 = AxiosError_1;
  var settle$1 = function settle(resolve2, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError$4("Request failed with status code " + response.status, [AxiosError$4.ERR_BAD_REQUEST, AxiosError$4.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
    }
  };
  var utils$b = utils$h;
  var cookies$1 = utils$b.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils$b.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$b.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$b.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove2(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }();
  var isAbsoluteURL$1 = function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  };
  var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  var isAbsoluteURL2 = isAbsoluteURL$1;
  var combineURLs2 = combineURLs$1;
  var buildFullPath$2 = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  var utils$a = utils$h;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  var parseHeaders$1 = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils$a.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils$a.trim(line.substr(0, i)).toLowerCase();
      val = utils$a.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  var utils$9 = utils$h;
  var isURLSameOrigin$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv2() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils$9.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  var AxiosError$3 = AxiosError_1;
  var utils$8 = utils$h;
  function CanceledError$3(message) {
    AxiosError$3.call(this, message == null ? "canceled" : message, AxiosError$3.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils$8.inherits(CanceledError$3, AxiosError$3, {
    __CANCEL__: true
  });
  var CanceledError_1 = CanceledError$3;
  var parseProtocol$1 = function parseProtocol(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  };
  var utils$7 = utils$h;
  var settle2 = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath$1 = buildFullPath$2;
  var parseHeaders2 = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var transitionalDefaults$1 = transitional;
  var AxiosError$2 = AxiosError_1;
  var CanceledError$2 = CanceledError_1;
  var parseProtocol2 = parseProtocol$1;
  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils$7.isFormData(requestData) && utils$7.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request3 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath$1(config.baseURL, config.url);
      request3.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
      request3.timeout = config.timeout;
      function onloadend() {
        if (!request3) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request3 ? parseHeaders2(request3.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request3.responseText : request3.response;
        var response = {
          data: responseData,
          status: request3.status,
          statusText: request3.statusText,
          headers: responseHeaders,
          config,
          request: request3
        };
        settle2(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request3 = null;
      }
      if ("onloadend" in request3) {
        request3.onloadend = onloadend;
      } else {
        request3.onreadystatechange = function handleLoad() {
          if (!request3 || request3.readyState !== 4) {
            return;
          }
          if (request3.status === 0 && !(request3.responseURL && request3.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request3.onabort = function handleAbort() {
        if (!request3) {
          return;
        }
        reject(new AxiosError$2("Request aborted", AxiosError$2.ECONNABORTED, config, request3));
        request3 = null;
      };
      request3.onerror = function handleError2() {
        reject(new AxiosError$2("Network Error", AxiosError$2.ERR_NETWORK, config, request3, request3));
        request3 = null;
      };
      request3.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional3 = config.transitional || transitionalDefaults$1;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError$2(timeoutErrorMessage, transitional3.clarifyTimeoutError ? AxiosError$2.ETIMEDOUT : AxiosError$2.ECONNABORTED, config, request3));
        request3 = null;
      };
      if (utils$7.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request3) {
        utils$7.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request3.setRequestHeader(key, val);
          }
        });
      }
      if (!utils$7.isUndefined(config.withCredentials)) {
        request3.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request3.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request3.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request3.upload) {
        request3.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request3) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError$2() : cancel);
          request3.abort();
          request3 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject(new AxiosError$2("Unsupported protocol " + protocol + ":", AxiosError$2.ERR_BAD_REQUEST, config));
        return;
      }
      request3.send(requestData);
    });
  };
  var _null = null;
  var utils$6 = utils$h;
  var normalizeHeaderName2 = normalizeHeaderName$1;
  var AxiosError$1 = AxiosError_1;
  var transitionalDefaults = transitional;
  var toFormData = toFormData_1;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils$6.isUndefined(headers) && utils$6.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = xhr;
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = xhr;
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$6.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$6.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults$3 = {
    transitional: transitionalDefaults,
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data2, headers) {
      normalizeHeaderName2(headers, "Accept");
      normalizeHeaderName2(headers, "Content-Type");
      if (utils$6.isFormData(data2) || utils$6.isArrayBuffer(data2) || utils$6.isBuffer(data2) || utils$6.isStream(data2) || utils$6.isFile(data2) || utils$6.isBlob(data2)) {
        return data2;
      }
      if (utils$6.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils$6.isURLSearchParams(data2)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data2.toString();
      }
      var isObjectPayload = utils$6.isObject(data2);
      var contentType = headers && headers["Content-Type"];
      var isFileList2;
      if ((isFileList2 = utils$6.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
        var _FormData = this.env && this.env.FormData;
        return toFormData(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
      } else if (isObjectPayload || contentType === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse(data2) {
      var transitional3 = this.transitional || defaults$3.transitional;
      var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
      var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils$6.isString(data2) && data2.length) {
        try {
          return JSON.parse(data2);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data2;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: _null
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils$6.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults$3.headers[method] = {};
  });
  utils$6.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults$3.headers[method] = utils$6.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$3;
  var utils$5 = utils$h;
  var defaults$2 = defaults_1;
  var transformData$1 = function transformData(data2, headers, fns) {
    var context = this || defaults$2;
    utils$5.forEach(fns, function transform2(fn) {
      data2 = fn.call(context, data2, headers);
    });
    return data2;
  };
  var isCancel$1 = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
  var utils$4 = utils$h;
  var transformData2 = transformData$1;
  var isCancel2 = isCancel$1;
  var defaults$1 = defaults_1;
  var CanceledError$1 = CanceledError_1;
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError$1();
    }
  }
  var dispatchRequest$1 = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData2.call(config, config.data, config.headers, config.transformRequest);
    config.headers = utils$4.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils$4.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults$1.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData2.call(config, response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel2(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData2.call(config, reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
  var utils$3 = utils$h;
  var mergeConfig$2 = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source2) {
      if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source2)) {
        return utils$3.merge(target, source2);
      } else if (utils$3.isPlainObject(source2)) {
        return utils$3.merge({}, source2);
      } else if (utils$3.isArray(source2)) {
        return source2.slice();
      }
      return source2;
    }
    function mergeDeepProperties(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$3.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function valueFromConfig2(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      }
    }
    function defaultToConfig2(prop) {
      if (!utils$3.isUndefined(config2[prop])) {
        return getMergedValue(void 0, config2[prop]);
      } else if (!utils$3.isUndefined(config1[prop])) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    function mergeDirectKeys(prop) {
      if (prop in config2) {
        return getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        return getMergedValue(void 0, config1[prop]);
      }
    }
    var mergeMap = {
      "url": valueFromConfig2,
      "method": valueFromConfig2,
      "data": valueFromConfig2,
      "baseURL": defaultToConfig2,
      "transformRequest": defaultToConfig2,
      "transformResponse": defaultToConfig2,
      "paramsSerializer": defaultToConfig2,
      "timeout": defaultToConfig2,
      "timeoutMessage": defaultToConfig2,
      "withCredentials": defaultToConfig2,
      "adapter": defaultToConfig2,
      "responseType": defaultToConfig2,
      "xsrfCookieName": defaultToConfig2,
      "xsrfHeaderName": defaultToConfig2,
      "onUploadProgress": defaultToConfig2,
      "onDownloadProgress": defaultToConfig2,
      "decompress": defaultToConfig2,
      "maxContentLength": defaultToConfig2,
      "maxBodyLength": defaultToConfig2,
      "beforeRedirect": defaultToConfig2,
      "transport": defaultToConfig2,
      "httpAgent": defaultToConfig2,
      "httpsAgent": defaultToConfig2,
      "cancelToken": defaultToConfig2,
      "socketPath": defaultToConfig2,
      "responseEncoding": defaultToConfig2,
      "validateStatus": mergeDirectKeys
    };
    utils$3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
      var merge2 = mergeMap[prop] || mergeDeepProperties;
      var configValue = merge2(prop);
      utils$3.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  };
  var data = {
    "version": "0.27.2"
  };
  var VERSION = data.version;
  var AxiosError = AxiosError_1;
  var validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  validators$1.transitional = function transitional2(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return function(value, opt, opts) {
      if (validator2 === false) {
        throw new AxiosError(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")), AxiosError.ERR_DEPRECATED);
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    var keys = Object.keys(options);
    var i = keys.length;
    while (i-- > 0) {
      var opt = keys[i];
      var validator2 = schema[opt];
      if (validator2) {
        var value = options[opt];
        var result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  var validator$1 = {
    assertOptions,
    validators: validators$1
  };
  var utils$2 = utils$h;
  var buildURL2 = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest2 = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  var buildFullPath2 = buildFullPath$2;
  var validator = validator$1;
  var validators = validator.validators;
  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios$1.prototype.request = function request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var transitional3 = config.transitional;
    if (transitional3 !== void 0) {
      validator.assertOptions(transitional3, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest2, void 0];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise = Promise.resolve(config);
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    }
    var newConfig = config;
    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected(error);
        break;
      }
    }
    try {
      promise = dispatchRequest2(newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    while (responseInterceptorChain.length) {
      promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise;
  };
  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    var fullPath = buildFullPath2(config.baseURL, config.url);
    return buildURL2(fullPath, config.params, config.paramsSerializer);
  };
  utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data2, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data: data2
        }));
      };
    }
    Axios$1.prototype[method] = generateHTTPMethod();
    Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios_1 = Axios$1;
  var CanceledError = CanceledError_1;
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token = this;
    this.promise.then(function(cancel) {
      if (!token._listeners)
        return;
      var i;
      var l = token._listeners.length;
      for (i = 0; i < l; i++) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve2) {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  var CancelToken_1 = CancelToken;
  var spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  var utils$1 = utils$h;
  var isAxiosError = function isAxiosError2(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  };
  var utils = utils$h;
  var bind2 = bind$2;
  var Axios = Axios_1;
  var mergeConfig2 = mergeConfig$2;
  var defaults = defaults_1;
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind2(Axios.prototype.request, context);
    utils.extend(instance, Axios.prototype, context);
    utils.extend(instance, context);
    instance.create = function create2(instanceConfig) {
      return createInstance(mergeConfig2(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios$1 = createInstance(defaults);
  axios$1.Axios = Axios;
  axios$1.CanceledError = CanceledError_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1;
  axios$1.VERSION = data.version;
  axios$1.toFormData = toFormData_1;
  axios$1.AxiosError = AxiosError_1;
  axios$1.Cancel = axios$1.CanceledError;
  axios$1.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$1.spread = spread;
  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1;
  axios$2.exports.default = axios$1;
  var axios = axios$2.exports;
  var retrieveUrl$1 = () => {
    const { addressFinder: { afd } } = useConfigStore();
    return afd.type === "id" ? afd.idUrl : afd.serialUrl;
  };
  var CountryCode;
  (function(CountryCode2) {
    CountryCode2["UK"] = "UK";
    CountryCode2["GB"] = "GB";
    CountryCode2["JE"] = "JE";
    CountryCode2["GG"] = "GG";
    CountryCode2["IM"] = "IM";
    CountryCode2["US"] = "US";
    CountryCode2["CA"] = "CA";
    CountryCode2["IE"] = "IE";
    CountryCode2["DE"] = "DE";
    CountryCode2["JP"] = "JP";
    CountryCode2["FR"] = "FR";
    CountryCode2["AU"] = "AU";
    CountryCode2["IT"] = "IT";
    CountryCode2["CH"] = "CH";
    CountryCode2["AT"] = "AT";
    CountryCode2["ES"] = "ES";
    CountryCode2["NL"] = "NL";
    CountryCode2["BE"] = "BE";
    CountryCode2["DK"] = "DK";
    CountryCode2["SE"] = "SE";
    CountryCode2["NO"] = "NO";
    CountryCode2["BR"] = "BR";
    CountryCode2["PT"] = "PT";
    CountryCode2["FI"] = "FI";
    CountryCode2["AX"] = "AX";
    CountryCode2["KR"] = "KR";
    CountryCode2["CN"] = "CN";
    CountryCode2["TW"] = "TW";
    CountryCode2["SG"] = "SG";
    CountryCode2["DZ"] = "DZ";
    CountryCode2["AD"] = "AD";
    CountryCode2["AR"] = "AR";
    CountryCode2["AM"] = "AM";
    CountryCode2["AZ"] = "AZ";
    CountryCode2["BH"] = "BH";
    CountryCode2["BD"] = "BD";
    CountryCode2["BB"] = "BB";
    CountryCode2["BY"] = "BY";
    CountryCode2["BM"] = "BM";
    CountryCode2["BA"] = "BA";
    CountryCode2["IO"] = "IO";
    CountryCode2["BN"] = "BN";
    CountryCode2["BG"] = "BG";
    CountryCode2["KH"] = "KH";
    CountryCode2["CV"] = "CV";
    CountryCode2["CL"] = "CL";
    CountryCode2["CR"] = "CR";
    CountryCode2["HR"] = "HR";
    CountryCode2["CY"] = "CY";
    CountryCode2["CZ"] = "CZ";
    CountryCode2["DO"] = "DO";
    CountryCode2["EC"] = "EC";
    CountryCode2["EG"] = "EG";
    CountryCode2["EE"] = "EE";
    CountryCode2["FO"] = "FO";
    CountryCode2["GE"] = "GE";
    CountryCode2["GR"] = "GR";
    CountryCode2["GL"] = "GL";
    CountryCode2["GT"] = "GT";
    CountryCode2["HT"] = "HT";
    CountryCode2["HN"] = "HN";
    CountryCode2["HU"] = "HU";
    CountryCode2["IS"] = "IS";
    CountryCode2["IN"] = "IN";
    CountryCode2["ID"] = "ID";
    CountryCode2["IL"] = "IL";
    CountryCode2["JO"] = "JO";
    CountryCode2["KZ"] = "KZ";
    CountryCode2["KE"] = "KE";
    CountryCode2["KW"] = "KW";
    CountryCode2["KY"] = "KY";
    CountryCode2["LA"] = "LA";
    CountryCode2["LV"] = "LV";
    CountryCode2["LB"] = "LB";
    CountryCode2["LI"] = "LI";
    CountryCode2["LT"] = "LT";
    CountryCode2["LU"] = "LU";
    CountryCode2["MK"] = "MK";
    CountryCode2["MY"] = "MY";
    CountryCode2["MV"] = "MV";
    CountryCode2["MT"] = "MT";
    CountryCode2["MU"] = "MU";
    CountryCode2["MX"] = "MX";
    CountryCode2["MD"] = "MD";
    CountryCode2["MC"] = "MC";
    CountryCode2["MA"] = "MA";
    CountryCode2["NP"] = "NP";
    CountryCode2["NZ"] = "NZ";
    CountryCode2["NI"] = "NI";
    CountryCode2["NG"] = "NG";
    CountryCode2["OM"] = "OM";
    CountryCode2["PA"] = "PA";
    CountryCode2["PK"] = "PK";
    CountryCode2["PY"] = "PY";
    CountryCode2["PH"] = "PH";
    CountryCode2["PL"] = "PL";
    CountryCode2["PR"] = "PR";
    CountryCode2["RO"] = "RO";
    CountryCode2["RU"] = "RU";
    CountryCode2["SM"] = "SM";
    CountryCode2["SA"] = "SA";
    CountryCode2["SN"] = "SN";
    CountryCode2["SK"] = "SK";
    CountryCode2["SI"] = "SI";
    CountryCode2["ZA"] = "ZA";
    CountryCode2["LK"] = "LK";
    CountryCode2["TJ"] = "TJ";
    CountryCode2["TH"] = "TH";
    CountryCode2["TN"] = "TN";
    CountryCode2["TR"] = "TR";
    CountryCode2["TM"] = "TM";
    CountryCode2["UA"] = "UA";
    CountryCode2["UY"] = "UY";
    CountryCode2["UZ"] = "UZ";
    CountryCode2["VA"] = "VA";
    CountryCode2["VE"] = "VE";
    CountryCode2["ZM"] = "ZM";
    CountryCode2["AS"] = "AS";
    CountryCode2["CC"] = "CC";
    CountryCode2["CK"] = "CK";
    CountryCode2["RS"] = "RS";
    CountryCode2["ME"] = "ME";
    CountryCode2["CS"] = "CS";
    CountryCode2["YU"] = "YU";
    CountryCode2["CX"] = "CX";
    CountryCode2["ET"] = "ET";
    CountryCode2["FK"] = "FK";
    CountryCode2["NF"] = "NF";
    CountryCode2["FM"] = "FM";
    CountryCode2["GF"] = "GF";
    CountryCode2["GN"] = "GN";
    CountryCode2["GP"] = "GP";
    CountryCode2["GS"] = "GS";
    CountryCode2["GU"] = "GU";
    CountryCode2["GW"] = "GW";
    CountryCode2["HM"] = "HM";
    CountryCode2["IQ"] = "IQ";
    CountryCode2["KG"] = "KG";
    CountryCode2["LR"] = "LR";
    CountryCode2["LS"] = "LS";
    CountryCode2["MG"] = "MG";
    CountryCode2["MH"] = "MH";
    CountryCode2["MN"] = "MN";
    CountryCode2["MP"] = "MP";
    CountryCode2["MQ"] = "MQ";
    CountryCode2["NC"] = "NC";
    CountryCode2["NE"] = "NE";
    CountryCode2["VI"] = "VI";
    CountryCode2["VN"] = "VN";
    CountryCode2["PF"] = "PF";
    CountryCode2["PG"] = "PG";
    CountryCode2["PM"] = "PM";
    CountryCode2["PN"] = "PN";
    CountryCode2["PW"] = "PW";
    CountryCode2["RE"] = "RE";
    CountryCode2["SH"] = "SH";
    CountryCode2["SJ"] = "SJ";
    CountryCode2["SO"] = "SO";
    CountryCode2["SZ"] = "SZ";
    CountryCode2["TC"] = "TC";
    CountryCode2["WF"] = "WF";
    CountryCode2["XK"] = "XK";
    CountryCode2["YT"] = "YT";
    CountryCode2["PE"] = "PE";
    CountryCode2["INTL"] = "INTL";
  })(CountryCode || (CountryCode = {}));
  const POSTCODE_REGEXES = /* @__PURE__ */ new Map([
    [
      CountryCode.UK,
      /^([A-Z]){1}([0-9][0-9]|[0-9]|[A-Z][0-9][A-Z]|[A-Z][0-9][0-9]|[A-Z][0-9]|[0-9][A-Z]){1}([ ])?([0-9][A-z][A-z]){1}$/i
    ],
    [
      CountryCode.GB,
      /^([A-Z]){1}([0-9][0-9]|[0-9]|[A-Z][0-9][A-Z]|[A-Z][0-9][0-9]|[A-Z][0-9]|[0-9][A-Z]){1}([ ])?([0-9][A-z][A-z]){1}$/i
    ],
    [CountryCode.JE, /^JE\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}$/],
    [CountryCode.GG, /^GY\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}$/],
    [CountryCode.IM, /^IM\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}$/],
    [CountryCode.US, /^([0-9]{5})(?:-([0-9]{4}))?$/],
    [CountryCode.CA, /^([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\s*([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])$/i],
    [CountryCode.IE, /^([AC-FHKNPRTV-Y][0-9]{2}|D6W)[ -]?[0-9AC-FHKNPRTV-Y]{4}$/],
    [CountryCode.DE, /^\d{5}$/],
    [CountryCode.JP, /^\d{3}-\d{4}$/],
    [CountryCode.FR, /^\d{2}[ ]?\d{3}$/],
    [CountryCode.AU, /^\d{4}$/],
    [CountryCode.IT, /^\d{5}$/],
    [CountryCode.CH, /^\d{4}$/],
    [CountryCode.AT, /^(?!0)\d{4}$/],
    [CountryCode.ES, /^(?:0[1-9]|[1-4]\d|5[0-2])\d{3}$/],
    [CountryCode.NL, /^\d{4}[ ]?[A-Z]{2}$/],
    [CountryCode.BE, /^\d{4}$/],
    [CountryCode.DK, /^\d{4}$/],
    [CountryCode.SE, /^(SE-)?\d{3}[ ]?\d{2}$/],
    [CountryCode.NO, /^\d{4}$/],
    [CountryCode.BR, /^\d{5}[\-]?\d{3}$/],
    [CountryCode.PT, /^\d{4}([\-]\d{3})?$/],
    [CountryCode.FI, /^(FI-|AX-)?\d{5}$/],
    [CountryCode.AX, /^22\d{3}$/],
    [CountryCode.KR, /^\d{5}$/],
    [CountryCode.CN, /^\d{6}$/],
    [CountryCode.TW, /^\d{3}(\d{2,3})?$/],
    [CountryCode.SG, /^\d{6}$/],
    [CountryCode.DZ, /^\d{5}$/],
    [CountryCode.AD, /^AD\d{3}$/],
    [CountryCode.AR, /^([A-HJ-NP-Z])?\d{4}([A-Z]{3})?$/],
    [CountryCode.AM, /^(37)?\d{4}$/],
    [CountryCode.AZ, /^\d{4}$/],
    [CountryCode.BH, /^((1[0-2]|[2-9])\d{2})?$/],
    [CountryCode.BD, /^\d{4}$/],
    [CountryCode.BB, /^(BB\d{5})?$/],
    [CountryCode.BY, /^\d{6}$/],
    [CountryCode.BM, /^[A-Z]{2}[ ]?[A-Z0-9]{2}$/],
    [CountryCode.BA, /^\d{5}$/],
    [CountryCode.IO, /^BBND 1ZZ$/],
    [CountryCode.BN, /^[A-Z]{2}[ ]?\d{4}$/],
    [CountryCode.BG, /^\d{4}$/],
    [CountryCode.KH, /^\d{5}$/],
    [CountryCode.CV, /^\d{4}$/],
    [CountryCode.CL, /^\d{7}$/],
    [CountryCode.CR, /^(\d{4,5}|\d{3}-\d{4})$/],
    [CountryCode.HR, /^(HR-)?\d{5}$/],
    [CountryCode.CY, /^\d{4}$/],
    [CountryCode.CZ, /^\d{3}[ ]?\d{2}$/],
    [CountryCode.DO, /^\d{5}$/],
    [CountryCode.EC, /^([A-Z]\d{4}[A-Z]|(?:[A-Z]{2})?\d{6})?$/],
    [CountryCode.EG, /^\d{5}$/],
    [CountryCode.EE, /^\d{5}$/],
    [CountryCode.FO, /^\d{3}$/],
    [CountryCode.GE, /^\d{4}$/],
    [CountryCode.GR, /^\d{3}[ ]?\d{2}$/],
    [CountryCode.GL, /^39\d{2}$/],
    [CountryCode.GT, /^\d{5}$/],
    [CountryCode.HT, /^\d{4}$/],
    [CountryCode.HN, /^(?:\d{5})?$/],
    [CountryCode.HU, /^\d{4}$/],
    [CountryCode.IS, /^\d{3}$/],
    [CountryCode.IN, /^\d{6}$/],
    [CountryCode.ID, /^\d{5}$/],
    [CountryCode.IL, /^\d{5,7}$/],
    [CountryCode.JO, /^\d{5}$/],
    [CountryCode.KZ, /^\d{6}$/],
    [CountryCode.KE, /^\d{5}$/],
    [CountryCode.KW, /^\d{5}$/],
    [CountryCode.KY, /^KY[123]-\d{4}$/],
    [CountryCode.LA, /^\d{5}$/],
    [CountryCode.LV, /^(LV-)?\d{4}$/],
    [CountryCode.LB, /^(\d{4}([ ]?\d{4})?)?$/],
    [CountryCode.LI, /^(948[5-9])|(949[0-7])$/],
    [CountryCode.LT, /^(LT-)?\d{5}$/],
    [CountryCode.LU, /^(L-)?\d{4}$/],
    [CountryCode.MK, /^\d{4}$/],
    [CountryCode.MY, /^\d{5}$/],
    [CountryCode.MV, /^\d{5}$/],
    [CountryCode.MT, /^[A-Z]{3}[ ]?\d{2,4}$/],
    [CountryCode.MU, /^((\d|[A-Z])\d{4})?$/],
    [CountryCode.MX, /^\d{5}$/],
    [CountryCode.MD, /^\d{4}$/],
    [CountryCode.MC, /^980\d{2}$/],
    [CountryCode.MA, /^\d{5}$/],
    [CountryCode.NP, /^\d{5}$/],
    [CountryCode.NZ, /^\d{4}$/],
    [CountryCode.NI, /^((\d{4}-)?\d{3}-\d{3}(-\d{1})?)?$/],
    [CountryCode.NG, /^(\d{6})?$/],
    [CountryCode.OM, /^(PC )?\d{3}$/],
    [CountryCode.PA, /^\d{4}$/],
    [CountryCode.PK, /^\d{5}$/],
    [CountryCode.PY, /^\d{4}$/],
    [CountryCode.PH, /^\d{4}$/],
    [CountryCode.PL, /^\d{2}-\d{3}$/],
    [CountryCode.PR, /^00[679]\d{2}([ \-]\d{4})?$/],
    [CountryCode.RO, /^\d{6}$/],
    [CountryCode.RU, /^\d{6}$/],
    [CountryCode.SM, /^4789\d$/],
    [CountryCode.SA, /^\d{5}$/],
    [CountryCode.SN, /^\d{5}$/],
    [CountryCode.SK, /^\d{3}[ ]?\d{2}$/],
    [CountryCode.SI, /^(SI-)?\d{4}$/],
    [CountryCode.ZA, /^\d{4}$/],
    [CountryCode.LK, /^\d{5}$/],
    [CountryCode.TJ, /^\d{6}$/],
    [CountryCode.TH, /^\d{5}$/],
    [CountryCode.TN, /^\d{4}$/],
    [CountryCode.TR, /^\d{5}$/],
    [CountryCode.TM, /^\d{6}$/],
    [CountryCode.UA, /^\d{5}$/],
    [CountryCode.UY, /^\d{5}$/],
    [CountryCode.UZ, /^\d{6}$/],
    [CountryCode.VA, /^00120$/],
    [CountryCode.VE, /^\d{4}$/],
    [CountryCode.ZM, /^\d{5}$/],
    [CountryCode.AS, /^96799$/],
    [CountryCode.CC, /^6799$/],
    [CountryCode.CK, /^\d{4}$/],
    [CountryCode.RS, /^\d{5,6}$/],
    [CountryCode.ME, /^8\d{4}$/],
    [CountryCode.CS, /^\d{5}$/],
    [CountryCode.YU, /^\d{5}$/],
    [CountryCode.CX, /^6798$/],
    [CountryCode.ET, /^\d{4}$/],
    [CountryCode.FK, /^FIQQ 1ZZ$/],
    [CountryCode.NF, /^2899$/],
    [CountryCode.FM, /^(9694[1-4])([ \-]\d{4})?$/],
    [CountryCode.GF, /^9[78]3\d{2}$/],
    [CountryCode.GN, /^\d{3}$/],
    [CountryCode.GP, /^9[78][01]\d{2}$/],
    [CountryCode.GS, /^SIQQ 1ZZ$/],
    [CountryCode.GU, /^969[123]\d([ \-]\d{4})?$/],
    [CountryCode.GW, /^\d{4}$/],
    [CountryCode.HM, /^\d{4}$/],
    [CountryCode.IQ, /^\d{5}$/],
    [CountryCode.KG, /^\d{6}$/],
    [CountryCode.LR, /^\d{4}$/],
    [CountryCode.LS, /^\d{3}$/],
    [CountryCode.MG, /^\d{3}$/],
    [CountryCode.MH, /^969[67]\d([ \-]\d{4})?$/],
    [CountryCode.MN, /^\d{6}$/],
    [CountryCode.MP, /^9695[012]([ \-]\d{4})?$/],
    [CountryCode.MQ, /^9[78]2\d{2}$/],
    [CountryCode.NC, /^988\d{2}$/],
    [CountryCode.NE, /^\d{4}$/],
    [CountryCode.VI, /^008(([0-4]\d)|(5[01]))([ \-]\d{4})?$/],
    [CountryCode.VN, /^\d{6}$/],
    [CountryCode.PF, /^987\d{2}$/],
    [CountryCode.PG, /^\d{3}$/],
    [CountryCode.PM, /^9[78]5\d{2}$/],
    [CountryCode.PN, /^PCRN 1ZZ$/],
    [CountryCode.PW, /^96940$/],
    [CountryCode.RE, /^9[78]4\d{2}$/],
    [CountryCode.SH, /^(ASCN|STHL) 1ZZ$/],
    [CountryCode.SJ, /^\d{4}$/],
    [CountryCode.SO, /^\d{5}$/],
    [CountryCode.SZ, /^[HLMS]\d{3}$/],
    [CountryCode.TC, /^TKCA 1ZZ$/],
    [CountryCode.WF, /^986\d{2}$/],
    [CountryCode.XK, /^\d{5}$/],
    [CountryCode.YT, /^976\d{2}$/],
    [CountryCode.PE, /^\d{5}$/],
    [CountryCode.INTL, /^(?:[A-Z0-9]+([- ]?[A-Z0-9]+)*)?$/i]
  ]);
  const postcodeValidator = (postcode, country) => {
    if (!POSTCODE_REGEXES.has(country)) {
      throw Error(`Invalid country code: ${country}`);
    }
    return POSTCODE_REGEXES.get(country).test(postcode);
  };
  const postcodeValidatorExistsForCountry = (country) => {
    return POSTCODE_REGEXES.has(country);
  };
  function mitt(n) {
    return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
      var i = n.get(t);
      i ? i.push(e) : n.set(t, [e]);
    }, off: function(t, e) {
      var i = n.get(t);
      i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
    }, emit: function(t, e) {
      var i = n.get(t);
      i && i.slice().map(function(n2) {
        n2(e);
      }), (i = n.get("*")) && i.slice().map(function(n2) {
        n2(t, e);
      });
    } };
  }
  var useLoadingStore = defineStore("loadingStore", {
    state: () => ({
      isLoading: false
    }),
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      setLoadingState(state) {
        this.setData({
          isLoading: state
        });
      }
    }
  });
  var useGtmStore = defineStore("gtmStore", {
    state: () => ({
      active: void 0
    }),
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      trackGtmEvent(event) {
        if (window.dataLayer) {
          window.dataLayer.push({ ecommerce: null });
          window.dataLayer.push(event);
        } else {
          document.addEventListener("ga:inited", () => {
            this.setData({
              active: true
            });
            window.dataLayer.push({ ecommerce: null });
            window.dataLayer.push(event);
          });
        }
      },
      trackStep(actionField) {
        const { cart } = useCartStore();
        const { currencyCode } = useConfigStore();
        this.trackGtmEvent({
          event: "checkoutSteps",
          ecommerce: {
            currencyCode,
            checkout: {
              actionField,
              products: cart.items
            }
          }
        });
      },
      addToCartEvent(product) {
        const { currencyCode } = useConfigStore();
        this.trackGtmEvent({
          event: "addToCart",
          ecommerce: {
            currencyCode,
            add: {
              actionField: {
                action: "add",
                list: "Shopping Basket"
              },
              products: [{
                id: product.id,
                name: product.name,
                price: product.price_range.minimum_price.final_price.value,
                quantity: product.quantity || 1,
                brand: product.brand,
                category: product.category_name
              }]
            }
          }
        });
      },
      removeFromCartEvent(product, quantity) {
        const { currencyCode } = useConfigStore();
        this.trackGtmEvent({
          event: "removeFromCart",
          ecommerce: {
            currencyCode,
            remove: {
              actionField: {
                action: "remove",
                list: "Shopping Basket"
              },
              products: [{
                id: product.id,
                name: product.name,
                price: product.price_range.minimum_price.final_price.value,
                quantity: quantity || 1,
                brand: product.brand,
                category: product.category_name
              }]
            }
          }
        });
      }
    }
  });
  var getDummyPaymentMethods = () => [
    {
      code: "checkmo",
      title: "Check / Money order"
    },
    {
      code: "braintree",
      title: "Credit Card"
    },
    {
      code: "braintree_cc_vault",
      title: "Stored Cards"
    },
    {
      code: "braintree_paypal_vault",
      title: "Stored Accounts (PayPal)"
    },
    {
      code: "braintree_applepay",
      title: "Apple Pay"
    },
    {
      code: "braintree_googlepay",
      title: "Google Pay"
    },
    {
      code: "braintree_venmo",
      title: "Venmo"
    },
    {
      code: "braintree_ach_direct_debit",
      title: "ACH Direct Debit"
    },
    {
      code: "braintree_local_payment",
      title: "Local Payments"
    },
    {
      code: "braintree_local_payment",
      title: "Local Payments"
    },
    {
      code: "braintree_paypal",
      title: "PayPal"
    },
    {
      code: "adyen_hpp",
      title: "Alternative payment methods"
    }
  ];
  var usePaymentStore = defineStore("paymentStore", {
    state: () => ({
      methodsResponse: [],
      clientKey: "",
      cache: {},
      errorMessage: "",
      paymentEmitter: mitt(),
      availableMethods: getDummyPaymentMethods(),
      expressMethods: [],
      hasVaultedMethods: false
    }),
    getters: {
      methodsResponse: (state) => state.methodsResponse,
      clientKey: (state) => state.clientKey,
      isPaymentMethodAvailable: (state) => (paymentMethod) => state.availableMethods.some(({ code: code2 }) => code2 === paymentMethod),
      getPaymentMethodTitle: (state) => (paymentMethod) => {
        const method = state.availableMethods.find(({ code: code2 }) => code2 === paymentMethod);
        return method ? method.title : null;
      },
      getPaymentPriority: (state) => (paymentMethod) => state.availableMethods.findIndex(({ code: code2 }) => code2 === paymentMethod),
      isExpressPaymentsVisible: (state) => state.expressMethods.length
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      setErrorMessage(message) {
        this.setData({
          errorMessage: message
        });
      },
      setPaymentMethods(paymentMethods2) {
        this.setData({
          availableMethods: paymentMethods2
        });
      },
      addExpressMethod(method) {
        this.setData({
          expressMethods: this.$state.expressMethods.concat([method])
        });
      },
      removeExpressMethod(method) {
        this.setData({
          expressMethods: this.$state.expressMethods.filter((expressMethod) => expressMethod !== method)
        });
      },
      setHasVaultedMethods() {
        this.setData({
          hasVaultedMethods: true
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCaches(cacheKeys) {
        if (cacheKeys.length) {
          cacheKeys.forEach((cacheKey) => {
            this.setData({
              cache: {
                [cacheKey]: void 0
              }
            });
          });
        }
      }
    }
  });
  var useStepsStore = defineStore("stepsStore", {
    state: () => ({
      signInPage: true,
      yourDetailsActive: false,
      shippingActive: false,
      paymentActive: false
    }),
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      setInitialStepState() {
        const { name } = this.$router.currentRoute.value;
        this.setData({
          signInPageActive: name === "SignInPage" || name === "DetailsPage" || name === "ShippingPage" || name === "PaymentPage",
          yourDetailsActive: name === "DetailsPage" || name === "ShippingPage" || name === "PaymentPage",
          shippingActive: name === "ShippingPage" || name === "PaymentPage",
          paymentActive: name === "PaymentPage"
        });
      },
      goToSignInPage() {
        this.setData({
          signInPage: true,
          yourDetailsActive: false,
          shippingActive: false,
          paymentActive: false
        });
        this.$router.push("/");
      },
      goToYouDetails() {
        this.setData({
          signInPage: false,
          yourDetailsActive: true,
          shippingActive: false,
          paymentActive: false
        });
        this.$router.push("/details");
      },
      goToShipping() {
        const { isItemRequiringDelivery } = useCartStore();
        if (isItemRequiringDelivery) {
          this.setData({
            signInPage: false,
            yourDetailsActive: true,
            shippingActive: true,
            paymentActive: false
          });
          this.$router.push("/shipping");
        } else {
          this.goToPayment();
        }
      },
      goToPayment() {
        this.setData({
          signInPage: false,
          yourDetailsActive: true,
          shippingActive: true,
          paymentActive: true
        });
        this.$router.push("/payments");
      },
      goToAdyenAmazonReviw() {
        this.setData({
          signInPage: true,
          yourDetailsActive: true,
          shippingActive: true,
          paymentActive: true
        });
        this.$router.push("/adyen-amazon-review");
      }
    }
  });
  var cleanAddress$1 = (address, removeSave = false) => {
    if (!address)
      return false;
    const cleanedAddress = address;
    const keysToRemove = [
      "customer_id",
      "default_shipping",
      "default_billing",
      "editing"
    ];
    keysToRemove.forEach((element) => {
      delete cleanedAddress[element];
    });
    if (cleanedAddress.region && cleanedAddress.region.region) {
      cleanedAddress.region = cleanedAddress.region.region;
    }
    if (removeSave) {
      delete cleanedAddress.save_in_address_book;
    }
    return cleanedAddress;
  };
  var lodash_clonedeep = { exports: {} };
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set2, value) {
      set2.add(value);
      return set2;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush2(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
    var coreJsData = root2["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    var objectToString2 = objectProto2.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries2) {
      var index = -1, length = entries2 ? entries2.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries2[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
    }
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
    }
    function hashSet(key, value) {
      var data2 = this.__data__;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries2) {
      var index = -1, length = entries2 ? entries2.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries2[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      return index < 0 ? void 0 : data2[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        data2.push([key, value]);
      } else {
        data2[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries2) {
      var index = -1, length = entries2 ? entries2.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries2[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries2) {
      this.__data__ = new ListCache(entries2);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache2 = this.__data__;
      if (cache2 instanceof ListCache) {
        var pairs = cache2.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache2 = this.__data__ = new MapCache(pairs);
      }
      cache2.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source2) {
      return object && copyObject(source2, keys(source2), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject2(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString2.call(value);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
      return arrayReduce(array, addSetEntry, new set2.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source2, array) {
      var index = -1, length = source2.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source2[index];
      }
      return array;
    }
    function copyObject(source2, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
        assignValue(object, key, newValue === void 0 ? source2[key] : newValue);
      }
      return object;
    }
    function copySymbols(source2, object) {
      return copyObject(source2, getSymbols(source2), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data2 = map.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString2.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag2:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep2(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    var isBuffer2 = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      var tag = isObject2(value) ? objectToString2.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep2;
  })(lodash_clonedeep, lodash_clonedeep.exports);
  var cloneDeep = lodash_clonedeep.exports;
  var deepClone = (object) => cloneDeep(object);
  var afterSubmittingShippingInformation = () => {
  };
  var setShippingMethodDataLayer = () => {
    const gtmStore = useGtmStore();
    const { cart } = useCartStore();
    const { selected_shipping_method: selctedMethod } = cart.shipping_addresses[0];
    gtmStore.trackGtmEvent({
      event: "selectShippingMethod",
      carrierCode: selctedMethod.carrier_code,
      methodCode: selctedMethod.method_code
    });
  };
  var yogaBrick = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gODAK/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8IAEQgAlgCWAwEiAAIRAQMRAf/EABsAAQADAQEBAQAAAAAAAAAAAAAEBQYCAQMH/8QAGgEBAAMBAQEAAAAAAAAAAAAAAAIEBQMBBv/aAAwDAQACEAMQAAAB/VAAAAAAAAAAHPh24HbgduB24HbgduPk8kKyVKElwj07ciKVpZK3ws2Ivy4U9wAAKiTmbNKBqshoI09QiS62wEvea/yH8/andV3298lqziS4l0UyHtirkVirhmKK1uPqcCl+P6VlKN9pPzywoe7NjXTzXeTC3D9liGmCH7LERLERLFFT6qqyu1hk4v31LXV31oJ1c60TtRC1MAAAABWWdZw7ZrQZ7SUdS1GrigAAAAAAKyzrOXbM6TN6TP1LUauKAS/CKlCKlCKlCKlCKlCLWXvkJ/nuku+69uMlLdGKlj0AAAAAAAAAAAAAAAAAAAH/xAAoEAABAwQBAwQCAwAAAAAAAAABAAIDBBESEwUQFDMVIDBANFAGISP/2gAIAQEAAQUC/c5BZBZBZBZBZBZBZBZBZBZBZBZBSTRxt76mUU8crcgsgrj5uT/GXF/j+wyO9RqpHMmikca9tfVdnNUmLjuNnMsXtqahsAqKp8zWyxmSCUwtgmEvW4U9PHNJJBHJDTwxwJsMTaZ0ETgyGJk1wrhXCuFcKrkymtLUyeiT4jbTOp32ftjW2PpNLgdji+MuLhN/mZzaOUuk9vKNMZ4Bg0L+QsHbUMpMfTWVqWorUVqWpalrK1laytZWsqqhEsVBIKM95T48nUCsNPHYdi9di/5ZGqanbKpaJ0bmRhqoqc5fPXf1CuPa0xfQ5DwLjvB9DkPAuO8H0OQ8C47wfQ5DwLjvB1sFYKwVgrBWCsFYKwVgrBWCsEWtK1RoMaFYKwVv3X//xAAmEQACAQMDAwQDAAAAAAAAAAABAgADBBMSIVERMDMQFEBBICIx/9oACAEDAQE/AfgE9NzFqI2wPZu66BSn3LJCG1wHr6YBzMAmFeZgHM9uOZ7ccxbNjUOuLbqDtDqpbGZJmaZmmZpmaZmmZppWp+0pWi/2XxRmCj6mgfnb+QS92pdm38qy+8XZpvoYNK92Kqaenx//xAAqEQABBAADBwMFAAAAAAAAAAACAAEDBBEVUQUSEzAxM1IQFEAgIiNBQv/aAAgBAgEBPwH4DNinAm6tya8RO7F+ldvRD+NCTE2Leg7YkJ8GFPteRv5ZZrL4ItsSD1FZ0fis6PxQ3wkBuHopY2IUEzwYivfFosqr6LKq+iyqvosqr6LKq2iyqtoglOjI8ZdEVvfH7VDWY23jXtI/rsCzxviqnc5M3bdVO5yTHeF2UNbhlvY/H//EAC8QAAEDAQUFCAIDAAAAAAAAAAEAAhExAxASIUEgIkBRkRMyM2FxcoGhBEIwUGD/2gAIAQEABj8C/wANie6AvE+ipY6RwPzcfdsss53DZF0echfjBpgPfB6K3sydxrWkDqiIm2IL2vjLChbE75aI9SnNe9r7SzdhLhr57WebuSh0BqwlyhkRVcncr6hC07R7HARLHQm2b3uOHMOxb0p2Fxc51XOMkrsAdyC2qsg7NtnQI2jIaSMJiiqFUKoVQqhWjjzWCzEnkpx2c8lhtBB1CY8UXiN6rxG9btBlPqmgDn9FPxRkYoi6Wk6NFU2B65KN3WmkbR5OKtH/ALF0XMtP2DoRadjS/RaLTacwiU/FPZmvkp7ZnVNa2ezb9prBqu81d5v8shcioLhFwtHjIU4CRkZuJIEzwPzcfdwPzcfdwPzcfdwPzcfdsUVAqBUCoFQKgVAqBUCoFQKgWbQu43osmhUCoP7v/8QAKRAAAgEDAwMCBwEAAAAAAAAAAAERITFhQVHxEKGxIEAwUHGRwdHwgf/aAAgBAQABPyH5zkM5nM5nM5nM5nM5nM5nL6TEwz+v6hgjDiYZnM4nWfxvF6d+8L0ro1ShoR+SfctO6k/wS4IMWbq8E70OahMt6Soj/UIdOtKSqncYvVCwt1Rj1L9xZS7KTCRFGsyV5Hdwm2L9XODjMZbES0ArM3TuSFlzSxYe6jvEO4zbW7o6RXcoZFIJqzbc5w5w5w5w5wmXRMl9EKSb7Joeep+YI99NzXIlgu7HGzifRkcoUk+FSMaG50mwt0JNnUSIaJ75GyGC2BvRk9VVUNrzEYJBbVWLpIr6qJXiYvmjhJfvozZRjw0/0VuYdH1zIk7sZEZES3EtxLcZkZkZkZkZkKRNp9RPNepu3NtPu+xUtUrLcSsw27n9TP6n8V86GpNN1LtamEkZA6sdiFg9fYPtoqhtty3LHlSvVqtl7Hx+nevC9j4/TvXhex8fp3rwvY+P0714Xom0fY4g4g4g4g4g4g4g4g4g4g4g4gSQyso4OIYRWEcQcQJFZJfOv//aAAwDAQACAAMAAAAQ88888888880888886/8APABBCAAFugQDMbBDTcUjAU4c4wQfwm8gAAAAAEzQAAAAAAAAfgABDDDDDC+DDPPPPPPPPPPPPPPPPPPPPP/EACURAAICAQIEBwAAAAAAAAAAAAERAGExEDAhQEFRcYGhscHh8P/aAAgBAwEBPxDkACxCFEyaI2S/LIfnHNjiLgAY0IwzAL1OkB8agGHRZ9/mLBpwCIzH7S+Xy+Xy+XwihOMGL8Rc6TJfWx49wyRdxs+sEyeI2XYGjFqvny//xAAlEQEAAgIBAwIHAAAAAAAAAAABABFhkSEwMVFAgRAgcaGx0eH/2gAIAQIBAT8Q9Aio7wm0D6dGnvBhNlXBxv8AUPPY/CkHbALdz5qCtU8d2KUO2Y+2Y+2A/MR7cdvacwj4FlzBmdtmdtmdtmdtmZtmZtlzJazxX9JVK4fEYjy9pjd/PQq+IBBjo/az8D0c0xLlvT//xAAoEAEAAgECBAYCAwAAAAAAAAABABEhMfBBUWHxECAwcYGRUMGhsdH/2gAIAQEAAT8Q/MoqJv2myM2RmyM2RmyM2RmyM2RmyM2RmyM2RlTFTJZfYnSQBHcdLNDWTqTZGbIx2h/r1tHfh8ph8KotAGQjdXosXWZRdA0cWMmMjSYNpE4kurbpryjV+MkXjBk4Ky6vEGE7YDC3ALW9BjzmDTMLRSvsfNWBPbKs5rwIrMgxVV1WGLlgAq+Vx7lKBdqBr8EZgULRvHM6eDO1JabqhWijWuQ+pau9HSujrpae0r1BhqUFeAaBiLGyRDn6vmGaooaxWniBa6sA8GmCIKOC0vkztSdqTtSdqTtSP8Z4JRX1DFqb1A5roe7DlnvS+0CAtLVg5HTPMlJNBVayw38XNyfuO1P78Ndlo2i6Q0yauuphuNLR3pAPIw3x9oWU9ss3G10fEaUKiVagRVzhoKpxK7S7jBLSpW1yj7RARcyrUOTY10zWvDy0Suimcp9/qVBG64hAPtfx4GLBlwqCfYfuFYlujdYfvwJu2NaxTZZp4mYaoC5Wpr8TWBqgXlo1m7Zu2btm7Zu2AUDduTly5fMdIQQWlih7anQ5Qfh+67j+IgBQFUvixwKuuOWCjJK6mpvf8Te/49UDK1oOEOuHoFnuIkRWQG09pfDGULw9owDOJSuDXI8H1mu1C02s8SMlJqrbCAxBUHM8X1tHZh8qB9bR2YfKgfW0dmHyoH1tHZh8qDXSKlVXiiduTtyduTtyduTtyduTtyduTtyduTtycfJUKTYH6maJXQhO3J25G7c6Ffmv/9k=";
  var foamRoll = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gODAK/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8IAEQgAlgCWAwEiAAIRAQMRAf/EABsAAQACAwEBAAAAAAAAAAAAAAADBgIEBQEH/8QAGQEBAAMBAQAAAAAAAAAAAAAAAAECBAMF/9oADAMBAAIQAxAAAAH6oAAACOlb1C59bvcfjP0qY7gvzAAAAAAApdWu1QzbYrpVvoE16A0ZAAAAABhDOLh1jLp5OGWpXTu2il2CK/SVYsenHIOvMAAABwe9UMvfm+RS+X6McG26V1JJVbedjjzTW/j2/JAAAAUG9UPBs0dzmbeLZse4+xHhlCD3ndK8/RfYZva8cJAAAQUO80bzt3ke/o8NEvhxt7JHIjQ93uZ3j6RswT+r5QWgAADUpN4o3m7tnTlgz6JMXvO2TFKfQ7vC78/os8UvqeYFoAAAjol+oeDZhp6ed43fND3nfoZc30t9c7nEifosmGfoYQmAAAHy/wCofIeOiHe4vZvRi17U2sosjq8vCXjo+qjvlAAAAfOituDsCfd0mulmJsW8VtZxfmAB/8QAKxAAAQMCBAUEAgMAAAAAAAAAAQACAwQFERIhMBATIDEzBhQyQSI0IyQl/9oACAEBAAEFAtiSRsTKi/tBpL5HIRqN/wBQEmL2+J9vgrM4mh37g9xrI3nPzCZLW53P37q+nEpIDm4E0cIij3nyNjF5k5lxD86dJyo/Tpexu49wY2evKnc5zqgMkTFlMjmSAKnuDgmPa9u1cpOJaCnRtw5bUGgcLfLll2q9+afHqOigd/JtSnGSQ4dUx/GHu3tsSaRv+dZ8GnoAUkhNVH2hOMOxUeB5QYHwM4ff2qqPKmHSm0p9iq/XeEMBaxw+0Vcx/VhUBxh2Kr9dymcBSBHiVU62yJU/g2KnwPVQNG9M7P8AGhUPi2JRjHIquVhfnaVqtVjwiwltkCj8ewe03cfN3D6TFZlAFH8Nmukfz4XHmI6AHgFSztghpJXGbaqCedTk5sUUzHFDvJ+TBCIK/avNMGVEbcqxWGZ1yaGXBN7wUrnU1ttxhl6f/8QAJBEAAQIGAgIDAQAAAAAAAAAAAQACAwQQESAxEiEUMDJBUXH/2gAIAQMBAT8BwZD5J7OPpg2so1gPRDlifkrAHpFofcJ8NzN5S4u+jtUe3k22UqN0tT6RxldFNN71YbhO3jK6TdVhno/1O3jK/aEct6XlD8Xkj8UB3LkjjL7UTdYRsMmOIPSJvW544f/EACQRAAECBQMFAQAAAAAAAAAAAAEAAgMEESAxEBIhFDAyQVEi/9oACAECAQE/AbHOomur2X5UPPYfNtHDU0mlSi9zKFQ4rYmLpt1GaQz+gqkph2urdOHARwgac6YQxbOeQUQUA1iCibgWznmFEzrF9JuBbO+kZYP5XRn6ujP1TDNoaEMWxQDlNxrEaHZuIrZTmz//xAAzEAABAwEFBAgFBQAAAAAAAAABAAIRAxAhMDFBEiBhcQQTMkBCUWKRIiRygbFDUqHB8P/aAAgBAQAGPwLAL6h2WjMqKFKeLkG129X6hkru4U6YyJkrNZpod4bu4VWu7LB8KhzfutnZu81UZ+nE9waxzvmHi4cFevh1UjNwE48vcAm1W6XBX9pFze1FydRc4lsSJ0xZdkopD7lS4krPZdxV4vQHg1KBpuv4ICqJHmpYZGGGbmULs2xocN3tgDDqfVKB47wbqUEMF3JFDmN4jQBFMPpGC/lZWc7wxHOd0qg/9wP5sp/SMF9hjPrd7omzx0V/4TDwwX2UWeZJO90cnQkWM5YL+VlIeif5V+63gUEzlguHCym1vhYAs92u3ylBN5YRTlCgBRJ91mfeyuDlA/tBN5YT4ddKIJmd7pRdqyFTbdecNwdnKaSrrDNoZMFzxf8A7mmMov668QRh7TDnejlB0sA81VaMrvwLeso7IqbXaOi6+q4OdoBvf//EACgQAQACAgEDAwMFAQAAAAAAAAEAESExQTBRYXGBoRCRsSBAwdHx4f/aAAgBAQABPyHoFZHacRmw8PV+0upnFl+7tEAoRyJ+w2eL2P8AYBY58pl+W+3j8/sF1xaJgsIF+kpX8xHGB4LK1cKzi39hT0rj2Zz9pSsfaYqj3cw7csL269UD5l+8ZnjiELHlmoWGFbalaPD+9XVWNQiBoQ9fkYbQafRL1oEx5Qc2qjXhTPpDXcrV8HTYScbZeWM3AMAkHomfSaQIYjZ3G9PAuH4RzxK7/QIwmO+JV6/T80VBPvAqXj6XX1rFtv2gr70Vt3Oi7PZM3O8GU3JkITmcz8kJegTBPFTzEnx0VXq4WGxxTB0sAXZD/sFY/QGIoW6lei/uaXMKN3/B0fiy68+0ALyAxU1xOIRzFiZJcYZcwtivYpHc2no/Em7BV/niE0yhiG5zHvxA7981DggofHom5N2ey491/cVlbExed/S5y32gNW7/AJqaWnwv46PkZQTviAelwoY3xxL7vieqWg5nMqVXzBrM/T/jom2eJTVzMru7Fim4YDK7zOD76WuZAac+sduzZihJe+YKLw6VCquqiuZeZsFgWs91A12mFuLMuBoBW1cH5mTsAuoFAdF01uKA7n4jg6bbhh2d5rNARvmH0CUrJmgBv8JjLk5DvpsaWwfO4qWxb5SzDgNqmlVjImRlsCpF0xoplpdGhgXm/wBX/9oADAMBAAIAAwAAABDzzzxKXzzzzzzzyL3zzzzzz/Eav7zzzzyv8/zrzzzzzo+p9JXzzzwIGqdPXzzzzZtJANXzzzwRnHzNTzzzyK2Qzhzzzzz96EAPzzz/xAAjEQEAAQQCAQQDAAAAAAAAAAABABEgITEQQXEwUZGxYaHB/9oACAEDAQE/ELGFSPn6KQTEeRldXgrQmXVD9zFQcu2O43Zx6mo8/EMagIrtyJWISjHgKKWnN+Yy8v4cMzb7v2zbX3t3+YQqO1++KSsB0vuZK16RfGoQ7IeqPnK/M2bahQGZ3nmp023ZEiKrO+EqBs//xAAjEQEAAQMEAgIDAAAAAAAAAAABABEgQRAhMaFRcWGxMJHB/9oACAECAQE/ELKqk4/4axHMK7MXqBVjHK9REjgm2YNv38ZuSmZYkY9xHmMcDi7uoNjEQMaJQR1Datr4gFPFda4Pg+iY3gt6n9iUDgDrU0q8h9Q09Vo3fuFFaLHF0hk6TeytCn6nFaYUVmLxqqArcQ3gBxDQDY//xAAoEAEAAgEDAwQCAwEBAAAAAAABABEhMUFRYXGRMIGhwbHRQOHwIPH/2gAIAQEAAT8Q9C47AcD/AG0A22qX1BzXdO0dijQN6NR5ghGELEdz+A0qdaqAHbLwR0uU5xCsOZQxGcRVdxT4APb+AiO4sE0263d+0oki0l69rfUHOWnomtaGeGHWoCBRDTe9deD+BZji0bstsNQOrpGIUHUtn2jHlFFKEs0MTemAdPXa9UWXsby/dQ0rg/Z8x/UtisPUqJkjKtGmufaF/Dda8VXDY10eX1aH/tZwA+s+xpLhNLUXMoeFCtJMmf3DXdqtx6ianWKBS3EAylvOnvKSh1Th6M4ELRPc3hZG3Wnfj02NAKurg/3WOAwT5jC4XCsVFVnLHOVTBeamlKuksoHeQF12fTCysc9xNNkuD/eIb1bEgLSXBBmK1b/Et96C+93+vPpLQroRGLgHu/siKatFytfbCA2RtvWpzCInMwdH9pAzFS2vTP5nQwfj0dlfhhi74vs5iIqhqGrzLupxlDBAgc6y8ZVxYDsUYSCCX5fzEdlPuf8At0D0QStFd8YYZOhgPhlwdY4Ensexi5CbK7w0Q0QULphjMpLZtEJrcsTCOLPD0e6/uS7Z06gG5fQX27wCD2CVC1aMWHhPtAJCzXnCvQzh5WPqNOQeWrAXBBDt6Lrtz5JgG0wnXJ5FT8ntGXVfDMQMVTcGI4fiIgqV6NvqUdSAV/k9Fjhbl4bmMtnYS5s1GCH6oqBhy5iJA3pcMlqbP1HjeLwr+xHY4PXEFClOj7PR3IpfE1HQl7APheaMxxcdoKzlbwxp0V1tBLZfokFqw8TUJBdyoTbgD8kcsbzhHUjs6Wvw9GgtVEQMQWx9RtfkK76wA6j4IgUAVhpASDrRLl8wfYUKS3mrgjMNbVvzBTGadDNvhjYMohszpOgxfB6WuJ4LC2+vzD8qFN7kVG+0yKy95mB4RRaHfrKMeI6Ne2FkAvc9iPTK1RLavH6hGaBXolSVIwvMrTlHsbfMwZrOxhx+JbgTcoqs7ZiA50oU0gj7iPvNE0pVcsJQAl2LT2g1ARymAAim+t7PHp5LslWWlo8W3DnQRCym9v1UGA+Ip7g34tqAZWJ4NCLBDR5YsQNDAYUCudefAd4DW6WBbVlUVf8A1//Z";
  var yogaStrap = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gODAK/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8IAEQgAlgCWAwEiAAIRAQMRAf/EABwAAQABBQEBAAAAAAAAAAAAAAADAgQFBgcIAf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHqgAAAAAAAAAAAAAGq7P52OiVcuhPR99y/qAAAAAAABovO9m0UyNttetRmO2eaPRVXoAAAAAGoZflBbWWRtS2x8kBL6V4h28AAAAAFJyTV7WkyDH1n2Ga6OsbWAAAAADBZ3WDiJQTRXFoTyRQnf83yLroAAAAA03ctVOKxXMJPaXlqVR1xGR9F+bfSJ9AAAAAwecHm6ntGnmm22UxxHTPtR87T8+gAAAAAADC5oaNuFyAAAAAAAAAAAAAAP//EACwQAAEDAwMDAgUFAAAAAAAAAAIBAwQABQYSMDEREzIhIhAUNUJQFRYjM0H/2gAIAQEAAQUC/Hz7wEd4shI6/cfZSDJCZF3jJAB09bgDpJ0lU8LfXfvdzFKOIijBjK5LvQdu7YiWm672TyBlGJkC4s43+oX76xFecjvQnHHYm5fp/YAkOjQ6D2lNdJ+TBb7srcucz5Nh1zWfNGBLXBvVi0UnrjuZJNRyf3KE6N309vV/1TGYyxrXtmSAOtTecJaGuvRfSoYAcrcvgodqHyMtKt8Gv8iV1qzy0mQdvJC02cfJzkfEv7fhiMjtzdvK/pQeTvKcff8A6nEJ3sy9vJkRbSPk9ynCUtfe0mpxONq9Mq/bPchO9FoPFKWl8rRanZZbkuxRX1k4/Kbp+G8xWlUVE6rj9t+bkCiCm/KtcSTS43H1x2G47X43/8QAFBEBAAAAAAAAAAAAAAAAAAAAYP/aAAgBAwEBPwFJ/8QAFBEBAAAAAAAAAAAAAAAAAAAAYP/aAAgBAgEBPwFJ/8QAMhAAAQQABAIHBwUBAAAAAAAAAQACAxESITAxBBATICMyUWFxIkJQUmKBkTNAcoKhwf/aAAgBAQAGPwL4eYo2h5HeN7ICJrGn6lXERh7voyTJ4+67Xc52wFp7juc1kja4iAnLvj/uvLwgoWKLrVxyflRQkZucuKaNsZKr5mEa7WRCxH73itynGY06qjXFfzTZIHYZBsVE+ZuGRzbI1egjPaP39FuswgQ6vunyP7zjaiZ8zgNXEM3nJoRe7N53ct1vQ5ApsmE9HHmTq9HHmIxh+6zKyN8rFoJpd3pDj1C52QGac69zaCs84my9wvF6vEYnOaA2/Z5ZKz1GPv2h7LvXUm86H+8xy+3J8JP6jcvXU/uOoUOUUg91wOpJfiOoUEU0eepO1ot1WFdcgjyPqg6sMV5uOqXMuJx+XZdkWSj8FdrC9nnS8eWOQdiw5+fkqaKA/YXJCMXi3JCpZcPghHC3CwfDv//EACgQAQACAgEDBAAHAQAAAAAAAAEAESExUTBBYXGBkaFAULHB0eHw8f/aAAgBAQABPyH8vwcBSguPM8qUtTCkjae373LXQbp2Ok67tU5PgipW1Xu3GRVpO64aisoKPjt+zro7yajnde0TfOWRo1Ma4vP1DAVSHrn9442/pn9uuO5TZ2v4mBH4SJsjnat3nmY2/wCVHsaJKA8cN6pjiWmz+0aaeh/yEGz2YS5hkrKZL7RiA7+RYFAGjqHhF2P1jP7tptjeRFrJXesDfOYbweJYM0HA1j76qpMsftKOy4gYx5g51ct++HaO92GCLV4cDr6PvqIYDUvYnfUkJQOiFTAPjEePnZzKvjTrxGGoh+LgUUa6hy0MlW9h8XMfbOBSzyJgR0pMESZ3jy8O/Urt0v603ekrtxPqTKBzXMC99QKaPgM/pfU/1+s2ekO/BNTKtpcXdOIjan7jqcBHPmDP0lT2TVU39c2jR8sUBpQXBQOOm1YAR3puYFHpKl5HWZRq4g+8yhuiLjg9A4OXq7sevK3p/EtnjQ/Q/wAxO/PmHzLqmjCollcspgJJhAFB+ASQV5v1uNTlVS/NQnmiH5d//9oADAMBAAIAAwAAABDzzzzzzzzzzzzzyDBzzzzzzzyjrTzzzzzzzzSzzzzzzgBBhTzzzzyyxCTTzzzzzyCSTzzzzzzyRgxTzzzzzzyxzzzzzzzzzzzzzzz/xAAUEQEAAAAAAAAAAAAAAAAAAABg/9oACAEDAQE/EEn/xAAUEQEAAAAAAAAAAAAAAAAAAABg/9oACAECAQE/EEn/xAAnEAEAAgEDAwQCAwEAAAAAAAABABEhMUFRMGFxgZGhscHwUNHh8f/aAAgBAQABPxD+PUg72fzCo34jSnULVO4WNffJLZ3uyDRkds3mzxDnbiukqK3ETr3RCbYLX2IsI8rqph7zRGUYnXsVdqxLZhbWl+br2npXQUECtLVbywc7RWJu1lJ7MXw1DVqPBZh6qIaF4GWgoc09YOC2KpC1Iwg8K9X5ujAU3xOFuHQtTesPBgO6eSgVtn0RUaPi9xhHkTFQtBgaJxxetbXXVSm4B5W3Z+B5lyQvRow0N6HHpn4inXDCit8P75iHlM8C0H4gZqQDkCEYAKA2OpVzaw3uux9pEJr5lH8djBCRh7rgZbXuEgRC/GOyLhIG8iLdjthVb5wa7dXVkA8ZrXxYek2S9EsmpKFV++JnCvhNS4UeTdMu5xmUcVojaPLacUgA+w9Ql0JqALVdioriLDQ2qtt+WWsEwwJWdcQbkmKW+Ix2qmpZ/qCYVLdq4gPkeMY7vtUAAAFAbdS8iVBFm0OVBOJmV+rjG65ne4jqrZzMWbf1/suDQbL4/WDVF75qjmBZGWM0Arzh9epSFCO9s/AxX+zWFXVVauYgJNhHobX9EoQr8mZpsBxGDLJXDhY/WuokAXm72kfu5gXT2Ih5BNX4F+5Q81Puf3MhMqlj7rUOAWeukGwTR6aoM+e1PpZjufylCVa0YB2lYnCjBO/5J4la83DXBCaC3WURoA6evnapEg7oJAaKGoc1EJji1Kr8QWQWl0yrVo4LAXwTlQH3ECQVqKOf+Ib9UhGlJYt1/SJW89LMex8ohRjVoeKUwQ7gHDCiUTNaMdJQ053ged+DyQPGA4BoAaHXQSksmXSzery4C8jBqA3ahwUV7MD7lZSu6uqvL/Hf/9k=";
  var getDummyFullCart = () => [
    {
      email: "hello@blueFinch.co.uk",
      applied_gift_cards: [
        {
          code: "035K7XUJDOWJ",
          expiration_date: null,
          current_balance: {
            currency: "USD",
            value: 10
          },
          applied_balance: {
            currency: "USD",
            value: 10
          }
        }
      ],
      billing_address: {
        city: "Brighton and Hove",
        country: {
          code: "GB",
          label: "GB"
        },
        firstname: "BlueFinch",
        lastname: "Commerce",
        postcode: "BN1 1AL",
        region: {
          code: null,
          label: null
        },
        street: [
          "20 Middle St"
        ],
        telephone: "01273030390"
      },
      shipping_addresses: [
        {
          firstname: "BlueFinch",
          lastname: "Commerce",
          street: [
            "20 Middle St"
          ],
          city: "Brighton and Hove",
          postcode: "BN1 1AL",
          region: {
            code: null,
            label: null
          },
          country: {
            code: "GB",
            label: "GB"
          },
          telephone: "01273030390",
          available_shipping_methods: [
            {
              amount: {
                currency: "USD",
                value: 0
              },
              available: true,
              carrier_code: "freeshipping",
              carrier_title: "1 Working Day",
              error_message: "",
              method_code: "freeshipping",
              method_title: "Free Delivery",
              price_excl_tax: {
                value: 0,
                currency: "USD"
              },
              price_incl_tax: {
                value: 0,
                currency: "USD"
              }
            },
            {
              amount: {
                currency: "USD",
                value: 10
              },
              available: true,
              carrier_code: "flatrate",
              carrier_title: "2-3 Working Days",
              error_message: "",
              method_code: "flatrate",
              method_title: "Standard Delivery",
              price_excl_tax: {
                value: 10,
                currency: "USD"
              },
              price_incl_tax: {
                value: 10,
                currency: "USD"
              }
            }
          ],
          selected_shipping_method: {
            amount: {
              value: 10,
              currency: "USD"
            },
            carrier_code: "flatrate",
            carrier_title: "2-3 Working Days",
            method_code: "flatrate",
            method_title: "Standard Delivery"
          }
        }
      ],
      items: [
        {
          __typename: "ConfigurableCartItem",
          id: "168",
          uid: "MTY4",
          configurable_options: [
            {
              option_label: "Size",
              value_label: "M"
            },
            {
              option_label: "Color",
              value_label: "Blue"
            }
          ],
          gift_wrapping: null,
          product: {
            name: "Proteus Fitness Jackshirt",
            sku: "MJ12",
            id: 430,
            thumbnail: {
              url: foamRoll,
              label: "Proteus Fitness Jackshirt"
            },
            price_range: {
              minimum_price: {
                final_price: {
                  value: 45
                }
              }
            }
          },
          quantity: 1,
          errors: null
        },
        {
          __typename: "GiftCardCartItem",
          id: "170",
          uid: "MTcw",
          recipient_name: "BlueFinch Checkout",
          recipient_email: "better@blueFinch.co.uk",
          sender_name: "BlueFinch Commerce",
          sender_email: "hello@blueFinch.co.uk",
          message: "Thanks for using BlueFinch Checkout",
          amount: {
            value: 25
          },
          product: {
            name: "Luma Virtual Gift Card",
            sku: "243-MB09",
            id: 2042,
            thumbnail: {
              url: yogaBrick,
              label: "Luma Virtual Gift Card"
            },
            price_range: {
              minimum_price: {
                final_price: {
                  value: 25
                }
              }
            }
          },
          quantity: 1,
          errors: null
        },
        {
          __typename: "SimpleCartItem",
          id: "171",
          uid: "MTcx",
          gift_wrapping: null,
          product: {
            name: "Strive Shoulder Pack",
            sku: "24-MB04",
            id: 2,
            thumbnail: {
              url: yogaStrap,
              label: "Strive Shoulder Pack"
            },
            price_range: {
              minimum_price: {
                final_price: {
                  value: 32
                }
              }
            }
          },
          quantity: 1,
          errors: null
        }
      ],
      available_payment_methods: [
        {
          code: "checkmo",
          title: "Check / Money order"
        },
        {
          code: "braintree",
          title: "Credit Card"
        },
        {
          code: "braintree_cc_vault",
          title: "Stored Cards"
        },
        {
          code: "braintree_paypal_vault",
          title: "Stored Accounts (PayPal)"
        },
        {
          code: "braintree_applepay",
          title: "Apple Pay"
        },
        {
          code: "braintree_googlepay",
          title: "Google Pay"
        },
        {
          code: "braintree_venmo",
          title: "Venmo"
        },
        {
          code: "braintree_ach_direct_debit",
          title: "ACH Direct Debit"
        },
        {
          code: "braintree_local_payment",
          title: "Local Payments"
        },
        {
          code: "braintree_local_payment",
          title: "Local Payments"
        },
        {
          code: "braintree_paypal",
          title: "PayPal"
        },
        {
          code: "adyen_hpp",
          title: "Alternative payment methods"
        }
      ],
      selected_payment_method: {
        code: "",
        title: ""
      },
      applied_coupons: null,
      gift_wrapping: null,
      applied_reward_points: null,
      prices: {
        grand_total: {
          value: 92,
          currency: "USD"
        },
        subtotal_including_tax: {
          value: 102,
          currency: "USD"
        },
        subtotal_excluding_tax: {
          value: 102,
          currency: "USD"
        },
        discounts: [
          {
            amount: {
              value: 10,
              currency: "USD"
            },
            label: "Gift Cards"
          }
        ]
      },
      is_virtual: false
    }
  ];
  var setShippingMethodOnCart = (carrierCode, methodCode) => {
    const cart = getDummyFullCart()[0];
    const selectedShippingMethod = cart.shipping_addresses[0].available_shipping_methods.find((method) => method.carrier_code === carrierCode && method.method_code === methodCode);
    cart.shipping_addresses[0].selected_shipping_method = selectedShippingMethod;
    let subtotalIncludingTax = cart.items.reduce((total, item) => total + item.product.price_range.minimum_price.final_price.value * item.quantity, 0);
    const discount = cart.prices.discounts.reduce((total, discountAmount) => total + discountAmount.amount.value, 0);
    subtotalIncludingTax -= discount;
    const shippingAmount = selectedShippingMethod ? selectedShippingMethod.amount.value : 0;
    cart.prices.subtotal_including_tax.value = subtotalIncludingTax;
    cart.prices.grand_total.value = subtotalIncludingTax + shippingAmount;
    return cart;
  };
  var getBaseUrl = () => {
    const { location: { hostname, origin, pathname } } = window;
    const splitPathname = pathname.split("/");
    const suffix = splitPathname[1].length === 4 ? `/${splitPathname[1]}` : "";
    return hostname === "localhost" ? "https://party.loc" : `${origin}${suffix}`;
  };
  var graphQlRequest = (query, variables = {}, customHeaders = {}) => {
    const { secureBaseLinkUrl, storeCode } = useConfigStore();
    const headers = {
      "content-type": "application/json",
      ...customHeaders
    };
    if (storeCode) {
      headers.Store = storeCode;
    }
    const base2 = secureBaseLinkUrl || `${getBaseUrl()}/`;
    return axios({
      url: `${base2}graphql`,
      method: "post",
      data: { query, variables },
      headers
    }).then((response) => response.data);
  };
  var formatAddress$1 = (address) => {
    const formattedAddress = address;
    delete formattedAddress.id;
    delete formattedAddress.default_shipping;
    delete formattedAddress.default_billing;
    const { region } = formattedAddress;
    if (region && typeof region !== "string") {
      delete formattedAddress.region;
    }
    return formattedAddress;
  };
  var getFullCart = () => {
    const customerStore = useCustomerStore();
    return `
    email
    applied_gift_cards {
      code
      expiration_date
      current_balance {
        currency
        value
      }
      applied_balance {
        currency
        value
      }
    }
    billing_address {
      city
      country {
        code
        label
      }
      firstname
      lastname
      postcode
      region {
        code
        label
      }
      street
      telephone
    }
    shipping_addresses {
      firstname
      lastname
      street
      city
      postcode
      region {
        code
        label
      }
      country {
        code
        label
      }
      telephone
      available_shipping_methods {
        amount {
          currency
          value
        }
        available
        carrier_code
        carrier_title
        error_message
        method_code
        method_title
        price_excl_tax {
          value
          currency
        }
        price_incl_tax {
          value
          currency
        }
      }
      selected_shipping_method {
        amount {
          value
          currency
        }
        price_incl_tax {
          value
          currency
        }
        carrier_code
        carrier_title
        method_code
        method_title
      }
    }
    items {
      __typename
      id
      uid
      ... on SimpleCartItem {
        gift_wrapping {
          price {
            value
          }
        }
      }
      ... on BundleCartItem {
        gift_wrapping {
          price {
            value
          }
        }
      }
      ... on ConfigurableCartItem {
        configurable_options {
          option_label
          value_label
        }
        gift_wrapping {
          price {
            value
          }
        }
      }
      ... on GiftCardCartItem {
        recipient_name
        sender_name
        message
        amount {
          value
        }
      }
      product {
        name
        sku
        id
        thumbnail {
          url
          label
        }
        price_range {
          minimum_price {
            final_price {
              value
            }
          }
        }
      }
      quantity
      errors {
        code
        message
      }
    }
    available_payment_methods {
      code
      title
    }
    selected_payment_method {
      code
      title
    }
    applied_coupons {
      code
    }
    gift_wrapping {
      price {
        value
      }
    }
    applied_reward_points {
      points
    }
    prices {
      grand_total {
        value
        currency
      }
      subtotal_including_tax {
        value
        currency
      }
      subtotal_excluding_tax {
        value
        currency
      }
      discounts {
        amount {
          value
          currency
        }
        label
      }
    }
    ${customerStore.isLoggedIn ? `applied_store_credit {
          applied_balance {
            value
            currency
          }
        }` : ""}
  `;
  };
  const convertBoolean = (value) => value === 1;
  const mapToGraphQLString = (obj) => Object.entries(obj).map(([key, value]) => `${key}: ${JSON.stringify(value)}`).join(", ");
  const buildShippingAddressMutation = (cartId, formattedAddressGraphQL) => `
mutation {
  setShippingAddressesOnCart(
    input: {
      cart_id: "${cartId}"
      shipping_addresses: [
        {
          address: { ${formattedAddressGraphQL} }
        }
      ]
    }
  ) {
    cart {
      ${getFullCart()}
    }
  }
}`;
  const mapShippingMethods = (response) => response.data.setShippingAddressesOnCart ? response.data.setShippingAddressesOnCart.cart.shipping_addresses[0].available_shipping_methods : [];
  var getShippingMethods = async (shippingAddress) => {
    const { maskedId, getMaskedId } = useCartStore();
    const formattedShippingAddress = formatAddress$1(shippingAddress);
    let cartId;
    if (!maskedId) {
      cartId = await getMaskedId();
    } else {
      cartId = maskedId;
    }
    const formattedAddress = {
      firstname: formattedShippingAddress.firstname,
      lastname: formattedShippingAddress.lastname,
      company: formattedShippingAddress.company,
      street: formattedShippingAddress.street,
      city: formattedShippingAddress.city,
      region: formattedShippingAddress.region,
      region_id: formattedShippingAddress.region_id || null,
      postcode: formattedShippingAddress.postcode,
      country_code: formattedShippingAddress.country_code ? formattedShippingAddress.country_code : formattedShippingAddress.country.code,
      telephone: formattedShippingAddress.telephone,
      save_in_address_book: convertBoolean(formattedShippingAddress.save_in_address_book)
    };
    const { countries } = useConfigStore();
    const foundCountry = countries.find((country) => country.two_letter_abbreviation === formattedShippingAddress.country_code);
    if (foundCountry && foundCountry.available_regions) {
      const foundRegion = foundCountry.available_regions.find((region) => region.name === formattedShippingAddress.region);
      if (foundRegion) {
        formattedAddress.region = foundRegion.code;
      }
    }
    const formattedAddressGraphQL = mapToGraphQLString(formattedAddress);
    const request3 = buildShippingAddressMutation(cartId, formattedAddressGraphQL);
    return graphQlRequest(request3).then(mapShippingMethods);
  };
  var getNominatedDates = () => false;
  var setClickAndCollectAgent = (agentId) => {
    const request3 = `
    mutation {
      CollectPlusUpdateAgent(agent_id: "${agentId}")
    }`;
    return graphQlRequest(request3);
  };
  var updateAmastyClickCollectStores = async (radius, lat, lng) => {
    const cartStore = useCartStore();
    const cartData = await cartStore.getCartData();
    const headers = {
      "X-Requested-With": "XMLHttpRequest"
    };
    const data2 = `lat=${lat}&lng=${lng}&radius=${Number(radius)}&product=0&category=0&sortByDistance=1`;
    return axios.post(`${cartData.store_pickup.map_data.ajax_call_url}`, data2, { headers }).then((response) => JSON.parse(response.data));
  };
  const formatAddress = (address) => {
    if (!address) {
      return address;
    }
    const clonedAddress = deepClone(address);
    clonedAddress.region_id = clonedAddress.region.region_id;
    clonedAddress.region = clonedAddress.region.region_code || clonedAddress.region.region;
    if (!clonedAddress.region_id) {
      delete clonedAddress.region_id;
    }
    if (!clonedAddress.region) {
      delete clonedAddress.region;
    }
    delete clonedAddress.id;
    delete clonedAddress.email;
    delete clonedAddress.editing;
    delete clonedAddress.country_id;
    delete clonedAddress.same_as_billing;
    delete clonedAddress.same_as_shipping;
    delete clonedAddress.region_code;
    delete clonedAddress.default_shipping;
    delete clonedAddress.default_billing;
    delete clonedAddress.country;
    delete clonedAddress.available_shipping_methods;
    delete clonedAddress.save_in_address_book;
    delete clonedAddress.selected_shipping_method;
    clonedAddress.save_in_address_book = !!clonedAddress.save_in_address_book;
    return clonedAddress;
  };
  var setAddressesOnCart = async (shippingAddress, billingAddress, email = false) => {
    const { maskedId } = useCartStore();
    const { isLoggedIn } = useCustomerStore();
    const request3 = `
    mutation SetAddresses(
      $cartId: String!,

      ${shippingAddress && shippingAddress.firstname ? `
        $shippingAddresses: [ShippingAddressInput]!,
        ` : ""}

      $billingAddress: BillingAddressInput!
      ${email && !isLoggedIn ? "$email: String!" : ""}
    ) {

      ${email && !isLoggedIn ? `
        setGuestEmailOnCart(
          input: {
            cart_id: $cartId
            email: $email
          }
        ) {
          cart {
            id
          }
        }` : ""}

      ${shippingAddress && shippingAddress.firstname ? `
        setShippingAddressesOnCart(
          input: {
            cart_id: $cartId
            shipping_addresses: $shippingAddresses
          }
        ) {
          cart {
            id
          }
        }` : ""}

      setBillingAddressOnCart(
        input: {
          cart_id: $cartId
          billing_address: $billingAddress
        }
      ) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    const variables = {
      cartId: maskedId,
      shippingAddresses: [{
        address: formatAddress(shippingAddress)
      }],
      billingAddress: {
        address: formatAddress(billingAddress)
      },
      ...email ? { email } : {}
    };
    return graphQlRequest(request3, variables).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.setBillingAddressOnCart;
    });
  };
  var useShippingMethodsStore = defineStore("shippingMethodsStore", {
    state: () => ({
      shippingMethods: [],
      nominatedDayEnabled: false,
      nominatedDates: false,
      nominatedSelectedMethod: false,
      nominatedSelectedDate: false,
      nominatedSelectedDateFormatted: false,
      selectedMethod: {},
      cache: {},
      isClickAndCollect: false,
      clickAndCollectLocation: {},
      amastyClickAndCollectData: {},
      amastySelectedStore: null,
      amastyClickCollectUpdatedStores: {}
    }),
    getters: {
      getError: (state) => state.shippingMethods.filter((rate) => rate.error_message !== "")[0]
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      setShippingMethods(shippingMethods2) {
        this.setData({
          shippingMethods: shippingMethods2
        });
        return shippingMethods2;
      },
      async getShippingMethods() {
        const { setLoadingState } = useLoadingStore();
        setLoadingState(true);
        const cartStore = useCartStore();
        const customerStore = useCustomerStore();
        await this.getNominatedDeliveryMethods(customerStore.selected.shipping.postcode);
        const clonedAddress = cleanAddress$1({ ...customerStore.selected.shipping });
        const isValid = customerStore.validateAddress("shipping") && customerStore.validatePostcode("shipping");
        if (!isValid) {
          setLoadingState(false);
          const stepsStore = useStepsStore();
          stepsStore.goToYouDetails();
          return;
        }
        const result = await this.getCachedResponse(getShippingMethods, "getShippingMethods", clonedAddress);
        cartStore.handleCartData(result);
        const methods = result.shipping_addresses[0].available_shipping_methods;
        this.setShippingMethods(methods);
        let isMethodAvailable = false;
        if (this.selectedMethod.carrier_code) {
          isMethodAvailable = methods.find((method) => method.method_code === this.selectedMethod.method_code);
        }
        if (this.selectedMethod.carrier_code === "nominated_delivery") {
          const shippingMethodsSliced = methods.slice(0, -1);
          const cheapestFromSliced = shippingMethodsSliced.reduce((prev, curr) => prev.price_incl_tax < curr.price_incl_tax ? prev : curr, {});
          this.selectShippingMethod(cheapestFromSliced);
        }
        if (methods.length && (!isMethodAvailable || !this.selectedMethod.carrier_code)) {
          const cheapest = methods.reduce((prev, curr) => prev.carrier_code && prev.amount.value < curr.amount.value ? prev : curr, {});
          if (cheapest.carrier_code === "nominated_delivery" || cheapest.carrier_code === "amstorepickup") {
            const shippingMethodsSliced = methods.slice(0, -1);
            const cheapestFromSliced = shippingMethodsSliced.reduce((prev, curr) => prev.price_incl_tax < curr.price_incl_tax ? prev : curr, {});
            this.selectShippingMethod(cheapestFromSliced);
          } else {
            this.selectShippingMethod(cheapest);
          }
          await this.submitShippingInfo(cheapest.carrier_code, cheapest.method_code);
        }
        setLoadingState(false);
      },
      async setDefaultShippingMethod() {
        var _a, _b, _c, _d, _e, _f;
        const cartStore = useCartStore();
        if (!((_c = (_b = (_a = cartStore.cart.shipping_addresses) == null ? void 0 : _a[0]) == null ? void 0 : _b.selected_shipping_method) == null ? void 0 : _c.length) && ((_f = (_e = (_d = cartStore.cart.shipping_addresses) == null ? void 0 : _d[0]) == null ? void 0 : _e.available_shipping_methods) == null ? void 0 : _f.length)) {
          const shippingMethod = cartStore.cart.shipping_addresses[0].available_shipping_methods[0];
          this.submitShippingInfo(shippingMethod.carrier_code, shippingMethod.method_code);
        }
      },
      async getNominatedDeliveryMethods(postcode) {
        this.nominatedDates = false;
        try {
          const nominatedDates = await this.getCachedResponse(getNominatedDates, "getNominatedDeliveryMethods", postcode);
          if (nominatedDates) {
            if (Object.keys(nominatedDates) < 1) {
              this.nominatedDayEnabled = false;
              return;
            }
            this.nominatedDates = nominatedDates;
            this.nominatedDayEnabled = true;
          }
        } catch {
        }
      },
      selectShippingMethod(item) {
        if (item.carrier_code && this.$state.selectedMethod.carrier_code && item.carrier_code !== this.$state.selectedMethod.carrier_code) {
          const gtmStore = useGtmStore();
          gtmStore.trackGtmEvent({
            event: "checkoutOption",
            ecommerce: {
              checkout_option: {
                actionField: {
                  step: 2,
                  option: "shipping"
                }
              }
            }
          });
        }
        const clonedMethod = deepClone(item);
        this.$patch({
          selectedMethod: clonedMethod
        });
        this.clearSubmitShippingInfoCache();
      },
      setShippingDataFromCartData(data2) {
        var _a, _b;
        this.setData({
          shippingMethods: (_a = data2.shipping_addresses) == null ? void 0 : _a[0].available_shipping_methods,
          selectedMethod: (_b = data2.shipping_addresses) == null ? void 0 : _b[0].selected_shipping_method
        });
      },
      async setAddressesOnCart() {
        const customerStore = useCustomerStore();
        const cartStore = useCartStore();
        const response = await setAddressesOnCart(customerStore.selected.shipping, customerStore.selected.billing);
        cartStore.handleCartData(response.cart);
      },
      async submitShippingInfo(carrierCode, methodCode) {
        const { setLoadingState } = useLoadingStore();
        setLoadingState(true);
        const cart = await setShippingMethodOnCart(carrierCode, methodCode);
        const cartStore = useCartStore();
        cartStore.handleCartData(cart);
        await afterSubmittingShippingInformation();
        setShippingMethodDataLayer();
        setLoadingState(false);
      },
      async setAsClickAndCollect(agentId) {
        const { setLoadingState } = useLoadingStore();
        setLoadingState(true);
        await setClickAndCollectAgent(agentId);
        setLoadingState(false);
      },
      async setClickAndCollect() {
        if (!this.isClickAndCollect) {
          const customerStore = useCustomerStore();
          if (customerStore.inputsSanitiseError) {
            customerStore.createNewAddress("shipping");
            customerStore.createNewAddress("billing");
          }
          await customerStore.getCustomerInformation();
          customerStore.selected.billing.same_as_shipping = true;
          this.setData({
            isClickAndCollect: true
          });
        }
      },
      async setNotClickAndCollect() {
        if (this.isClickAndCollect) {
          const customerStore = useCustomerStore();
          this.$state.selectedMethod = {};
          await this.setAsClickAndCollect("");
          if (customerStore.inputsSanitiseError) {
            customerStore.createNewAddress("shipping");
            customerStore.createNewAddress("billing");
          }
          await customerStore.getCustomerInformation();
          customerStore.selected.billing.same_as_shipping = true;
          this.setData({
            isClickAndCollect: false
          });
        }
      },
      setClickAndCollectLocation(location2) {
        this.setData({
          clickAndCollectLocation: {
            ...location2,
            lat: parseFloat(location2.lat),
            long: parseFloat(location2.long)
          }
        });
      },
      async searchAmastyClickCollectStores(radius, lat, lng) {
        const response = await updateAmastyClickCollectStores(radius, lat, lng);
        const stores = response.items;
        this.setData({
          amastyClickCollectUpdatedStores: {
            stores
          }
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCaches(cacheKeys) {
        if (cacheKeys.length) {
          cacheKeys.forEach((cacheKey) => {
            this.setData({
              cache: {
                [cacheKey]: void 0
              }
            });
          });
        }
      },
      clearShippingMethodCache() {
        this.clearCaches(["getNominatedDeliveryMethods", "getShippingMethods"]);
        this.clearSubmitShippingInfoCache();
      },
      clearSubmitShippingInfoCache() {
        this.clearCaches(["submitShippingInfo"]);
      }
    }
  });
  var addCartItem = (product) => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      addSimpleProductsToCart(input: {
        cart_id: "${maskedId}"
        cart_items: [
          {
            data: {
              sku: "${product.sku}"
              quantity: "1"
              selected_options: []
              entered_options: []
            }
          }
        ]
      }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.addSimpleProductsToCart.cart;
    });
  };
  var addGiftCardCode = (code2) => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      applyGiftCardToCart(input: {
        cart_id: "${maskedId}"
        gift_card_code: "${code2}"
      }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.applyGiftCardToCart.cart;
    });
  };
  var addDiscountCode = (coupon) => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      applyCouponToCart(input: {
        cart_id: "${maskedId}"
        coupon_code: "${coupon}"
      }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.applyCouponToCart.cart;
    });
  };
  var getBaseRestUrl = () => {
    const { storeCode } = useConfigStore();
    return `${getBaseUrl()}/rest/${storeCode}/V1`;
  };
  var getAmastyShippingInfo = () => {
    const url = `${getBaseRestUrl()}/amasty_shipbar/mine/bar/data`;
    const data2 = {
      customerGroup: 0,
      page: "cart",
      position: [10]
    };
    return axios.post(url, data2).then((response) => response.data).catch(() => ({}));
  };
  var tokenTypes = {
    authKey: "AUTHKEY",
    guestUser: "GUESTUSER",
    phpSessionId: "PHPSESSIONID"
  };
  var handleServiceError = (error) => {
    var _a, _b;
    let message = "";
    if ((_b = (_a = error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message) {
      message = error.response.data.message;
    } else if (error.message) {
      message = error.message;
    } else {
      message = globalThis.$t("errorMessages.unexpectedPaymentError");
    }
    throw new Error(message);
  };
  var authenticatedRequest = () => {
    const instance = axios.create({
      baseURL: getBaseRestUrl()
    });
    instance.interceptors.request.use((config) => {
      const { customer: { token, tokenType } } = useCustomerStore();
      const customConfig = config;
      customConfig.headers["X-Requested-With"] = "XMLHttpRequest";
      if (tokenType === tokenTypes.authKey) {
        customConfig.headers.Authorization = `Bearer ${token}`;
      } else if (tokenType === tokenTypes.phpSessionId || tokenType === tokenTypes.guestUser) {
        customConfig.withCredentials = true;
      }
      return customConfig;
    }, (error) => Promise.reject(error));
    return instance;
  };
  var getCartData = () => {
    const { customer: { token, tokenType } } = useCustomerStore();
    const builtPath = tokenType === tokenTypes.guestUser ? `${getBaseRestUrl()}/checkout/${token}/data` : `${getBaseRestUrl()}/checkout/mine/data`;
    return authenticatedRequest().get(builtPath).then((response) => JSON.parse(response.data)).then((response) => response.result).catch(handleServiceError);
  };
  var formatPrice = (price) => {
    const { currencyCode: currency = "GBP", locale } = useConfigStore();
    return new Intl.NumberFormat(locale, { style: "currency", currency }).format(price);
  };
  const mergeProductCrosssells = (items) => items.reduce((prev, item) => item.crosssell_products ? prev.concat(item.crosssell_products) : prev, []);
  const convertToString = (sku) => `"${sku}"`;
  var getCrosssells = (items) => {
    const productSkus = items.map(({ product: { sku } }) => sku);
    const request3 = `{
    products (
      filter: {
        sku: {
          in: [${productSkus.map(convertToString).join(",")}]
        }
      }
      pageSize: 10
    ) {
      items {
        crosssell_products {
          id
          __typename
          name
          stock_status
          thumbnail {
              url
              label
          }
          sku
          url_rewrites {
            url
          }
          price_range {
              minimum_price {
                  final_price {
                      value
                  }
              }
          }
        }
      }
    }
  }`;
    return graphQlRequest(request3).then((data2) => data2.data.products.items.length ? mergeProductCrosssells(data2.data.products.items).filter((value, index, self2) => index === self2.findIndex((t) => t.place === value.place && t.name === value.name)) : []).then((data2) => data2.filter((product) => product.stock_status === "IN_STOCK" && product.price_range.minimum_price.final_price.value && product.__typename === "SimpleProduct" && !productSkus.some((productSku) => productSku === product.sku))).then((data2) => data2.map((product) => ({
      formattedPrice: formatPrice(product.price_range.minimum_price.final_price.value),
      ...product
    })));
  };
  var mergeGuestCart = (quoteId, customerId, storeId) => authenticatedRequest().put(`${getBaseRestUrl()}/guest-carts/${quoteId}`, {
    customerId,
    storeId,
    cartId: quoteId
  }).then((response) => response.data);
  var removeCartItem = (uid2) => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      removeItemFromCart(input: {
        cart_id: "${maskedId}"
        cart_item_uid: "${uid2}"
      }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.removeItemFromCart.cart;
    });
  };
  var removeGiftCardCode = (code2) => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      removeGiftCardFromCart(input: {
        cart_id: "${maskedId}"
        gift_card_code: "${code2}"
      }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.removeGiftCardFromCart.cart;
    });
  };
  var updateCartItemQuantity = (item, change) => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      updateCartItems(input: {
        cart_id: "${maskedId}"
        cart_items: [{
          cart_item_uid: "${item.uid}"
          quantity: "${item.quantity + change}"
          customizable_options: []
        }]
      }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.updateCartItems.cart;
    });
  };
  var removeDiscountCode = () => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      removeCouponFromCart(input: {
        cart_id: "${maskedId}"
      }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.removeCouponFromCart.cart;
    });
  };
  var removeRewardPoints = () => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      removeRewardPointsFromCart(cartId: "${maskedId}") {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.removeRewardPointsFromCart.cart;
    });
  };
  var useRewardPoints = () => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      applyRewardPointsToCart(cartId: "${maskedId}") {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.applyRewardPointsToCart.cart;
    });
  };
  var useStoreCredit = () => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      applyStoreCreditToCart(input: { cart_id: "${maskedId}" }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.applyStoreCreditToCart.cart;
    });
  };
  var refreshCustomerData = (sections = []) => {
    const { secureBaseUrl } = useConfigStore();
    const params = new URLSearchParams({
      sections,
      force_new_section_timestamp: false,
      _: new Date().getTime()
    });
    const url = `${secureBaseUrl}customer/section/load/?${params.toString()}`;
    const headers = {
      "X-Requested-With": "XMLHttpRequest"
    };
    return axios.get(url, { headers }).then((response) => response.data).then((data2) => {
      const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
      sections.forEach((section) => {
        mageCache[section] = data2[section];
      });
      localStorage.setItem("mage-cache-storage", JSON.stringify(mageCache));
    });
  };
  var removeStoreCredit = () => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      removeStoreCreditFromCart(input: { cart_id: "${maskedId}" }) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      return response.data.removeStoreCreditFromCart.cart;
    });
  };
  var getDummyCartItems = () => [
    {
      __typename: "ConfigurableCartItem",
      id: "168",
      uid: "MTY4",
      configurable_options: [
        {
          option_label: "Size",
          value_label: "M"
        },
        {
          option_label: "Color",
          value_label: "Blue"
        }
      ],
      gift_wrapping: null,
      product: {
        name: "Proteus Fitness Jackshirt",
        sku: "MJ12",
        id: 430,
        thumbnail: {
          url: foamRoll,
          label: "Proteus Fitness Jackshirt"
        },
        price_range: {
          minimum_price: {
            final_price: {
              value: 45
            }
          }
        }
      },
      quantity: 1,
      errors: null
    },
    {
      __typename: "GiftCardCartItem",
      id: "170",
      uid: "MTcw",
      recipient_name: "BlueFinch Checkout",
      recipient_email: "checkout@bluefinch.co.uk",
      sender_name: "BlueFinch Commerce",
      sender_email: "hello@bluefinch.co.uk",
      message: "Thanks for using BlueFinch Checkout",
      amount: {
        value: 25
      },
      product: {
        name: "Luma Virtual Gift Card",
        sku: "243-MB09",
        id: 2042,
        thumbnail: {
          url: yogaBrick,
          label: "Luma Virtual Gift Card"
        },
        price_range: {
          minimum_price: {
            final_price: {
              value: 25
            }
          }
        }
      },
      quantity: 1,
      errors: null
    },
    {
      __typename: "SimpleCartItem",
      id: "171",
      uid: "MTcx",
      gift_wrapping: null,
      product: {
        name: "Strive Shoulder Pack",
        sku: "24-MB04",
        id: 2,
        thumbnail: {
          url: yogaStrap,
          label: "Strive Shoulder Pack"
        },
        price_range: {
          minimum_price: {
            final_price: {
              value: 32
            }
          }
        }
      },
      quantity: 1,
      errors: null
    }
  ];
  var getDummyGiftCards = () => [
    {
      code: "012ABIKQJS67",
      expiration_date: null,
      current_balance: {
        currency: "USD",
        value: 10
      },
      applied_balance: {
        currency: "USD",
        value: 10
      }
    }
  ];
  var getDummyCartPrices = () => ({
    grand_total: {
      value: 92,
      currency: "USD"
    },
    subtotal_including_tax: {
      value: 102,
      currency: "USD"
    },
    subtotal_excluding_tax: {
      value: 102,
      currency: "USD"
    },
    discounts: [
      {
        amount: {
          value: 10,
          currency: "USD"
        },
        label: "Gift Cards"
      }
    ]
  });
  var getDummyShippingAddresses = () => [
    {
      firstname: "BlueFinch",
      lastname: "Commerce",
      street: [
        "20 Middle St"
      ],
      city: "Brighton and Hove",
      postcode: "BN1 1AL",
      region: {
        code: null,
        label: null
      },
      country: {
        code: "GB",
        label: "GB"
      },
      telephone: "01273030390",
      available_shipping_methods: [
        {
          amount: {
            currency: "USD",
            value: 0
          },
          available: true,
          carrier_code: "freeshipping",
          carrier_title: "1 Working Day",
          error_message: "",
          method_code: "freeshipping",
          method_title: "Free Delivery",
          price_excl_tax: {
            value: 0,
            currency: "USD"
          },
          price_incl_tax: {
            value: 0,
            currency: "USD"
          }
        },
        {
          amount: {
            currency: "USD",
            value: 10
          },
          available: true,
          carrier_code: "flatrate",
          carrier_title: "2-3 Working Days",
          error_message: "",
          method_code: "flatrate",
          method_title: "Standard Delivery",
          price_excl_tax: {
            value: 10,
            currency: "USD"
          },
          price_incl_tax: {
            value: 10,
            currency: "USD"
          }
        }
      ],
      selected_shipping_method: {
        amount: {
          value: 0,
          currency: "USD"
        },
        carrier_code: "freeshipping",
        carrier_title: "1 Working Days",
        method_code: "freeshipping",
        method_title: "Free Delivery"
      }
    }
  ];
  var toneBand = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gA7Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBxdWFsaXR5ID0gODAK/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8IAEQgAlgCWAwEiAAIRAQMRAf/EABwAAQACAwEBAQAAAAAAAAAAAAAEBgMFBwIBCP/EABcBAQEBAQAAAAAAAAAAAAAAAAABAgP/2gAMAwEAAhADEAAAAeqAAAAAAAAAAAAAAMVFL+qtqAAAAAAABpyk9E5h1eKtD1s0vjz6oAAAAYjK08c3/Jt/sY0V55L1aqLnzx4zdA4n2k9igAAPnI71yLcj+JetiRta5MjdztPm6T3707ndxdKP826FX69rI/QnqnXHFAA5vz+5UjUzQpEMk45HohS8GGJGSF6NhlhfdydrfsfN6v0KkXfNAA5tz7uPJa1MPbxTEzfLMePN8IOTznzcPiX8qJJySDo9+p1xgAB8+jUQ7GKpq7+OU67s4/P2D9Daw4Zj7JDrlO2tVkjZbQAAAAAAAAAAAAAAAAAAAAAP/8QALxAAAQMDAgMHAgcAAAAAAAAAAgEDBAAFEQYSECAhExQiIyQwMiUxMzQ1QEFQYP/aAAgBAQABBQL/AALrgtN73r28CpanP2Gp5ROPxWhYj6gJpGbXIeiSPeukxIcVhjFuBdw6qP1EaV9HAkMfcJUFH3SvF11Q4jLEFd0LVSeqsAd4t2mJqqnsuOA0Ltyhtg1d4jlX64CTNltiRB1O5vu1t/TtVAuNKL5kslt99AkMOdVREutwKaZAo0LxBSPFvbI6XBKEl4BnTXnG7VOOI7ciKdJtVybjw5d6HZGuzkZ8SQx5L+/2NuzWaf6GlA8o0DiLWaleJY3y3VvSt1SS8Wl5CuwOTVjnmZrNOL4hBFEh20i4oXaM8k2XT5LupCpwsrpD8Hk1Z+f4F8h+NEPFFxXaJjelK7w0kX0/k1Y15uKxRJ1T7cFTgiZratYWsLQBitJJ5PJdonfIj0V1pezpwMKKZTHH+R+3DHXFaXTEHlVMo7bYjirZoa0ViiU7p9aOwykorZLCn4xtkIdNi1toE6tNZW2R+6w/cIUJHLdDcp2xwzotPs1LsLjaWa3d0a/vP//EABQRAQAAAAAAAAAAAAAAAAAAAGD/2gAIAQMBAT8BSf/EACARAAIBBAEFAAAAAAAAAAAAAAABEQIQICESMDFAUFH/2gAIAQIBAT8B9TShqNoT+2jZxQ0ksEVO3YT2SVPF3RBHRnyP/8QAORAAAgECAgcEBwYHAAAAAAAAAQIAAyEEERASICIxUWEwMnGBExQjQUJzwTNAkqGx8FBSYGJygtH/2gAIAQEABj8C/oEvUOqo4mFULUsCnE+9otN6rHDtZdb4f39fuK4amd1eI5mJTQZBRKKVhmGf8oMDis2U/ZVOY7cv8ZsomJxuIuzdzPnnxgPOUV5LnKFdxn6vUAPh+zAynNTcHtSTYCLTUkJwXoJhsLTsovMOedNf0lI/2fWYygffGwdXit0/52WtUdUXmxymt6xTbopzl2Kf5CLh8Mwc1OJXlPS1Pt2H4Y4/kAEw3y1/SUGHUTEL0Ed1+GpreRist1YZjsCTwEK8KANhOYljOcu2UzNzAEquAOTRUqVGZc87xmp6pzGW9DWIVSRlKdGvrZrbWmWGB1+ZEBruaiOd7OBlOam4OywHGpu6baL3EtoEvsDpDTbjTOXls0KfQnZvLS+xbQZXN/ds0/l/U6TBotpvo4y2h194fZoVOmrpPZZmYg9RslF74us9ojL4icO0qfM+g2rzNqI/1tO434jN30inxns6w8xN0I3gZfDv5DObyMviJlpF4LEk8BziUz3uLePa5MAR1m9h6fkMpuh08Gm7VceMDYU+kPI2mvXyNc/l/Hf/xAArEAEAAgEDAQcEAgMAAAAAAAABABEhMUFRYSBxgZGhscEQMNHwQOFQYPH/2gAIAQEAAT8h/wBBCaO02lvPUGF4iIvyb83Bj/iGSz+BZUqS3YK0ko53jwqJrUpl9SGro3pseHt9/Ep75MSypBamlfN8wR9AM1Lwu9/qW2TzHZ7CBaDQ3PuqWCtXYloJtmzq984uh6GD5l66o9E71U9UPQWnopj2joa9nG/2nSuAEVKhs0+UILfj8Vk1wYW+54wvkyOBxFV0H8r+Y7/WwjBisz5f3HEN2vlf5mP3EOcleTHzoE5H7DN0Fq7Rk+YfV6wyxh7BRttTClp0DDWxt2CEygQqYt6BXmB2twgOKEDZiXzTaCyrxM1q6YlNgG8dSFaDQ3OzbSmr46+kYKymJhIsYmKg6amekGp0grcomnLRBNMzo+nkUum72T57LZWDzuPj61j6Q0uFjPhzEVrMvxjLiVuoLqYmGISFahEepOTG/wCeymvav0Cesi8iLjrN+HGsqaYNTTFEAMxcYQcy1+rfBDspwV27m/nsFafd9QmiylGTxTNVM6oiidEvR7OFw9zzxEAsNaUtyj21rMTWka7SokRtKVvDHEscM0YT1RbtAIAR2ZTjep9s25kobcgD8TKW9K43+g9ajjcr9lTWEcxLrNYlHmTBFoxBNQGVxFovG5fteH3W71sLJ+w13T3Ab3uJM90D+IUneq8esah34yHg/wA7/9oADAMBAAIAAwAAABDzzzzzzzzzzzzzzzDzzzzzzzzrfTzzzzzwZTfrzzzwztsOdhpTzy/mG13GHzzzwzFlTDTzzzwwx5Ej7zzzzzzzzzzzzzzzzzzzzzz/xAAbEQEAAgMBAQAAAAAAAAAAAAABABEQIFAhMf/aAAgBAwEBPxDkrBuOL8lsG9EgY+ypUDU43//EABwRAQACAwEBAQAAAAAAAAAAAAEAERAgITFAUP/aAAgBAgEBPxD8Cr0NSeuMERQkRzi5jRUSwiCQXxPRAy3hoM8weYFsrOI6nJcLG8F+f//EACsQAQACAQMDAwMDBQAAAAAAAAEAESExQVFhcYGRobEgMNEQ4fBAUGDB8f/aAAgBAQABPxD/AAFNdm6BD+GSXZvWQNbah2zpfbjsSjtg4sqAQRLE3/oFY269APNCY5WUnLLjDLqrbfWdWQREF1LTqE0owS6Fi96aeDiq+8P2xdumqcGr4N5rlG/SB4VfBGi+3slxMhSnqU/0hWbKqxun8yQSiULELE8fdRuB6gC1Zg+GGLCvUC+htBsoWOx5/X0RtWF8pExcZXb8kfEaS25i8JfETxWhZq+0tnRePtOhVBKV0LUJtCg1uAX7RidNCT3oeWH1ATSWoKbrU4OsNsqgNppry6W+DlQ9e2aX7uXOdR6LPZzCAc6F6hBwuBcaj2KkAqAugLH0fsGhccwAtWGhYNeosO0XtflX0Pc1DrEy5Lwsn7R3Qx64YT6gQHpHOqY7XywcjB0DQAcEKHMxAFXeu7KuP2UqxxSZxFL9rRFXpxXpFXp41sRV3gQ02hWqKph1qF5fEHdqlY8Zgq9ApMbEMIlGxCxOlfTgpTPtZ9pPMHN76zSrZFdp2HMLUvmHDvEuTzB1R0Op3hVkd5QCzZvvX4iIgHuShgehMA+6YGT4IjwK0eX/AITeCO3jo8NOwfTS1HZyoHy9YU3smm9SDibCHU7gcyiIVoIDYDciUyOdmXgbCgjJQK1crGhq3rN2ce0pqIIZYKpc0V00+IBhV8OA8O7+HP08IKZ3Em8TfnVFB4EFdl6MwLcHJtAqhUQt7wiVhuzJ7QK7wAJ8y+C7tQ6aG9isQ6YzzLsZacLnw/TiPPuDQ+fpGuafJCEMW8Hov07xzmZpO8Y0TMPoD2YLVwYZXUqDkDtNiXWV7uWfJ9KMAOMKiZdRTvXEsvyWC+jo+J2TmWoki9Gb24jLNJxpuOmDMNYbsxI4HmWV6kt6F78MGA7kZopJcUpB6fm+os7UhYnaMlfV9jYQWqXA3ysvTWxPIwyxnRZ9RfiXOg46YEAe78x7RNcbFb7JBdgDYO5OdTtGzZXQjIQXgTJArouSdAcy1s7VWWWl7hi3A+7q4OKnhguu1sn61ZaL/WHpLvlofoHymcAwijWAtE6bddrMLVez02x1tNbq2v77/9k=";
  var getDummyCrossSellItems = () => [
    {
      id: 18,
      __typename: "SimpleProduct",
      name: "Pursuit Lumaflex&trade; Tone Band",
      stock_status: "IN_STOCK",
      thumbnail: {
        url: toneBand,
        label: "Pursuit Lumaflex&trade; Tone Band"
      },
      sku: "24-UG02",
      url_rewrites: [
        {
          url: "pursuit-lumaflex-trade-tone-band.html"
        }
      ],
      price_range: {
        minimum_price: {
          final_price: {
            value: 16
          }
        }
      }
    },
    {
      id: 21,
      __typename: "SimpleProduct",
      name: "Sprite Foam Yoga Brick",
      stock_status: "IN_STOCK",
      thumbnail: {
        url: yogaBrick,
        label: "Sprite Foam Yoga Brick"
      },
      sku: "24-WG084",
      url_rewrites: [
        {
          url: "sprite-foam-yoga-brick.html"
        }
      ],
      price_range: {
        minimum_price: {
          final_price: {
            value: 5
          }
        }
      }
    },
    {
      id: 22,
      __typename: "SimpleProduct",
      name: "Sprite Foam Roller",
      stock_status: "IN_STOCK",
      thumbnail: {
        url: foamRoll,
        label: "Sprite Foam Roller"
      },
      sku: "24-WG088",
      url_rewrites: [
        {
          url: "sprite-foam-roller.html"
        }
      ],
      price_range: {
        minimum_price: {
          final_price: {
            value: 19
          }
        }
      }
    },
    {
      id: 45,
      __typename: "GroupedProduct",
      name: "Set of Sprite Yoga Straps",
      stock_status: "IN_STOCK",
      thumbnail: {
        url: yogaStrap,
        label: "Set of Sprite Yoga Straps"
      },
      sku: "24-WG085_Group",
      url_rewrites: [
        {
          url: "set-of-sprite-yoga-straps.html"
        }
      ],
      price_range: {
        minimum_price: {
          final_price: {
            value: 14
          }
        }
      }
    }
  ];
  var getCartItems = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    if (!mageCache.cart) {
      return [];
    }
    return mageCache.cart.items.map((item) => ({
      ...item,
      quantity: item.qty,
      product: {
        name: item.product_name,
        price_range: {
          minimum_price: {
            final_price: {
              value: item.product_price_value
            }
          }
        },
        thumbnail: {
          url: item.product_image.src
        },
        giftMessage: {}
      }
    })).sort((a, b) => parseInt(a.item_id, 10) - parseInt(b.item_id, 10));
  };
  var getCartSectionNames = () => ["cart"];
  var getLocalMaskedId = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.guest_masked_id ? mageCache.cart.guest_masked_id : null;
  };
  var getBasketPath = () => {
    const { useStoreInUrl, storeCode } = useConfigStore();
    return useStoreInUrl ? `/${storeCode}/checkout/cart` : "/checkout/cart";
  };
  var cleanAddress = async () => {
    await refreshCustomerData(getCartSectionNames());
    window.location.replace(getBasketPath());
  };
  var discountCodeDataLayer = (type) => {
    var _a, _b, _c, _d, _e, _f;
    const gtmStore = useGtmStore();
    const {
      cart: {
        applied_coupons: appliedCoupons,
        prices
      }
    } = useCartStore();
    if (appliedCoupons == null ? void 0 : appliedCoupons.length) {
      const { code: code2 } = appliedCoupons[0];
      let label = "";
      let value = 0;
      if ((_a = prices.discounts) == null ? void 0 : _a.length) {
        label = (_c = (_b = prices.discounts[0]) == null ? void 0 : _b.label) != null ? _c : "";
        value = (_f = (_e = (_d = prices.discounts[0]) == null ? void 0 : _d.amount) == null ? void 0 : _e.value) != null ? _f : 0;
      }
      gtmStore.trackGtmEvent({
        event: type,
        discountCode: code2,
        dicountTitle: label,
        discountAmount: value
      });
    }
  };
  var giftCardCodeDataLayer = (type) => {
    const gtmStore = useGtmStore();
    const {
      cart: {
        applied_gift_cards: appliedGiftCards,
        prices
      }
    } = useCartStore();
    if (appliedGiftCards == null ? void 0 : appliedGiftCards.length) {
      const { code: code2 } = appliedGiftCards[0];
      const { label } = prices.discounts[0];
      const { value } = prices.discounts[0].amount;
      gtmStore.trackGtmEvent({
        event: type,
        discountCode: code2,
        dicountTitle: label,
        discountAmount: value
      });
    }
  };
  var useCartStore = defineStore("cartStore", {
    state: () => ({
      id: null,
      cart: {
        applied_gift_cards: getDummyGiftCards(),
        items: getDummyCartItems(),
        prices: getDummyCartPrices(),
        shipping_addresses: getDummyShippingAddresses(),
        is_virtual: false
      },
      customer_is_guest: null,
      subtotalInclTax: null,
      totalSegments: [],
      discountCode: "",
      giftCardCode: getDummyGiftCards()[0].code,
      discountErrorMessage: "The code isn't valid. Verify the code and try again.",
      giftCardErrorMessage: null,
      data: {},
      crosssells: getDummyCrossSellItems(),
      amastyData: {},
      amastyEnabled: false,
      freeShipping: null,
      cache: {},
      cartEmitter: mitt(),
      maskedId: getLocalMaskedId()
    }),
    getters: {
      isItemRequiringDelivery: (state) => Object.values(state.cartItems).some(({ product_type: productType }) => productType !== "giftcard" && productType !== "virtual"),
      getTotalSegment: (state) => (segment) => state.totalSegments.find(({ code: code2 }) => code2 === segment),
      cartItems: (state) => state.cart.items,
      getCartItemsQty: (state) => state.cart.items.reduce((prev, curr) => {
        const totalQuantity = prev + curr.quantity;
        return totalQuantity;
      }, 0),
      cartGrandTotal: (state) => {
        var _a, _b, _c;
        return ((_c = (_b = (_a = state.cart) == null ? void 0 : _a.prices) == null ? void 0 : _b.grand_total) == null ? void 0 : _c.value) ? Math.round(state.cart.prices.grand_total.value * 100) : 0;
      },
      cartDiscountTotal: (state) => {
        var _a, _b;
        return ((_b = (_a = state.cart.prices) == null ? void 0 : _a.discounts) == null ? void 0 : _b.reduce((prev, { amount }) => prev + amount.value, 0)) || 0;
      },
      getCouponValue: (state) => (coupon) => {
        var _a, _b, _c;
        return ((_c = (_b = (_a = state.cart.prices.discounts) == null ? void 0 : _a.find((discount) => discount.label.includes(coupon))) == null ? void 0 : _b.amount) == null ? void 0 : _c.value) || 0;
      },
      getGiftWrappingTotal: (state) => {
        var _a, _b;
        return state.cart.items.reduce((prev, curr) => {
          if (!curr.gift_wrapping) {
            return prev;
          }
          return prev + curr.gift_wrapping.price.value;
        }, ((_b = (_a = state.cart.gift_wrapping) == null ? void 0 : _a.price) == null ? void 0 : _b.value) || 0);
      }
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      async getCart() {
      },
      async getCartData() {
        const data2 = await this.getCachedResponse(getCartData, "getCartData");
        const customerStore = useCustomerStore();
        const { amastySubs } = customerStore;
        if (!Object.keys(amastySubs).length && data2.checkboxes) {
          Object.keys(data2.checkboxes).forEach((checkbox) => {
            customerStore.updateAmastySubscription({
              [checkbox]: data2.checkboxes[checkbox].is_prechecked
            });
          });
        }
        return data2;
      },
      handleCartData(cart) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        if (cart && cart.items.length) {
          const localItems = getCartItems();
          const mappedCartItems = cart.items.map((item) => ({ ...localItems[item.id], ...item }));
          this.setData({
            cart: {
              items: mappedCartItems
            }
          });
        } else {
          cleanAddress();
          return;
        }
        this.setData({
          cart,
          discountCode: (_c = (_b = (_a = cart == null ? void 0 : cart.applied_coupons) == null ? void 0 : _a[0]) == null ? void 0 : _b.code) != null ? _c : "",
          giftCardCode: (_f = (_e = (_d = cart == null ? void 0 : cart.applied_gift_cards) == null ? void 0 : _d[0]) == null ? void 0 : _e.code) != null ? _f : ""
        });
        const customerStore = useCustomerStore();
        const paymentStore = usePaymentStore();
        const shippingMethodsStore = useShippingMethodsStore();
        customerStore.setEmailAddress((_g = cart.email) != null ? _g : "");
        if (cart.billing_address) {
          customerStore.setAddressToStore(cart.billing_address, "billing");
        }
        if (cart.shipping_addresses.length) {
          customerStore.setAddressToStore(cart.shipping_addresses[0], "shipping");
        }
        paymentStore.setPaymentMethods(cart.available_payment_methods);
        shippingMethodsStore.setShippingMethods((_j = (_i = (_h = cart == null ? void 0 : cart.shipping_addresses) == null ? void 0 : _h[0]) == null ? void 0 : _i.available_shipping_methods) != null ? _j : []);
      },
      async updateQuantity(updateItem, change) {
        const { setLoadingState } = useLoadingStore();
        setLoadingState(true);
        try {
          const cart = await updateCartItemQuantity(updateItem, change);
          this.handleCartData(cart);
          this.emitUpdate();
        } catch (error) {
          const { items } = this.cart;
          const updatedItems = items.map((item) => {
            if (item.uid === updateItem.uid) {
              return {
                ...item,
                errors: [{
                  message: error.message
                }]
              };
            }
            return item;
          });
          this.setData({ cart: { items: updatedItems } });
        }
        refreshCustomerData(getCartSectionNames());
        const gtmStore = useGtmStore();
        if (change > 0) {
          gtmStore.addToCartEvent(updateItem.product);
        } else {
          gtmStore.removeFromCartEvent(updateItem.product);
        }
        setLoadingState(false);
      },
      async removeItem(product) {
        const { setLoadingState } = useLoadingStore();
        setLoadingState(true);
        try {
          const cart = await removeCartItem(product.uid);
          this.handleCartData(cart);
          this.emitUpdate();
        } catch (error) {
          console.warn("Unable to remove cart item", error.message);
        }
        this.clearCaches(["getCrosssells"]);
        await this.getCrosssells();
        refreshCustomerData(getCartSectionNames());
        const gtmStore = useGtmStore();
        gtmStore.removeFromCartEvent(product.product, product.quantity);
        setLoadingState(false);
      },
      async addDiscountCode(code2) {
        try {
          const cart = await addDiscountCode(code2);
          this.setData({
            cart,
            discountErrorMessage: null
          });
          discountCodeDataLayer("discountCodeApplied");
        } catch (error) {
          this.setData({
            discountErrorMessage: error.message
          });
        }
      },
      async removeDiscountCode() {
        try {
          discountCodeDataLayer("discountCodeRemoved");
          const cart = await removeDiscountCode();
          this.setData({
            cart,
            discountErrorMessage: null
          });
        } catch (error) {
          this.setData({
            discountErrorMessage: error.message
          });
        }
      },
      async addGiftCardCode(code2) {
        try {
          const cart = await addGiftCardCode(code2);
          this.setData({
            cart,
            giftCardErrorMessage: null
          });
          giftCardCodeDataLayer("giftCardCodeApplied");
        } catch (error) {
          this.setData({
            giftCardErrorMessage: error.message
          });
        }
      },
      async removeGiftCardCode(code2) {
        giftCardCodeDataLayer("giftCardCodeRemoved");
        try {
          const cart = await removeGiftCardCode(code2);
          this.setData({
            cart,
            giftCardErrorMessage: null
          });
        } catch (error) {
          this.setData({
            giftCardErrorMessage: error.message
          });
        }
      },
      async mergeGuestCart(customerId, storeId) {
        const { maskedId } = this.$state;
        if (maskedId) {
          await mergeGuestCart(maskedId, customerId, storeId);
        }
      },
      async getCrosssells() {
        const crosssells = await this.getCachedResponse(getCrosssells, "getCrosssells", this.cart.items);
        this.setData({
          crosssells
        });
        return crosssells;
      },
      async getAmastyShippingData() {
        const data2 = await this.getCachedResponse(getAmastyShippingInfo, "getAmastyShippingInfo");
        if (Object.keys(data2).length > 0) {
          this.setData({
            amastyData: data2,
            amastyEnabled: true
          });
        } else {
          this.setData({
            amastyEnabled: false
          });
        }
        this.calculateFreeShipping();
      },
      async addCartItem(product) {
        const { setLoadingState } = useLoadingStore();
        setLoadingState(true);
        try {
          const cart = await addCartItem(product);
          this.setData({ cart });
        } catch (error) {
          console.warn("Unable to add cart item", error.message);
        }
        this.clearCaches(["getCrosssells"]);
        await this.getCrosssells();
        this.calculateFreeShipping();
        refreshCustomerData(getCartSectionNames());
        const gtmStore = useGtmStore();
        gtmStore.addToCartEvent(product);
        setLoadingState(false);
      },
      calculateFreeShipping() {
        const { goal } = this.amastyData;
        if (goal) {
          this.setData({
            freeShipping: goal - this.subtotalInclTax
          });
        }
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCaches(cacheKeys) {
        if (cacheKeys.length) {
          cacheKeys.forEach((cacheKey) => {
            this.setData({
              cache: {
                [cacheKey]: void 0
              }
            });
          });
        }
      },
      clearAllCaches() {
        this.clearCaches(["getCart", "getCrosssells"]);
      },
      async emitUpdate() {
        this.$state.cartEmitter.emit("cartUpdated");
        refreshCustomerData(getCartSectionNames());
      },
      async useRewardPoints() {
        const cart = await useRewardPoints();
        this.handleCartData(cart);
        this.emitUpdate();
      },
      async removeRewardPoints() {
        const cart = await removeRewardPoints();
        this.handleCartData(cart);
        this.emitUpdate();
      },
      async useStoreCredit() {
        const cart = await useStoreCredit();
        this.handleCartData(cart);
        this.emitUpdate();
      },
      async removeStoreCredit() {
        const cart = await removeStoreCredit();
        this.handleCartData(cart);
        this.emitUpdate();
      },
      clearCartItems(cartItemIds) {
        if (cartItemIds === "all") {
          Object.keys(this.cartItems).forEach((cartItemId) => {
            delete this.cartItems[cartItemId];
          });
          return;
        }
        const cartItemsArray = Array.isArray(cartItemIds) ? cartItemIds : [cartItemIds];
        cartItemsArray.forEach((cartItemId) => {
          delete this.cartItems[cartItemId];
        });
      }
    }
  });
  var getCustomerInformation = async () => {
    const request3 = `{
    customer {
      default_billing
      default_shipping
      email
      firstname
      lastname
      addresses {
        city
        country_code
        default_billing
        default_shipping
        firstname
        id
        lastname
        postcode
        region {
          region
          region_code
          region_id
        }
        region_id
        street
        telephone
      }
      created_at
      reward_points {
        balance {
          points
          money {
            value
          }
        }
        subscription_status {
          balance_updates
        }
      }
      store_credit {
        enabled
        current_balance {
          value
          currency
        }
      }
      is_subscribed
    }
  }`;
    try {
      const response = await graphQlRequest(request3);
      return response.data.customer;
    } catch (error) {
      const customerStore = useCustomerStore();
      customerStore.setData({
        customer: {
          tokenType: tokenTypes.guestUser
        }
      });
      throw error;
    }
  };
  var getDummyCustomerDetails = (sameAsShipping = false) => {
    const address = {
      id: 1,
      street: ["20 Middle St", ""],
      city: "Brighton and Hove",
      region: "",
      country: {
        code: "GB",
        label: "GB"
      },
      postcode: "BN1 1AL",
      company: "",
      telephone: "01273 030390",
      firstname: "BlueFinch",
      lastname: "Commerce",
      editing: false
    };
    if (sameAsShipping) {
      address.same_as_shipping = true;
    }
    return address;
  };
  var getDummySavedAddresses = () => [
    {
      city: "Brighton and Hove",
      country_code: "GB",
      default_billing: true,
      default_shipping: true,
      firstname: "BlueFinch",
      id: 1,
      lastname: "Commerce",
      postcode: "BN1 1AL",
      region: {
        region: null,
        region_code: null
      },
      street: [
        "20 Middle St"
      ],
      telephone: "01273030390"
    },
    {
      city: "Maidenhead",
      country_code: "GB",
      default_billing: false,
      default_shipping: false,
      firstname: "Adobe",
      id: 2,
      lastname: "Commerce",
      postcode: "SL6 8AD",
      region: {
        region: null,
        region_code: null
      },
      street: [
        "Market House"
      ],
      telephone: "1628590000"
    }
  ];
  var isEmailAvailable = async (email) => {
    const request3 = ` {
  isEmailAvailable(email: "${email}") {
    is_email_available
  }
} `;
    return graphQlRequest(request3).then((response) => {
      var _a, _b;
      return typeof ((_b = (_a = response.data) == null ? void 0 : _a.isEmailAvailable) == null ? void 0 : _b.is_email_available) !== "undefined" ? response.data.isEmailAvailable.is_email_available : true;
    });
  };
  var recapchaTypes = {
    invisible: "invisible",
    recaptchaV2: "recaptcha",
    recaptchaV3: "recaptcha_v3"
  };
  var useRecaptchaStore = defineStore("RecaptchaStore", {
    state: () => ({
      v2CheckboxKey: null,
      v2InvisibleKey: null,
      v3Invisible: null,
      failureMessage: "",
      enabled: {
        customerLogin: false,
        placeOrder: false
      },
      tokens: {},
      errors: {},
      cache: {}
    }),
    getters: {
      getTypeByPlacement: (state) => (placement) => state.enabled[placement],
      getRecaptchaError: (state) => (placement) => state.errors[placement],
      isRecaptchaVisible: (state) => (placement) => state.getTypeByPlacement(placement) === recapchaTypes.recaptchaV2
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      getInitialConfigValues() {
        return `
        storeConfig {
          recaptcha_v2_checkbox_key
          recaptcha_v2_invisible_key
          recaptcha_v3_invisible_key
          recaptcha_customer_login
          recaptcha_place_order
          validation_failure_message
        }
      `;
      },
      handleInitialConfig({ storeConfig }) {
        this.setData({
          v2CheckboxKey: storeConfig.recaptcha_v2_checkbox_key,
          v2InvisibleKey: storeConfig.recaptcha_v2_invisible_key,
          v3Invisible: storeConfig.recaptcha_v3_invisible_key,
          failureMessage: storeConfig.validation_failure_message,
          enabled: {
            customerLogin: storeConfig.recaptcha_customer_login,
            placeOrder: storeConfig.recaptcha_place_order
          }
        });
      },
      async addRecaptchaJs(type) {
        await this.getCachedResponse(() => new Promise((resolve2) => {
          window.bluefinchCheckoutRecaptchaLoaded = resolve2;
          const render = type === recapchaTypes.recaptchaV3 ? this.v3Invisible : "explicit";
          const script = document.createElement("script");
          script.src = `https://www.google.com/recaptcha/api.js?onload=bluefinchCheckoutRecaptchaLoaded&render=${render}`;
          script.async = true;
          script.defer = true;
          document.head.appendChild(script);
        }), "addRecaptchaJs");
      },
      setToken(id, token) {
        this.setData({
          errors: {
            [id]: null
          },
          tokens: {
            [id]: token
          }
        });
      },
      resetToken(id) {
        this.setData({
          tokens: {
            [id]: null
          }
        });
      },
      validateToken(id) {
        if (this.$state.enabled[id] && !this.$state.tokens[id]) {
          this.setData({
            errors: {
              [id]: this.$state.failureMessage
            }
          });
          return false;
        }
        return true;
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      }
    }
  });
  var login = (username, password) => {
    const { secureBaseUrl } = useConfigStore();
    const { tokens } = useRecaptchaStore();
    const headers = {
      "X-Requested-With": "XMLHttpRequest"
    };
    return axios.post(`${secureBaseUrl}customer/ajax/login`, {
      username,
      password,
      context: "checkout",
      "g-recaptcha-response": tokens.customerLogin
    }, { headers }).then(({ data: data2 }) => {
      if (data2.errors) {
        throw new Error(data2.message);
      }
      return data2;
    });
  };
  var amastyConsentLogic = (email) => axios.post(`${getBaseRestUrl()}/consent/getStatuses`, {
    email
  }).then((response) => response.data);
  var setGuestEmailOnCart = async (email) => {
    const { maskedId } = useCartStore();
    const request3 = `
    mutation {
      setGuestEmailOnCart(
        input: {
          cart_id: "${maskedId}"
          email: "${email}"
        }
      ) {
        cart {
          ${getFullCart()}
        }
      }
    }`;
    return graphQlRequest(request3).then((response) => response.data.setGuestEmailOnCart.cart);
  };
  var doAddressesMatch = (address1, address2) => {
    const properties = [
      "city",
      "country_code",
      "firstname",
      "lastname",
      "postcode",
      "telephone"
    ];
    const same = properties.every((property) => address1[property] === address2[property]);
    if (!same) {
      return false;
    }
    const steetSame = address1.street.every((element, index) => address1.street[index] === address2.street[index]);
    return steetSame;
  };
  var getEmptyAddress = (sameAsShipping = false) => {
    const address = {
      id: null,
      street: ["", ""],
      city: "",
      region: {
        region: "",
        region_id: "",
        region_code: ""
      },
      country_code: "",
      postcode: "",
      company: "",
      telephone: "",
      firstname: "",
      lastname: "",
      editing: false
    };
    if (sameAsShipping) {
      address.same_as_shipping = true;
    }
    return address;
  };
  var getPhoneValidation = (phone) => {
    const phoneValid = /^[+]?[\d() -]{8,32}$/im.test(phone);
    return phoneValid;
  };
  var getUrlTokens = {
    token: "",
    tokenType: tokenTypes.phpSessionId
  };
  var useCustomerStore = defineStore("customerStore", {
    state: () => ({
      customer: {
        type: "",
        loggedIn: false,
        registered: void 0,
        addresses: getDummySavedAddresses(),
        email: "",
        ...getUrlTokens
      },
      hasPreviouslyOrderedFpf: false,
      emailEntered: false,
      currentStep: "",
      selected: {
        shipping: getDummyCustomerDetails(),
        billing: getDummyCustomerDetails(false),
        formErrors: {
          billing: [],
          shipping: [],
          message: {
            billing: false,
            shipping: false
          }
        },
        regionRequired: {
          billing: {
            required: false,
            regionOptions: []
          },
          shipping: {
            required: false,
            regionOptions: []
          }
        }
      },
      newsletter: {
        subscribeToNewsletter: false,
        isSubscribed: false
      },
      amastySubs: {},
      amastyConsentStatus: {},
      isEmailAvailableController: void 0,
      postCodeValid: false,
      cache: {},
      inputsSanitiseError: false
    }),
    getters: {
      isLoggedIn: (state) => state.customer.tokenType === tokenTypes.authKey || state.customer.tokenType === tokenTypes.phpSessionId,
      getSelectedBillingAddress: (state) => formatAddress$1(cleanAddress({ ...state.selected.billing })),
      getSelectedShippingAddress: (state) => formatAddress$1(cleanAddress({ ...state.selected.shipping })),
      isUsingSavedShippingAddress: (state) => state.customer.addresses.some((address) => address.id === state.selected.shipping.id),
      isUsingSavedBillingAddress: (state) => state.customer.addresses.some((address) => address.id === state.selected.billing.id),
      getAddressFieldHasError: (state) => (addressType, field) => state.selected.formErrors[addressType].find((fieldError) => fieldError === field),
      getRegionOptions: (state) => (addressType) => state.selected.regionRequired[addressType].regionOptions,
      getRegionRequired: (state) => (addressType) => state.selected.regionRequired[addressType].required
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      dummyLogIn(step) {
        this.setData({
          customer: {
            email: "hello@bluefinch.co.uk",
            loggedIn: true
          },
          emailEntered: true,
          currentStep: step
        });
      },
      dummyLogOut(step) {
        this.setData({
          customer: {
            email: "",
            loggedIn: false
          },
          emailEntered: false,
          currentStep: step
        });
      },
      dummyUserType(userType) {
        if (userType === "NoUser") {
          this.setData({
            customer: {
              type: userType,
              email: "",
              loggedIn: false,
              registered: void 0
            },
            emailEntered: false
          });
        } else if (userType === "GuestUser") {
          this.setData({
            customer: {
              type: userType,
              email: "guest@bluefinch.co.uk",
              loggedIn: false,
              registered: false
            },
            emailEntered: true
          });
        } else if (userType === "RegisteredUser") {
          this.setData({
            customer: {
              type: userType,
              email: "hello@bluefinch.co.uk",
              loggedIn: false,
              registered: true
            },
            emailEntered: true
          });
        }
      },
      setAddressToStore(address, addressType) {
        if (addressType === "shipping") {
          const shippingMethodsStore = useShippingMethodsStore();
          if (this.selected.billing.same_as_shipping && !shippingMethodsStore.isClickAndCollect) {
            this.setData({
              selected: {
                billing: Object.assign(address, { email: this.customer.email })
              }
            });
          }
        }
        this.setData({
          selected: {
            [addressType]: Object.assign(address, { email: this.customer.email })
          }
        });
      },
      setAddressAsEditing(addressType, value) {
        this.setData({
          selected: {
            [addressType]: {
              editing: value
            }
          }
        });
      },
      setAddressAsCustom(addressType) {
        this.setData({
          selected: {
            [addressType]: {
              id: "custom"
            }
          }
        });
        if (addressType === "billing") {
          this.setData({
            selected: {
              billing: {
                same_as_shipping: false
              }
            }
          });
        }
      },
      updateRegionRequired(addressType) {
        const { stateRequired } = useConfigStore();
        const currentCountry = this.selected[addressType].country_code;
        this.setData({
          selected: {
            [addressType]: {
              region: {
                region: "",
                region_code: "",
                region_id: 0
              }
            },
            regionRequired: {
              [addressType]: {
                required: false,
                regionOptions: []
              }
            }
          }
        });
        if (stateRequired.indexOf(currentCountry) !== -1) {
          const { countries } = useConfigStore();
          const country = countries.find((cty) => cty.id === currentCountry);
          if (country) {
            const availableRegions = country.available_regions || [];
            const regionOptions = availableRegions.map((region) => ({
              option: {
                name: region.name,
                value: region.id,
                code: region.code
              }
            }));
            this.setData({
              selected: {
                regionRequired: {
                  [addressType]: {
                    required: true,
                    regionOptions
                  }
                }
              }
            });
          }
        }
      },
      addAddressError(addressType, error) {
        const errors = this.selected.formErrors[addressType];
        const index = errors.indexOf(error);
        if (index === -1) {
          errors.push(error);
          this.setData({
            selected: {
              formErrors: {
                [addressType]: errors
              }
            }
          });
        }
      },
      removeAddressError(addressType, error) {
        const errors = this.selected.formErrors[addressType];
        const index = errors.indexOf(error);
        if (index !== -1) {
          errors.splice(index, 1);
          this.setData({
            selected: {
              formErrors: {
                [addressType]: errors
              }
            }
          });
        }
      },
      isEmailAvailable(email) {
        if (this.$state.isEmailAvailableController) {
          this.$state.isEmailAvailableController.abort();
        }
        const controller = new AbortController();
        this.setData({
          isEmailAvailableController: controller
        });
        return isEmailAvailable(email);
      },
      setEmailAddress(email) {
        this.setData({
          customer: {
            email
          }
        });
      },
      async login(email, pass) {
        const data2 = await login(email, pass);
        const cartStore = useCartStore();
        cartStore.setData({
          maskedId: null
        });
        refreshCustomerData(["customer"].concat(getCartSectionNames()));
        this.setData({
          customer: {
            email,
            tokenType: tokenTypes.phpSessionId
          }
        });
        cartStore.clearAllCaches();
        cartStore.clearCartItems("all");
        await cartStore.getCart();
        this.clearCaches(["getCustomerInformation"]);
        await this.getCustomerInformation();
        return data2;
      },
      async getCustomerInformation() {
        if (this.customer.tokenType !== tokenTypes.guestUser) {
          const data2 = await this.getCachedResponse(getCustomerInformation, "getCustomerInformation");
          if (data2) {
            this.setData({
              customer: {
                ...data2,
                id: this.customer.firstname
              }
            });
            this.setEmailEntered();
            const matchedShipping = data2.addresses.findIndex((address) => doAddressesMatch(address, this.selected.shipping));
            if (matchedShipping !== -1) {
              this.setAddressToStore(data2.addresses[matchedShipping], "shipping");
            }
            const matchedBilling = data2.addresses.findIndex((address) => doAddressesMatch(address, this.selected.billing));
            if (matchedBilling !== -1) {
              this.setAddressToStore(data2.addresses[matchedBilling], "billing");
            }
            if (!this.selected.shipping.id && !this.selected.shipping.firstname) {
              const defaultShipping = this.getDefaultAddress(data2, "default_shipping");
              defaultShipping && this.setAddressToStore(defaultShipping, "shipping");
            }
            if (!this.selected.billing.id && !this.selected.billing.firstname) {
              const defaultBilling = this.getDefaultAddress(data2, "default_billing");
              defaultBilling && this.setAddressToStore(defaultBilling, "billing");
            }
            if (!this.selected.shipping.id) {
              this.setAddressAsEditing("shipping", true);
            }
            if (!doAddressesMatch(this.selected.billing, this.selected.shipping)) {
              this.setAddressAsCustom("billing");
            }
            this.setData({
              newsletter: {
                isSubscribed: data2.is_subscribed || false
              }
            });
          }
          if (this.customer.tokenType !== tokenTypes.authKey) {
            const tokenType = data2 ? tokenTypes.phpSessionId : tokenTypes.guestUser;
            this.setData({
              customer: {
                tokenType
              }
            });
          }
          return data2;
        }
        if (!doAddressesMatch(this.selected.billing, this.selected.shipping)) {
          this.setAddressAsCustom("billing");
        }
        return null;
      },
      checkForGuestUser() {
        const maskedId = getLocalMaskedId();
        if (maskedId) {
          this.setMaskedId(maskedId);
        }
      },
      setMaskedId(maskedId) {
        this.setData({
          customer: {
            token: maskedId,
            tokenType: tokenTypes.guestUser
          }
        });
      },
      async submitEmail(email) {
        if (this.customer.tokenType === tokenTypes.guestUser) {
          const cart = await setGuestEmailOnCart(email);
          const cartStore = useCartStore();
          cartStore.handleCartData(cart);
        }
      },
      setEmailEntered() {
        this.setData({ emailEntered: true });
      },
      editEmail() {
        this.setData({ emailEntered: false });
      },
      createNewAddress(addressType) {
        const sameAsShipping = addressType === "billing";
        this.setData({
          selected: {
            [addressType]: getEmptyAddress(sameAsShipping)
          }
        });
      },
      createNewBillingAddress(addressType) {
        this.setData({
          selected: {
            [addressType]: getEmptyAddress(false)
          }
        });
      },
      validateAddress(addressType, addErrors = false) {
        const requiredFields = {
          street: "Address Line 1",
          city: "City",
          country_code: "Country",
          region: "State/Region"
        };
        let valid = true;
        const streetAddress1 = this.selected[addressType].street[0];
        const streetAddress2 = this.selected[addressType].street[1];
        const streetAddressLength = [streetAddress1, streetAddress2].join(" ").length;
        Object.entries(requiredFields).forEach(([key, value]) => {
          addErrors && this.removeAddressError(addressType, value);
          if (key === "street") {
            if (!this.selected[addressType].street[0].trim() || streetAddressLength > 75) {
              addErrors && this.addAddressError(addressType, value);
              valid = false;
            }
          }
          if (key === "region") {
            if (this.selected.regionRequired[addressType].required) {
              if (!this.selected[addressType][key] || typeof this.selected[addressType][key] === "string" && !this.selected[addressType][key].trim()) {
                addErrors && this.addAddressError(addressType, value);
                valid = false;
              }
            }
          } else if (!this.selected[addressType][key] || typeof this.selected[addressType][key] === "string" && !this.selected[addressType][key].trim()) {
            addErrors && this.addAddressError(addressType, value);
            valid = false;
          }
        });
        if (!valid) {
          addErrors && this.setAddressErrorMessage(addressType);
        }
        return valid;
      },
      validatePostcode(addressType, addErrors = false) {
        const configStore = useConfigStore();
        addErrors && this.removeAddressError(addressType, "Country");
        addErrors && this.removeAddressError(addressType, "Postcode");
        let isValid = true;
        if (configStore.postcodeRequired(this.selected[addressType].country_code)) {
          if (!this.selected[addressType].country_code) {
            addErrors && this.addAddressError(addressType, "Country");
          } else {
            const countId = this.selected[addressType].country_code;
            const postCode = this.selected[addressType].postcode;
            if (postcodeValidatorExistsForCountry(countId)) {
              isValid = postcodeValidator(postCode, countId);
            } else {
              isValid = true;
            }
            this.setData({
              postCodeValid: isValid
            });
            !isValid && addErrors && this.addAddressError(addressType, "Postcode");
          }
        }
        this.setData({
          postCodeValid: isValid
        });
        return isValid;
      },
      validateNameField(addressType, fieldName, value, addErrors = false) {
        const invalid = !value || typeof value === "string" && !value.trim();
        if (invalid) {
          addErrors && this.addAddressError(addressType, fieldName);
        } else {
          this.removeAddressError(addressType, fieldName);
        }
        return !invalid;
      },
      validatePhone(addressType, phone, addErrors = false) {
        const isValid = getPhoneValidation(phone);
        if (!isValid) {
          addErrors && this.addAddressError(addressType, "Telephone");
        } else {
          this.removeAddressError(addressType, "Telephone");
        }
        return isValid;
      },
      setAddressErrorMessage(addressType) {
        const address = this.selected.formErrors[addressType];
        if (address.length) {
          const message = `The following fields are missing from your ${addressType} address: ${address.join(", ").toString()}`;
          this.setData({
            selected: {
              formErrors: {
                message: {
                  [addressType]: message
                }
              }
            }
          });
        }
      },
      getDefaultAddress(data2, addressType) {
        const foundAddress = data2.addresses.find((address) => typeof address[addressType] !== "undefined" && address[addressType]);
        return foundAddress ? Object.assign(foundAddress, { editing: false }) : {};
      },
      updateNewsletterSubscription(state) {
        this.setData({
          newsletter: {
            subscribeToNewsletter: state
          }
        });
      },
      updateAmastySubscription(state) {
        this.setData({
          amastySubs: state
        });
      },
      async getAmastyConsentStatus(email) {
        const status = await amastyConsentLogic(email);
        this.setData({
          amastyConsentStatus: status
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCaches(cacheKeys) {
        if (cacheKeys.length) {
          cacheKeys.forEach((cacheKey) => {
            this.setData({
              cache: {
                [cacheKey]: void 0
              }
            });
          });
        }
      }
    }
  });
  var afdPostcode = {
    getAfdConfiguration() {
      const request3 = `{
      storeConfig {
        afd_general_account_type
        afd_general_account_serial_url
        afd_general_account_serial
        afd_general_account_password
        afd_general_account_id_url
        afd_general_account_id
        afd_general_account_token
        afd_response_max_quantity
      }
    }`;
      return graphQlRequest(request3).then((response) => response.data.storeConfig);
    },
    getSuggestions(query, addressType) {
      var _a;
      const { countryCode, afd: { maxQuantity } } = useConfigStore();
      const { selected } = useCustomerStore();
      const afdCountry = ((_a = selected[addressType]) == null ? void 0 : _a.country_code) || countryCode;
      const paramsObj = {
        format: "json",
        intp: "mag010603",
        intf: "jqu011001",
        countryiso: `${afdCountry}`,
        data: "address",
        fields: "fflist",
        task: "fastfindv4",
        lookup: `${query}`,
        allpc: "1",
        matchPositions: "1",
        maxquantity: maxQuantity,
        uniqueid: "89296&_=1664704178149"
      };
      const searchParams = new URLSearchParams(this.addCredentials(paramsObj));
      const requestUrl = `${retrieveUrl$1()}?${searchParams}`;
      return axios.get(requestUrl).then((response) => response.data.Item).catch(this.logResponseErrors);
    },
    logResponseErrors(error) {
      if (axios.isCancel(error))
        console.log("AFD request cancelled");
    },
    getAndUseAddress(id, addressType) {
      var _a;
      const { countryCode } = useConfigStore();
      const { selected } = useCustomerStore();
      const afdCountry = ((_a = selected[addressType]) == null ? void 0 : _a.country_code) || countryCode;
      const paramsObj = {
        format: "json",
        intp: "mag010603",
        intf: "jqu011001",
        countryiso: `${afdCountry}`,
        key: `${id}`,
        data: "address",
        fields: "standard",
        task: "retrieve"
      };
      const searchParams = new URLSearchParams(this.addCredentials(paramsObj));
      return axios.get(`${retrieveUrl$1()}?${searchParams}`).then((response) => {
        if (typeof response.data.Item[0].Error !== "string") {
          return response.data.Item[0];
        }
        return handleError({ error: { message: response.data.Item[0].Error } });
      });
    },
    addCredentials(params) {
      const { afd } = useConfigStore();
      const credentials = afd.type === "id" ? {
        id: afd.id,
        token: afd.token
      } : {
        serial: afd.serial,
        password: afd.password
      };
      return Object.assign(params, credentials);
    }
  };
  var getStoreConfig = (configs = []) => {
    const request3 = `{
    storeConfig {
      ${configs.join(" ")}
    }
  }`;
    return graphQlRequest(request3).then((response) => {
      var _a;
      return (_a = response.data) == null ? void 0 : _a.storeConfig;
    });
  };
  var getBlock = (blockId) => axios.get(`${getBaseRestUrl()}/cmsBlock/${blockId}`).then((response) => response.data);
  var getStoreId = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.storeId ? mageCache.cart.storeId : null;
  };
  var getStoreCode = () => {
    const storeId = getStoreId();
    const request3 = `{
    storecode(store_id: "${storeId}") {
        store_code
    }
  }`;
    return graphQlRequest(request3).then((response) => {
      var _a, _b;
      return (_b = (_a = response.data) == null ? void 0 : _a.storecode) == null ? void 0 : _b.store_code;
    });
  };
  var getPrivacyPolicyId = () => "privacy_policy_content";
  var getGeneralTermsServicesId = () => "general_terms_services";
  var getWithdrawTermsServicesId = () => "withdraw_terms_services";
  var getFallBackStaticPath = () => {
    const element = document.querySelector("[data-static-path]");
    if (element) {
      const { staticPath } = element.dataset;
      const staticPathFragments = staticPath.split("/");
      const staticIndex = staticPathFragments.findIndex((path) => path.startsWith("version"));
      return staticPathFragments.slice(0, staticIndex + 1).join("/");
    }
    return void 0;
  };
  var getStoreCodeFromLocalStorage = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.storeCode ? mageCache.cart.storeCode : null;
  };
  var getLocale = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.locale ? mageCache.cart.locale : null;
  };
  var getCurrencyCode = () => {
    const mageCache = JSON.parse(localStorage.getItem("mage-cache-storage"));
    return mageCache && mageCache.cart && mageCache.cart.currencyCode ? mageCache.cart.currencyCode : void 0;
  };
  var useAgreementStore = defineStore("agreementStore", {
    state: () => ({
      agreements: {},
      showError: false
    }),
    getters: {
      agreementIds: (state) => {
        const agreementValues = state.agreements ? Object.values(state.agreements) : [];
        return agreementValues.map((agreementValue) => agreementValue.agreement_id);
      }
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      getInitialConfigValues() {
        return `
        checkoutAgreements {
          agreement_id
          name
          content
          checkbox_text
          mode
        }
      `;
      },
      handleInitialConfig({ checkoutAgreements }) {
        const formattedAgreements = checkoutAgreements.reduce((prev, curr) => {
          const allAgreements = prev;
          allAgreements[curr.agreement_id] = curr;
          return allAgreements;
        }, {});
        this.setData({ agreements: formattedAgreements });
      },
      updateAgreementData(agreement, approved) {
        this.setData({
          agreements: {
            [agreement.agreement_id]: {
              approved
            }
          },
          showError: false
        });
      },
      validateAgreements() {
        const { agreements } = this;
        const agreementValues = agreements ? Object.values(agreements) : [];
        if (!agreementValues.length) {
          return true;
        }
        const updatedAgreements = agreementValues.map((agreement) => ({
          ...agreement,
          valid: agreement.mode !== "MANUAL" || agreement.approved === true
        }));
        updatedAgreements.forEach((updatedAgreement) => {
          this.setData({
            agreements: {
              [updatedAgreement.agreement_id]: {
                ...updatedAgreement
              }
            }
          });
        });
        const unaprovedAgreements = updatedAgreements.some((agreement) => agreement.mode === "MANUAL" && agreement.valid === false);
        if (unaprovedAgreements) {
          this.setData({
            showError: true
          });
        }
        return !unaprovedAgreements;
      }
    }
  });
  var createClientToken = () => {
    const request3 = `
    mutation {
      createBraintreeClientToken
    }`;
    return graphQlRequest(request3);
  };
  var getVaultedMethods = async () => {
    const request3 = `{
    customerPaymentTokens {
      items {
        public_hash
        payment_method_code
        type
        details
      }
    }
  }`;
    const methods = await graphQlRequest(request3).then((response) => {
      var _a;
      return ((_a = response.data.customerPaymentTokens) == null ? void 0 : _a.items) || [];
    });
    return methods.filter(({ payment_method_code: code2 }) => code2 === "braintree").reduce((prev, curr) => {
      const updated = prev;
      updated[curr.public_hash] = {
        ...curr,
        publicHash: curr.public_hash,
        details: JSON.parse(curr.details),
        selected: false
      };
      return updated;
    }, {});
  };
  var getFilteredLpmMethods = (lpmMethods) => {
    const { selected: { billing: { country } } } = useCustomerStore();
    const methods = {
      bancontact: ["BE"],
      eps: ["AT"],
      giropay: ["DE"],
      ideal: ["NL"],
      sofort: ["AT", "BE", "DE", "ES", "IT", "NL", "GB"],
      mybank: ["IT"],
      p24: ["PL"],
      sepa: ["AT", "DE"]
    };
    return lpmMethods.filter((method) => {
      var _a;
      return (_a = methods[method]) == null ? void 0 : _a.includes(country.code);
    });
  };
  var useBraintreeStore = defineStore("brainteeStore", {
    state: () => ({
      cache: {},
      environment: "sandbox",
      isBraintreeEnabled: null,
      showMagentoPayments: false,
      merchantAccountId: "",
      cCTypes: [],
      clientToken: null,
      clientInstance: null,
      threeDSecureInstance: null,
      vaultActive: false,
      vaultedMethods: {},
      vaultVerifyCvv: false,
      threeDSThresholdAmount: 0,
      threeDSEnabled: false,
      alwaysRequestThreeDS: false,
      errorMessage: null,
      sendCartLineItems: false,
      google: {
        buttonColor: "white",
        cCTypes: [],
        merchantId: "",
        vaultActive: false
      },
      lpm: {
        allowedMethods: [],
        fallbackText: "",
        redirectOnFail: ""
      },
      paypal: {
        merchantNameOverride: null,
        merchantCountry: "",
        requireBillingAddress: false,
        buttonLabel: "",
        buttonColor: "",
        buttonShape: "",
        vaultActive: false,
        creditActive: false,
        creditColor: "",
        creditLabel: "",
        creditShape: ""
      }
    }),
    getters: {
      selectedVaultMethod: (state) => Object.values(state.vaultedMethods).find(({ selected }) => selected),
      getFilteredLpmMethods: (state) => getFilteredLpmMethods(state.lpm.allowedMethods)
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      getInitialConfigValues() {
        return `
        storeConfig {
          braintree_environment,
          braintree_active,
          braintree_merchant_account_id
          braintree_cc_types
          braintree_cc_vault_active
          braintree_cc_vault_cvv
          braintree_send_line_items
          braintree_3dsecure_threshold_amount
          braintree_3dsecure_verify_3dsecure
          braintree_3dsecure_always_request_3ds
          braintree_googlepay_merchant_id
          braintree_googlepay_cctypes
          braintree_googlepay_btn_color
          braintree_googlepay_vault_active
          braintree_paypal_merchant_name_override
          braintree_paypal_merchant_country
          braintree_paypal_require_billing_address
          braintree_paypal_button_location_checkout_type_paypal_label
          braintree_paypal_button_location_checkout_type_paypal_color
          braintree_paypal_button_location_checkout_type_paypal_shape
          braintree_paypal_vault_active
          braintree_paypal_credit_active
          braintree_paypal_credit_color
          braintree_paypal_credit_shape
          braintree_paypal_credit_label
          braintree_local_payment_fallback_button_text
          braintree_local_payment_redirect_on_fail
          braintree_local_payment_allowed_methods
        }
      `;
      },
      handleInitialConfig({ storeConfig }) {
        var _a;
        if (storeConfig) {
          this.setData({
            environment: storeConfig.braintree_environment,
            isBraintreeEnabled: storeConfig.braintree_active,
            merchantAccountId: storeConfig.braintree_merchant_account_id,
            cCTypes: ((_a = storeConfig.braintree_cc_types) == null ? void 0 : _a.split(",")) || [],
            vaultActive: storeConfig.braintree_cc_vault_active === "1",
            vaultVerifyCvv: storeConfig.braintree_cc_vault_cvv,
            sendCartLineItems: storeConfig.braintree_send_line_items,
            threeDSThresholdAmount: storeConfig.braintree_3dsecure_threshold_amount ? parseFloat(storeConfig.braintree_3dsecure_threshold_amount) : 0,
            threeDSEnabled: storeConfig.braintree_3dsecure_verify_3dsecure,
            alwaysRequestThreeDS: storeConfig.braintree_3dsecure_always_request_3ds,
            google: {
              buttonColor: storeConfig.braintree_googlepay_btn_color === "0" ? "white" : "black",
              cCTypes: storeConfig.braintree_googlepay_cctypes ? markRaw(storeConfig.braintree_googlepay_cctypes.split(",")) : [],
              merchantId: storeConfig.braintree_googlepay_merchant_id,
              vaultActive: storeConfig.braintree_googlepay_vault_active
            },
            lpm: {
              allowedMethods: storeConfig.braintree_local_payment_allowed_methods ? storeConfig.braintree_local_payment_allowed_methods.split(",") : [],
              fallbackText: storeConfig.braintree_local_payment_fallback_button_text,
              redirectOnFail: storeConfig.braintree_local_payment_redirect_on_fail
            },
            paypal: {
              merchantNameOverride: storeConfig.braintree_paypal_merchant_name_override,
              merchantCountry: storeConfig.braintree_paypal_merchant_country,
              requireBillingAddress: storeConfig.braintree_paypal_require_billing_address,
              buttonLabel: storeConfig.braintree_paypal_button_location_checkout_type_paypal_label,
              buttonColor: storeConfig.braintree_paypal_button_location_checkout_type_paypal_color,
              buttonShape: storeConfig.braintree_paypal_button_location_checkout_type_paypal_shape,
              vaultActive: storeConfig.braintree_paypal_vault_active,
              creditActive: storeConfig.braintree_paypal_credit_active,
              creditColor: storeConfig.braintree_paypal_credit_color,
              creditShape: storeConfig.braintree_paypal_credit_shape,
              creditLabel: storeConfig.braintree_paypal_credit_label
            }
          });
        }
      },
      async createClientToken() {
        var _a;
        const clientToken = await this.getCachedResponse(createClientToken, "createClientToken");
        if ((_a = clientToken == null ? void 0 : clientToken.data) == null ? void 0 : _a.createBraintreeClientToken) {
          this.setData({
            clientToken: clientToken.data.createBraintreeClientToken
          });
        }
      },
      setClientInstance(clientInstance) {
        this.setData({
          clientInstance
        });
      },
      setThreeDSInstance(threeDSecureInstance) {
        this.setData({
          threeDSecureInstance
        });
      },
      getPayPalLineItems(includeShipping = true) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const items = [];
        if (!this.sendCartLineItems) {
          return items;
        }
        const {
          cart,
          cartItems,
          getCouponValue,
          getGiftWrappingTotal
        } = useCartStore();
        Object.values(cartItems).forEach((cartItem) => {
          const unitAmount = cartItem.__typename === "GiftCardCartItem" ? cartItem.amount.value : cartItem.product.price_range.minimum_price.final_price.value;
          items.push({
            name: cartItem.product.name,
            kind: "debit",
            quantity: cartItem.quantity,
            unitAmount,
            productCode: cartItem.product.sku,
            description: ""
          });
        });
        if (getGiftWrappingTotal) {
          items.push({
            name: this.$i18n.global.t("orderSummary.giftWrappingTitle"),
            kind: "debit",
            quantity: 1,
            unitAmount: Math.abs(getGiftWrappingTotal)
          });
        }
        if (cart.applied_store_credit) {
          items.push({
            name: this.$i18n.global.t("orderSummary.storeCreditTitle"),
            kind: "credit",
            quantity: 1,
            unitAmount: Math.abs(cart.applied_store_credit.applied_balance.value)
          });
        }
        if (cart.applied_reward_points) {
          items.push({
            name: this.$i18n.global.t("orderSummary.rewardsTitle"),
            kind: "credit",
            quantity: 1,
            unitAmount: Math.abs(cart.applied_reward_points.value)
          });
        }
        if (cart.applied_gift_cards) {
          cart.applied_gift_cards.forEach((giftCard) => {
            items.push({
              name: this.$i18n.global.t("giftCardDiscount.title", { code: giftCard.code }),
              kind: "credit",
              quantity: 1,
              unitAmount: Math.abs(giftCard.applied_balance.value)
            });
          });
        }
        if (cart.applied_coupons && !cart.prices.discounts) {
          items.push({
            name: this.$i18n.global.t("couponDiscount.title"),
            kind: "credit",
            quantity: 1,
            unitAmount: Math.abs(getCouponValue(cart.applied_coupons[0].code))
          });
        }
        if (cart.prices.discounts && Object.keys(cart.prices.discounts).length > 0) {
          items.push({
            name: this.$i18n.global.t("couponDiscount.title"),
            kind: "credit",
            quantity: 1,
            unitAmount: Math.abs(cart.prices.discounts[0].amount.value)
          });
        }
        if (includeShipping && (((_d = (_c = (_b = (_a = cart.shipping_addresses) == null ? void 0 : _a[0]) == null ? void 0 : _b.selected_shipping_method) == null ? void 0 : _c.price_incl_tax) == null ? void 0 : _d.value) || ((_h = (_g = (_f = (_e = cart.shipping_addresses) == null ? void 0 : _e[0]) == null ? void 0 : _f.selected_shipping_method) == null ? void 0 : _g.amount) == null ? void 0 : _h.value))) {
          items.push({
            name: this.$i18n.global.t("progressBar.shippingStepTitle"),
            kind: "debit",
            quantity: 1,
            unitAmount: cart.shipping_addresses[0].selected_shipping_method.price_incl_tax.value ? Math.abs(cart.shipping_addresses[0].selected_shipping_method.price_incl_tax.value) : Math.abs(cart.shipping_addresses[0].selected_shipping_method.amount.value)
          });
        }
        return items;
      },
      setErrorMessage(errorMessage) {
        this.setData({
          errorMessage
        });
      },
      clearErrorMessage() {
        this.setData({
          errorMessage: null
        });
      },
      escapeNonAsciiCharacters(str) {
        return str.split("").map((c) => /[^\x00-\x7F]$/.test(c) ? c : c.split("").map((a) => `\\u00${a.charCodeAt().toString(16)}`).join("")).join("");
      },
      async getVaultedMethods() {
        const paymentStore = usePaymentStore();
        const result = await getVaultedMethods();
        this.setData({
          vaultedMethods: result
        });
        if (Object.keys(result).length) {
          paymentStore.setHasVaultedMethods(true);
        }
      },
      selectVaultedMethod(vaultedMethod) {
        this.unselectVaultedMethods();
        this.setData({
          vaultedMethods: {
            [vaultedMethod.publicHash]: {
              selected: true
            }
          }
        });
      },
      mapCartTypes(cartType) {
        switch (cartType) {
          case "AE":
            return "american-express";
          case "DI":
            return "discover";
          case "DN":
            return "diners-club";
          case "JCB":
            return "jcb";
          case "MC":
            return "master-card";
          case "MI":
            return "maestro";
          case "UPD":
            return "unionpay";
          case "VI":
            return "visa";
          default:
            return "";
        }
      },
      unselectVaultedMethods() {
        Object.keys(this.vaultedMethods).forEach((publicHash) => {
          this.setData({
            vaultedMethods: {
              [publicHash]: {
                selected: false
              }
            }
          });
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCache(cacheKey) {
        if (cacheKey) {
          this.setData({
            cache: {
              [cacheKey]: void 0
            }
          });
        }
      }
    }
  });
  var getInitialConfig = async () => {
    const agreementStore = useAgreementStore();
    const braintreeStore = useBraintreeStore();
    const configStore = useConfigStore();
    const recaptchaStore = useRecaptchaStore();
    const request3 = `{
    ${agreementStore.getInitialConfigValues()}
    ${braintreeStore.getInitialConfigValues()}
    ${configStore.getInitialConfigValues()}
    ${recaptchaStore.getInitialConfigValues()}
  }`;
    const { data: data2 } = await graphQlRequest(request3);
    return data2;
  };
  var getCustomConfigs = [];
  var mapCustomConfigs = () => ({});
  var handleInitialConfig = async (data2) => {
    const agreementStore = useAgreementStore();
    const braintreeStore = useBraintreeStore();
    const configStore = useConfigStore();
    const recaptchaStore = useRecaptchaStore();
    agreementStore.handleInitialConfig(data2);
    braintreeStore.handleInitialConfig(data2);
    configStore.handleInitialConfig(data2);
    recaptchaStore.handleInitialConfig(data2);
  };
  var useConfigStore = defineStore("configStore", {
    state: () => ({
      staticUrl: getFallBackStaticPath(),
      currencyCode: getCurrencyCode(),
      storeCode: getStoreCodeFromLocalStorage(),
      locale: getLocale(),
      countryCode: void 0,
      superPaymentsActive: false,
      cache: {},
      privacyPolicy: {},
      generalTermsServices: {},
      withdrawTermsServices: {},
      countries: [],
      secureBaseUrl: void 0,
      secureBaseLinkUrl: void 0,
      useStoreInUrl: false,
      newsletterEnabled: false,
      newsletterAllowGuests: false,
      stateRequired: [],
      displayState: false,
      rewardsEnabled: false,
      clickandcollectSms: false,
      custom: {},
      optionalZipCountries: "",
      addressFinder: {
        enabled: true,
        loqate: {},
        afd: {}
      },
      clickCollectTabsEnabled: false,
      websiteName: "",
      taxCartDisplayPrice: false,
      taxCartDisplayShipping: false,
      taxCartDisplayFullSummary: false,
      copyrightText: "",
      progressBarVisible: false
    }),
    getters: {
      postcodeRequired: (state) => (countryId) => !state.optionalZipCountries.includes(countryId),
      getCountryByCode: (state) => (countryCode) => state.countries.find(({ id }) => id === countryCode),
      getRegionId: (state) => (countryCode, regionCode) => {
        var _a;
        const country = state.getCountryByCode(countryCode);
        return country && country.available_regions ? (_a = country.available_regions.find(({ code: code2 }) => code2 === regionCode)) == null ? void 0 : _a.id : void 0;
      }
    },
    actions: {
      setData(data2) {
        this.$patch(data2);
      },
      async getConfig(configs) {
        const cacheKey = this.createCacheKey(configs);
        const data2 = await this.getCachedResponse(getStoreConfig, cacheKey, configs);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      async getStoreCode() {
        const storeCode = await getStoreCode();
        this.setData({
          storeCode
        });
      },
      async getInitialConfig() {
        if (!this.storeCode) {
          await this.getCachedResponse(this.getStoreCode, "getStoreCode");
        }
        const request3 = () => getInitialConfig().then(handleInitialConfig);
        await this.getCachedResponse(request3, "getInitialConfig");
      },
      getInitialConfigValues() {
        const configs = [
          "base_static_url",
          "default_display_currency_code",
          "code",
          "secure_base_url",
          "secure_base_link_url",
          "use_store_in_url",
          "website_name",
          "bluefinch_checkout_newsletter_enabled",
          "bluefinch_checkout_newsletter_allow_guest",
          "bluefinch_checkout_country_state_required",
          "bluefinch_checkout_country_display_state",
          "magento_reward_general_is_enabled",
          "magento_reward_general_is_enabled_on_front",
          "optional_zip_countries",
          "tax_cart_display_price",
          "tax_cart_display_shipping",
          "tax_cart_display_full_summary",
          "bluefinch_checkout_copyright_text",
          "bluefinch_checkout_afd_enable",
          "bluefinch_checkout_progress_bar_visible",
          "bluefinch_checkout_loqate_api_key",
          "bluefinch_checkout_loqate_enabled",
          "bluefinch_checkout_click_collect_tabs_enabled",
          "bluefinch_checkout_afd_enable"
        ];
        if (this.locale) {
          this.setLocale(this.locale);
        } else {
          configs.push("locale");
        }
        const allConfigs = configs.concat(getCustomConfigs);
        return `
        storeConfig {
          ${allConfigs.join(" ")}
        }

        countries {
          id
          two_letter_abbreviation
          three_letter_abbreviation
          full_name_locale
          available_regions {
            id
            code
            name
          }
        }
      `;
      },
      async handleInitialConfig({ countries, storeConfig }) {
        this.setData({
          staticUrl: storeConfig.base_static_url.replace(/\/+$/, ""),
          currencyCode: storeConfig.default_display_currency_code,
          storeCode: storeConfig.code,
          useStoreInUrl: storeConfig.use_store_in_url,
          websiteName: storeConfig.website_name || "",
          secureBaseUrl: storeConfig.secure_base_url,
          secureBaseLinkUrl: storeConfig.secure_base_link_url,
          newsletterEnabled: storeConfig.bluefinch_checkout_newsletter_enabled === "1",
          newsletterAllowGuests: storeConfig.bluefinch_checkout_newsletter_allow_guest === "1",
          stateRequired: storeConfig.bluefinch_checkout_country_state_required ? storeConfig.bluefinch_checkout_country_state_required.split(",") : [],
          displayState: storeConfig.bluefinch_checkout_country_display_state === "1",
          rewardsEnabled: storeConfig.magento_reward_general_is_enabled === "1" && storeConfig.magento_reward_general_is_enabled_on_front === "1",
          optionalZipCountries: storeConfig.optional_zip_countries || "",
          taxCartDisplayPrice: storeConfig.tax_cart_display_price === "2",
          taxCartDisplayShipping: storeConfig.tax_cart_display_shipping === "2",
          taxCartDisplayFullSummary: storeConfig.tax_cart_display_full_summary === "1",
          copyrightText: storeConfig.bluefinch_checkout_copyright_text,
          progressBarVisible: storeConfig.bluefinch_checkout_progress_bar_visible === true,
          addressFinder: {
            enabled: !!+storeConfig.bluefinch_checkout_loqate_enabled,
            loqate: {
              enabled: !!+storeConfig.bluefinch_checkout_loqate_enabled,
              apiKey: storeConfig.bluefinch_checkout_loqate_api_key
            },
            afd: {
              enabled: storeConfig.bluefinch_checkout_afd_enable
            }
          },
          clickCollectTabsEnabled: storeConfig.bluefinch_checkout_click_collect_tabs_enabled
        });
        if (storeConfig.locale) {
          this.setLocale(storeConfig.locale);
        }
        countries.sort((a, b) => a.full_name_locale.toUpperCase().localeCompare(b.full_name_locale.toUpperCase()));
        this.setData({ countries });
        const customConfigs = await mapCustomConfigs();
        this.setData({
          custom: customConfigs
        });
      },
      setLocale(locale) {
        const replaced = locale.replace("_", "-");
        const countryCode = replaced.split("-")[1];
        this.$i18n.global.locale = replaced;
        this.setData({
          countryCode,
          locale: replaced
        });
      },
      createCacheKey(configs) {
        return configs.join("-");
      },
      getRegionsByCountry(countryId) {
        const country = this.countries.find((cty) => cty.id === countryId);
        if (country) {
          const availableRegions = country.available_regions || [];
          const regionOptions = availableRegions.map((region) => ({
            option: {
              name: region.name,
              value: region.id,
              code: region.code
            }
          }));
          return regionOptions;
        }
        return [];
      },
      async getPrivacyPolicyBlock() {
        const privacyPolicyId = getPrivacyPolicyId();
        {
          const data2 = await this.getCachedResponse(getBlock, "getPrivacyPolicyBlock", privacyPolicyId);
          this.setData({
            privacyPolicy: data2
          });
        }
      },
      async getGeneralTermsServicesBlock() {
        const generalTermsServicesId = getGeneralTermsServicesId();
        {
          const data2 = await this.getCachedResponse(getBlock, "getGeneralTermsServicesBlock", generalTermsServicesId);
          this.setData({
            generalTermsServices: data2
          });
        }
      },
      async getWithdrawTermsServicesBlock() {
        const withdrawTermsServicesId = getWithdrawTermsServicesId();
        {
          const data2 = await this.getCachedResponse(getBlock, "getWithdrawTermsServicesBlock", withdrawTermsServicesId);
          this.setData({
            withdrawTermsServices: data2
          });
        }
      },
      async getAfdConfiguration() {
        const config = await this.getCachedResponse(afdPostcode.getAfdConfiguration, "getAfdConfiguration");
        this.setData({
          addressFinder: {
            afd: {
              type: config.afd_general_account_type,
              serialUrl: config.afd_general_account_serial_url,
              serial: config.afd_general_account_serial,
              password: config.afd_general_account_password,
              idUrl: config.afd_general_account_id_url,
              id: config.afd_general_account_id,
              token: config.afd_general_account_token,
              maxQuantity: config.afd_response_max_quantity || "5"
            }
          }
        });
      },
      getCachedResponse(request3, cacheKey, args = {}) {
        if (typeof this.$state.cache[cacheKey] !== "undefined") {
          return this.$state.cache[cacheKey];
        }
        const data2 = request3(args);
        this.$patch({
          cache: {
            [cacheKey]: data2
          }
        });
        return data2;
      },
      clearCache(cacheKey) {
        if (cacheKey) {
          this.setData({
            cache: {
              [cacheKey]: void 0
            }
          });
        }
      }
    }
  });
  var getStaticUrl = (file) => {
    const { location: { hostname } } = window;
    const { staticUrl } = useConfigStore();
    const { staticPath } = window.bluefinchCheckout;
    if (staticUrl || staticPath) {
      if (hostname === "localhost") {
        return file;
      }
      return staticPath ? staticPath + file : staticUrl + file;
    }
    return file;
  };
  var logoSvg = "/logo.svg";
  var _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$1C = {
    name: "Logo",
    props: {
      params: {
        type: String
      },
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      alt: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    },
    data() {
      return {
        logo: ""
      };
    },
    async created() {
      var _a;
      await this.getInitialConfig();
      this.logo = ((_a = window.bluefinchCheckout) == null ? void 0 : _a.logo) || getStaticUrl(logoSvg);
      document.addEventListener("bluefinch:checkout-image-update", (event) => {
        this.logo = (event == null ? void 0 : event.detail) || getStaticUrl(logoSvg);
      });
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"])
    }
  };
  const _hoisted_1$1t = ["src", "alt"];
  function _sfc_render$1C(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("span", {
      class: normalizeClass($data.logo ? "" : "text-loading")
    }, [
      createBaseVNode("img", {
        src: $data.logo,
        alt: $props.alt,
        style: normalizeStyle($props.params)
      }, null, 12, _hoisted_1$1t)
    ], 2);
  }
  var Logo = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["render", _sfc_render$1C], ["__scopeId", "data-v-57ec5078"]]);
  var lockIconSvg = "/lockIcon.svg";
  const _sfc_main$1B = {
    name: "Lock",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      lockIconSvg() {
        return `${getStaticUrl(lockIconSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$1s = ["src", "alt"];
  function _sfc_render$1B(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.lockIconSvg,
      alt: $options.lockIconSvg
    }, null, 8, _hoisted_1$1s);
  }
  var Lock = /* @__PURE__ */ _export_sfc(_sfc_main$1B, [["render", _sfc_render$1B]]);
  const _sfc_main$1A = {
    name: "AppHeader",
    components: {
      Logo,
      Lock
    },
    data() {
      return {
        headerText: "",
        headerTextId: "bluefinch-checkout-header-text"
      };
    },
    async created() {
      var _a;
      await this.getInitialConfig();
      this.headerText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.headerTextId]) || this.$t("header.text");
      document.addEventListener(this.headerTextId, this.setHeaderText);
    },
    unmounted() {
      document.removeEventListener(this.headerTextId, this.setHeaderText);
    },
    computed: {
      ...mapState(useConfigStore, ["secureBaseLinkUrl"])
    },
    methods: {
      ...mapActions(useConfigStore, ["custom", "getInitialConfig"])
    }
  };
  const _hoisted_1$1r = { class: "header-content" };
  const _hoisted_2$18 = ["href"];
  const _hoisted_3$V = { class: "header-title" };
  const _hoisted_4$A = { class: "secure-text" };
  function _sfc_render$1A(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Logo = resolveComponent("Logo");
    const _component_Lock = resolveComponent("Lock");
    return openBlock(), createElementBlock("header", {
      class: "header-container",
      style: normalizeStyle(_ctx.style)
    }, [
      createBaseVNode("div", _hoisted_1$1r, [
        createBaseVNode("a", {
          href: _ctx.secureBaseLinkUrl,
          "aria-label": "logo",
          class: normalizeClass(["header-logo", _ctx.custom.checkoutLogo ? "logo-no-width" : ""])
        }, [
          createVNode(_component_Logo, { alt: "logo" })
        ], 10, _hoisted_2$18),
        createBaseVNode("div", _hoisted_3$V, [
          createVNode(_component_Lock, {
            stroke: "white",
            class: "secure-logo"
          }),
          createBaseVNode("h1", _hoisted_4$A, toDisplayString$1($data.headerText), 1)
        ])
      ])
    ], 4);
  }
  var AppHeader = /* @__PURE__ */ _export_sfc(_sfc_main$1A, [["render", _sfc_render$1A], ["__scopeId", "data-v-2b80a50b"]]);
  const _sfc_main$1z = {
    name: "TextField",
    props: {
      text: {
        type: String,
        required: true,
        default: ""
      },
      dataCy: {
        type: String
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      },
      fontStyle: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          fontSize: reactiveProps.fontSize,
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontStyle: reactiveProps.fontStyle
        })),
        classes: computed(() => ({
          "text-loading": typeof reactiveProps.text === "string" && reactiveProps.text === " "
        }))
      };
    }
  };
  const _hoisted_1$1q = ["data-cy", "innerHTML"];
  function _sfc_render$1z(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("p", {
      class: normalizeClass($setup.classes),
      style: normalizeStyle($setup.style),
      "data-cy": $props.dataCy ? $props.dataCy : "text",
      innerHTML: $setup.classes["text-loading"] ? "" : $props.text
    }, null, 14, _hoisted_1$1q);
  }
  var TextField = /* @__PURE__ */ _export_sfc(_sfc_main$1z, [["render", _sfc_render$1z], ["__scopeId", "data-v-d918115a"]]);
  var ApplePaySvg$1 = "/icon-applepay-white.svg";
  var GooglePaySvg$1 = "/icon-googlepay-white.svg";
  var ExpressPaySvg$1 = "/icon-amex-white.svg";
  var PayPalSvg$1 = "/icon-paypal-white.svg";
  var KlarnaSvg$1 = "/icon-klarna-white.svg";
  var MaestroPaySvg$1 = "/icon-maestro-white.svg";
  var MastercardPaySvg$1 = "/icon-mastercard-white.svg";
  var VisaPaySvg$1 = "/icon-visa-white.svg";
  var ClearpaySvg$1 = "/icon-clearpay-white.svg";
  var VenmoPayIcon$1 = "/icon-venmo-white.svg";
  var DiscoverSvg$1 = "/icon-discover-white.svg";
  var DinersSvg$1 = "/icon-diners-white.svg";
  var JCBSvg$1 = "/icon-jcb-white.svg";
  const _sfc_main$1y = {
    name: "FooterIcons",
    props: {
      visibility: {
        type: String
      }
    },
    data() {
      return {
        map: [],
        paymentOptionPriority: []
      };
    },
    computed: {
      ...mapState(useBraintreeStore, ["cCTypes"]),
      ...mapState(usePaymentStore, ["availableMethods", "getPaymentPriority", "isPaymentMethodAvailable"]),
      ApplePayIcon() {
        return `${getStaticUrl(ApplePaySvg$1)}`;
      },
      GooglePayIcon() {
        return `${getStaticUrl(GooglePaySvg$1)}`;
      },
      ExpressPayIcon() {
        return `${getStaticUrl(ExpressPaySvg$1)}`;
      },
      PayPalIcon() {
        return `${getStaticUrl(PayPalSvg$1)}`;
      },
      KlarnaIcon() {
        return `${getStaticUrl(KlarnaSvg$1)}`;
      },
      MaestroPayIcon() {
        return `${getStaticUrl(MaestroPaySvg$1)}`;
      },
      MastercardPayIcon() {
        return `${getStaticUrl(MastercardPaySvg$1)}`;
      },
      VisaPayIcon() {
        return `${getStaticUrl(VisaPaySvg$1)}`;
      },
      ClearpayIcon() {
        return `${getStaticUrl(ClearpaySvg$1)}`;
      },
      VenmoPayIcon() {
        return `${getStaticUrl(VenmoPayIcon$1)}`;
      }
    },
    methods: {
      generateClass(paymentName) {
        return paymentName.toLowerCase().replace(/\s+/g, "_");
      },
      getCCIcon(type) {
        switch (type) {
          case "AE":
            return getStaticUrl(ExpressPaySvg$1);
          case "DI":
            return getStaticUrl(DiscoverSvg$1);
          case "DN":
            return getStaticUrl(DinersSvg$1);
          case "JCB":
            return getStaticUrl(JCBSvg$1);
          case "MC":
            return getStaticUrl(MastercardPaySvg$1);
          case "MI":
            return getStaticUrl(MaestroPaySvg$1);
          case "VI":
            return getStaticUrl(VisaPaySvg$1);
          default:
            return "";
        }
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          display: reactiveProps.visibility
        }))
      };
    }
  };
  const _hoisted_1$1p = { key: 0 };
  const _hoisted_2$17 = { key: 0 };
  const _hoisted_3$U = ["src", "alt"];
  const _hoisted_4$z = { key: 0 };
  const _hoisted_5$u = ["alt", "src"];
  const _hoisted_6$m = {
    key: 0,
    class: "pay-with__content"
  };
  const _hoisted_7$j = ["src", "alt"];
  function _sfc_render$1y(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", {
      style: normalizeStyle($setup.style),
      class: "footer-icons"
    }, [
      _ctx.isAdyenAvailable ? (openBlock(), createElementBlock("div", _hoisted_1$1p, [
        Object.keys(_ctx.paymentTypes).length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_2$17, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paymentTypes, (paymentType, index) => {
            return openBlock(), createElementBlock("li", {
              key: index,
              class: "pay-with__content"
            }, [
              !paymentType.icon.includes("klarna_account") ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: paymentType.icon.includes("klarna") ? $options.KlarnaIcon : paymentType.icon.includes("clearpay") ? $options.ClearpayIcon : paymentType.icon.includes("paypal") ? $options.PayPalIcon : paymentType.icon.includes("amex") ? $options.ExpressPayIcon : paymentType.icon.includes("mc") ? $options.MastercardPayIcon : paymentType.icon.includes("visa") ? $options.VisaPayIcon : paymentType.icon.includes("google") ? $options.GooglePayIcon : paymentType.icon.includes("apple") ? $options.ApplePayIcon : paymentType.icon,
                alt: paymentType.name,
                class: normalizeClass($options.generateClass(paymentType.name))
              }, null, 10, _hoisted_3$U)) : createCommentVNode("", true)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true),
      createBaseVNode("div", null, [
        !_ctx.isAdyenAvailable && _ctx.availableMethods.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_4$z, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.availableMethods, (paymentType, index) => {
            return openBlock(), createElementBlock(Fragment, { key: index }, [
              paymentType.code === "braintree" && _ctx.cCTypes.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.cCTypes, (cCType) => {
                return openBlock(), createElementBlock("li", {
                  key: cCType,
                  class: "pay-with__content"
                }, [
                  createBaseVNode("img", {
                    alt: cCType,
                    src: $options.getCCIcon(cCType)
                  }, null, 8, _hoisted_5$u)
                ]);
              }), 128)) : paymentType.code !== "braintree_cc_vault" && paymentType.code !== "braintree_ach_direct_debit" && paymentType.code !== "braintree_local_payment" && paymentType.code !== "braintree_paypal_vault" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                paymentType.code.includes("braintree") ? (openBlock(), createElementBlock("li", _hoisted_6$m, [
                  createBaseVNode("img", {
                    src: paymentType.code === "braintree_applepay" ? $options.ApplePayIcon : paymentType.code === "braintree_googlepay" ? $options.GooglePayIcon : paymentType.code === "braintree_venmo" ? $options.VenmoPayIcon : paymentType.code === "braintree_paypal" ? $options.PayPalIcon : "",
                    alt: paymentType.title,
                    class: normalizeClass($options.generateClass(paymentType.title))
                  }, null, 10, _hoisted_7$j)
                ])) : createCommentVNode("", true)
              ], 64)) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ])) : createCommentVNode("", true)
      ])
    ], 4);
  }
  var FooterIcons = /* @__PURE__ */ _export_sfc(_sfc_main$1y, [["render", _sfc_render$1y], ["__scopeId", "data-v-33e0ad0b"]]);
  const _sfc_main$1x = {
    name: "AppFooter",
    components: {
      TextField,
      FooterIcons
    },
    props: {
      backgroundColor: {
        type: String
      }
    },
    computed: {
      ...mapState(useConfigStore, ["copyrightText"])
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor
        }))
      };
    }
  };
  const _hoisted_1$1o = { class: "footer-block" };
  function _sfc_render$1x(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_FooterIcons = resolveComponent("FooterIcons");
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("footer", {
      class: "footer-container",
      style: normalizeStyle($setup.style)
    }, [
      createBaseVNode("div", _hoisted_1$1o, [
        createVNode(_component_FooterIcons),
        createVNode(_component_TextField, { text: _ctx.copyrightText }, null, 8, ["text"])
      ])
    ], 4);
  }
  var AppFooter = /* @__PURE__ */ _export_sfc(_sfc_main$1x, [["render", _sfc_render$1x], ["__scopeId", "data-v-3fe43330"]]);
  var Loader$1 = "/loader.gif";
  const _sfc_main$1w = {
    name: "Loader",
    computed: {
      ...mapState(useLoadingStore, ["isLoading"]),
      Loader() {
        return `${getStaticUrl(Loader$1)}`;
      }
    },
    methods: {
      captureClick(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    }
  };
  const _hoisted_1$1n = { class: "loader" };
  const _hoisted_2$16 = ["src"];
  function _sfc_render$1w(_ctx, _cache, $props, $setup, $data, $options) {
    return _ctx.isLoading ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "loading-mask",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.captureClick && $options.captureClick(...args)),
      onKeydown: _cache[1] || (_cache[1] = (...args) => $options.captureClick && $options.captureClick(...args))
    }, [
      createBaseVNode("div", _hoisted_1$1n, [
        createBaseVNode("img", {
          style: normalizeStyle(_ctx.style),
          src: $options.Loader,
          alt: "loader",
          width: "50px",
          height: "50px"
        }, null, 12, _hoisted_2$16)
      ])
    ], 32)) : createCommentVNode("", true);
  }
  var Loader = /* @__PURE__ */ _export_sfc(_sfc_main$1w, [["render", _sfc_render$1w]]);
  const _sfc_main$1v = {
    name: "MockDesktop"
  };
  const _hoisted_1$1m = { class: "mock-desktop" };
  const _hoisted_2$15 = { class: "display" };
  const _hoisted_3$T = /* @__PURE__ */ createBaseVNode("div", { class: "footer" }, null, -1);
  const _hoisted_4$y = /* @__PURE__ */ createBaseVNode("div", { class: "stand" }, null, -1);
  function _sfc_render$1v(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$1m, [
        createBaseVNode("div", _hoisted_2$15, [
          renderSlot(_ctx.$slots, "default")
        ])
      ]),
      _hoisted_3$T,
      _hoisted_4$y
    ], 64);
  }
  var MockDesktop = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["render", _sfc_render$1v]]);
  const _sfc_main$1u = {
    name: "MockFull"
  };
  const _hoisted_1$1l = { class: "mock-full" };
  const _hoisted_2$14 = { class: "display" };
  function _sfc_render$1u(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$1l, [
      createBaseVNode("div", _hoisted_2$14, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ]);
  }
  var MockFull = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["render", _sfc_render$1u], ["__scopeId", "data-v-eed1cf12"]]);
  const _sfc_main$1t = {
    name: "MockLaptop"
  };
  const _withScopeId$a = (n) => (pushScopeId("data-v-6e47274c"), n = n(), popScopeId(), n);
  const _hoisted_1$1k = { class: "mock-laptop" };
  const _hoisted_2$13 = { class: "display" };
  const _hoisted_3$S = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("div", { class: "footer" }, null, -1));
  function _sfc_render$1t(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$1k, [
        createBaseVNode("div", _hoisted_2$13, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]),
      _hoisted_3$S
    ], 64);
  }
  var MockLaptop = /* @__PURE__ */ _export_sfc(_sfc_main$1t, [["render", _sfc_render$1t], ["__scopeId", "data-v-6e47274c"]]);
  const _sfc_main$1s = {
    name: "MockMobile"
  };
  const _withScopeId$9 = (n) => (pushScopeId("data-v-c33f62b2"), n = n(), popScopeId(), n);
  const _hoisted_1$1j = { class: "mock-mobile" };
  const _hoisted_2$12 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", { class: "camera" }, null, -1));
  const _hoisted_3$R = { class: "display" };
  function _sfc_render$1s(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$1j, [
      _hoisted_2$12,
      createBaseVNode("div", _hoisted_3$R, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ]);
  }
  var MockMobile = /* @__PURE__ */ _export_sfc(_sfc_main$1s, [["render", _sfc_render$1s], ["__scopeId", "data-v-c33f62b2"]]);
  const _sfc_main$1r = {
    name: "MockTablet"
  };
  const _hoisted_1$1i = { class: "mock-tablet" };
  const _hoisted_2$11 = { class: "display" };
  function _sfc_render$1r(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$1i, [
      createBaseVNode("div", _hoisted_2$11, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ])
    ]);
  }
  var MockTablet = /* @__PURE__ */ _export_sfc(_sfc_main$1r, [["render", _sfc_render$1r], ["__scopeId", "data-v-69519b4b"]]);
  const _sfc_main$1q = {
    name: "SlideUp",
    props: {
      visible: {
        type: Boolean,
        default: false
      }
    },
    emits: ["close", "focus"],
    methods: {
      close() {
        this.$emit("close");
      },
      focus() {
        this.$emit("focus");
      }
    }
  };
  const _hoisted_1$1h = {
    id: "slideUpTitle",
    class: "slideup-header"
  };
  const _hoisted_2$10 = {
    id: "slideUpBody",
    class: "slideUp-body"
  };
  function _sfc_render$1q(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(Transition, { name: "fade" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: "slideup-backdrop",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.close && $options.close(...args)),
            onKeydown: _cache[1] || (_cache[1] = (...args) => $options.focus && $options.focus(...args))
          }, null, 544), [
            [vShow, $props.visible]
          ])
        ]),
        _: 1
      }),
      createVNode(Transition, {
        name: "slideup",
        appear: ""
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: "slideup-container",
            role: "dialog",
            "aria-labelledby": "slideUpTitle",
            "aria-describedby": "slideUpBody",
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("header", _hoisted_1$1h, [
              renderSlot(_ctx.$slots, "header", {}, void 0, true)
            ]),
            createBaseVNode("section", _hoisted_2$10, [
              renderSlot(_ctx.$slots, "body", {}, void 0, true)
            ])
          ], 512), [
            [vShow, $props.visible]
          ])
        ]),
        _: 3
      })
    ], 64);
  }
  var SlideUp = /* @__PURE__ */ _export_sfc(_sfc_main$1q, [["render", _sfc_render$1q], ["__scopeId", "data-v-6c13ecb0"]]);
  const _sfc_main$1p = {
    name: "Price",
    props: {
      value: {
        type: String,
        required: true
      }
    },
    methods: {
      formatPrice(price) {
        if (price === void 0)
          return "";
        return price < 0 ? `-${formatPrice(Math.abs(price))}` : formatPrice(price);
      }
    }
  };
  function _sfc_render$1p(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("p", null, toDisplayString$1($options.formatPrice($props.value)), 1);
  }
  var Price = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["render", _sfc_render$1p]]);
  const _sfc_main$1o = {
    name: "ErrorMessage",
    components: {
      TextField
    },
    props: {
      message: {
        type: String,
        require: true,
        default: ""
      },
      attached: {
        type: Boolean,
        default: true
      },
      margin: {
        type: Boolean,
        default: true
      },
      backgroundColor: {
        type: String
      },
      color: {
        type: String
      },
      borderColor: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor,
          color: reactiveProps.color,
          borderColor: reactiveProps.borderColor
        }))
      };
    }
  };
  function _sfc_render$1o(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", {
      class: normalizeClass(["error-message", {
        "error-message-attached": $props.attached,
        "error-message-margin": $props.margin
      }]),
      style: normalizeStyle($setup.style)
    }, [
      createVNode(_component_TextField, { text: $props.message }, null, 8, ["text"])
    ], 6);
  }
  var ErrorMessage = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["render", _sfc_render$1o], ["__scopeId", "data-v-b2efd404"]]);
  const _sfc_main$1n = {
    name: "ArrowUp",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$1g = ["role", "aria-label"];
  const _hoisted_2$$ = /* @__PURE__ */ createBaseVNode("path", {
    d: "M12.0326 10.0052C11.9042 10.124 11.8239 10.1959 11.7469 10.2678C9.58981 12.3656 7.42953 14.4602 5.27567 16.5611C4.87763 16.9457 4.41861 17.102 3.87935 16.93C3.03834 16.6643 2.73019 15.6764 3.26625 14.9948C3.3465 14.8948 3.43959 14.8041 3.53267 14.7166C6.00432 12.3156 8.47276 9.91453 10.9444 7.51663C11.6538 6.82571 12.3504 6.82884 13.063 7.51976C15.5474 9.93329 18.0319 12.3499 20.5196 14.7603C20.908 15.1355 21.0942 15.5607 20.953 16.0828C20.7219 16.9331 19.6754 17.277 18.95 16.7487C18.8473 16.6737 18.7542 16.583 18.6611 16.4923C16.5297 14.4227 14.4015 12.3562 12.2701 10.2866C12.1931 10.2115 12.1289 10.1209 12.0358 10.0083L12.0326 10.0052Z",
    fill: "#3F5D7C"
  }, null, -1);
  const _hoisted_3$Q = [
    _hoisted_2$$
  ];
  function _sfc_render$1n(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$Q, 12, _hoisted_1$1g);
  }
  var ArrowUp = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["render", _sfc_render$1n]]);
  const _sfc_main$1m = {
    name: "ArrowDown",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$1f = ["role", "aria-label"];
  const _hoisted_2$_ = /* @__PURE__ */ createBaseVNode("path", {
    d: "M11.9674 13.9948C12.0958 13.876 12.1761 13.8041 12.2531 13.7322C14.4102 11.6344 16.5705 9.53978 18.7243 7.43888C19.1224 7.05435 19.5814 6.89803 20.1207 7.06998C20.9617 7.33572 21.2698 8.32364 20.7338 9.00518C20.6535 9.10522 20.5604 9.19589 20.4673 9.28342C17.9957 11.6844 15.5272 14.0855 13.0556 16.4834C12.3462 17.1743 11.6496 17.1712 10.937 16.4802C8.45256 14.0667 5.96807 11.6501 3.48038 9.23965C3.09197 8.86449 2.9058 8.43931 3.04704 7.91721C3.27815 7.06685 4.32459 6.72295 5.05003 7.2513C5.15275 7.32634 5.24584 7.417 5.33892 7.50766C7.47032 9.5773 9.5985 11.6438 11.7299 13.7134C11.8069 13.7885 11.8711 13.8791 11.9642 13.9917L11.9674 13.9948Z",
    fill: "#3F5D7C"
  }, null, -1);
  const _hoisted_3$P = [
    _hoisted_2$_
  ];
  function _sfc_render$1m(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$P, 12, _hoisted_1$1f);
  }
  var ArrowDown = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["render", _sfc_render$1m]]);
  const _sfc_main$1l = {
    name: "ProductOptions",
    components: {
      TextField,
      ArrowUp,
      ArrowDown
    },
    props: {
      item: {
        type: Object
      }
    },
    data() {
      return {
        productOptionsVisible: false
      };
    },
    methods: {
      showProductOptions() {
        this.productOptionsVisible = !this.productOptionsVisible;
      }
    }
  };
  const _hoisted_1$1e = {
    key: 0,
    class: "product-options"
  };
  const _hoisted_2$Z = {
    key: 0,
    class: "product-option"
  };
  function _sfc_render$1l(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    return $props.item.configurable_options && $props.item.configurable_options.length ? (openBlock(), createElementBlock("div", _hoisted_1$1e, [
      createBaseVNode("div", {
        class: "product-options-trigger",
        "data-cy": "product-options-trigger",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.showProductOptions && $options.showProductOptions(...args)),
        onKeydown: _cache[1] || (_cache[1] = (...args) => $options.showProductOptions && $options.showProductOptions(...args))
      }, [
        createVNode(_component_TextField, {
          text: _ctx.$t("productOptionsTrigger")
        }, null, 8, ["text"]),
        $data.productOptionsVisible ? (openBlock(), createBlock(_component_ArrowUp, { key: 0 })) : createCommentVNode("", true),
        !$data.productOptionsVisible ? (openBlock(), createBlock(_component_ArrowDown, { key: 1 })) : createCommentVNode("", true)
      ], 32),
      $data.productOptionsVisible ? (openBlock(), createElementBlock("div", _hoisted_2$Z, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.item.configurable_options, (option, index) => {
          return openBlock(), createElementBlock("div", {
            key: index,
            class: "option-value"
          }, [
            createVNode(_component_TextField, {
              text: `${option.option_label}: ${option.value_label}`
            }, null, 8, ["text"])
          ]);
        }), 128))
      ])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true);
  }
  var ProductOptions = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["render", _sfc_render$1l], ["__scopeId", "data-v-29079443"]]);
  const _sfc_main$1k = {
    name: "MyButton",
    components: {
      TextField
    },
    props: {
      type: {
        type: String
      },
      dataCy: {
        type: String
      },
      label: {
        type: String,
        required: true
      },
      primary: {
        type: Boolean,
        default: false
      },
      secondary: {
        type: Boolean,
        default: false
      },
      tertiary: {
        type: Boolean,
        default: false
      },
      tab: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        validator(value) {
          return ["small", "medium", "large"].indexOf(value) !== -1;
        },
        default: "medium"
      },
      backgroundColor: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    emits: ["click"],
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        classes: computed(() => ({
          button: true,
          "button--primary": reactiveProps.primary,
          "button--secondary": reactiveProps.secondary,
          "button--tertiary": reactiveProps.tertiary,
          "button--tab": reactiveProps.tab,
          [`button--${reactiveProps.size || "medium"}`]: true
        })),
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor
        }))
      };
    }
  };
  const _hoisted_1$1d = ["type", "role", "aria-label", "disabled", "data-cy"];
  function _sfc_render$1k(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("button", {
      type: $props.type,
      class: normalizeClass($setup.classes),
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      disabled: $props.disabled,
      "data-cy": $props.dataCy ? $props.dataCy : $props.type
    }, [
      createVNode(_component_TextField, { text: $props.label }, null, 8, ["text"])
    ], 14, _hoisted_1$1d);
  }
  var MyButton = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$1k]]);
  /*! @license DOMPurify 3.0.9 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.9/LICENSE */
  const {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  let {
    freeze,
    seal,
    create
  } = Object;
  let {
    apply,
    construct
  } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze2(x) {
      return x;
    };
  }
  if (!seal) {
    seal = function seal2(x) {
      return x;
    };
  }
  if (!apply) {
    apply = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return new Func(...args);
    };
  }
  const arrayForEach = unapply(Array.prototype.forEach);
  const arrayPop = unapply(Array.prototype.pop);
  const arrayPush = unapply(Array.prototype.push);
  const stringToLowerCase = unapply(String.prototype.toLowerCase);
  const stringToString = unapply(String.prototype.toString);
  const stringMatch = unapply(String.prototype.match);
  const stringReplace = unapply(String.prototype.replace);
  const stringIndexOf = unapply(String.prototype.indexOf);
  const stringTrim = unapply(String.prototype.trim);
  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  const regExpTest = unapply(RegExp.prototype.test);
  const typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set2, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set2, null);
    }
    let l = array.length;
    while (l--) {
      let element = array[l];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }
          element = lcElement;
        }
      }
      set2[element] = true;
    }
    return set2;
  }
  function cleanArray(array) {
    for (let index = 0; index < array.length; index++) {
      const isPropertyExist = objectHasOwnProperty(array, index);
      if (!isPropertyExist) {
        array[index] = null;
      }
    }
    return array;
  }
  function clone(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === "object" && value.constructor === Object) {
          newObject[property] = clone(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  const text = freeze(["#text"]);
  const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
  const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
  const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
  const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
  const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
  const DOCTYPE_NAME = seal(/^html$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MUSTACHE_EXPR,
    ERB_EXPR,
    TMPLIT_EXPR,
    DATA_ATTR,
    ARIA_ATTR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE,
    DOCTYPE_NAME
  });
  const getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify = (root2) => createDOMPurify(root2);
    DOMPurify.version = "3.0.9";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== 9) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document: document2
    } = window2;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node,
      Element: Element2,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser,
      trustedTypes
    } = window2;
    const ElementPrototype = Element2.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = {};
    DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    const _parseConfig = function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    const HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = function _checkValidNamespace2(element) {
      let parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      return false;
    };
    const _forceRemove = function _forceRemove2(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });
      try {
        node.parentNode.removeChild(node);
      } catch (_) {
        node.remove();
      }
    };
    const _removeAttribute = function _removeAttribute2(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }
      node.removeAttribute(name);
      if (name === "is" && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {
          }
        } else {
          try {
            node.setAttribute(name, "");
          } catch (_) {
          }
        }
      }
    };
    const _initDocument = function _initDocument2(dirty) {
      let doc2 = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc2 = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {
        }
      }
      if (!doc2 || !doc2.documentElement) {
        doc2 = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_) {
        }
      }
      const body = doc2.body || doc2.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc2.documentElement : body;
    };
    const _createNodeIterator = function _createNodeIterator2(root2) {
      return createNodeIterator.call(root2.ownerDocument || root2, root2, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null);
    };
    const _isClobbered = function _isClobbered2(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
    };
    const _isNode = function _isNode2(object) {
      return typeof Node === "function" && object instanceof Node;
    };
    const _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
      if (!hooks[entryPoint]) {
        return;
      }
      arrayForEach(hooks[entryPoint], (hook) => {
        hook.call(DOMPurify, currentNode, data2, CONFIG);
      });
    };
    const _sanitizeElements = function _sanitizeElements2(currentNode) {
      let content = null;
      _executeHook("beforeSanitizeElements", currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHook("uponSanitizeElement", currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content = stringReplace(content, expr, " ");
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHook("afterSanitizeElements", currentNode, null);
      return false;
    };
    const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName))
        ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName))
        ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (_isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
          ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName])
        ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, "")))
        ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
        ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, "")))
        ;
      else if (value) {
        return false;
      } else
        ;
      return true;
    };
    const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && tagName.indexOf("-") > 0;
    };
    const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      _executeHook("beforeSanitizeAttributes", currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      let l = attributes.length;
      while (l--) {
        const attr = attributes[l];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        let value = name === "value" ? attrValue : stringTrim(attrValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        _removeAttribute(name, currentNode);
        if (!hookEvent.keepAttr) {
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI)
            ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            currentNode.setAttribute(name, value);
          }
          arrayPop(DOMPurify.removed);
        } catch (_) {
        }
      }
      _executeHook("afterSanitizeAttributes", currentNode, null);
    };
    const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHook("beforeSanitizeShadowDOM", fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHook("uponSanitizeShadowNode", shadowNode, null);
        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
        _sanitizeAttributes(shadowNode);
      }
      _executeHook("afterSanitizeShadowDOM", fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        _sanitizeAttributes(currentNode);
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    DOMPurify.removeHooks = function(entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    DOMPurify.removeAllHooks = function() {
      hooks = {};
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  var sanitiseInputValue = (input, type) => {
    const sanitizedInput = purify.sanitize(input);
    let allowedCharactersRegex;
    if (type === "email") {
      allowedCharactersRegex = /^[\u0600-\u06FF\u0750-\u077F\u0400-\u04FF\u2E80-\u9FFF\w\s.@+_]*[^,#?][\u0600-\u06FF\u0750-\u077F\u0400-\u04FF\u2E80-\u9FFF\w\s.@+_]*$/;
    } else if (type === "tel") {
      allowedCharactersRegex = /^[+]?[\d() -]+$/;
    } else {
      allowedCharactersRegex = /^[\u0600-\u06FF\u0750-\u077F\u0400-\u04FF\u2E80-\u9FFF\w\s.,\-]*$/;
    }
    return allowedCharactersRegex.test(sanitizedInput);
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  var now = function() {
    return root.Date.now();
  };
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var lodash_debounce = debounce;
  const screenXxs = "320px";
  const screenXs = "480px";
  const screenS = "640px";
  const screenM = "768px";
  const screenMl = "992px";
  const screenL = "1024px";
  const screenXl = "1440px";
  var breakpoints = {
    screenXxs,
    screenXs,
    screenS,
    screenM,
    screenMl,
    screenL,
    screenXl
  };
  const _sfc_main$1j = {
    name: "TextInput",
    components: {
      ErrorMessage
    },
    props: {
      modelValue: {
        type: String,
        default: ""
      },
      dataCy: {
        type: String
      },
      name: {
        type: String
      },
      placeholder: {
        type: String
      },
      label: {
        type: String
      },
      ariaLabel: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      },
      required: {
        type: Boolean,
        default: false
      },
      type: {
        type: String
      },
      borderColor: {
        type: String
      },
      error: {
        type: Boolean
      },
      errorMessage: {
        type: String,
        default: ""
      },
      identifier: {
        type: String
      },
      onBlur: {
        type: Function,
        default: () => {
        }
      },
      onFocus: {
        type: Function,
        default: () => {
        }
      },
      autocomplete: {
        type: String,
        default: null
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        classes: computed(() => ({
          error: reactiveProps.error
        })),
        style: computed(() => ({
          borderColor: reactiveProps.borderColor
        }))
      };
    },
    data() {
      return {
        inputVal: "",
        validationErrorMessage: "",
        isInputActive: false
      };
    },
    computed: {
      ...mapWritableState(useCustomerStore, ["inputsSanitiseError"])
    },
    methods: {
      customValidation() {
        const inputValue = this.$refs.input.value;
        const inputType = this.type;
        const isValid = sanitiseInputValue(inputValue, inputType);
        if (this.identifier !== "password") {
          if (isValid) {
            this.$emit("update:modelValue", inputValue);
            this.validationErrorMessage = "";
          } else {
            this.$emit("update:modelValue", inputValue);
            if (inputType === "tel") {
              this.$emit("telephone-error");
            } else {
              this.validationErrorMessage = this.$t("errorMessages.sanitiseError");
            }
          }
          this.$nextTick(() => {
            this.inputsSanitiseError = document.querySelectorAll(".sanitise-error").length > 0;
          });
        }
      },
      moveIntoViewport(event) {
        this.isInputActive = true;
        const breakpoint = parseInt(breakpoints.screenM, 10);
        if (window.innerWidth > breakpoint) {
          return;
        }
        const { target } = event;
        const container = target.closest(".text-input");
        const footer = document.querySelector(".order-summary-container");
        const footerHeight = footer.getBoundingClientRect().height;
        const currScroll = window.scrollY;
        const debouncedResize = lodash_debounce(() => {
          const boundingRect = container.getBoundingClientRect();
          const isHidden = window.innerHeight - footerHeight < boundingRect.bottom;
          if (isHidden) {
            window.scrollTo({
              top: boundingRect.bottom + currScroll - (window.innerHeight - footerHeight),
              behavior: "smooth"
            });
          }
          window.removeEventListener("resize", debouncedResize);
        }, 20);
        window.addEventListener("resize", debouncedResize);
      }
    }
  };
  const _hoisted_1$1c = ["for"];
  const _hoisted_2$Y = ["id", "name", "autocomplete", "type", "placeholder", "disabled", "required", "aria-label", "data-cy", "value"];
  function _sfc_render$1j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    return openBlock(), createElementBlock("div", {
      class: normalizeClass(["text-input", { "custom-validation-error": $data.validationErrorMessage !== "", ...$setup.classes }])
    }, [
      createBaseVNode("label", {
        for: $props.identifier,
        class: normalizeClass({ "sanitise-error": $data.validationErrorMessage !== "", ...$setup.classes })
      }, [
        $props.label ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass($props.modelValue.length > 0 || $data.isInputActive ? "text-input-has-value" : "text-input-no-value")
        }, toDisplayString$1($props.required ? $props.label + " *" : $props.label), 3)) : createCommentVNode("", true),
        createBaseVNode("input", {
          id: $props.identifier,
          ref: "input",
          name: $props.name,
          autocomplete: $props.autocomplete,
          style: normalizeStyle($setup.style),
          type: $props.type,
          placeholder: $props.required ? $props.placeholder + " *" : $props.placeholder,
          disabled: $props.disabled,
          required: $props.required,
          "aria-label": $props.ariaLabel,
          "data-cy": $props.dataCy ? $props.dataCy : "input",
          value: $props.modelValue,
          onBlur: _cache[0] || (_cache[0] = (...args) => $props.onBlur && $props.onBlur(...args)),
          onFocus: _cache[1] || (_cache[1] = (event) => {
            $options.moveIntoViewport(event);
            $props.onFocus();
          }),
          onInput: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:modelValue", $event.target.value)),
          onKeyup: _cache[3] || (_cache[3] = (...args) => $options.customValidation && $options.customValidation(...args))
        }, null, 44, _hoisted_2$Y),
        renderSlot(_ctx.$slots, "icon", {}, void 0, true)
      ], 10, _hoisted_1$1c),
      $props.errorMessage !== "" ? (openBlock(), createBlock(_component_ErrorMessage, {
        key: 0,
        message: $props.errorMessage
      }, null, 8, ["message"])) : createCommentVNode("", true),
      $data.validationErrorMessage !== "" ? (openBlock(), createBlock(_component_ErrorMessage, {
        key: 1,
        message: $data.validationErrorMessage
      }, null, 8, ["message"])) : createCommentVNode("", true)
    ], 2);
  }
  var TextInput = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$1j], ["__scopeId", "data-v-4b807d08"]]);
  const _sfc_main$1i = {
    name: "QtyButton",
    components: {
      MyButton,
      TextInput
    },
    props: {
      item: {
        type: Object
      }
    },
    methods: {
      ...mapActions(useCartStore, ["updateQuantity"])
    }
  };
  const _hoisted_1$1b = {
    key: 0,
    class: "item-qty-container"
  };
  function _sfc_render$1i(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_MyButton = resolveComponent("MyButton");
    const _component_TextInput = resolveComponent("TextInput");
    return $props.item ? (openBlock(), createElementBlock("div", _hoisted_1$1b, [
      createVNode(_component_MyButton, {
        primary: false,
        "aria-label": _ctx.$t("orderSummary.minusOneItem"),
        "data-cy": "qty-decrease",
        label: " - ",
        onClick: _cache[0] || (_cache[0] = ($event) => $props.item.quantity === 1 ? false : _ctx.updateQuantity($props.item, -1))
      }, null, 8, ["aria-label"]),
      createBaseVNode("span", null, [
        createVNode(_component_TextInput, {
          modelValue: $props.item.quantity,
          name: `input-qty-${$props.item.id}`,
          "data-cy": "qty-input",
          placeholder: $props.item.quantity,
          disabled: true
        }, null, 8, ["modelValue", "name", "placeholder"])
      ]),
      createVNode(_component_MyButton, {
        primary: false,
        "aria-label": _ctx.$t("orderSummary.plusOneItem"),
        "data-cy": "qty-increase",
        label: " + ",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.updateQuantity($props.item, 1))
      }, null, 8, ["aria-label"])
    ])) : createCommentVNode("", true);
  }
  var QtyButton = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$1i], ["__scopeId", "data-v-0a66a2bc"]]);
  var binSvg = "/bin.svg";
  const _sfc_main$1h = {
    name: "Remove",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      bin() {
        return `${getStaticUrl(binSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$1a = ["src"];
  function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.bin,
      width: "24",
      height: "24",
      alt: "remove-icon"
    }, null, 8, _hoisted_1$1a);
  }
  var Remove = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["render", _sfc_render$1h]]);
  const _sfc_main$1g = {
    name: "RemoveItemButton",
    components: {
      Remove,
      TextField
    },
    props: {
      product: {
        type: Object
      }
    },
    data() {
      return {
        removeItemText: "",
        removeItemTextId: "bluefinch-checkout-removeitem-text"
      };
    },
    async created() {
      var _a;
      this.removeItemText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.removeItemTextId]) || this.$t("orderSummary.removeItemButton");
      document.addEventListener(this.removeItemTextId, this.setRemoveItemText);
    },
    unmounted() {
      document.removeEventListener(this.removeItemTextId, this.setRemoveItemText);
    },
    methods: {
      ...mapActions(useCartStore, ["removeItem"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      setRemoveItemText(event) {
        this.removeItemText = (event == null ? void 0 : event.detail) || this.$t("orderSummary.removeItemButton");
      }
    }
  };
  const _hoisted_1$19 = { class: "remove-item-icon" };
  const _hoisted_2$X = ["aria-label"];
  function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Remove = resolveComponent("Remove");
    const _component_TextField = resolveComponent("TextField");
    return $props.product ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "remove-item",
      "data-cy": "remove-item-button",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.removeItem($props.product)),
      onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.removeItem($props.product), ["enter"]))
    }, [
      createBaseVNode("div", _hoisted_1$19, [
        createVNode(_component_Remove)
      ]),
      createBaseVNode("button", {
        class: "remove-item-action button--blank",
        "aria-label": _ctx.$t("orderSummary.removeItemButtonLabel")
      }, [
        createVNode(_component_TextField, {
          class: "remove-item-copy",
          text: $data.removeItemText
        }, null, 8, ["text"])
      ], 8, _hoisted_2$X)
    ], 32)) : createCommentVNode("", true);
  }
  var RemoveItemButton = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$1g], ["__scopeId", "data-v-ecc2fb66"]]);
  const _sfc_main$1f = {
    name: "OrderSummaryItem",
    components: {
      TextField,
      Price,
      ErrorMessage,
      ProductOptions,
      QtyButton,
      RemoveItemButton
    },
    props: {
      response: {
        type: Object
      }
    },
    computed: {
      ...mapState(useCartStore, ["cartItems"])
    }
  };
  const _hoisted_1$18 = { key: 0 };
  const _hoisted_2$W = { class: "product-item-container" };
  const _hoisted_3$O = { class: "product-image" };
  const _hoisted_4$x = ["src", "alt"];
  const _hoisted_5$t = { class: "product-item-info" };
  const _hoisted_6$l = { class: "product-item-price" };
  const _hoisted_7$i = { class: "product-item-actions" };
  const _hoisted_8$d = {
    key: 1,
    class: "gift-message"
  };
  const _hoisted_9$8 = {
    key: 2,
    class: "qty-error-message"
  };
  function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_ProductOptions = resolveComponent("ProductOptions");
    const _component_Price = resolveComponent("Price");
    const _component_QtyButton = resolveComponent("QtyButton");
    const _component_RemoveItemButton = resolveComponent("RemoveItemButton");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    return Object.keys(_ctx.cartItems).length !== 0 ? (openBlock(), createElementBlock("div", _hoisted_1$18, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.cartItems, (item, index) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        return openBlock(), createElementBlock("div", {
          key: index,
          class: "product-item"
        }, [
          createBaseVNode("div", _hoisted_2$W, [
            createBaseVNode("div", _hoisted_3$O, [
              createBaseVNode("img", {
                src: (_b = (_a = item.product) == null ? void 0 : _a.thumbnail) == null ? void 0 : _b.url,
                alt: (_d = (_c = item.product) == null ? void 0 : _c.thumbnail) == null ? void 0 : _d.label
              }, null, 8, _hoisted_4$x)
            ]),
            createBaseVNode("div", _hoisted_5$t, [
              createVNode(_component_TextField, {
                text: (_e = item == null ? void 0 : item.product) == null ? void 0 : _e.name
              }, null, 8, ["text"]),
              (item == null ? void 0 : item.configurable_options) ? (openBlock(), createBlock(_component_ProductOptions, {
                key: 0,
                item
              }, null, 8, ["item"])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_6$l, [
                createVNode(_component_Price, {
                  value: (_i = (_h = (_g = (_f = item.product) == null ? void 0 : _f.price_range) == null ? void 0 : _g.minimum_price) == null ? void 0 : _h.final_price) == null ? void 0 : _i.value
                }, null, 8, ["value"])
              ]),
              createBaseVNode("div", _hoisted_7$i, [
                createVNode(_component_QtyButton, { item }, null, 8, ["item"]),
                createVNode(_component_RemoveItemButton, { product: item }, null, 8, ["product"])
              ]),
              item.__typename === "GiftCardCartItem" ? (openBlock(), createElementBlock("div", _hoisted_8$d, [
                createVNode(_component_ProductOptions, {
                  item: {
                    configurable_options: [
                      {
                        option_label: _ctx.$t("giftMessage.to"),
                        value_label: item.recipient_name
                      },
                      {
                        option_label: _ctx.$t("giftMessage.from"),
                        value_label: item.sender_name
                      },
                      {
                        option_label: _ctx.$t("giftMessage.message"),
                        value_label: item.message
                      }
                    ]
                  }
                }, null, 8, ["item"])
              ])) : createCommentVNode("", true),
              (item == null ? void 0 : item.errors) ? (openBlock(), createElementBlock("div", _hoisted_9$8, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(item.errors, (error) => {
                  return openBlock(), createBlock(_component_ErrorMessage, {
                    key: error.message,
                    attached: false,
                    message: error.message
                  }, null, 8, ["message"]);
                }), 128))
              ])) : createCommentVNode("", true)
            ])
          ])
        ]);
      }), 128))
    ])) : createCommentVNode("", true);
  }
  var OrderSummaryItem = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["render", _sfc_render$1f], ["__scopeId", "data-v-d688ed7c"]]);
  const _sfc_main$1e = {
    name: "OrderSummaryTotal",
    components: {
      Price,
      TextField
    },
    data() {
      return {
        orderSummaryText: "",
        orderSummaryTextId: "bluefinch-checkout-ordersummary-text",
        grandTotalText: "",
        grandTotalTextId: "bluefinch-checkout-grandtotal-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["cart", "cartGrandTotal", "getCartItemsQty", "getGiftWrappingTotal"]),
      ...mapState(useConfigStore, ["taxCartDisplayFullSummary"]),
      ...mapState(useShippingMethodsStore, ["selectedMethod"])
    },
    async created() {
      var _a, _b;
      this.orderSummaryText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.orderSummaryTextId]) || this.$t("orderSummary.modalHeader");
      this.grandTotalText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.grandTotalTextId]) || this.$t("orderSummary.grandTotalTitle");
      document.addEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
      document.addEventListener(this.grandTotalTextId, this.setGrandTotalText);
    },
    unmounted() {
      document.removeEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
      document.removeEventListener(this.grandTotalTextId, this.setGrandTotalText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      setOrderSummaryText(event) {
        var _a;
        this.orderSummaryText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.modalHeader");
      },
      setGrandTotalText(event) {
        var _a;
        this.grandTotalText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.grandTotalTitle");
      }
    }
  };
  const _hoisted_1$17 = { class: "order-total-title" };
  const _hoisted_2$V = { class: "order-total-container" };
  const _hoisted_3$N = { class: "order-total-wrapper" };
  const _hoisted_4$w = { class: "total__row" };
  const _hoisted_5$s = { class: "total__row" };
  const _hoisted_6$k = {
    key: 0,
    class: "total__row"
  };
  const _hoisted_7$h = { class: "total__row" };
  const _hoisted_8$c = { class: "order-total-grand" };
  function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
    var _a, _b, _c, _d, _e, _f;
    const _component_TextField = resolveComponent("TextField");
    const _component_Price = resolveComponent("Price");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$17, [
        createVNode(_component_TextField, { text: $data.orderSummaryText }, null, 8, ["text"]),
        _ctx.getCartItemsQty > 0 ? (openBlock(), createBlock(_component_TextField, {
          key: 0,
          class: "order-total-title-amount",
          text: `(${_ctx.getCartItemsQty})`
        }, null, 8, ["text"])) : createCommentVNode("", true)
      ]),
      createBaseVNode("div", _hoisted_2$V, [
        createBaseVNode("div", _hoisted_3$N, [
          createBaseVNode("div", _hoisted_4$w, [
            createVNode(_component_TextField, {
              class: "total__text title",
              text: _ctx.$t("orderSummary.subtotalTitle")
            }, null, 8, ["text"]),
            ((_b = (_a = _ctx.cart) == null ? void 0 : _a.prices) == null ? void 0 : _b.subtotal_including_tax) ? (openBlock(), createBlock(_component_Price, {
              key: 0,
              class: "total__text",
              value: _ctx.cart.prices.subtotal_including_tax.value
            }, null, 8, ["value"])) : createCommentVNode("", true)
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList((_d = (_c = _ctx.cart) == null ? void 0 : _c.prices) == null ? void 0 : _d.discounts, (discount, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: "order-total"
            }, [
              createBaseVNode("div", _hoisted_5$s, [
                createVNode(_component_TextField, {
                  class: "total__text title",
                  text: _ctx.$t("orderSummary.giftCardDiscount.title")
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "total__text discount",
                  value: "-" + discount.amount.value
                }, null, 8, ["value"])
              ])
            ]);
          }), 128)),
          _ctx.getGiftWrappingTotal ? (openBlock(), createElementBlock("div", _hoisted_6$k, [
            createVNode(_component_TextField, {
              class: "total__text title",
              text: _ctx.$t("orderSummary.giftWrappingTitle")
            }, null, 8, ["text"]),
            createVNode(_component_Price, {
              class: "total__text",
              value: _ctx.getGiftWrappingTotal
            }, null, 8, ["value"])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_7$h, [
            createVNode(_component_TextField, {
              class: "total__text title",
              text: _ctx.$t("progressBar.shippingStepTitle")
            }, null, 8, ["text"]),
            ((_f = (_e = _ctx.cart.shipping_addresses) == null ? void 0 : _e[0]) == null ? void 0 : _f.selected_shipping_method) ? (openBlock(), createBlock(_component_Price, {
              key: 0,
              class: "total__text",
              value: _ctx.cart.shipping_addresses[0].selected_shipping_method.price_incl_tax.value ? _ctx.cart.shipping_addresses[0].selected_shipping_method.price_incl_tax.value : _ctx.cart.shipping_addresses[0].selected_shipping_method.amount.value
            }, null, 8, ["value"])) : (openBlock(), createBlock(_component_TextField, {
              key: 1,
              class: "total__text",
              text: _ctx.$t("shippingStep.tbc")
            }, null, 8, ["text"]))
          ])
        ]),
        createBaseVNode("div", _hoisted_8$c, [
          createVNode(_component_TextField, {
            class: "title",
            text: $data.grandTotalText
          }, null, 8, ["text"]),
          createVNode(_component_Price, {
            value: _ctx.cartGrandTotal / 100
          }, null, 8, ["value"])
        ])
      ])
    ], 64);
  }
  var OrderSummaryTotal = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$1e], ["__scopeId", "data-v-548caefe"]]);
  const _sfc_main$1d = {
    name: "DropDown"
  };
  const _hoisted_1$16 = { class: "dropdown" };
  function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$16, [
      renderSlot(_ctx.$slots, "content", {}, () => [
        createTextVNode(" default content ")
      ])
    ]);
  }
  var DropDown = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$1d]]);
  var promoSvg = "/promo-icon.svg";
  const _sfc_main$1c = {
    name: "PromotionComponent",
    components: {
      Price,
      TextField,
      MyButton,
      DropDown,
      ArrowUp,
      ArrowDown
    },
    data() {
      return {
        isDropDownVisible: false,
        crossSellsText: "",
        crossSellsCTAText: "",
        crossSellsTextId: "bluefinch-checkout-crosssells-text",
        crossSellsCTATextId: "bluefinch-checkout-crosssells-cta-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["crosssells", "freeShipping", "amastyEnabled"]),
      promoIconUrl() {
        return `${getStaticUrl(promoSvg)}`;
      }
    },
    async created() {
      var _a, _b;
      this.crossSellsText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.crossSellsTextId]) || this.$t("orderSummary.crossSellsTitle");
      this.crossSellsCTAText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.crossSellsCTATextId]) || this.$t("orderSummary.addToCart");
      document.addEventListener(this.crossSellsTextId, this.setCrossSellsText);
      document.addEventListener(this.crossSellsCTATextId, this.setCrossSellsCTAText);
    },
    unmounted() {
      document.removeEventListener(this.crossSellsTextId, this.setCrossSellsText);
      document.removeEventListener(this.crossSellsCTATextId, this.setCrossSellsCTAText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useCartStore, [
        "getCart",
        "getCrosssells",
        "getAmastyShippingData",
        "addCartItem"
      ]),
      setCrossSellsText(event) {
        var _a;
        this.crossSellsText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.crossSellsTitle");
      },
      setCrossSellsCTAText(event) {
        var _a;
        this.crossSellsCTAText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.addToCart");
      },
      openDropDown() {
        this.isDropDownVisible = !this.isDropDownVisible;
      },
      openDropDownKeyDown(event) {
        if (event.type === "keydown" && event.key === "Enter") {
          this.isDropDownVisible = !this.isDropDownVisible;
        }
      },
      async addItem(product) {
        await this.addCartItem(product);
      }
    }
  };
  const _hoisted_1$15 = { class: "promotion-icon-container" };
  const _hoisted_2$U = ["src"];
  const _hoisted_3$M = { class: "promo-title no-shipping" };
  const _hoisted_4$v = { class: "promo-title crosssells" };
  const _hoisted_5$r = { class: "product-item-image" };
  const _hoisted_6$j = ["src", "alt"];
  const _hoisted_7$g = { class: "product-item-info" };
  const _hoisted_8$b = { class: "product-actions" };
  function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_Price = resolveComponent("Price");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_DropDown = resolveComponent("DropDown");
    return openBlock(), createElementBlock(Fragment, null, [
      _ctx.freeShipping > 0 && _ctx.crosssells.length === 0 ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["promotion-trigger dropdown-button", { opened: $data.isDropDownVisible }]),
        tabindex: "0",
        "data-cy": "dropdown-trigger",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.openDropDown && $options.openDropDown(...args)),
        onKeydown: _cache[1] || (_cache[1] = ($event) => $options.openDropDownKeyDown($event))
      }, [
        createBaseVNode("div", _hoisted_1$15, [
          createBaseVNode("img", {
            src: $options.promoIconUrl,
            alt: "promo-dropdown-icon"
          }, null, 8, _hoisted_2$U)
        ]),
        createBaseVNode("div", _hoisted_3$M, [
          createBaseVNode("div", null, [
            createVNode(_component_TextField, {
              text: _ctx.$t("orderSummary.couponCodeTitle")
            }, null, 8, ["text"]),
            createVNode(_component_Price, {
              class: "bold",
              value: _ctx.freeShipping
            }, null, 8, ["value"]),
            createVNode(_component_TextField, {
              text: _ctx.$t("orderSummary.couponCodeTitleBottom")
            }, null, 8, ["text"]),
            createVNode(_component_TextField, {
              class: "bold",
              text: _ctx.$t("orderSummary.couponCodeTitleFreeShipping")
            }, null, 8, ["text"])
          ])
        ]),
        !$data.isDropDownVisible && _ctx.crosssells.length ? (openBlock(), createBlock(_component_ArrowDown, {
          key: 0,
          class: "dropdown-arrow__down"
        })) : createCommentVNode("", true),
        $data.isDropDownVisible && _ctx.crosssells.length ? (openBlock(), createBlock(_component_ArrowUp, {
          key: 1,
          class: "dropdown-arrow__up"
        })) : createCommentVNode("", true)
      ], 34)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(["promotion-trigger dropdown-button", { opened: $data.isDropDownVisible }]),
        tabindex: "0",
        "data-cy": "dropdown-trigger",
        onClick: _cache[2] || (_cache[2] = (...args) => $options.openDropDown && $options.openDropDown(...args)),
        onKeydown: _cache[3] || (_cache[3] = ($event) => $options.openDropDownKeyDown($event))
      }, [
        createBaseVNode("div", _hoisted_4$v, [
          createBaseVNode("div", null, [
            createVNode(_component_TextField, { text: $data.crossSellsText }, null, 8, ["text"])
          ]),
          !$data.isDropDownVisible && _ctx.crosssells.length ? (openBlock(), createBlock(_component_ArrowDown, {
            key: 0,
            class: "dropdown-arrow__down"
          })) : createCommentVNode("", true),
          $data.isDropDownVisible && _ctx.crosssells.length ? (openBlock(), createBlock(_component_ArrowUp, {
            key: 1,
            class: "dropdown-arrow__up"
          })) : createCommentVNode("", true)
        ])
      ], 34),
      $data.isDropDownVisible && _ctx.crosssells.length ? (openBlock(), createBlock(_component_DropDown, {
        key: 1,
        class: normalizeClass(["promo-dropdown", { active: $data.isDropDownVisible }])
      }, {
        content: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(["product-item-carousel", `product-item-carousel-${_ctx.crosssells.length}`])
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.crosssells, (product, index) => {
              return openBlock(), createElementBlock("div", {
                key: index,
                class: "product-item"
              }, [
                createBaseVNode("div", _hoisted_5$r, [
                  createBaseVNode("img", {
                    src: product.thumbnail.url,
                    alt: product.thumbnail.label
                  }, null, 8, _hoisted_6$j)
                ]),
                createBaseVNode("div", _hoisted_7$g, [
                  createVNode(_component_TextField, {
                    text: product.name,
                    class: "product-item-name"
                  }, null, 8, ["text"]),
                  createVNode(_component_Price, {
                    class: "product-item-price",
                    value: product.price_range.minimum_price.final_price.value
                  }, null, 8, ["value"])
                ]),
                createBaseVNode("div", _hoisted_8$b, [
                  createVNode(_component_MyButton, {
                    primary: "",
                    label: $data.crossSellsCTAText,
                    onClick: ($event) => $options.addItem(product)
                  }, null, 8, ["label", "onClick"])
                ])
              ]);
            }), 128))
          ], 2)
        ]),
        _: 1
      }, 8, ["class"])) : createCommentVNode("", true)
    ], 64);
  }
  var PromotionComponent = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$1c], ["__scopeId", "data-v-5d853955"]]);
  const _sfc_main$1b = {
    name: "SuccessIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$14 = ["role", "aria-label"];
  const _hoisted_2$T = /* @__PURE__ */ createBaseVNode("path", { d: "M0 7.5a7.5 7.5 0 1 1 15 0a7.5 7.5 0 0 1-15 0Zm7.072 3.21l4.318-5.398l-.78-.624l-3.682 4.601L4.32 7.116l-.64.768l3.392 2.827Z" }, null, -1);
  const _hoisted_3$L = [
    _hoisted_2$T
  ];
  function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "20",
      height: "20",
      viewBox: "0 0 15 15",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$L, 12, _hoisted_1$14);
  }
  var SuccessIcon = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$1b]]);
  const _sfc_main$1a = {
    name: "SuccessMessage",
    components: {
      TextField,
      SuccessIcon
    },
    props: {
      message: {
        type: String,
        require: true,
        default: ""
      },
      backgroundColor: {
        type: String
      },
      color: {
        type: String
      },
      borderColor: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor,
          color: reactiveProps.color,
          borderColor: reactiveProps.borderColor
        }))
      };
    }
  };
  function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_SuccessIcon = resolveComponent("SuccessIcon");
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", {
      class: "success-message",
      style: normalizeStyle($setup.style)
    }, [
      createVNode(_component_SuccessIcon),
      createVNode(_component_TextField, { text: $props.message }, null, 8, ["text"])
    ], 4);
  }
  var SuccessMessage = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$1a], ["__scopeId", "data-v-3c631fa8"]]);
  var GiftIcon = "/gift-icon.svg";
  const _sfc_main$19 = {
    name: "GiftCardDiscount",
    components: {
      DropDown,
      TextField,
      ArrowDown,
      ArrowUp,
      TextInput,
      MyButton,
      ErrorMessage,
      SuccessMessage
    },
    data() {
      return {
        isDropDownVisible: false,
        applyButtonText: "",
        applyButtonTextId: "bluefinch-checkout-applybutton-text",
        removeButtonText: "",
        removeButtonTextId: "bluefinch-checkout-removebutton-text",
        giftCardText: "",
        giftCardTextId: "bluefinch-checkout-giftcard-text",
        giftCardPlaceholderText: "",
        giftCardPlaceholderTextId: "bluefinch-checkout-giftcardplaceholder-text"
      };
    },
    async created() {
      var _a, _b, _c, _d;
      await this.getInitialConfig();
      this.applyButtonText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.applyButtonTextId]) || this.$t("orderSummary.applyBtn");
      this.removeButtonText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.removeButtonTextId]) || this.$t("orderSummary.removeBtn");
      this.giftCardText = ((_c = window.bluefinchCheckout) == null ? void 0 : _c[this.giftCardTextId]) || this.$t("orderSummary.giftDiscountTitle");
      this.giftCardPlaceholderText = ((_d = window.bluefinchCheckout) == null ? void 0 : _d[this.giftCardPlaceholderTextId]) || this.$t("orderSummary.giftCardDiscount.placeholder");
      document.addEventListener(this.applyButtonTextId, this.setApplyButtonText);
      document.addEventListener(this.removeButtonTextId, this.setRemoveButtonText);
      document.addEventListener(this.giftCardTextId, this.setGiftCardText);
      document.addEventListener(this.giftCardPlaceholderTextId, this.setGiftCardPlaceholderText);
    },
    unmounted() {
      document.removeEventListener(this.applyButtonTextId, this.setApplyButtonText);
      document.removeEventListener(this.removeButtonTextId, this.setRemoveButtonText);
      document.removeEventListener(this.giftCardTextId, this.setGiftCardText);
      document.removeEventListener(this.giftCardPlaceholderTextId, this.setGiftCardPlaceholderText);
    },
    computed: {
      ...mapState(useCartStore, ["cart", "giftCardErrorMessage"]),
      ...mapWritableState(useCartStore, ["giftCardCode"]),
      GiftIcon() {
        return `${getStaticUrl(GiftIcon)}`;
      }
    },
    methods: {
      ...mapActions(useCartStore, ["addGiftCardCode", "removeGiftCardCode"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useLoadingStore, ["setLoadingState"]),
      setApplyButtonText(event) {
        var _a;
        this.applyButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.applyBtn");
      },
      setRemoveButtonText(event) {
        var _a;
        this.removeButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.removeBtn");
      },
      setGiftCardText(event) {
        var _a;
        this.giftCardText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.giftDiscountTitle");
      },
      setGiftCardPlaceholderText(event) {
        var _a;
        this.giftCardPlaceholderText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.giftCardDiscount.placeholder");
      },
      async dispatchDiscountCode() {
      },
      openDropDown() {
        this.isDropDownVisible = !this.isDropDownVisible;
      },
      openDropDownKeyDown(event) {
        if (event.type === "keydown" && event.key === "Enter") {
          this.isDropDownVisible = !this.isDropDownVisible;
        }
      }
    }
  };
  const _hoisted_1$13 = { class: "gift-discount-icon-container" };
  const _hoisted_2$S = ["src"];
  const _hoisted_3$K = { class: "field gift-code-field" };
  const _hoisted_4$u = { class: "success" };
  const _hoisted_5$q = { class: "error" };
  function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_SuccessMessage = resolveComponent("SuccessMessage");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_DropDown = resolveComponent("DropDown");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", {
        class: normalizeClass(["gift-discount-trigger dropdown-button", { opened: $data.isDropDownVisible }]),
        "data-cy": "dropdown-trigger-gift",
        tabindex: "0",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.openDropDown && $options.openDropDown(...args)),
        onKeydown: _cache[1] || (_cache[1] = ($event) => $options.openDropDownKeyDown($event))
      }, [
        createBaseVNode("div", _hoisted_1$13, [
          createBaseVNode("img", {
            src: $options.GiftIcon,
            alt: "gift-dropdown-icon"
          }, null, 8, _hoisted_2$S)
        ]),
        createVNode(_component_TextField, {
          text: $data.giftCardText,
          class: "gift-discount-title"
        }, null, 8, ["text"]),
        withDirectives(createVNode(_component_ArrowDown, { class: "dropdown-arrow__down" }, null, 512), [
          [vShow, !$data.isDropDownVisible]
        ]),
        withDirectives(createVNode(_component_ArrowUp, { class: "dropdown-arrow__up" }, null, 512), [
          [vShow, $data.isDropDownVisible]
        ])
      ], 34),
      withDirectives(createVNode(_component_DropDown, {
        class: normalizeClass(["gift-dropdown", { active: $data.isDropDownVisible }])
      }, {
        content: withCtx(() => {
          var _a, _b, _c;
          return [
            createBaseVNode("div", _hoisted_3$K, [
              createVNode(_component_TextInput, {
                error: _ctx.giftCardErrorMessage,
                name: "gift-code",
                placeholder: $data.giftCardPlaceholderText,
                autocomplete: "off"
              }, null, 8, ["error", "placeholder"]),
              !((_a = _ctx.cart.applied_gift_cards) == null ? void 0 : _a[0]) ? (openBlock(), createBlock(_component_MyButton, {
                key: 0,
                primary: "",
                label: $data.applyButtonText,
                onClick: _cache[2] || (_cache[2] = ($event) => $options.dispatchDiscountCode(_ctx.giftCardCode))
              }, null, 8, ["label"])) : createCommentVNode("", true),
              ((_b = _ctx.cart.applied_gift_cards) == null ? void 0 : _b[0]) ? (openBlock(), createBlock(_component_MyButton, {
                key: 1,
                secondary: "",
                label: $data.removeButtonText,
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.removeGiftCardCode(_ctx.giftCardCode))
              }, null, 8, ["label"])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_4$u, [
                ((_c = _ctx.cart.applied_gift_cards) == null ? void 0 : _c[0]) ? (openBlock(), createBlock(_component_SuccessMessage, {
                  key: 0,
                  message: _ctx.$t("orderSummary.giftCardDiscount.successMessage", { code: _ctx.giftCardCode })
                }, null, 8, ["message"])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_5$q, [
                _ctx.giftCardErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
                  key: 0,
                  message: _ctx.$t("orderSummary.giftCardDiscount.errorMessage")
                }, null, 8, ["message"])) : createCommentVNode("", true)
              ])
            ])
          ];
        }),
        _: 1
      }, 8, ["class"]), [
        [vShow, $data.isDropDownVisible]
      ])
    ], 64);
  }
  var GiftCardDiscount = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$19], ["__scopeId", "data-v-6cbe4d37"]]);
  var CouponCode = "/coupon-icon.svg";
  const _sfc_main$18 = {
    name: "CouponDiscount",
    components: {
      DropDown,
      TextField,
      ArrowDown,
      ArrowUp,
      TextInput,
      MyButton,
      ErrorMessage,
      SuccessMessage
    },
    data() {
      return {
        isDropDownVisible: false,
        applyButtonText: "",
        applyButtonTextId: "bluefinch-checkout-applybutton-text",
        removeButtonText: "",
        removeButtonTextId: "bluefinch-checkout-removebutton-text",
        couponDiscountText: "",
        couponDiscountTextId: "bluefinch-checkout-coupondiscount-text",
        couponDiscountPlaceholderText: "",
        couponDiscountPlaceholderTextId: "bluefinch-checkout-coupondiscountplaceholder-text"
      };
    },
    async created() {
      var _a, _b, _c, _d;
      this.applyButtonText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.applyButtonTextId]) || this.$t("orderSummary.applyBtn");
      this.removeButtonText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.removeButtonTextId]) || this.$t("orderSummary.removeBtn");
      this.couponDiscountText = ((_c = window.bluefinchCheckout) == null ? void 0 : _c[this.couponDiscountTextId]) || this.$t("orderSummary.couponDiscountTitle");
      this.couponDiscountPlaceholderText = ((_d = window.bluefinchCheckout) == null ? void 0 : _d[this.couponDiscountTextId]) || this.$t("orderSummary.couponDiscount.placeholder");
      document.addEventListener(this.applyButtonTextId, this.setApplyButtonText);
      document.addEventListener(this.removeButtonTextId, this.setRemoveButtonText);
      document.addEventListener(this.couponDiscountTextId, this.setcouponDiscountText);
      document.addEventListener(this.couponDiscountPlaceholderTextId, this.setCouponDiscountPlaceholderText);
    },
    unmounted() {
      document.removeEventListener(this.applyButtonTextId, this.setApplyButtonText);
      document.removeEventListener(this.removeButtonTextId, this.setRemoveButtonText);
      document.removeEventListener(this.couponDiscountTextId, this.setcouponDiscountText);
      document.removeEventListener(this.couponDiscountPlaceholderTextId, this.setCouponDiscountPlaceholderText);
    },
    computed: {
      ...mapState(useCartStore, ["cart", "discountErrorMessage"]),
      ...mapWritableState(useCartStore, ["discountCode"]),
      CouponCodeIcon() {
        return `${getStaticUrl(CouponCode)}`;
      }
    },
    methods: {
      ...mapActions(useCartStore, ["addDiscountCode", "removeDiscountCode"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useLoadingStore, ["setLoadingState"]),
      setApplyButtonText(event) {
        var _a;
        this.applyButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.applyBtn");
      },
      setRemoveButtonText(event) {
        var _a;
        this.removeButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.removeBtn");
      },
      setcouponDiscountText(event) {
        var _a;
        this.couponDiscountText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.couponDiscountTitle");
      },
      setCouponDiscountPlaceholderText(event) {
        var _a;
        this.couponDiscountPlaceholderText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.couponDiscount.placeholder");
      },
      async dispatchDiscountCode() {
      },
      openDropDown() {
        this.isDropDownVisible = !this.isDropDownVisible;
      },
      openDropDownKeyDown(event) {
        if (event.type === "keydown" && event.key === "Enter") {
          this.isDropDownVisible = !this.isDropDownVisible;
        }
      }
    }
  };
  const _hoisted_1$12 = { class: "coupon-discount-icon-container" };
  const _hoisted_2$R = ["src"];
  const _hoisted_3$J = { class: "field coupon-code-field" };
  const _hoisted_4$t = { class: "success" };
  const _hoisted_5$p = { class: "error" };
  function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_SuccessMessage = resolveComponent("SuccessMessage");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_DropDown = resolveComponent("DropDown");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", {
        class: normalizeClass(["coupon-discount-trigger dropdown-button", { opened: $data.isDropDownVisible }]),
        tabindex: "0",
        "data-cy": "dropdown-trigger-coupon",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.openDropDown && $options.openDropDown(...args)),
        onKeydown: _cache[1] || (_cache[1] = ($event) => $options.openDropDownKeyDown($event))
      }, [
        createBaseVNode("div", _hoisted_1$12, [
          createBaseVNode("img", {
            src: $options.CouponCodeIcon,
            alt: "coupon-dropdown-icon"
          }, null, 8, _hoisted_2$R)
        ]),
        createVNode(_component_TextField, {
          text: $data.couponDiscountText,
          class: "coupon-discount-title"
        }, null, 8, ["text"]),
        withDirectives(createVNode(_component_ArrowDown, { class: "dropdown-arrow__down" }, null, 512), [
          [vShow, !$data.isDropDownVisible]
        ]),
        withDirectives(createVNode(_component_ArrowUp, { class: "dropdown-arrow__up" }, null, 512), [
          [vShow, $data.isDropDownVisible]
        ])
      ], 34),
      withDirectives(createVNode(_component_DropDown, {
        class: normalizeClass(["coupon-dropdown", { active: $data.isDropDownVisible }])
      }, {
        content: withCtx(() => {
          var _a, _b, _c, _d;
          return [
            createBaseVNode("div", _hoisted_3$J, [
              createVNode(_component_TextInput, {
                modelValue: _ctx.discountCode,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.discountCode = $event),
                error: _ctx.discountErrorMessage,
                name: "coupon-code",
                placeholder: $data.couponDiscountPlaceholderText,
                disabled: (_a = _ctx.cart.applied_coupons) == null ? void 0 : _a.length,
                autocomplete: "off"
              }, null, 8, ["modelValue", "error", "placeholder", "disabled"]),
              !((_b = _ctx.cart.applied_coupons) == null ? void 0 : _b.length) ? (openBlock(), createBlock(_component_MyButton, {
                key: 0,
                primary: "",
                label: $data.applyButtonText,
                onClick: _cache[3] || (_cache[3] = ($event) => $options.dispatchDiscountCode(_ctx.discountCode))
              }, null, 8, ["label"])) : createCommentVNode("", true),
              ((_c = _ctx.cart.applied_coupons) == null ? void 0 : _c.length) ? (openBlock(), createBlock(_component_MyButton, {
                key: 1,
                secondary: "",
                label: $data.removeButtonText,
                onClick: _ctx.removeDiscountCode
              }, null, 8, ["label", "onClick"])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_4$t, [
                ((_d = _ctx.cart.applied_coupons) == null ? void 0 : _d.length) ? (openBlock(), createBlock(_component_SuccessMessage, {
                  key: 0,
                  message: _ctx.$t("orderSummary.couponDiscount.successMessage", { code: _ctx.cart.applied_coupons[0].code })
                }, null, 8, ["message"])) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_5$p, [
                _ctx.discountErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
                  key: 0,
                  message: _ctx.discountErrorMessage
                }, null, 8, ["message"])) : createCommentVNode("", true)
              ])
            ])
          ];
        }),
        _: 1
      }, 8, ["class"]), [
        [vShow, $data.isDropDownVisible]
      ])
    ], 64);
  }
  var CouponDiscount = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$18], ["__scopeId", "data-v-0d977cc3"]]);
  const _sfc_main$17 = {
    name: "OrderSummaryTitleWithAmount",
    props: ["orderItemsAmount"],
    components: {
      TextField
    },
    data() {
      return {
        orderSummaryText: "",
        orderSummaryTextId: "bluefinch-checkout-ordersummary-text"
      };
    },
    async created() {
      var _a;
      this.orderSummaryText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.orderSummaryTextId]) || this.$t("orderSummary.modalHeader");
      document.addEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
    },
    unmounted() {
      document.removeEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      setOrderSummaryText(event) {
        var _a;
        this.orderSummaryText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.modalHeader");
      }
    }
  };
  const _hoisted_1$11 = { class: "order-summary-title-amount" };
  function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", _hoisted_1$11, [
      createVNode(_component_TextField, { text: $data.orderSummaryText }, null, 8, ["text"]),
      createVNode(_component_TextField, { text: "(" }),
      createVNode(_component_TextField, { text: $props.orderItemsAmount }, null, 8, ["text"]),
      createVNode(_component_TextField, { text: ")" })
    ]);
  }
  var OrderSummaryTitleWithAmount = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$17], ["__scopeId", "data-v-59074e4c"]]);
  const _sfc_main$16 = {
    name: "Close",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$10 = ["role", "aria-label"];
  const _hoisted_2$Q = /* @__PURE__ */ createBaseVNode("path", {
    d: "M19.6142 17.7537L13.8617 12L19.6142 6.24626C20.1286 5.7317 20.1286 4.90048 19.6142 4.38592C19.0997 3.87136 18.2687 3.87136 17.7542 4.38592L12.0018 10.1397L6.24576 4.38592C5.73131 3.87136 4.90028 3.87136 4.38583 4.38592C3.87139 4.90048 3.87139 5.7317 4.38583 6.24626L10.1383 12L4.38583 17.7537C3.87139 18.2683 3.87139 19.0995 4.38583 19.6141C4.90028 20.1286 5.73131 20.1286 6.24576 19.6141L11.9982 13.8603L17.7506 19.6141C18.2651 20.1286 19.0961 20.1286 19.6106 19.6141C20.125 19.0995 20.125 18.2683 19.6106 17.7537H19.6142Z",
    fill: "#3F5D7C"
  }, null, -1);
  const _hoisted_3$I = [
    _hoisted_2$Q
  ];
  function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$I, 12, _hoisted_1$10);
  }
  var CloseIcon = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16]]);
  const _sfc_main$15 = {
    name: "OrderSummaryMobile",
    components: {
      ArrowDown,
      TextField,
      ArrowUp,
      OrderSummaryItem,
      OrderSummaryTotal,
      Price,
      GiftCardDiscount,
      CouponDiscount,
      PromotionComponent,
      SlideUp,
      Close: CloseIcon,
      OrderSummaryTitleWithAmount
    },
    props: {
      backgroundColor: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          backgroundColor: reactiveProps.backgroundColor
        }))
      };
    },
    data() {
      return {
        isModalVisible: false,
        orderSummaryText: "",
        orderSummaryTextId: "bluefinch-checkout-ordersummary-text",
        orderSummaryDescriptionText: "",
        orderSummaryDescriptionTextId: "bluefinch-checkout-ordersummarydescription-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["cartGrandTotal", "getCartItemsQty"]),
      ...mapState(useConfigStore, ["storeCode"])
    },
    async created() {
      var _a, _b;
      this.orderSummaryText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.orderSummaryTextId]) || this.$t("orderSummary.modalHeader");
      this.orderSummaryDescriptionText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.orderSummaryDescriptionTextId]) || this.$t("orderSummary.mobileDiscountText");
      document.addEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
      document.addEventListener(this.orderSummaryDescriptionTextId, this.setOrderSummaryDescriptionText);
    },
    unmounted() {
      document.removeEventListener(this.orderSummaryTextId, this.setOrderSummaryText);
      document.removeEventListener(this.orderSummaryDescriptionTextId, this.setOrderSummaryDescriptionText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useCustomerStore, ["getCustomerInformation", "checkForGuestUser"]),
      ...mapActions(useCartStore, ["getCart"]),
      toggleSummary() {
        this.isModalVisible = !this.isModalVisible;
        if (this.isModalVisible) {
          document.body.classList.add("no-scrollable");
        } else {
          document.body.classList.remove("no-scrollable");
        }
      },
      closeSummary() {
        document.body.classList.remove("no-scrollable");
        this.isModalVisible = false;
      },
      setOrderSummaryText(event) {
        var _a;
        this.orderSummaryText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.modalHeader");
      },
      setOrderSummaryDescriptionText(event) {
        var _a;
        this.orderSummaryDescriptionText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("orderSummary.mobileDiscountText");
      }
    }
  };
  const _hoisted_1$$ = ["aria-label"];
  const _hoisted_2$P = { class: "product-items" };
  const _hoisted_3$H = {
    key: 0,
    class: "order-summary-header"
  };
  const _hoisted_4$s = { class: "order-summary-title" };
  const _hoisted_5$o = { class: "order-summary-icon" };
  const _hoisted_6$i = {
    key: 0,
    class: "arrow-up-icon"
  };
  const _hoisted_7$f = { class: "order-summary-description" };
  function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OrderSummaryTitleWithAmount = resolveComponent("OrderSummaryTitleWithAmount");
    const _component_Close = resolveComponent("Close");
    const _component_PromotionComponent = resolveComponent("PromotionComponent");
    const _component_CouponDiscount = resolveComponent("CouponDiscount");
    const _component_GiftCardDiscount = resolveComponent("GiftCardDiscount");
    const _component_OrderSummaryItem = resolveComponent("OrderSummaryItem");
    const _component_OrderSummaryTotal = resolveComponent("OrderSummaryTotal");
    const _component_SlideUp = resolveComponent("SlideUp");
    const _component_TextField = resolveComponent("TextField");
    const _component_Price = resolveComponent("Price");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(_component_SlideUp, {
        visible: $data.isModalVisible,
        onClose: $options.closeSummary
      }, {
        header: withCtx(() => [
          createVNode(_component_OrderSummaryTitleWithAmount, { "order-items-amount": _ctx.getCartItemsQty }, null, 8, ["order-items-amount"]),
          createBaseVNode("button", {
            class: "order-summary-close-button",
            "aria-label": _ctx.$t("orderSummary.closeButton"),
            onClick: _cache[0] || (_cache[0] = (...args) => $options.toggleSummary && $options.toggleSummary(...args)),
            onKeydown: _cache[1] || (_cache[1] = (...args) => $options.toggleSummary && $options.toggleSummary(...args))
          }, [
            createVNode(_component_Close)
          ], 40, _hoisted_1$$)
        ]),
        body: withCtx(() => [
          createVNode(_component_PromotionComponent),
          createVNode(_component_CouponDiscount),
          createVNode(_component_GiftCardDiscount),
          createBaseVNode("div", _hoisted_2$P, [
            createVNode(_component_OrderSummaryItem)
          ]),
          createVNode(_component_OrderSummaryTotal)
        ]),
        _: 1
      }, 8, ["visible", "onClose"]),
      createBaseVNode("div", {
        class: "is-hidden-desktop is-hidden-tablet order-summary-container",
        style: normalizeStyle($setup.style),
        onClick: _cache[2] || (_cache[2] = (...args) => $options.toggleSummary && $options.toggleSummary(...args)),
        onKeydown: _cache[3] || (_cache[3] = (...args) => $options.toggleSummary && $options.toggleSummary(...args))
      }, [
        _ctx.cartGrandTotal || _ctx.getCartItemsQty ? (openBlock(), createElementBlock("div", _hoisted_3$H, [
          createBaseVNode("div", _hoisted_4$s, [
            createVNode(_component_TextField, {
              class: "order-summary-title-text",
              text: $data.orderSummaryText + ": "
            }, null, 8, ["text"]),
            _ctx.cartGrandTotal !== null ? (openBlock(), createBlock(_component_Price, {
              key: 0,
              class: "price",
              value: _ctx.cartGrandTotal / 100
            }, null, 8, ["value"])) : createCommentVNode("", true),
            createVNode(_component_Price, {
              class: "storyBookEmptyPrice",
              value: "532.5"
            })
          ]),
          createBaseVNode("div", _hoisted_5$o, [
            $data.isModalVisible ? (openBlock(), createElementBlock("div", _hoisted_6$i, [
              createVNode(_component_ArrowUp)
            ])) : (openBlock(), createBlock(_component_ArrowDown, { key: 1 }))
          ]),
          createBaseVNode("div", _hoisted_7$f, [
            createVNode(_component_TextField, { text: $data.orderSummaryDescriptionText }, null, 8, ["text"])
          ])
        ])) : createCommentVNode("", true)
      ], 36)
    ], 64);
  }
  var OrderSummaryMobile = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$15], ["__scopeId", "data-v-137fa8b0"]]);
  const _sfc_main$14 = {
    name: "OrderSummaryDesktop",
    components: {
      OrderSummaryTotal,
      OrderSummaryItem,
      PromotionComponent,
      GiftCardDiscount,
      CouponDiscount
    }
  };
  const _hoisted_1$_ = { class: "order-summary-desktop" };
  const _hoisted_2$O = { class: "order-summary-desktop-items" };
  function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_PromotionComponent = resolveComponent("PromotionComponent");
    const _component_CouponDiscount = resolveComponent("CouponDiscount");
    const _component_GiftCardDiscount = resolveComponent("GiftCardDiscount");
    const _component_OrderSummaryItem = resolveComponent("OrderSummaryItem");
    const _component_OrderSummaryTotal = resolveComponent("OrderSummaryTotal");
    return openBlock(), createElementBlock("div", _hoisted_1$_, [
      createVNode(_component_PromotionComponent),
      createVNode(_component_CouponDiscount),
      createVNode(_component_GiftCardDiscount),
      createBaseVNode("div", _hoisted_2$O, [
        createVNode(_component_OrderSummaryItem)
      ]),
      createVNode(_component_OrderSummaryTotal)
    ]);
  }
  var OrderSummaryDesktop = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$14], ["__scopeId", "data-v-4086cf69"]]);
  const _sfc_main$13 = {
    name: "AppSteps",
    components: {
      OrderSummaryDesktop
    }
  };
  const _hoisted_1$Z = { class: "root" };
  const _hoisted_2$N = { class: "steps-container" };
  const _hoisted_3$G = { class: "container" };
  const _hoisted_4$r = { class: "is-hidden-mobile summary" };
  const _hoisted_5$n = { class: "content" };
  function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_OrderSummaryDesktop = resolveComponent("OrderSummaryDesktop");
    const _component_router_view = resolveComponent("router-view");
    return openBlock(), createElementBlock("div", _hoisted_1$Z, [
      createBaseVNode("div", _hoisted_2$N, [
        createBaseVNode("div", _hoisted_3$G, [
          createBaseVNode("div", _hoisted_4$r, [
            createVNode(_component_OrderSummaryDesktop)
          ]),
          createBaseVNode("div", _hoisted_5$n, [
            createVNode(_component_router_view, null, {
              default: withCtx(({ Component }) => [
                createVNode(Transition, null, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(Component)))
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 1
            })
          ])
        ])
      ])
    ]);
  }
  var Steps = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$13]]);
  const _sfc_main$12 = {
    name: "App",
    components: {
      AppFooter,
      AppHeader,
      Loader,
      MockDesktop,
      MockFull,
      MockLaptop,
      MockMobile,
      MockTablet,
      OrderSummaryMobile,
      Steps
    },
    data() {
      return {
        currentDevice: "MockDesktop",
        currentStep: "SignInPage",
        currentUser: "NoUser",
        devices: [
          { deviceName: "MockMobile", displayName: "Mobile" },
          { deviceName: "MockTablet", displayName: "Tablet" },
          { deviceName: "MockLaptop", displayName: "Laptop" },
          { deviceName: "MockDesktop", displayName: "Desktop" },
          { deviceName: "MockFull", displayName: "Full" }
        ],
        checkoutSteps: [
          { stepName: "SignInPage", displayName: "Sign In" },
          { stepName: "YourDetails", displayName: "Your Details" },
          { stepName: "Shipping", displayName: "Shipping" },
          { stepName: "Payment", displayName: "Payment" }
        ],
        userType: [
          { userTypeName: "NoUser", displayName: "No User" },
          { userTypeName: "GuestUser", displayName: "Guest User" },
          { userTypeName: "RegisteredUser", displayName: "Registered User" }
        ]
      };
    },
    computed: {
      ...mapState(useStepsStore, ["signInPageActive", "yourDetailsActive", "shippingActive", "paymentActive"])
    },
    async created() {
      this.goToSignInPage();
      this.dummyLogOut(this.currentStep);
      await this.getInitialConfig();
      this.dispatchDeviceType(this.currentDevice);
      this.dispatchStep(this.currentStep);
      document.dispatchEvent(new Event("bluefinch-checkout-loaded"));
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useStepsStore, ["goToSignInPage", "goToYouDetails", "goToShipping", "goToPayment"]),
      ...mapActions(useCustomerStore, ["dummyLogIn", "dummyLogOut", "dummyUserType"]),
      switchDevice(device) {
        this.currentDevice = device.deviceName;
        this.dispatchDeviceType(device.deviceName);
      },
      dispatchDeviceType(deviceName) {
        document.dispatchEvent(new CustomEvent("switchDeviceType", { detail: deviceName }));
      },
      goToStep(step) {
        this.currentStep = step.stepName;
        switch (step.stepName) {
          case "SignInPage":
            this.dummyLogOut(step.stepName);
            this.setUserStatus({ userTypeName: "NoUser", displayName: "No User" });
            this.goToSignInPage();
            break;
          case "YourDetails":
            this.dummyLogIn(step.stepName);
            this.goToYouDetails();
            break;
          case "Shipping":
            this.dummyLogOut(step.stepName);
            this.dummyUserType("NoUser");
            this.goToShipping();
            break;
          case "Payment":
            this.dummyLogOut(step.stepName);
            this.dummyUserType("NoUser");
            this.goToPayment();
            break;
        }
        this.dispatchStep(step.stepName);
      },
      dispatchStep(stepName) {
        document.dispatchEvent(new CustomEvent("switchDisplayedStep", { detail: stepName }));
      },
      setUserStatus(user) {
        this.currentUser = user.userTypeName;
        this.dummyUserType(user.userTypeName);
        this.dispatchUserStatus(user.userTypeName);
      },
      dispatchUserStatus(userType) {
        document.dispatchEvent(new CustomEvent("updateUserStatus", { detail: userType }));
      }
    }
  };
  const _hoisted_1$Y = { class: "switchers" };
  const _hoisted_2$M = ["onClick"];
  const _hoisted_3$F = { id: "bluefinch-checkout-root" };
  const _hoisted_4$q = { class: "switchers" };
  const _hoisted_5$m = ["onClick"];
  const _hoisted_6$h = {
    key: 0,
    class: "switchers"
  };
  const _hoisted_7$e = ["onClick"];
  function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_AppHeader = resolveComponent("AppHeader");
    const _component_Steps = resolveComponent("Steps");
    const _component_AppFooter = resolveComponent("AppFooter");
    const _component_OrderSummaryMobile = resolveComponent("OrderSummaryMobile");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$Y, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.devices, (device, index) => {
          return openBlock(), createElementBlock("button", {
            key: index,
            class: normalizeClass({
              "action-secondary": $data.currentDevice === device.deviceName
            }),
            onClick: ($event) => $options.switchDevice(device)
          }, toDisplayString$1(device.displayName), 11, _hoisted_2$M);
        }), 128))
      ]),
      createBaseVNode("div", _hoisted_3$F, [
        (openBlock(), createBlock(resolveDynamicComponent($data.currentDevice), null, {
          default: withCtx(() => [
            createVNode(_component_Loader),
            createVNode(_component_AppHeader),
            createVNode(_component_Steps),
            createVNode(_component_AppFooter),
            createVNode(_component_OrderSummaryMobile)
          ]),
          _: 1
        }))
      ]),
      createBaseVNode("div", _hoisted_4$q, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.checkoutSteps, (step, index) => {
          return openBlock(), createElementBlock("button", {
            key: index,
            class: normalizeClass({
              "action-secondary": $data.currentStep === step.stepName
            }),
            onClick: ($event) => $options.goToStep(step)
          }, toDisplayString$1(step.displayName), 11, _hoisted_5$m);
        }), 128))
      ]),
      $data.currentStep === "SignInPage" ? (openBlock(), createElementBlock("div", _hoisted_6$h, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.userType, (user, index) => {
          return openBlock(), createElementBlock("button", {
            key: index,
            class: normalizeClass({
              "action-secondary": $data.currentUser === user.userTypeName
            }),
            onClick: ($event) => $options.setUserStatus(user)
          }, toDisplayString$1(user.displayName), 11, _hoisted_7$e);
        }), 128))
      ])) : createCommentVNode("", true)
    ], 64);
  }
  var App = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$12], ["__scopeId", "data-v-ff1a712e"]]);
  /*!
    * vue-router v4.0.16
    * (c) 2022 Eduardo San Martin Morote
    * @license MIT
    */
  const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  const PolySymbol = (name) => hasSymbol ? Symbol(name) : "_vr_" + name;
  const matchedRouteKey = /* @__PURE__ */ PolySymbol("rvlm");
  const viewDepthKey = /* @__PURE__ */ PolySymbol("rvd");
  const routerKey = /* @__PURE__ */ PolySymbol("r");
  const routeLocationKey = /* @__PURE__ */ PolySymbol("rl");
  const routerViewLocationKey = /* @__PURE__ */ PolySymbol("rvl");
  const isBrowser = typeof window !== "undefined";
  function isESModule(obj) {
    return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === "Module";
  }
  const assign = Object.assign;
  function applyToParams(fn, params) {
    const newParams = {};
    for (const key in params) {
      const value = params[key];
      newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
    }
    return newParams;
  }
  const noop = () => {
  };
  const TRAILING_SLASH_RE = /\/$/;
  const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
  function parseURL(parseQuery2, location2, currentLocation = "/") {
    let path, query = {}, searchString = "", hash = "";
    const searchPos = location2.indexOf("?");
    const hashPos = location2.indexOf("#", searchPos > -1 ? searchPos : 0);
    if (searchPos > -1) {
      path = location2.slice(0, searchPos);
      searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
      query = parseQuery2(searchString);
    }
    if (hashPos > -1) {
      path = path || location2.slice(0, hashPos);
      hash = location2.slice(hashPos, location2.length);
    }
    path = resolveRelativePath(path != null ? path : location2, currentLocation);
    return {
      fullPath: path + (searchString && "?") + searchString + hash,
      path,
      query,
      hash
    };
  }
  function stringifyURL(stringifyQuery2, location2) {
    const query = location2.query ? stringifyQuery2(location2.query) : "";
    return location2.path + (query && "?") + query + (location2.hash || "");
  }
  function stripBase(pathname, base2) {
    if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase()))
      return pathname;
    return pathname.slice(base2.length) || "/";
  }
  function isSameRouteLocation(stringifyQuery2, a, b) {
    const aLastIndex = a.matched.length - 1;
    const bLastIndex = b.matched.length - 1;
    return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
  }
  function isSameRouteRecord(a, b) {
    return (a.aliasOf || a) === (b.aliasOf || b);
  }
  function isSameRouteLocationParams(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length)
      return false;
    for (const key in a) {
      if (!isSameRouteLocationParamsValue(a[key], b[key]))
        return false;
    }
    return true;
  }
  function isSameRouteLocationParamsValue(a, b) {
    return Array.isArray(a) ? isEquivalentArray(a, b) : Array.isArray(b) ? isEquivalentArray(b, a) : a === b;
  }
  function isEquivalentArray(a, b) {
    return Array.isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
  }
  function resolveRelativePath(to, from) {
    if (to.startsWith("/"))
      return to;
    if (!to)
      return from;
    const fromSegments = from.split("/");
    const toSegments = to.split("/");
    let position = fromSegments.length - 1;
    let toPosition;
    let segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
      segment = toSegments[toPosition];
      if (position === 1 || segment === ".")
        continue;
      if (segment === "..")
        position--;
      else
        break;
    }
    return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
  }
  var NavigationType;
  (function(NavigationType2) {
    NavigationType2["pop"] = "pop";
    NavigationType2["push"] = "push";
  })(NavigationType || (NavigationType = {}));
  var NavigationDirection;
  (function(NavigationDirection2) {
    NavigationDirection2["back"] = "back";
    NavigationDirection2["forward"] = "forward";
    NavigationDirection2["unknown"] = "";
  })(NavigationDirection || (NavigationDirection = {}));
  function normalizeBase(base2) {
    if (!base2) {
      if (isBrowser) {
        const baseEl = document.querySelector("base");
        base2 = baseEl && baseEl.getAttribute("href") || "/";
        base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
      } else {
        base2 = "/";
      }
    }
    if (base2[0] !== "/" && base2[0] !== "#")
      base2 = "/" + base2;
    return removeTrailingSlash(base2);
  }
  const BEFORE_HASH_RE = /^[^#]+#/;
  function createHref(base2, location2) {
    return base2.replace(BEFORE_HASH_RE, "#") + location2;
  }
  function getElementPosition(el, offset) {
    const docRect = document.documentElement.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    return {
      behavior: offset.behavior,
      left: elRect.left - docRect.left - (offset.left || 0),
      top: elRect.top - docRect.top - (offset.top || 0)
    };
  }
  const computeScrollPosition = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
  });
  function scrollToPosition(position) {
    let scrollToOptions;
    if ("el" in position) {
      const positionEl = position.el;
      const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
      const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
      if (!el) {
        return;
      }
      scrollToOptions = getElementPosition(el, position);
    } else {
      scrollToOptions = position;
    }
    if ("scrollBehavior" in document.documentElement.style)
      window.scrollTo(scrollToOptions);
    else {
      window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
    }
  }
  function getScrollKey(path, delta) {
    const position = history.state ? history.state.position - delta : -1;
    return position + path;
  }
  const scrollPositions = /* @__PURE__ */ new Map();
  function saveScrollPosition(key, scrollPosition) {
    scrollPositions.set(key, scrollPosition);
  }
  function getSavedScrollPosition(key) {
    const scroll = scrollPositions.get(key);
    scrollPositions.delete(key);
    return scroll;
  }
  let createBaseLocation = () => location.protocol + "//" + location.host;
  function createCurrentLocation(base2, location2) {
    const { pathname, search, hash } = location2;
    const hashPos = base2.indexOf("#");
    if (hashPos > -1) {
      let slicePos = hash.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
      let pathFromHash = hash.slice(slicePos);
      if (pathFromHash[0] !== "/")
        pathFromHash = "/" + pathFromHash;
      return stripBase(pathFromHash, "");
    }
    const path = stripBase(pathname, base2);
    return path + search + hash;
  }
  function useHistoryListeners(base2, historyState, currentLocation, replace) {
    let listeners = [];
    let teardowns = [];
    let pauseState = null;
    const popStateHandler = ({ state }) => {
      const to = createCurrentLocation(base2, location);
      const from = currentLocation.value;
      const fromState = historyState.value;
      let delta = 0;
      if (state) {
        currentLocation.value = to;
        historyState.value = state;
        if (pauseState && pauseState === from) {
          pauseState = null;
          return;
        }
        delta = fromState ? state.position - fromState.position : 0;
      } else {
        replace(to);
      }
      listeners.forEach((listener) => {
        listener(currentLocation.value, from, {
          delta,
          type: NavigationType.pop,
          direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
        });
      });
    };
    function pauseListeners() {
      pauseState = currentLocation.value;
    }
    function listen(callback) {
      listeners.push(callback);
      const teardown = () => {
        const index = listeners.indexOf(callback);
        if (index > -1)
          listeners.splice(index, 1);
      };
      teardowns.push(teardown);
      return teardown;
    }
    function beforeUnloadListener() {
      const { history: history2 } = window;
      if (!history2.state)
        return;
      history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
    }
    function destroy() {
      for (const teardown of teardowns)
        teardown();
      teardowns = [];
      window.removeEventListener("popstate", popStateHandler);
      window.removeEventListener("beforeunload", beforeUnloadListener);
    }
    window.addEventListener("popstate", popStateHandler);
    window.addEventListener("beforeunload", beforeUnloadListener);
    return {
      pauseListeners,
      listen,
      destroy
    };
  }
  function buildState(back, current, forward, replaced = false, computeScroll = false) {
    return {
      back,
      current,
      forward,
      replaced,
      position: window.history.length,
      scroll: computeScroll ? computeScrollPosition() : null
    };
  }
  function useHistoryStateNavigation(base2) {
    const { history: history2, location: location2 } = window;
    const currentLocation = {
      value: createCurrentLocation(base2, location2)
    };
    const historyState = { value: history2.state };
    if (!historyState.value) {
      changeLocation(currentLocation.value, {
        back: null,
        current: currentLocation.value,
        forward: null,
        position: history2.length - 1,
        replaced: true,
        scroll: null
      }, true);
    }
    function changeLocation(to, state, replace2) {
      const hashIndex = base2.indexOf("#");
      const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to : createBaseLocation() + base2 + to;
      try {
        history2[replace2 ? "replaceState" : "pushState"](state, "", url);
        historyState.value = state;
      } catch (err) {
        {
          console.error(err);
        }
        location2[replace2 ? "replace" : "assign"](url);
      }
    }
    function replace(to, data2) {
      const state = assign({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data2, { position: historyState.value.position });
      changeLocation(to, state, true);
      currentLocation.value = to;
    }
    function push(to, data2) {
      const currentState = assign({}, historyState.value, history2.state, {
        forward: to,
        scroll: computeScrollPosition()
      });
      changeLocation(currentState.current, currentState, true);
      const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data2);
      changeLocation(to, state, false);
      currentLocation.value = to;
    }
    return {
      location: currentLocation,
      state: historyState,
      push,
      replace
    };
  }
  function createWebHistory(base2) {
    base2 = normalizeBase(base2);
    const historyNavigation = useHistoryStateNavigation(base2);
    const historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
    function go(delta, triggerListeners = true) {
      if (!triggerListeners)
        historyListeners.pauseListeners();
      history.go(delta);
    }
    const routerHistory = assign({
      location: "",
      base: base2,
      go,
      createHref: createHref.bind(null, base2)
    }, historyNavigation, historyListeners);
    Object.defineProperty(routerHistory, "location", {
      enumerable: true,
      get: () => historyNavigation.location.value
    });
    Object.defineProperty(routerHistory, "state", {
      enumerable: true,
      get: () => historyNavigation.state.value
    });
    return routerHistory;
  }
  function createWebHashHistory(base2) {
    base2 = location.host ? base2 || location.pathname + location.search : "";
    if (!base2.includes("#"))
      base2 += "#";
    return createWebHistory(base2);
  }
  function isRouteLocation(route) {
    return typeof route === "string" || route && typeof route === "object";
  }
  function isRouteName(name) {
    return typeof name === "string" || typeof name === "symbol";
  }
  const START_LOCATION_NORMALIZED = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
  };
  const NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("nf");
  var NavigationFailureType;
  (function(NavigationFailureType2) {
    NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
    NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
    NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
  })(NavigationFailureType || (NavigationFailureType = {}));
  function createRouterError(type, params) {
    {
      return assign(new Error(), {
        type,
        [NavigationFailureSymbol]: true
      }, params);
    }
  }
  function isNavigationFailure(error, type) {
    return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
  }
  const BASE_PARAM_PATTERN = "[^/]+?";
  const BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true
  };
  const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
  function tokensToParser(segments, extraOptions) {
    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    const score = [];
    let pattern = options.start ? "^" : "";
    const keys = [];
    for (const segment of segments) {
      const segmentScores = segment.length ? [] : [90];
      if (options.strict && !segment.length)
        pattern += "/";
      for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
        const token = segment[tokenIndex];
        let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
        if (token.type === 0) {
          if (!tokenIndex)
            pattern += "/";
          pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
          subSegmentScore += 40;
        } else if (token.type === 1) {
          const { value, repeatable, optional, regexp } = token;
          keys.push({
            name: value,
            repeatable,
            optional
          });
          const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
          if (re2 !== BASE_PARAM_PATTERN) {
            subSegmentScore += 10;
            try {
              new RegExp(`(${re2})`);
            } catch (err) {
              throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
            }
          }
          let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
          if (!tokenIndex)
            subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
          if (optional)
            subPattern += "?";
          pattern += subPattern;
          subSegmentScore += 20;
          if (optional)
            subSegmentScore += -8;
          if (repeatable)
            subSegmentScore += -20;
          if (re2 === ".*")
            subSegmentScore += -50;
        }
        segmentScores.push(subSegmentScore);
      }
      score.push(segmentScores);
    }
    if (options.strict && options.end) {
      const i = score.length - 1;
      score[i][score[i].length - 1] += 0.7000000000000001;
    }
    if (!options.strict)
      pattern += "/?";
    if (options.end)
      pattern += "$";
    else if (options.strict)
      pattern += "(?:/|$)";
    const re = new RegExp(pattern, options.sensitive ? "" : "i");
    function parse2(path) {
      const match = path.match(re);
      const params = {};
      if (!match)
        return null;
      for (let i = 1; i < match.length; i++) {
        const value = match[i] || "";
        const key = keys[i - 1];
        params[key.name] = value && key.repeatable ? value.split("/") : value;
      }
      return params;
    }
    function stringify(params) {
      let path = "";
      let avoidDuplicatedSlash = false;
      for (const segment of segments) {
        if (!avoidDuplicatedSlash || !path.endsWith("/"))
          path += "/";
        avoidDuplicatedSlash = false;
        for (const token of segment) {
          if (token.type === 0) {
            path += token.value;
          } else if (token.type === 1) {
            const { value, repeatable, optional } = token;
            const param = value in params ? params[value] : "";
            if (Array.isArray(param) && !repeatable)
              throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
            const text2 = Array.isArray(param) ? param.join("/") : param;
            if (!text2) {
              if (optional) {
                if (segment.length < 2 && segments.length > 1) {
                  if (path.endsWith("/"))
                    path = path.slice(0, -1);
                  else
                    avoidDuplicatedSlash = true;
                }
              } else
                throw new Error(`Missing required param "${value}"`);
            }
            path += text2;
          }
        }
      }
      return path;
    }
    return {
      re,
      score,
      keys,
      parse: parse2,
      stringify
    };
  }
  function compareScoreArray(a, b) {
    let i = 0;
    while (i < a.length && i < b.length) {
      const diff = b[i] - a[i];
      if (diff)
        return diff;
      i++;
    }
    if (a.length < b.length) {
      return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
    } else if (a.length > b.length) {
      return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
    }
    return 0;
  }
  function comparePathParserScore(a, b) {
    let i = 0;
    const aScore = a.score;
    const bScore = b.score;
    while (i < aScore.length && i < bScore.length) {
      const comp = compareScoreArray(aScore[i], bScore[i]);
      if (comp)
        return comp;
      i++;
    }
    if (Math.abs(bScore.length - aScore.length) === 1) {
      if (isLastScoreNegative(aScore))
        return 1;
      if (isLastScoreNegative(bScore))
        return -1;
    }
    return bScore.length - aScore.length;
  }
  function isLastScoreNegative(score) {
    const last = score[score.length - 1];
    return score.length > 0 && last[last.length - 1] < 0;
  }
  const ROOT_TOKEN = {
    type: 0,
    value: ""
  };
  const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
  function tokenizePath(path) {
    if (!path)
      return [[]];
    if (path === "/")
      return [[ROOT_TOKEN]];
    if (!path.startsWith("/")) {
      throw new Error(`Invalid path "${path}"`);
    }
    function crash(message) {
      throw new Error(`ERR (${state})/"${buffer}": ${message}`);
    }
    let state = 0;
    let previousState = state;
    const tokens = [];
    let segment;
    function finalizeSegment() {
      if (segment)
        tokens.push(segment);
      segment = [];
    }
    let i = 0;
    let char;
    let buffer = "";
    let customRe = "";
    function consumeBuffer() {
      if (!buffer)
        return;
      if (state === 0) {
        segment.push({
          type: 0,
          value: buffer
        });
      } else if (state === 1 || state === 2 || state === 3) {
        if (segment.length > 1 && (char === "*" || char === "+"))
          crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
        segment.push({
          type: 1,
          value: buffer,
          regexp: customRe,
          repeatable: char === "*" || char === "+",
          optional: char === "*" || char === "?"
        });
      } else {
        crash("Invalid state to consume buffer");
      }
      buffer = "";
    }
    function addCharToBuffer() {
      buffer += char;
    }
    while (i < path.length) {
      char = path[i++];
      if (char === "\\" && state !== 2) {
        previousState = state;
        state = 4;
        continue;
      }
      switch (state) {
        case 0:
          if (char === "/") {
            if (buffer) {
              consumeBuffer();
            }
            finalizeSegment();
          } else if (char === ":") {
            consumeBuffer();
            state = 1;
          } else {
            addCharToBuffer();
          }
          break;
        case 4:
          addCharToBuffer();
          state = previousState;
          break;
        case 1:
          if (char === "(") {
            state = 2;
          } else if (VALID_PARAM_RE.test(char)) {
            addCharToBuffer();
          } else {
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i--;
          }
          break;
        case 2:
          if (char === ")") {
            if (customRe[customRe.length - 1] == "\\")
              customRe = customRe.slice(0, -1) + char;
            else
              state = 3;
          } else {
            customRe += char;
          }
          break;
        case 3:
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
          customRe = "";
          break;
        default:
          crash("Unknown state");
          break;
      }
    }
    if (state === 2)
      crash(`Unfinished custom RegExp for param "${buffer}"`);
    consumeBuffer();
    finalizeSegment();
    return tokens;
  }
  function createRouteRecordMatcher(record, parent, options) {
    const parser = tokensToParser(tokenizePath(record.path), options);
    const matcher = assign(parser, {
      record,
      parent,
      children: [],
      alias: []
    });
    if (parent) {
      if (!matcher.record.aliasOf === !parent.record.aliasOf)
        parent.children.push(matcher);
    }
    return matcher;
  }
  function createRouterMatcher(routes2, globalOptions) {
    const matchers = [];
    const matcherMap = /* @__PURE__ */ new Map();
    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
    function getRecordMatcher(name) {
      return matcherMap.get(name);
    }
    function addRoute(record, parent, originalRecord) {
      const isRootAdd = !originalRecord;
      const mainNormalizedRecord = normalizeRouteRecord(record);
      mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
      const options = mergeOptions(globalOptions, record);
      const normalizedRecords = [
        mainNormalizedRecord
      ];
      if ("alias" in record) {
        const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
        for (const alias of aliases) {
          normalizedRecords.push(assign({}, mainNormalizedRecord, {
            components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
            path: alias,
            aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          }));
        }
      }
      let matcher;
      let originalMatcher;
      for (const normalizedRecord of normalizedRecords) {
        const { path } = normalizedRecord;
        if (parent && path[0] !== "/") {
          const parentPath = parent.record.path;
          const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
          normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
        }
        matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
        if (originalRecord) {
          originalRecord.alias.push(matcher);
        } else {
          originalMatcher = originalMatcher || matcher;
          if (originalMatcher !== matcher)
            originalMatcher.alias.push(matcher);
          if (isRootAdd && record.name && !isAliasRecord(matcher))
            removeRoute(record.name);
        }
        if ("children" in mainNormalizedRecord) {
          const children = mainNormalizedRecord.children;
          for (let i = 0; i < children.length; i++) {
            addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
          }
        }
        originalRecord = originalRecord || matcher;
        insertMatcher(matcher);
      }
      return originalMatcher ? () => {
        removeRoute(originalMatcher);
      } : noop;
    }
    function removeRoute(matcherRef) {
      if (isRouteName(matcherRef)) {
        const matcher = matcherMap.get(matcherRef);
        if (matcher) {
          matcherMap.delete(matcherRef);
          matchers.splice(matchers.indexOf(matcher), 1);
          matcher.children.forEach(removeRoute);
          matcher.alias.forEach(removeRoute);
        }
      } else {
        const index = matchers.indexOf(matcherRef);
        if (index > -1) {
          matchers.splice(index, 1);
          if (matcherRef.record.name)
            matcherMap.delete(matcherRef.record.name);
          matcherRef.children.forEach(removeRoute);
          matcherRef.alias.forEach(removeRoute);
        }
      }
    }
    function getRoutes() {
      return matchers;
    }
    function insertMatcher(matcher) {
      let i = 0;
      while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))
        i++;
      matchers.splice(i, 0, matcher);
      if (matcher.record.name && !isAliasRecord(matcher))
        matcherMap.set(matcher.record.name, matcher);
    }
    function resolve2(location2, currentLocation) {
      let matcher;
      let params = {};
      let path;
      let name;
      if ("name" in location2 && location2.name) {
        matcher = matcherMap.get(location2.name);
        if (!matcher)
          throw createRouterError(1, {
            location: location2
          });
        name = matcher.record.name;
        params = assign(paramsFromLocation(currentLocation.params, matcher.keys.filter((k) => !k.optional).map((k) => k.name)), location2.params);
        path = matcher.stringify(params);
      } else if ("path" in location2) {
        path = location2.path;
        matcher = matchers.find((m) => m.re.test(path));
        if (matcher) {
          params = matcher.parse(path);
          name = matcher.record.name;
        }
      } else {
        matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
        if (!matcher)
          throw createRouterError(1, {
            location: location2,
            currentLocation
          });
        name = matcher.record.name;
        params = assign({}, currentLocation.params, location2.params);
        path = matcher.stringify(params);
      }
      const matched = [];
      let parentMatcher = matcher;
      while (parentMatcher) {
        matched.unshift(parentMatcher.record);
        parentMatcher = parentMatcher.parent;
      }
      return {
        name,
        path,
        params,
        matched,
        meta: mergeMetaFields(matched)
      };
    }
    routes2.forEach((route) => addRoute(route));
    return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
  }
  function paramsFromLocation(params, keys) {
    const newParams = {};
    for (const key of keys) {
      if (key in params)
        newParams[key] = params[key];
    }
    return newParams;
  }
  function normalizeRouteRecord(record) {
    return {
      path: record.path,
      redirect: record.redirect,
      name: record.name,
      meta: record.meta || {},
      aliasOf: void 0,
      beforeEnter: record.beforeEnter,
      props: normalizeRecordProps(record),
      children: record.children || [],
      instances: {},
      leaveGuards: /* @__PURE__ */ new Set(),
      updateGuards: /* @__PURE__ */ new Set(),
      enterCallbacks: {},
      components: "components" in record ? record.components || {} : { default: record.component }
    };
  }
  function normalizeRecordProps(record) {
    const propsObject = {};
    const props = record.props || false;
    if ("component" in record) {
      propsObject.default = props;
    } else {
      for (const name in record.components)
        propsObject[name] = typeof props === "boolean" ? props : props[name];
    }
    return propsObject;
  }
  function isAliasRecord(record) {
    while (record) {
      if (record.record.aliasOf)
        return true;
      record = record.parent;
    }
    return false;
  }
  function mergeMetaFields(matched) {
    return matched.reduce((meta, record) => assign(meta, record.meta), {});
  }
  function mergeOptions(defaults2, partialOptions) {
    const options = {};
    for (const key in defaults2) {
      options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
    }
    return options;
  }
  function isRecordChildOf(record, parent) {
    return parent.children.some((child) => child === record || isRecordChildOf(record, child));
  }
  const HASH_RE = /#/g;
  const AMPERSAND_RE = /&/g;
  const SLASH_RE = /\//g;
  const EQUAL_RE = /=/g;
  const IM_RE = /\?/g;
  const PLUS_RE = /\+/g;
  const ENC_BRACKET_OPEN_RE = /%5B/g;
  const ENC_BRACKET_CLOSE_RE = /%5D/g;
  const ENC_CARET_RE = /%5E/g;
  const ENC_BACKTICK_RE = /%60/g;
  const ENC_CURLY_OPEN_RE = /%7B/g;
  const ENC_PIPE_RE = /%7C/g;
  const ENC_CURLY_CLOSE_RE = /%7D/g;
  const ENC_SPACE_RE = /%20/g;
  function commonEncode(text2) {
    return encodeURI("" + text2).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
  }
  function encodeHash(text2) {
    return commonEncode(text2).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryValue(text2) {
    return commonEncode(text2).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
  }
  function encodeQueryKey(text2) {
    return encodeQueryValue(text2).replace(EQUAL_RE, "%3D");
  }
  function encodePath(text2) {
    return commonEncode(text2).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
  }
  function encodeParam(text2) {
    return text2 == null ? "" : encodePath(text2).replace(SLASH_RE, "%2F");
  }
  function decode(text2) {
    try {
      return decodeURIComponent("" + text2);
    } catch (err) {
    }
    return "" + text2;
  }
  function parseQuery(search) {
    const query = {};
    if (search === "" || search === "?")
      return query;
    const hasLeadingIM = search[0] === "?";
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
    for (let i = 0; i < searchParams.length; ++i) {
      const searchParam = searchParams[i].replace(PLUS_RE, " ");
      const eqPos = searchParam.indexOf("=");
      const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
      const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
      if (key in query) {
        let currentValue = query[key];
        if (!Array.isArray(currentValue)) {
          currentValue = query[key] = [currentValue];
        }
        currentValue.push(value);
      } else {
        query[key] = value;
      }
    }
    return query;
  }
  function stringifyQuery(query) {
    let search = "";
    for (let key in query) {
      const value = query[key];
      key = encodeQueryKey(key);
      if (value == null) {
        if (value !== void 0) {
          search += (search.length ? "&" : "") + key;
        }
        continue;
      }
      const values = Array.isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
      values.forEach((value2) => {
        if (value2 !== void 0) {
          search += (search.length ? "&" : "") + key;
          if (value2 != null)
            search += "=" + value2;
        }
      });
    }
    return search;
  }
  function normalizeQuery(query) {
    const normalizedQuery = {};
    for (const key in query) {
      const value = query[key];
      if (value !== void 0) {
        normalizedQuery[key] = Array.isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
      }
    }
    return normalizedQuery;
  }
  function useCallbacks() {
    let handlers = [];
    function add2(handler) {
      handlers.push(handler);
      return () => {
        const i = handlers.indexOf(handler);
        if (i > -1)
          handlers.splice(i, 1);
      };
    }
    function reset() {
      handlers = [];
    }
    return {
      add: add2,
      list: () => handlers,
      reset
    };
  }
  function guardToPromiseFn(guard, to, from, record, name) {
    const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return () => new Promise((resolve2, reject) => {
      const next = (valid) => {
        if (valid === false)
          reject(createRouterError(4, {
            from,
            to
          }));
        else if (valid instanceof Error) {
          reject(valid);
        } else if (isRouteLocation(valid)) {
          reject(createRouterError(2, {
            from: to,
            to: valid
          }));
        } else {
          if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function")
            enterCallbackArray.push(valid);
          resolve2();
        }
      };
      const guardReturn = guard.call(record && record.instances[name], to, from, next);
      let guardCall = Promise.resolve(guardReturn);
      if (guard.length < 3)
        guardCall = guardCall.then(next);
      guardCall.catch((err) => reject(err));
    });
  }
  function extractComponentsGuards(matched, guardType, to, from) {
    const guards = [];
    for (const record of matched) {
      for (const name in record.components) {
        let rawComponent = record.components[name];
        if (guardType !== "beforeRouteEnter" && !record.instances[name])
          continue;
        if (isRouteComponent(rawComponent)) {
          const options = rawComponent.__vccOpts || rawComponent;
          const guard = options[guardType];
          guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
        } else {
          let componentPromise = rawComponent();
          guards.push(() => componentPromise.then((resolved) => {
            if (!resolved)
              return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
            const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
            record.components[name] = resolvedComponent;
            const options = resolvedComponent.__vccOpts || resolvedComponent;
            const guard = options[guardType];
            return guard && guardToPromiseFn(guard, to, from, record, name)();
          }));
        }
      }
    }
    return guards;
  }
  function isRouteComponent(component) {
    return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
  }
  function useLink(props) {
    const router2 = inject(routerKey);
    const currentRoute = inject(routeLocationKey);
    const route = computed(() => router2.resolve(unref(props.to)));
    const activeRecordIndex = computed(() => {
      const { matched } = route.value;
      const { length } = matched;
      const routeMatched = matched[length - 1];
      const currentMatched = currentRoute.matched;
      if (!routeMatched || !currentMatched.length)
        return -1;
      const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
      if (index > -1)
        return index;
      const parentRecordPath = getOriginalPath(matched[length - 2]);
      return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
    });
    const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
    const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
    function navigate(e = {}) {
      if (guardEvent(e)) {
        return router2[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop);
      }
      return Promise.resolve();
    }
    return {
      route,
      href: computed(() => route.value.href),
      isActive,
      isExactActive,
      navigate
    };
  }
  const RouterLinkImpl = /* @__PURE__ */ defineComponent({
    name: "RouterLink",
    compatConfig: { MODE: 3 },
    props: {
      to: {
        type: [String, Object],
        required: true
      },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        default: "page"
      }
    },
    useLink,
    setup(props, { slots }) {
      const link = reactive(useLink(props));
      const { options } = inject(routerKey);
      const elClass = computed(() => ({
        [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
        [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
      }));
      return () => {
        const children = slots.default && slots.default(link);
        return props.custom ? children : h("a", {
          "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
          href: link.href,
          onClick: link.navigate,
          class: elClass.value
        }, children);
      };
    }
  });
  const RouterLink = RouterLinkImpl;
  function guardEvent(e) {
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
      return;
    if (e.defaultPrevented)
      return;
    if (e.button !== void 0 && e.button !== 0)
      return;
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const target = e.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(target))
        return;
    }
    if (e.preventDefault)
      e.preventDefault();
    return true;
  }
  function includesParams(outer, inner) {
    for (const key in inner) {
      const innerValue = inner[key];
      const outerValue = outer[key];
      if (typeof innerValue === "string") {
        if (innerValue !== outerValue)
          return false;
      } else {
        if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
          return false;
      }
    }
    return true;
  }
  function getOriginalPath(record) {
    return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
  }
  const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
  const RouterViewImpl = /* @__PURE__ */ defineComponent({
    name: "RouterView",
    inheritAttrs: false,
    props: {
      name: {
        type: String,
        default: "default"
      },
      route: Object
    },
    compatConfig: { MODE: 3 },
    setup(props, { attrs, slots }) {
      const injectedRoute = inject(routerViewLocationKey);
      const routeToDisplay = computed(() => props.route || injectedRoute.value);
      const depth = inject(viewDepthKey, 0);
      const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);
      provide(viewDepthKey, depth + 1);
      provide(matchedRouteKey, matchedRouteRef);
      provide(routerViewLocationKey, routeToDisplay);
      const viewRef = ref();
      watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
        if (to) {
          to.instances[name] = instance;
          if (from && from !== to && instance && instance === oldInstance) {
            if (!to.leaveGuards.size) {
              to.leaveGuards = from.leaveGuards;
            }
            if (!to.updateGuards.size) {
              to.updateGuards = from.updateGuards;
            }
          }
        }
        if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
          (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
        }
      }, { flush: "post" });
      return () => {
        const route = routeToDisplay.value;
        const matchedRoute = matchedRouteRef.value;
        const ViewComponent = matchedRoute && matchedRoute.components[props.name];
        const currentName = props.name;
        if (!ViewComponent) {
          return normalizeSlot(slots.default, { Component: ViewComponent, route });
        }
        const routePropsOption = matchedRoute.props[props.name];
        const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
        const onVnodeUnmounted = (vnode) => {
          if (vnode.component.isUnmounted) {
            matchedRoute.instances[currentName] = null;
          }
        };
        const component = h(ViewComponent, assign({}, routeProps, attrs, {
          onVnodeUnmounted,
          ref: viewRef
        }));
        return normalizeSlot(slots.default, { Component: component, route }) || component;
      };
    }
  });
  function normalizeSlot(slot, data2) {
    if (!slot)
      return null;
    const slotContent = slot(data2);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
  }
  const RouterView = RouterViewImpl;
  function createRouter(options) {
    const matcher = createRouterMatcher(options.routes, options);
    const parseQuery$1 = options.parseQuery || parseQuery;
    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
    const routerHistory = options.history;
    const beforeGuards = useCallbacks();
    const beforeResolveGuards = useCallbacks();
    const afterGuards = useCallbacks();
    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
    let pendingLocation = START_LOCATION_NORMALIZED;
    if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }
    const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
    const encodeParams = applyToParams.bind(null, encodeParam);
    const decodeParams = applyToParams.bind(null, decode);
    function addRoute(parentOrRoute, route) {
      let parent;
      let record;
      if (isRouteName(parentOrRoute)) {
        parent = matcher.getRecordMatcher(parentOrRoute);
        record = route;
      } else {
        record = parentOrRoute;
      }
      return matcher.addRoute(record, parent);
    }
    function removeRoute(name) {
      const recordMatcher = matcher.getRecordMatcher(name);
      if (recordMatcher) {
        matcher.removeRoute(recordMatcher);
      }
    }
    function getRoutes() {
      return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
    }
    function hasRoute(name) {
      return !!matcher.getRecordMatcher(name);
    }
    function resolve2(rawLocation, currentLocation) {
      currentLocation = assign({}, currentLocation || currentRoute.value);
      if (typeof rawLocation === "string") {
        const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
        const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
        const href2 = routerHistory.createHref(locationNormalized.fullPath);
        return assign(locationNormalized, matchedRoute2, {
          params: decodeParams(matchedRoute2.params),
          hash: decode(locationNormalized.hash),
          redirectedFrom: void 0,
          href: href2
        });
      }
      let matcherLocation;
      if ("path" in rawLocation) {
        matcherLocation = assign({}, rawLocation, {
          path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
        });
      } else {
        const targetParams = assign({}, rawLocation.params);
        for (const key in targetParams) {
          if (targetParams[key] == null) {
            delete targetParams[key];
          }
        }
        matcherLocation = assign({}, rawLocation, {
          params: encodeParams(rawLocation.params)
        });
        currentLocation.params = encodeParams(currentLocation.params);
      }
      const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
      const hash = rawLocation.hash || "";
      matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
      const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
        hash: encodeHash(hash),
        path: matchedRoute.path
      }));
      const href = routerHistory.createHref(fullPath);
      return assign({
        fullPath,
        hash,
        query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      }, matchedRoute, {
        redirectedFrom: void 0,
        href
      });
    }
    function locationAsObject(to) {
      return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
    }
    function checkCanceledNavigation(to, from) {
      if (pendingLocation !== to) {
        return createRouterError(8, {
          from,
          to
        });
      }
    }
    function push(to) {
      return pushWithRedirect(to);
    }
    function replace(to) {
      return push(assign(locationAsObject(to), { replace: true }));
    }
    function handleRedirectRecord(to) {
      const lastMatched = to.matched[to.matched.length - 1];
      if (lastMatched && lastMatched.redirect) {
        const { redirect } = lastMatched;
        let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
        if (typeof newTargetLocation === "string") {
          newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
          newTargetLocation.params = {};
        }
        return assign({
          query: to.query,
          hash: to.hash,
          params: to.params
        }, newTargetLocation);
      }
    }
    function pushWithRedirect(to, redirectedFrom) {
      const targetLocation = pendingLocation = resolve2(to);
      const from = currentRoute.value;
      const data2 = to.state;
      const force = to.force;
      const replace2 = to.replace === true;
      const shouldRedirect = handleRedirectRecord(targetLocation);
      if (shouldRedirect)
        return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
          state: data2,
          force,
          replace: replace2
        }), redirectedFrom || targetLocation);
      const toLocation = targetLocation;
      toLocation.redirectedFrom = redirectedFrom;
      let failure;
      if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
        failure = createRouterError(16, { to: toLocation, from });
        handleScroll(from, from, true, false);
      }
      return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {
        if (failure2) {
          if (isNavigationFailure(failure2, 2)) {
            return pushWithRedirect(assign(locationAsObject(failure2.to), {
              state: data2,
              force,
              replace: replace2
            }), redirectedFrom || toLocation);
          }
        } else {
          failure2 = finalizeNavigation(toLocation, from, true, replace2, data2);
        }
        triggerAfterEach(toLocation, from, failure2);
        return failure2;
      });
    }
    function checkCanceledNavigationAndReject(to, from) {
      const error = checkCanceledNavigation(to, from);
      return error ? Promise.reject(error) : Promise.resolve();
    }
    function navigate(to, from) {
      let guards;
      const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
      guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
      for (const record of leavingRecords) {
        record.leaveGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards).then(() => {
        guards = [];
        for (const guard of beforeGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
        for (const record of updatingRecords) {
          record.updateGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = [];
        for (const record of to.matched) {
          if (record.beforeEnter && !from.matched.includes(record)) {
            if (Array.isArray(record.beforeEnter)) {
              for (const beforeEnter of record.beforeEnter)
                guards.push(guardToPromiseFn(beforeEnter, to, from));
            } else {
              guards.push(guardToPromiseFn(record.beforeEnter, to, from));
            }
          }
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        to.matched.forEach((record) => record.enterCallbacks = {});
        guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).then(() => {
        guards = [];
        for (const guard of beforeResolveGuards.list()) {
          guards.push(guardToPromiseFn(guard, to, from));
        }
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards);
      }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
    }
    function triggerAfterEach(to, from, failure) {
      for (const guard of afterGuards.list())
        guard(to, from, failure);
    }
    function finalizeNavigation(toLocation, from, isPush, replace2, data2) {
      const error = checkCanceledNavigation(toLocation, from);
      if (error)
        return error;
      const isFirstNavigation = from === START_LOCATION_NORMALIZED;
      const state = !isBrowser ? {} : history.state;
      if (isPush) {
        if (replace2 || isFirstNavigation)
          routerHistory.replace(toLocation.fullPath, assign({
            scroll: isFirstNavigation && state && state.scroll
          }, data2));
        else
          routerHistory.push(toLocation.fullPath, data2);
      }
      currentRoute.value = toLocation;
      handleScroll(toLocation, from, isPush, isFirstNavigation);
      markAsReady();
    }
    let removeHistoryListener;
    function setupListeners() {
      if (removeHistoryListener)
        return;
      removeHistoryListener = routerHistory.listen((to, _from, info) => {
        const toLocation = resolve2(to);
        const shouldRedirect = handleRedirectRecord(toLocation);
        if (shouldRedirect) {
          pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
          return;
        }
        pendingLocation = toLocation;
        const from = currentRoute.value;
        if (isBrowser) {
          saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
        }
        navigate(toLocation, from).catch((error) => {
          if (isNavigationFailure(error, 4 | 8)) {
            return error;
          }
          if (isNavigationFailure(error, 2)) {
            pushWithRedirect(error.to, toLocation).then((failure) => {
              if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
                routerHistory.go(-1, false);
              }
            }).catch(noop);
            return Promise.reject();
          }
          if (info.delta)
            routerHistory.go(-info.delta, false);
          return triggerError(error, toLocation, from);
        }).then((failure) => {
          failure = failure || finalizeNavigation(toLocation, from, false);
          if (failure) {
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
              routerHistory.go(-1, false);
            }
          }
          triggerAfterEach(toLocation, from, failure);
        }).catch(noop);
      });
    }
    let readyHandlers = useCallbacks();
    let errorHandlers = useCallbacks();
    let ready;
    function triggerError(error, to, from) {
      markAsReady(error);
      const list = errorHandlers.list();
      if (list.length) {
        list.forEach((handler) => handler(error, to, from));
      } else {
        console.error(error);
      }
      return Promise.reject(error);
    }
    function isReady() {
      if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
        return Promise.resolve();
      return new Promise((resolve3, reject) => {
        readyHandlers.add([resolve3, reject]);
      });
    }
    function markAsReady(err) {
      if (!ready) {
        ready = !err;
        setupListeners();
        readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
        readyHandlers.reset();
      }
      return err;
    }
    function handleScroll(to, from, isPush, isFirstNavigation) {
      const { scrollBehavior } = options;
      if (!isBrowser || !scrollBehavior)
        return Promise.resolve();
      const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
      return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
    }
    const go = (delta) => routerHistory.go(delta);
    let started;
    const installedApps = /* @__PURE__ */ new Set();
    const router2 = {
      currentRoute,
      addRoute,
      removeRoute,
      hasRoute,
      getRoutes,
      resolve: resolve2,
      options,
      push,
      replace,
      go,
      back: () => go(-1),
      forward: () => go(1),
      beforeEach: beforeGuards.add,
      beforeResolve: beforeResolveGuards.add,
      afterEach: afterGuards.add,
      onError: errorHandlers.add,
      isReady,
      install(app2) {
        const router3 = this;
        app2.component("RouterLink", RouterLink);
        app2.component("RouterView", RouterView);
        app2.config.globalProperties.$router = router3;
        Object.defineProperty(app2.config.globalProperties, "$route", {
          enumerable: true,
          get: () => unref(currentRoute)
        });
        if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
          started = true;
          push(routerHistory.location).catch((err) => {
          });
        }
        const reactiveRoute = {};
        for (const key in START_LOCATION_NORMALIZED) {
          reactiveRoute[key] = computed(() => currentRoute.value[key]);
        }
        app2.provide(routerKey, router3);
        app2.provide(routeLocationKey, reactive(reactiveRoute));
        app2.provide(routerViewLocationKey, currentRoute);
        const unmountApp = app2.unmount;
        installedApps.add(app2);
        app2.unmount = function() {
          installedApps.delete(app2);
          if (installedApps.size < 1) {
            pendingLocation = START_LOCATION_NORMALIZED;
            removeHistoryListener && removeHistoryListener();
            removeHistoryListener = null;
            currentRoute.value = START_LOCATION_NORMALIZED;
            started = false;
            ready = false;
          }
          unmountApp();
        };
      }
    };
    return router2;
  }
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
  }
  function extractChangingRecords(to, from) {
    const leavingRecords = [];
    const updatingRecords = [];
    const enteringRecords = [];
    const len = Math.max(from.matched.length, to.matched.length);
    for (let i = 0; i < len; i++) {
      const recordFrom = from.matched[i];
      if (recordFrom) {
        if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
          updatingRecords.push(recordFrom);
        else
          leavingRecords.push(recordFrom);
      }
      const recordTo = to.matched[i];
      if (recordTo) {
        if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
          enteringRecords.push(recordTo);
        }
      }
    }
    return [leavingRecords, updatingRecords, enteringRecords];
  }
  var ApplePaySvg = "/icon-applepay-colour.svg";
  var GooglePaySvg = "/icon-googlepay-colour.svg";
  var ExpressPaySvg = "/icon-amex-colour.svg";
  var PayPalSvg = "/icon-paypal-colour.svg";
  var KlarnaSvg = "/icon-klarna-colour.svg";
  var MaestroPaySvg = "/icon-maestro-colour.svg";
  var MastercardPaySvg = "/icon-mastercard-colour.svg";
  var VisaPaySvg = "/icon-visa-colour.svg";
  var ClearpaySvg = "/icon-clearpay-colour.svg";
  var VenmoPayIcon = "/icon-venmo-colour.svg";
  var DiscoverSvg = "/icon-discover-colour.svg";
  var DinersSvg = "/icon-diners-colour.svg";
  var JCBSvg = "/icon-jcb-colour.svg";
  const _sfc_main$11 = {
    name: "PayWith",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      background: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          background: reactiveProps.background,
          width: reactiveProps.width,
          height: reactiveProps.height
        }))
      };
    },
    computed: {
      ...mapState(useBraintreeStore, ["cCTypes"]),
      ...mapState(usePaymentStore, ["availableMethods"]),
      ApplePayIcon() {
        return `${getStaticUrl(ApplePaySvg)}`;
      },
      GooglePayIcon() {
        return `${getStaticUrl(GooglePaySvg)}`;
      },
      ExpressPayIcon() {
        return `${getStaticUrl(ExpressPaySvg)}`;
      },
      PayPalIcon() {
        return `${getStaticUrl(PayPalSvg)}`;
      },
      KlarnaIcon() {
        return `${getStaticUrl(KlarnaSvg)}`;
      },
      MaestroPayIcon() {
        return `${getStaticUrl(MaestroPaySvg)}`;
      },
      MastercardPayIcon() {
        return `${getStaticUrl(MastercardPaySvg)}`;
      },
      VisaPayIcon() {
        return `${getStaticUrl(VisaPaySvg)}`;
      },
      ClearpayIcon() {
        return `${getStaticUrl(ClearpaySvg)}`;
      },
      VenmoPayIcon() {
        return `${getStaticUrl(VenmoPayIcon)}`;
      }
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      generateClass(paymentName) {
        return paymentName.toLowerCase().replace(/\s+/g, "_");
      },
      setPayWithText(event) {
        this.payWithText = (event == null ? void 0 : event.detail) || this.$t("payWithBlockTitle");
      },
      getCCIcon(type) {
        switch (type) {
          case "AE":
            return getStaticUrl(ExpressPaySvg);
          case "DI":
            return getStaticUrl(DiscoverSvg);
          case "DN":
            return getStaticUrl(DinersSvg);
          case "JCB":
            return getStaticUrl(JCBSvg);
          case "MC":
            return getStaticUrl(MastercardPaySvg);
          case "MI":
            return getStaticUrl(MaestroPaySvg);
          case "VI":
            return getStaticUrl(VisaPaySvg);
          default:
            return "";
        }
      }
    }
  };
  const _hoisted_1$X = { key: 0 };
  const _hoisted_2$L = {
    key: 0,
    class: "pay-with__column"
  };
  const _hoisted_3$E = ["src", "alt"];
  const _hoisted_4$p = {
    key: 0,
    class: "pay-with__column"
  };
  const _hoisted_5$l = ["alt", "src"];
  const _hoisted_6$g = {
    key: 0,
    class: "pay-with__content"
  };
  const _hoisted_7$d = ["src", "alt"];
  function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", {
      style: normalizeStyle($setup.style),
      class: "pay-with__container"
    }, [
      _ctx.isAdyenAvailable ? (openBlock(), createElementBlock("div", _hoisted_1$X, [
        Object.keys(_ctx.paymentTypes).length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_2$L, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paymentTypes, (paymentType, index) => {
            return openBlock(), createElementBlock("li", {
              key: index,
              class: "pay-with__content"
            }, [
              !paymentType.icon.includes("klarna_account") ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: paymentType.icon.includes("klarna") ? $options.KlarnaIcon : paymentType.icon.includes("clearpay") ? $options.ClearpayIcon : paymentType.icon.includes("paypal") ? $options.PayPalIcon : paymentType.icon.includes("amex") ? $options.ExpressPayIcon : paymentType.icon.includes("mc") ? $options.MastercardPayIcon : paymentType.icon.includes("visa") ? $options.VisaPayIcon : paymentType.icon.includes("google") ? $options.GooglePayIcon : paymentType.icon.includes("apple") ? $options.ApplePayIcon : paymentType.icon,
                alt: paymentType.name,
                class: normalizeClass($options.generateClass(paymentType.name))
              }, null, 10, _hoisted_3$E)) : createCommentVNode("", true)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true),
      createBaseVNode("div", null, [
        _ctx.availableMethods.length > 0 ? (openBlock(), createElementBlock("ul", _hoisted_4$p, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.availableMethods, (paymentType, index) => {
            return openBlock(), createElementBlock(Fragment, { key: index }, [
              paymentType.code === "braintree" && _ctx.cCTypes.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.cCTypes, (cCType) => {
                return openBlock(), createElementBlock("li", {
                  key: cCType,
                  class: "pay-with__content"
                }, [
                  createBaseVNode("img", {
                    alt: cCType,
                    src: $options.getCCIcon(cCType)
                  }, null, 8, _hoisted_5$l)
                ]);
              }), 128)) : paymentType.code !== "braintree_cc_vault" && paymentType.code !== "braintree_ach_direct_debit" && paymentType.code !== "braintree_local_payment" && paymentType.code !== "braintree_paypal_vault" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                paymentType.code.includes("braintree") ? (openBlock(), createElementBlock("li", _hoisted_6$g, [
                  createBaseVNode("img", {
                    src: paymentType.code === "braintree_applepay" ? $options.ApplePayIcon : paymentType.code === "braintree_googlepay" ? $options.GooglePayIcon : paymentType.code === "braintree_venmo" ? $options.VenmoPayIcon : paymentType.code === "braintree_paypal" ? $options.PayPalIcon : "",
                    alt: paymentType.title,
                    class: normalizeClass($options.generateClass(paymentType.title))
                  }, null, 10, _hoisted_7$d)
                ])) : createCommentVNode("", true)
              ], 64)) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ])) : createCommentVNode("", true)
      ])
    ], 4);
  }
  var PayWith = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$11], ["__scopeId", "data-v-58923868"]]);
  const _sfc_main$10 = {
    name: "DividerComponent",
    components: {
      TextField
    },
    data() {
      return {
        dividerText: "",
        dividerTextId: "bluefinch-checkout-divider-text"
      };
    },
    computed: {
      ...mapState(usePaymentStore, ["availableMethods", "isExpressPaymentsVisible"])
    },
    mounted() {
      var _a;
      this.dividerText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.dividerTextId]) || this.$t("dividerText");
      document.addEventListener(this.dividerTextId, this.setDividerText);
    },
    unmounted() {
      document.removeEventListener(this.dividerTextId, this.setDividerText);
    },
    methods: {
      setDividerText(event) {
        var _a;
        this.dividerText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("dividerText");
      }
    }
  };
  const _withScopeId$8 = (n) => (pushScopeId("data-v-28f6bd6c"), n = n(), popScopeId(), n);
  const _hoisted_1$W = { class: "divider" };
  const _hoisted_2$K = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_3$D = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    return openBlock(), createElementBlock("div", _hoisted_1$W, [
      _hoisted_2$K,
      _ctx.isExpressPaymentsVisible ? (openBlock(), createBlock(_component_TextField, {
        key: 0,
        text: $data.dividerText
      }, null, 8, ["text"])) : (openBlock(), createBlock(_component_TextField, {
        key: 1,
        text: _ctx.$t("payNoExpressWithBlockTitle")
      }, null, 8, ["text"])),
      _hoisted_3$D
    ]);
  }
  var DividerComponent = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$10], ["__scopeId", "data-v-28f6bd6c"]]);
  const _sfc_main$$ = {
    name: "Recaptcha",
    components: {
      ErrorMessage
    },
    props: {
      id: {
        type: String,
        required: true,
        default: ""
      },
      location: {
        type: String,
        required: true,
        default: ""
      }
    },
    computed: {
      ...mapState(usePaymentStore, ["paymentEmitter"]),
      ...mapState(useRecaptchaStore, [
        "getRecaptchaError",
        "isRecaptchaVisible",
        "v2CheckboxKey",
        "v2InvisibleKey",
        "v3Invisible"
      ])
    },
    async mounted() {
      await this.getInitialConfig();
      const recapchaType = this.getTypeByPlacement(this.id);
      if (!recapchaType) {
        return;
      }
      await this.addRecaptchaJs(recapchaType);
      if (recapchaType === recapchaTypes.recaptchaV2) {
        this.renderV2();
      } else if (recapchaType === recapchaTypes.invisible) {
        this.renderV2Invisible();
      } else if (recapchaType === recapchaTypes.recaptchaV3) {
        this.renderV3();
      }
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useRecaptchaStore, ["addRecaptchaJs", "getTypeByPlacement", "setToken", "resetToken"]),
      renderV2() {
        this.resetToken(this.id);
        window.grecaptcha.render(this.location, {
          sitekey: this.v2CheckboxKey,
          callback: (token) => {
            this.setToken(this.id, token);
          },
          "expired-callback": () => {
            this.setToken(this.id, null);
          }
        });
      },
      renderV2Invisible() {
        window.grecaptcha.render(this.location, {
          sitekey: this.v2InvisibleKey,
          size: "invisible",
          callback: (token) => {
            this.setToken(this.id, token);
          },
          "expired-callback": () => {
            this.setToken(this.id, null);
          }
        });
        window.grecaptcha.execute();
      },
      renderV3() {
        window.grecaptcha.ready(() => {
          window.grecaptcha.execute(this.v3Invisible, { action: "submit" }).then((token) => {
            this.setToken(this.id, token);
          });
        });
      }
    }
  };
  const _hoisted_1$V = ["id"];
  const _hoisted_2$J = ["id"];
  function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    return openBlock(), createElementBlock(Fragment, null, [
      _ctx.isRecaptchaVisible($props.id) ? (openBlock(), createElementBlock("div", {
        key: 0,
        id: $props.location,
        class: "recaptcha-container"
      }, null, 8, _hoisted_1$V)) : (openBlock(), createElementBlock("div", {
        key: 1,
        id: $props.location,
        class: "recaptcha-container-invisible"
      }, null, 8, _hoisted_2$J)),
      _ctx.getRecaptchaError($props.id) ? (openBlock(), createBlock(_component_ErrorMessage, {
        key: 2,
        message: _ctx.getRecaptchaError($props.id),
        attached: false,
        margin: false
      }, null, 8, ["message"])) : createCommentVNode("", true)
    ], 64);
  }
  var Recaptcha = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$$], ["__scopeId", "data-v-27cb3eee"]]);
  const _sfc_main$_ = {
    name: "ShowIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$U = ["role", "aria-label"];
  const _hoisted_2$I = /* @__PURE__ */ createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M12.6998 3H11.293C11.1415 3.02419 10.9895 3.04595 10.8374 3.06773C10.5355 3.11094 10.2333 3.1542 9.93426 3.21661C7.90701 3.6354 6.15631 4.61257 4.59318 5.93633C2.77034 7.48632 1.31783 9.33958 0.168337 11.4335C0.126258 11.5093 0.0877135 11.5863 0.0494051 11.6628C0.03298 11.6956 0.0165983 11.7283 0 11.7608V12.2302C1.07495 14.3121 2.47455 16.1437 4.20601 17.7153C5.71863 19.0872 7.41883 20.139 9.41242 20.6565C12.2068 21.3809 14.8449 20.9405 17.329 19.5156C19.2914 18.3892 20.8834 16.8441 22.2132 15.0341C22.6657 14.4168 23.0699 13.764 23.4738 13.1117C23.5959 12.9146 23.7179 12.7175 23.8413 12.5214C24.0433 12.2013 24.0529 11.8523 23.8677 11.5178C22.3551 8.77638 20.4048 6.4225 17.7379 4.72329C16.2493 3.775 14.626 3.18533 12.8561 3.03851C12.8183 3.03679 12.7817 3.02523 12.7446 3.0135C12.7298 3.00882 12.7149 3.00412 12.6998 3ZM16.3527 17.7707C15.0084 18.5625 13.5607 18.9982 12.707 18.9958H12.7046C10.0786 18.9933 8.38316 18.3459 6.83927 17.2652C4.91543 15.915 3.44128 14.1532 2.23647 12.1532C2.19319 12.0834 2.17395 11.9486 2.21242 11.886C3.56633 9.63802 5.23527 7.68127 7.50541 6.30216C9.02284 5.38035 10.6677 4.91583 12.4545 5.01451C13.9791 5.09875 15.3667 5.59696 16.6509 6.40084C18.4737 7.54408 19.9022 9.08926 21.1166 10.8462C21.3427 11.1736 21.5543 11.5105 21.7563 11.8523C21.7996 11.9221 21.8092 12.0545 21.7707 12.1195C20.388 14.4059 18.6878 16.3964 16.3527 17.7707ZM15.9896 12.0136C15.9992 9.79451 14.2196 8.00865 12 8.00383C9.79239 7.99902 8.01283 9.77285 8.00321 11.9823C7.99359 14.199 9.77556 15.9921 11.9928 15.9921C14.198 15.9945 15.98 14.2207 15.9896 12.0136ZM12.0144 9.99669C13.1134 10.0111 14.008 10.9209 13.9984 12.0112C13.9888 13.1087 13.0822 14.0065 11.9904 14.0016C10.8842 13.9968 9.97516 13.0726 9.99439 11.9751C10.0136 10.8752 10.9251 9.98224 12.0144 9.99669Z",
    fill: "#3F5D7C"
  }, null, -1);
  const _hoisted_3$C = [
    _hoisted_2$I
  ];
  function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$C, 12, _hoisted_1$U);
  }
  var ShowIcon = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$_]]);
  const _sfc_main$Z = {
    name: "HideIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$T = ["role", "aria-label"];
  const _hoisted_2$H = /* @__PURE__ */ createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M20.3867 6.07735C21.722 7.36384 22.8735 9.02632 23.841 11.0648C23.9457 11.2864 24 11.5285 24 11.7735C24 12.0186 23.9457 12.2607 23.841 12.4823C21.2372 17.9927 17.2902 20.7479 12 20.7479C10.0916 20.7479 8.35758 20.3878 6.79785 19.6676L8.31528 18.1501C9.43828 18.5608 10.6665 18.7661 12 18.7661C16.4424 18.7661 19.6931 16.5146 21.9831 11.7749C21.123 9.99683 20.1283 8.56914 18.9863 7.47779L20.3867 6.07735ZM20.9179 1.06458L22.0913 2.23933C22.1118 2.25978 22.128 2.28407 22.1391 2.31079C22.1502 2.33752 22.1559 2.36618 22.1559 2.39512C22.1559 2.42405 22.1502 2.45271 22.1391 2.47944C22.128 2.50617 22.1118 2.53046 22.0913 2.5509L2.48972 22.1517C2.44843 22.1929 2.39244 22.2161 2.33407 22.2161C2.27569 22.2161 2.2197 22.1929 2.17841 22.1517L1.00339 20.9766C0.962129 20.9353 0.93895 20.8794 0.93895 20.821C0.93895 20.7626 0.962129 20.7066 1.00339 20.6653L3.91604 17.7535C2.45155 16.4322 1.19918 14.676 0.158941 12.4851C0.0542801 12.2634 0 12.0214 0 11.7763C0 11.5312 0.0542801 11.2892 0.158941 11.0675C2.76276 5.55713 6.70977 2.80193 12 2.80193C14.0709 2.80193 15.9363 3.22581 17.596 4.07356L20.6063 1.06458C20.6268 1.04411 20.6511 1.02786 20.6778 1.01678C20.7045 1.00571 20.7332 1 20.7621 1C20.7911 1 20.8197 1.00571 20.8465 1.01678C20.8732 1.02786 20.8975 1.04411 20.9179 1.06458ZM12 4.78369C7.56028 4.78369 4.30964 7.0352 2.01685 11.7749C2.95268 13.7093 4.04815 15.229 5.31896 16.3506L7.61506 14.0545C7.12612 13.1381 6.94466 12.0889 7.09745 11.0615C7.25023 10.0341 7.72917 9.08308 8.46361 8.34865C9.19806 7.6142 10.1491 7.13526 11.1765 6.98248C12.2038 6.82969 13.2531 7.01115 14.1695 7.50008L16.1044 5.56512C14.8661 5.04132 13.5012 4.78369 12 4.78369ZM9.1427 10.3786C8.92259 10.8112 8.80762 11.2896 8.80714 11.7749C8.80679 12.0944 8.8561 12.4119 8.9533 12.7163L12.8312 8.83833C12.3689 8.69074 11.8782 8.65431 11.3991 8.73198C10.92 8.80965 10.466 8.99924 10.0739 9.28535C9.68185 9.57146 9.3628 9.94601 9.1427 10.3786ZM11.6078 14.8447C11.7008 14.8533 11.7947 14.8577 11.8899 14.8577C12.2948 14.8579 12.6958 14.7783 13.0699 14.6234C13.444 14.4686 13.7839 14.2415 14.0702 13.9552C14.3565 13.6689 14.5836 13.329 14.7384 12.9549C14.8933 12.5808 14.9729 12.1798 14.9726 11.7749C14.9726 11.6797 14.9682 11.5858 14.9597 11.4928L16.4136 10.0389C16.7484 10.9134 16.8229 11.8661 16.6278 12.7819C16.4328 13.6977 15.9766 14.5374 15.3145 15.1995C14.6524 15.8616 13.8127 16.3178 12.8969 16.5128C11.9811 16.7079 11.0284 16.6334 10.1539 16.2986L11.6078 14.8447Z",
    fill: "#3F5D7C"
  }, null, -1);
  const _hoisted_3$B = [
    _hoisted_2$H
  ];
  function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$B, 12, _hoisted_1$T);
  }
  var HideIcon = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Z]]);
  const _sfc_main$Y = {
    name: "Edit",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$S = ["role", "aria-label"];
  const _hoisted_2$G = /* @__PURE__ */ createBaseVNode("path", {
    d: "M5.6425 18C5.6925 18 5.7425 17.995 5.7925 17.9875L9.9975 17.25C10.0475 17.24 10.095 17.2175 10.13 17.18L20.7275 6.5825C20.7507 6.55937 20.7691 6.5319 20.7816 6.50166C20.7942 6.47141 20.8006 6.43899 20.8006 6.40625C20.8006 6.37351 20.7942 6.34109 20.7816 6.31084C20.7691 6.2806 20.7507 6.25313 20.7275 6.23L16.5725 2.0725C16.525 2.025 16.4625 2 16.395 2C16.3275 2 16.265 2.025 16.2175 2.0725L5.62 12.67C5.5825 12.7075 5.56 12.7525 5.55 12.8025L4.8125 17.0075C4.78818 17.1414 4.79687 17.2793 4.83782 17.4091C4.87877 17.5389 4.95074 17.6568 5.0475 17.7525C5.2125 17.9125 5.42 18 5.6425 18ZM7.3275 13.64L16.395 4.575L18.2275 6.4075L9.16 15.4725L6.9375 15.865L7.3275 13.64ZM21.2 20.1H2.8C2.3575 20.1 2 20.4575 2 20.9V21.8C2 21.91 2.09 22 2.2 22H21.8C21.91 22 22 21.91 22 21.8V20.9C22 20.4575 21.6425 20.1 21.2 20.1Z",
    fill: "#3F5D7C"
  }, null, -1);
  const _hoisted_3$A = [
    _hoisted_2$G
  ];
  function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$A, 12, _hoisted_1$S);
  }
  var Edit = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$Y]]);
  const _sfc_main$X = {
    name: "ValidIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$R = ["role", "aria-label"];
  const _hoisted_2$F = /* @__PURE__ */ createBaseVNode("path", {
    d: "M11.2999 0C11.7692 0 12.2385 0 12.7051 0C13.1214 0.0530388 13.5403 0.0928179 13.9539 0.16442C16.8147 0.662985 19.2168 1.99956 21.0966 4.21393C23.4748 7.01438 24.4028 10.2657 23.8407 13.8988C23.39 16.8212 21.9874 19.2504 19.7285 21.1545C17.1567 23.3238 14.166 24.252 10.8148 23.9417C8.64597 23.7402 6.67338 22.9764 4.92616 21.6716C2.36233 19.7569 0.768884 17.227 0.188244 14.0712C0.106053 13.6204 0.0609805 13.1642 0 12.7081C0 12.2387 0 11.7693 0 11.3026C0.0212106 11.1408 0.0424212 10.979 0.0609805 10.8173C0.315508 8.45703 1.16658 6.34079 2.66723 4.50034C4.56823 2.16398 7.0048 0.708068 9.98224 0.182984C10.4171 0.106078 10.8598 0.0609946 11.2999 0ZM11.2522 13.7211C11.1356 13.5965 11.0401 13.4931 10.9447 13.3896C10.189 12.5675 9.43341 11.7454 8.67248 10.926C8.36758 10.5945 7.99109 10.4566 7.55097 10.5812C7.09759 10.7112 6.82451 11.0241 6.73436 11.4855C6.64422 11.9443 6.798 12.3315 7.10555 12.6657C8.15547 13.8139 9.216 14.949 10.2527 16.1079C10.7273 16.6383 11.6101 16.8133 12.2359 16.1344C13.9804 14.2462 15.7701 12.4031 17.5253 10.5255C17.7241 10.3134 17.8726 10.0137 17.9389 9.72996C18.1377 8.89725 17.6021 8.23692 16.8147 8.29261C16.4912 8.31648 16.25 8.48886 16.0326 8.71692C14.927 9.87582 13.8214 11.0347 12.7158 12.191C12.2359 12.6922 11.756 13.1934 11.2549 13.7185L11.2522 13.7211Z",
    fill: "#24B53B"
  }, null, -1);
  const _hoisted_3$z = [
    _hoisted_2$F
  ];
  function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$z, 12, _hoisted_1$R);
  }
  var ValidIcon = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$X]]);
  var isEmailValid = (emailAddress) => {
    if (emailAddress.length < 4) {
      return false;
    }
    const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(String(emailAddress).toLowerCase());
  };
  var scrollToTarget = (target) => {
    const element = typeof target === "string" ? document.querySelector(target) : target;
    element.scrollIntoView({
      behavior: "smooth"
    });
  };
  var customerLoginDataLayer = () => {
    const gtmStore = useGtmStore();
    gtmStore.trackGtmEvent({
      event: "customerLoggedInAtCheckout"
    });
  };
  var continueAsGuestDataLayer = () => {
    const gtmStore = useGtmStore();
    gtmStore.trackGtmEvent({
      event: "continueAsGuestUser"
    });
  };
  const _sfc_main$W = {
    name: "EmailAddress",
    components: {
      TextInput,
      MyButton,
      HideIcon,
      ShowIcon,
      ValidIcon,
      TextField,
      ErrorMessage,
      Edit,
      Recaptcha
    },
    data() {
      return {
        emailError: false,
        emailRegistered: void 0,
        emailErrorMessage: "",
        emailValid: false,
        passwordErrorMessage: "",
        passwordError: false,
        loginErrorMessage: null,
        showPassword: false,
        passwordValid: false,
        password: "",
        baseURL: getBaseUrl(),
        isEmailAvailableRequest: void 0,
        continueButtonText: "",
        continueButtonTextId: "bluefinch-checkout-continuebutton-text",
        noAccountGuestButtonText: "",
        noAccountGuestButtonTextId: "bluefinch-checkout-noaccountguestbutton-text",
        signInButtonText: "",
        signInButtonTextId: "bluefinch-checkout-signinbutton-text",
        accountGuestButtonText: "",
        accountGuestButtonTextId: "bluefinch-checkout-accountguestbutton-text",
        tabKeyPressed: false
      };
    },
    computed: {
      ...mapState(useCustomerStore, ["isLoggedIn", "emailEntered", "inputsSanitiseError", "dummyUserType", "currentStep"]),
      ...mapWritableState(useCustomerStore, ["customer"]),
      ...mapState(useCartStore, ["guestCheckoutEnabled"]),
      ...mapState(useConfigStore, ["storeCode"]),
      proceedAsGuestInvalid() {
        return this.emailError;
      },
      passwordInputType() {
        return this.showPassword ? "text" : "password";
      }
    },
    async mounted() {
      var _a, _b, _c, _d;
      await this.getInitialConfig();
      await this.getCart();
      this.trackStep({
        step: 1,
        description: "login"
      });
      document.addEventListener("keydown", this.handleKeyDown);
      this.continueButtonText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.continueButtonTextId]) || this.$t("continueButton");
      this.noAccountGuestButtonText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.noAccountGuestButtonTextId]) || this.$t("noAccountGuestButton");
      this.signInButtonText = ((_c = window.bluefinchCheckout) == null ? void 0 : _c[this.signInButtonTextId]) || this.$t("signInButton");
      this.accountGuestButtonText = ((_d = window.bluefinchCheckout) == null ? void 0 : _d[this.accountGuestButtonTextId]) || this.$t("accountGuestButton");
      document.addEventListener(this.continueButtonTextId, this.setContinueButtonText);
      document.addEventListener(this.noAccountGuestButtonTextId, this.setNoAccountGuestButtonText);
      document.addEventListener(this.signInButtonTextId, this.setSignInButtonText);
      document.addEventListener(this.accountGuestButtonTextId, this.setAccountGuestButtonText);
    },
    unmounted() {
      document.removeEventListener(this.continueButtonTextId, this.setContinueButtonText);
      document.removeEventListener(this.noAccountGuestButtonTextId, this.setNoAccountGuestButtonText);
      document.removeEventListener(this.signInButtonTextId, this.setSignInButtonText);
      document.removeEventListener(this.accountGuestButtonTextId, this.setAccountGuestButtonText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useCustomerStore, [
        "login",
        "submitEmail",
        "setEmailEntered",
        "isEmailAvailable",
        "editEmail"
      ]),
      ...mapActions(useCartStore, ["getCart", "emitUpdate"]),
      ...mapActions(useGtmStore, ["trackStep"]),
      ...mapActions(useLoadingStore, ["setLoadingState"]),
      setContinueButtonText(event) {
        var _a;
        this.continueButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("continueButton");
      },
      setNoAccountGuestButtonText(event) {
        var _a;
        this.noAccountGuestButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("noAccountGuestButton");
      },
      setSignInButtonText(event) {
        var _a;
        this.signInButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("signInButton");
      },
      setAccountGuestButtonText(event) {
        var _a;
        this.accountGuestButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("accountGuestButton");
      },
      toggleShowPassword() {
        this.showPassword = !this.showPassword;
      },
      changeEmail() {
        this.editEmail();
        setTimeout(() => {
          this.$refs.email.$refs.input.focus();
        }, 0);
      },
      async loginAndProceed() {
        try {
          await this.login(this.customer.email, this.password);
          this.loginErrorMessage = "";
          this.proceed();
          customerLoginDataLayer();
        } catch (error) {
          this.loginErrorMessage = error.message;
        }
      },
      async submitForm() {
        scrollToTarget(".details-form");
      },
      validatePassword() {
        this.passwordValid = false;
        let counter = 0;
        const requiredNumber = 3;
        if (/[0-9]+/.test(this.password))
          counter++;
        if (/[A-Z]+/.test(this.password))
          counter++;
        if (/[a-z]+/.test(this.password))
          counter++;
        if (/[^a-zA-Z0-9]+/.test(this.password))
          counter++;
        this.passwordValid = counter >= requiredNumber;
        if (this.passwordValid === false) {
          this.passwordError = true;
          this.passwordErrorMessage = this.$t("errorMessages.passwordErrorMessage");
        } else {
          this.passwordError = false;
          this.passwordErrorMessage = "";
        }
      },
      proceedAsGuest() {
        continueAsGuestDataLayer();
        this.proceed();
      },
      proceed() {
        this.setEmailEntered();
        this.submitEmail(this.customer.email);
      },
      setEmailErrorState(hasError) {
        this.emailError = hasError;
        this.emailErrorMessage = hasError ? this.$t("errorMessages.emailErrorMessage") : "";
      },
      handleKeyDown(event) {
        if (event.key === "Tab") {
          this.tabKeyPressed = true;
        }
      },
      emailAddressBlur() {
        if (!isEmailValid(this.customer.email.toLowerCase())) {
          this.setEmailErrorState(this.customer.email.length > 0);
        } else {
          this.emailValid = true;
          if (this.tabKeyPressed && this.emailValid && !this.focusReturnedToEmail) {
            this.$refs.email.$refs.input.focus();
            this.focusReturnedToEmail = true;
          }
        }
        this.tabKeyPressed = false;
      },
      async emailAddressChange() {
        this.setEmailErrorState(false);
        if (isEmailValid(this.customer.email.toLowerCase())) {
          this.emailRegistered = !await this.isEmailAvailable(this.customer.email);
        } else {
          this.emailRegistered = void 0;
        }
      }
    }
  };
  const _withScopeId$7 = (n) => (pushScopeId("data-v-f625662c"), n = n(), popScopeId(), n);
  const _hoisted_1$Q = { class: "customer-form" };
  const _hoisted_2$E = { class: "checkout-section checkout-email" };
  const _hoisted_3$y = ["aria-label"];
  const _hoisted_4$o = { key: 1 };
  const _hoisted_5$k = { class: "field__password" };
  const _hoisted_6$f = ["aria-label"];
  const _hoisted_7$c = { key: 0 };
  const _hoisted_8$a = { key: 1 };
  const _hoisted_9$7 = { id: "password_help_text" };
  const _hoisted_10$7 = { class: "checkout-email__footer" };
  const _hoisted_11$6 = {
    class: "forgot-pass",
    "data-cy": "forgot-pass-button"
  };
  const _hoisted_12$5 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("span", { style: { "display": "none" } }, "forgotPass link", -1));
  const _hoisted_13$4 = {
    key: 0,
    class: "actions"
  };
  const _hoisted_14$1 = { class: "divider" };
  const _hoisted_15$1 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_16$1 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_17$1 = {
    key: 2,
    class: "actions"
  };
  function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_ValidIcon = resolveComponent("ValidIcon");
    const _component_Edit = resolveComponent("Edit");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_ShowIcon = resolveComponent("ShowIcon");
    const _component_HideIcon = resolveComponent("HideIcon");
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    return openBlock(), createElementBlock("section", _hoisted_1$Q, [
      createBaseVNode("div", _hoisted_2$E, [
        _ctx.customer.registered !== void 0 && !_ctx.customer.loggedIn && _ctx.emailEntered ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createVNode(_component_TextField, {
            class: "welcome-message-title",
            "data-cy": "email",
            text: _ctx.customer.registered ? _ctx.$t("welcomeMessages.accountTitle") : _ctx.$t("welcomeMessages.guestTitle")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            class: "welcome-message",
            text: _ctx.customer.registered ? _ctx.$t("welcomeMessages.accountBody") : _ctx.$t("welcomeMessages.guestBody")
          }, null, 8, ["text"])
        ], 64)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass({ "logged-in-email": _ctx.customer.loggedIn && _ctx.currentStep === "YourDetails" })
        }, [
          createVNode(_component_TextInput, {
            ref: "email",
            modelValue: _ctx.customer.email,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.customer.email = $event),
            error: $data.emailError,
            class: normalizeClass({ "field-valid": $data.emailValid && !_ctx.emailEntered && !$data.emailError && !_ctx.inputsSanitiseError }),
            "data-cy": "email",
            "error-message": $data.emailErrorMessage,
            identifier: "email",
            label: _ctx.$t("yourDetailsSection.emailAddress.label"),
            placeholder: _ctx.$t("yourDetailsSection.emailAddress.placeholder"),
            required: !_ctx.isLoggedIn,
            autocomplete: "email",
            type: "email",
            disabled: _ctx.emailEntered,
            style: "pointer-events: none;",
            onBlur: $options.emailAddressBlur,
            onKeyup: $options.emailAddressChange
          }, null, 8, ["modelValue", "error", "class", "error-message", "label", "placeholder", "required", "disabled", "onBlur", "onKeyup"]),
          $data.emailValid && !_ctx.emailEntered && !$data.emailError && !_ctx.inputsSanitiseError ? (openBlock(), createBlock(_component_ValidIcon, { key: 0 })) : createCommentVNode("", true),
          _ctx.emailEntered && !_ctx.isLoggedIn ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "email-address-edit-btn",
            onClick: _cache[1] || (_cache[1] = ($event) => $options.changeEmail()),
            onKeydown: _cache[2] || (_cache[2] = withKeys(($event) => $options.changeEmail(), ["enter"]))
          }, [
            createBaseVNode("button", {
              class: "edit-button",
              "data-cy": "button",
              "aria-label": _ctx.$t("yourDetailsSection.editDetailsButtonLabel")
            }, [
              createVNode(_component_TextField, {
                text: _ctx.$t("yourDetailsSection.editButton")
              }, null, 8, ["text"]),
              createVNode(_component_Edit)
            ], 8, _hoisted_3$y)
          ], 32)) : createCommentVNode("", true)
        ], 2),
        createBaseVNode("div", null, [
          _ctx.customer.registered === void 0 && !_ctx.emailEntered && _ctx.currentStep === "SignInPage" ? (openBlock(), createBlock(_component_MyButton, {
            key: 0,
            class: "continue-btn",
            primary: "",
            label: $data.continueButtonText,
            onClick: _cache[3] || (_cache[3] = ($event) => $options.emailAddressChange())
          }, null, 8, ["label"])) : createCommentVNode("", true)
        ]),
        _ctx.customer.registered && _ctx.emailEntered && _ctx.currentStep === "SignInPage" ? (openBlock(), createElementBlock("div", _hoisted_4$o, [
          createBaseVNode("div", _hoisted_5$k, [
            createVNode(_component_TextInput, {
              ref: "passwordInput",
              modelValue: $data.password,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.password = $event),
              error: $data.passwordError,
              "error-message": $data.passwordErrorMessage,
              type: $options.passwordInputType,
              "data-cy": "password",
              identifier: "password",
              label: _ctx.$t("yourDetailsSection.passwordField.label"),
              placeholder: _ctx.$t("yourDetailsSection.passwordField.placeholder"),
              required: ""
            }, {
              icon: withCtx(() => [
                createBaseVNode("button", {
                  class: "button_show_password",
                  "aria-label": _ctx.$t("yourDetailsSection.showPassLabel"),
                  onClick: _cache[4] || (_cache[4] = (...args) => $options.toggleShowPassword && $options.toggleShowPassword(...args))
                }, [
                  $data.showPassword ? (openBlock(), createElementBlock("span", _hoisted_7$c, [
                    createVNode(_component_ShowIcon)
                  ])) : (openBlock(), createElementBlock("span", _hoisted_8$a, [
                    createVNode(_component_HideIcon)
                  ]))
                ], 8, _hoisted_6$f)
              ]),
              _: 1
            }, 8, ["modelValue", "error", "error-message", "type", "label", "placeholder"])
          ]),
          createBaseVNode("div", _hoisted_9$7, [
            createVNode(_component_TextField, {
              class: "field__help-text",
              text: _ctx.$t("errorMessages.passwordHelpText")
            }, null, 8, ["text"])
          ]),
          createBaseVNode("div", _hoisted_10$7, [
            createBaseVNode("a", _hoisted_11$6, [
              _hoisted_12$5,
              createVNode(_component_TextField, {
                text: _ctx.$t("forgotPass")
              }, null, 8, ["text"])
            ])
          ]),
          _ctx.emailEntered ? (openBlock(), createElementBlock("div", _hoisted_13$4, [
            createVNode(_component_Recaptcha, {
              id: "customerLogin",
              location: "emailAddress"
            }),
            $data.loginErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
              key: 0,
              message: $data.loginErrorMessage,
              attached: false
            }, null, 8, ["message"])) : createCommentVNode("", true),
            createVNode(_component_MyButton, {
              type: "submit",
              class: "sign-in-btn",
              primary: "",
              label: $data.signInButtonText,
              onClick: $options.submitForm
            }, null, 8, ["label", "onClick"]),
            createBaseVNode("div", _hoisted_14$1, [
              _hoisted_15$1,
              createVNode(_component_TextField, {
                text: _ctx.$t("signInDividerText")
              }, null, 8, ["text"]),
              _hoisted_16$1
            ]),
            createVNode(_component_MyButton, {
              class: "guest-btn",
              secondary: "",
              disabled: $options.proceedAsGuestInvalid,
              label: $data.accountGuestButtonText,
              onClick: _cache[6] || (_cache[6] = ($event) => {
                $options.proceedAsGuest();
              })
            }, null, 8, ["disabled", "label"])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        _ctx.customer.registered === false && _ctx.emailEntered && _ctx.currentStep === "SignInPage" ? (openBlock(), createElementBlock("div", _hoisted_17$1, [
          createVNode(_component_MyButton, {
            class: "guest-btn single",
            secondary: "",
            disabled: $options.proceedAsGuestInvalid,
            label: $data.noAccountGuestButtonText,
            onClick: _cache[7] || (_cache[7] = ($event) => {
              $options.proceedAsGuest();
            })
          }, null, 8, ["disabled", "label"])
        ])) : createCommentVNode("", true)
      ])
    ]);
  }
  var EmailAddress = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$W], ["__scopeId", "data-v-f625662c"]]);
  var browser = { exports: {} };
  (function(module, exports) {
    (function(f) {
      {
        module.exports = f();
      }
    })(function() {
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = typeof commonjsRequire == "function" && commonjsRequire;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p2 = n[i2] = { exports: {} };
              e[i2][0].call(p2.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p2, p2.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = typeof commonjsRequire == "function" && commonjsRequire, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(_dereq_, module2, exports2) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.PromiseGlobal = void 0;
        var promise_polyfill_1 = __importDefault(_dereq_("promise-polyfill"));
        var PromiseGlobal = typeof Promise !== "undefined" ? Promise : promise_polyfill_1.default;
        exports2.PromiseGlobal = PromiseGlobal;
      }, { "promise-polyfill": 68 }], 2: [function(_dereq_, module2, exports2) {
        var promise_1 = _dereq_("./lib/promise");
        var scriptPromiseCache = {};
        function loadScript(options) {
          var scriptLoadPromise;
          var stringifiedOptions = JSON.stringify(options);
          if (!options.forceScriptReload) {
            scriptLoadPromise = scriptPromiseCache[stringifiedOptions];
            if (scriptLoadPromise) {
              return scriptLoadPromise;
            }
          }
          var script = document.createElement("script");
          var attrs = options.dataAttributes || {};
          var container = options.container || document.head;
          script.src = options.src;
          script.id = options.id || "";
          script.async = true;
          if (options.crossorigin) {
            script.setAttribute("crossorigin", "" + options.crossorigin);
          }
          Object.keys(attrs).forEach(function(key) {
            script.setAttribute("data-" + key, "" + attrs[key]);
          });
          scriptLoadPromise = new promise_1.PromiseGlobal(function(resolve2, reject) {
            script.addEventListener("load", function() {
              resolve2(script);
            });
            script.addEventListener("error", function() {
              reject(new Error(options.src + " failed to load."));
            });
            script.addEventListener("abort", function() {
              reject(new Error(options.src + " has aborted."));
            });
            container.appendChild(script);
          });
          scriptPromiseCache[stringifiedOptions] = scriptLoadPromise;
          return scriptLoadPromise;
        }
        loadScript.clearCache = function() {
          scriptPromiseCache = {};
        };
        module2.exports = loadScript;
      }, { "./lib/promise": 1 }], 3: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/load-script");
      }, { "./dist/load-script": 2 }], 4: [function(_dereq_, module2, exports2) {
        module2.exports = function isAndroid(ua) {
          ua = ua || window.navigator.userAgent;
          return /Android/i.test(ua);
        };
      }, {}], 5: [function(_dereq_, module2, exports2) {
        module2.exports = function isChromeOS(ua) {
          ua = ua || window.navigator.userAgent;
          return /CrOS/i.test(ua);
        };
      }, {}], 6: [function(_dereq_, module2, exports2) {
        var isEdge = _dereq_("./is-edge");
        var isSamsung = _dereq_("./is-samsung");
        var isDuckDuckGo = _dereq_("./is-duckduckgo");
        var isOpera = _dereq_("./is-opera");
        var isSilk = _dereq_("./is-silk");
        module2.exports = function isChrome(ua) {
          ua = ua || window.navigator.userAgent;
          return (ua.indexOf("Chrome") !== -1 || ua.indexOf("CriOS") !== -1) && !isEdge(ua) && !isSamsung(ua) && !isDuckDuckGo(ua) && !isOpera(ua) && !isSilk(ua);
        };
      }, { "./is-duckduckgo": 7, "./is-edge": 8, "./is-opera": 18, "./is-samsung": 19, "./is-silk": 20 }], 7: [function(_dereq_, module2, exports2) {
        module2.exports = function isDuckDuckGo(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("DuckDuckGo/") !== -1;
        };
      }, {}], 8: [function(_dereq_, module2, exports2) {
        module2.exports = function isEdge(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("Edge/") !== -1;
        };
      }, {}], 9: [function(_dereq_, module2, exports2) {
        module2.exports = function isFirefox(ua) {
          ua = ua || window.navigator.userAgent;
          return /Firefox/i.test(ua);
        };
      }, {}], 10: [function(_dereq_, module2, exports2) {
        module2.exports = function isIe9(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("MSIE 9") !== -1;
        };
      }, {}], 11: [function(_dereq_, module2, exports2) {
        module2.exports = function isIosFirefox(ua) {
          ua = ua || window.navigator.userAgent;
          return /FxiOS/i.test(ua);
        };
      }, {}], 12: [function(_dereq_, module2, exports2) {
        var isIos = _dereq_("./is-ios");
        function isGoogleSearchApp(ua) {
          return /\bGSA\b/.test(ua);
        }
        module2.exports = function isIosGoogleSearchApp(ua) {
          ua = ua || window.navigator.userAgent;
          return isIos(ua) && isGoogleSearchApp(ua);
        };
      }, { "./is-ios": 16 }], 13: [function(_dereq_, module2, exports2) {
        var isIos = _dereq_("./is-ios");
        var isIosFirefox = _dereq_("./is-ios-firefox");
        var webkitRegexp = /webkit/i;
        function isWebkit(ua) {
          return webkitRegexp.test(ua);
        }
        function isIosChrome(ua) {
          return ua.indexOf("CriOS") > -1;
        }
        function isFacebook(ua) {
          return ua.indexOf("FBAN") > -1;
        }
        module2.exports = function isIosSafari(ua) {
          ua = ua || window.navigator.userAgent;
          return isIos(ua) && isWebkit(ua) && !isIosChrome(ua) && !isIosFirefox(ua) && !isFacebook(ua);
        };
      }, { "./is-ios": 16, "./is-ios-firefox": 11 }], 14: [function(_dereq_, module2, exports2) {
        var isIos = _dereq_("./is-ios");
        var isIosGoogleSearchApp = _dereq_("./is-ios-google-search-app");
        module2.exports = function isIosWebview(ua) {
          ua = ua || window.navigator.userAgent;
          if (isIos(ua)) {
            if (isIosGoogleSearchApp(ua)) {
              return true;
            }
            return /.+AppleWebKit(?!.*Safari)/i.test(ua);
          }
          return false;
        };
      }, { "./is-ios": 16, "./is-ios-google-search-app": 12 }], 15: [function(_dereq_, module2, exports2) {
        var isIosWebview = _dereq_("./is-ios-webview");
        module2.exports = function isIosWKWebview(ua, statusBarVisible) {
          statusBarVisible = typeof statusBarVisible !== "undefined" ? statusBarVisible : window.statusbar.visible;
          return isIosWebview(ua) && statusBarVisible;
        };
      }, { "./is-ios-webview": 14 }], 16: [function(_dereq_, module2, exports2) {
        var isIpadOS = _dereq_("./is-ipados");
        module2.exports = function isIos(ua, checkIpadOS, document2) {
          if (checkIpadOS === void 0) {
            checkIpadOS = true;
          }
          ua = ua || window.navigator.userAgent;
          var iOsTest = /iPhone|iPod|iPad/i.test(ua);
          return checkIpadOS ? iOsTest || isIpadOS(ua, document2) : iOsTest;
        };
      }, { "./is-ipados": 17 }], 17: [function(_dereq_, module2, exports2) {
        module2.exports = function isIpadOS(ua, document2) {
          ua = ua || window.navigator.userAgent;
          document2 = document2 || window.document;
          return /Mac|iPad/i.test(ua) && "ontouchend" in document2;
        };
      }, {}], 18: [function(_dereq_, module2, exports2) {
        module2.exports = function isOpera(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("OPR/") !== -1 || ua.indexOf("Opera/") !== -1 || ua.indexOf("OPT/") !== -1;
        };
      }, {}], 19: [function(_dereq_, module2, exports2) {
        module2.exports = function isSamsungBrowser(ua) {
          ua = ua || window.navigator.userAgent;
          return /SamsungBrowser/i.test(ua);
        };
      }, {}], 20: [function(_dereq_, module2, exports2) {
        module2.exports = function isSilk(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("Silk/") !== -1;
        };
      }, {}], 21: [function(_dereq_, module2, exports2) {
        var MINIMUM_SUPPORTED_CHROME_IOS_VERSION = 48;
        var isAndroid = _dereq_("./is-android");
        var isIosFirefox = _dereq_("./is-ios-firefox");
        var isIosWebview = _dereq_("./is-ios-webview");
        var isChrome = _dereq_("./is-chrome");
        var isSamsungBrowser = _dereq_("./is-samsung");
        var isDuckDuckGo = _dereq_("./is-duckduckgo");
        function isUnsupportedIosChrome(ua) {
          ua = ua || window.navigator.userAgent;
          var match = ua.match(/CriOS\/(\d+)\./);
          if (!match) {
            return false;
          }
          var version2 = parseInt(match[1], 10);
          return version2 < MINIMUM_SUPPORTED_CHROME_IOS_VERSION;
        }
        function isOperaMini(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("Opera Mini") > -1;
        }
        function isAndroidWebview(ua) {
          var androidWebviewRegExp = /Version\/[\d.]+/i;
          ua = ua || window.navigator.userAgent;
          if (isAndroid(ua)) {
            return androidWebviewRegExp.test(ua) && !isOperaMini(ua) && !isDuckDuckGo(ua);
          }
          return false;
        }
        function isOldSamsungBrowserOrSamsungWebview(ua) {
          return !isChrome(ua) && !isSamsungBrowser(ua) && /samsung/i.test(ua);
        }
        module2.exports = function supportsPopups(ua) {
          ua = ua || window.navigator.userAgent;
          return !(isIosWebview(ua) || isIosFirefox(ua) || isAndroidWebview(ua) || isOperaMini(ua) || isUnsupportedIosChrome(ua) || isOldSamsungBrowserOrSamsungWebview(ua));
        };
      }, { "./is-android": 4, "./is-chrome": 6, "./is-duckduckgo": 7, "./is-ios-firefox": 11, "./is-ios-webview": 14, "./is-samsung": 19 }], 22: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-android");
      }, { "./dist/is-android": 4 }], 23: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-chrome-os");
      }, { "./dist/is-chrome-os": 5 }], 24: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-chrome");
      }, { "./dist/is-chrome": 6 }], 25: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-firefox");
      }, { "./dist/is-firefox": 9 }], 26: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-ie9");
      }, { "./dist/is-ie9": 10 }], 27: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-ios-safari");
      }, { "./dist/is-ios-safari": 13 }], 28: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-ios-webview");
      }, { "./dist/is-ios-webview": 14 }], 29: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-ios-wkwebview");
      }, { "./dist/is-ios-wkwebview": 15 }], 30: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-ios");
      }, { "./dist/is-ios": 16 }], 31: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/is-samsung");
      }, { "./dist/is-samsung": 19 }], 32: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/supports-popups");
      }, { "./dist/supports-popups": 21 }], 33: [function(_dereq_, module2, exports2) {
        var EventEmitter = function() {
          function EventEmitter2() {
            this._events = {};
          }
          EventEmitter2.prototype.on = function(event, callback) {
            if (this._events[event]) {
              this._events[event].push(callback);
            } else {
              this._events[event] = [callback];
            }
          };
          EventEmitter2.prototype.off = function(event, callback) {
            var eventCallbacks = this._events[event];
            if (!eventCallbacks) {
              return;
            }
            var indexOfCallback = eventCallbacks.indexOf(callback);
            eventCallbacks.splice(indexOfCallback, 1);
          };
          EventEmitter2.prototype._emit = function(event) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
            }
            var eventCallbacks = this._events[event];
            if (!eventCallbacks) {
              return;
            }
            eventCallbacks.forEach(function(callback) {
              callback.apply(void 0, args);
            });
          };
          EventEmitter2.prototype.hasListener = function(event) {
            var eventCallbacks = this._events[event];
            if (!eventCallbacks) {
              return false;
            }
            return eventCallbacks.length > 0;
          };
          EventEmitter2.createChild = function(ChildObject) {
            ChildObject.prototype = Object.create(EventEmitter2.prototype, {
              constructor: ChildObject
            });
          };
          return EventEmitter2;
        }();
        module2.exports = EventEmitter;
      }, {}], 34: [function(_dereq_, module2, exports2) {
        var GlobalPromise = typeof Promise !== "undefined" ? Promise : null;
        var ExtendedPromise = function() {
          function ExtendedPromise2(options) {
            var _this = this;
            if (typeof options === "function") {
              this._promise = new ExtendedPromise2.Promise(options);
              return;
            }
            this._promise = new ExtendedPromise2.Promise(function(resolve2, reject) {
              _this._resolveFunction = resolve2;
              _this._rejectFunction = reject;
            });
            options = options || {};
            this._onResolve = options.onResolve || ExtendedPromise2.defaultOnResolve;
            this._onReject = options.onReject || ExtendedPromise2.defaultOnReject;
            if (ExtendedPromise2.shouldCatchExceptions(options)) {
              this._promise.catch(function() {
              });
            }
            this._resetState();
          }
          ExtendedPromise2.defaultOnResolve = function(result) {
            return ExtendedPromise2.Promise.resolve(result);
          };
          ExtendedPromise2.defaultOnReject = function(err) {
            return ExtendedPromise2.Promise.reject(err);
          };
          ExtendedPromise2.setPromise = function(PromiseClass) {
            ExtendedPromise2.Promise = PromiseClass;
          };
          ExtendedPromise2.shouldCatchExceptions = function(options) {
            if (options.hasOwnProperty("suppressUnhandledPromiseMessage")) {
              return Boolean(options.suppressUnhandledPromiseMessage);
            }
            return Boolean(ExtendedPromise2.suppressUnhandledPromiseMessage);
          };
          ExtendedPromise2.all = function(args) {
            return ExtendedPromise2.Promise.all(args);
          };
          ExtendedPromise2.allSettled = function(args) {
            return ExtendedPromise2.Promise.allSettled(args);
          };
          ExtendedPromise2.race = function(args) {
            return ExtendedPromise2.Promise.race(args);
          };
          ExtendedPromise2.reject = function(arg) {
            return ExtendedPromise2.Promise.reject(arg);
          };
          ExtendedPromise2.resolve = function(arg) {
            return ExtendedPromise2.Promise.resolve(arg);
          };
          ExtendedPromise2.prototype.then = function() {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = this._promise).then.apply(_a, args);
          };
          ExtendedPromise2.prototype.catch = function() {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = this._promise).catch.apply(_a, args);
          };
          ExtendedPromise2.prototype.resolve = function(arg) {
            var _this = this;
            if (this.isFulfilled) {
              return this;
            }
            this._setResolved();
            ExtendedPromise2.Promise.resolve().then(function() {
              return _this._onResolve(arg);
            }).then(function(argForResolveFunction) {
              _this._resolveFunction(argForResolveFunction);
            }).catch(function(err) {
              _this._resetState();
              _this.reject(err);
            });
            return this;
          };
          ExtendedPromise2.prototype.reject = function(arg) {
            var _this = this;
            if (this.isFulfilled) {
              return this;
            }
            this._setRejected();
            ExtendedPromise2.Promise.resolve().then(function() {
              return _this._onReject(arg);
            }).then(function(result) {
              _this._setResolved();
              _this._resolveFunction(result);
            }).catch(function(err) {
              return _this._rejectFunction(err);
            });
            return this;
          };
          ExtendedPromise2.prototype._resetState = function() {
            this.isFulfilled = false;
            this.isResolved = false;
            this.isRejected = false;
          };
          ExtendedPromise2.prototype._setResolved = function() {
            this.isFulfilled = true;
            this.isResolved = true;
            this.isRejected = false;
          };
          ExtendedPromise2.prototype._setRejected = function() {
            this.isFulfilled = true;
            this.isResolved = false;
            this.isRejected = true;
          };
          ExtendedPromise2.Promise = GlobalPromise;
          return ExtendedPromise2;
        }();
        module2.exports = ExtendedPromise;
      }, {}], 35: [function(_dereq_, module2, exports2) {
        var set_attributes_1 = _dereq_("./lib/set-attributes");
        var default_attributes_1 = _dereq_("./lib/default-attributes");
        var assign_1 = _dereq_("./lib/assign");
        module2.exports = function createFrame(options) {
          if (options === void 0) {
            options = {};
          }
          var iframe = document.createElement("iframe");
          var config = assign_1.assign({}, default_attributes_1.defaultAttributes, options);
          if (config.style && typeof config.style !== "string") {
            assign_1.assign(iframe.style, config.style);
            delete config.style;
          }
          set_attributes_1.setAttributes(iframe, config);
          if (!iframe.getAttribute("id")) {
            iframe.id = iframe.name;
          }
          return iframe;
        };
      }, { "./lib/assign": 36, "./lib/default-attributes": 37, "./lib/set-attributes": 38 }], 36: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.assign = void 0;
        function assign2(target) {
          var objs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            objs[_i - 1] = arguments[_i];
          }
          objs.forEach(function(obj) {
            if (typeof obj !== "object") {
              return;
            }
            Object.keys(obj).forEach(function(key) {
              target[key] = obj[key];
            });
          });
          return target;
        }
        exports2.assign = assign2;
      }, {}], 37: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.defaultAttributes = void 0;
        exports2.defaultAttributes = {
          src: "about:blank",
          frameBorder: 0,
          allowtransparency: true,
          scrolling: "no"
        };
      }, {}], 38: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.setAttributes = void 0;
        function setAttributes(element, attributes) {
          for (var key in attributes) {
            if (attributes.hasOwnProperty(key)) {
              var value = attributes[key];
              if (value == null) {
                element.removeAttribute(key);
              } else {
                element.setAttribute(key, value);
              }
            }
          }
        }
        exports2.setAttributes = setAttributes;
      }, {}], 39: [function(_dereq_, module2, exports2) {
        function uuid() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0;
            var v = c === "x" ? r : r & 3 | 8;
            return v.toString(16);
          });
        }
        module2.exports = uuid;
      }, {}], 40: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function deferred(fn) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            setTimeout(function() {
              try {
                fn.apply(void 0, args);
              } catch (err) {
                console.log("Error in callback function");
                console.log(err);
              }
            }, 1);
          };
        }
        exports2.deferred = deferred;
      }, {}], 41: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function once(fn) {
          var called = false;
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (!called) {
              called = true;
              fn.apply(void 0, args);
            }
          };
        }
        exports2.once = once;
      }, {}], 42: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function promiseOrCallback(promise, callback) {
          if (!callback) {
            return promise;
          }
          promise.then(function(data2) {
            return callback(null, data2);
          }).catch(function(err) {
            return callback(err);
          });
        }
        exports2.promiseOrCallback = promiseOrCallback;
      }, {}], 43: [function(_dereq_, module2, exports2) {
        var deferred_1 = _dereq_("./lib/deferred");
        var once_1 = _dereq_("./lib/once");
        var promise_or_callback_1 = _dereq_("./lib/promise-or-callback");
        function wrapPromise(fn) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var callback;
            var lastArg = args[args.length - 1];
            if (typeof lastArg === "function") {
              callback = args.pop();
              callback = once_1.once(deferred_1.deferred(callback));
            }
            return promise_or_callback_1.promiseOrCallback(fn.apply(this, args), callback);
          };
        }
        wrapPromise.wrapPrototype = function(target, options) {
          if (options === void 0) {
            options = {};
          }
          var ignoreMethods = options.ignoreMethods || [];
          var includePrivateMethods = options.transformPrivateMethods === true;
          var methods = Object.getOwnPropertyNames(target.prototype).filter(function(method) {
            var isNotPrivateMethod;
            var isNonConstructorFunction = method !== "constructor" && typeof target.prototype[method] === "function";
            var isNotAnIgnoredMethod = ignoreMethods.indexOf(method) === -1;
            if (includePrivateMethods) {
              isNotPrivateMethod = true;
            } else {
              isNotPrivateMethod = method.charAt(0) !== "_";
            }
            return isNonConstructorFunction && isNotPrivateMethod && isNotAnIgnoredMethod;
          });
          methods.forEach(function(method) {
            var original = target.prototype[method];
            target.prototype[method] = wrapPromise(original);
          });
          return target;
        };
        module2.exports = wrapPromise;
      }, { "./lib/deferred": 40, "./lib/once": 41, "./lib/promise-or-callback": 42 }], 44: [function(_dereq_, module2, exports2) {
        var __assign = this && this.__assign || function() {
          __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p2 in s)
                if (Object.prototype.hasOwnProperty.call(s, p2))
                  t[p2] = s[p2];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        var cardTypes = _dereq_("./lib/card-types");
        var add_matching_cards_to_results_1 = _dereq_("./lib/add-matching-cards-to-results");
        var is_valid_input_type_1 = _dereq_("./lib/is-valid-input-type");
        var find_best_match_1 = _dereq_("./lib/find-best-match");
        var clone_1 = _dereq_("./lib/clone");
        var customCards = {};
        var cardNames = {
          VISA: "visa",
          MASTERCARD: "mastercard",
          AMERICAN_EXPRESS: "american-express",
          DINERS_CLUB: "diners-club",
          DISCOVER: "discover",
          JCB: "jcb",
          UNIONPAY: "unionpay",
          MAESTRO: "maestro",
          ELO: "elo",
          MIR: "mir",
          HIPER: "hiper",
          HIPERCARD: "hipercard"
        };
        var ORIGINAL_TEST_ORDER = [
          cardNames.VISA,
          cardNames.MASTERCARD,
          cardNames.AMERICAN_EXPRESS,
          cardNames.DINERS_CLUB,
          cardNames.DISCOVER,
          cardNames.JCB,
          cardNames.UNIONPAY,
          cardNames.MAESTRO,
          cardNames.ELO,
          cardNames.MIR,
          cardNames.HIPER,
          cardNames.HIPERCARD
        ];
        var testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
        function findType(cardType) {
          return customCards[cardType] || cardTypes[cardType];
        }
        function getAllCardTypes() {
          return testOrder.map(function(cardType) {
            return clone_1.clone(findType(cardType));
          });
        }
        function getCardPosition(name, ignoreErrorForNotExisting) {
          if (ignoreErrorForNotExisting === void 0) {
            ignoreErrorForNotExisting = false;
          }
          var position = testOrder.indexOf(name);
          if (!ignoreErrorForNotExisting && position === -1) {
            throw new Error('"' + name + '" is not a supported card type.');
          }
          return position;
        }
        function creditCardType(cardNumber) {
          var results = [];
          if (!is_valid_input_type_1.isValidInputType(cardNumber)) {
            return results;
          }
          if (cardNumber.length === 0) {
            return getAllCardTypes();
          }
          testOrder.forEach(function(cardType) {
            var cardConfiguration = findType(cardType);
            add_matching_cards_to_results_1.addMatchingCardsToResults(cardNumber, cardConfiguration, results);
          });
          var bestMatch = find_best_match_1.findBestMatch(results);
          if (bestMatch) {
            return [bestMatch];
          }
          return results;
        }
        creditCardType.getTypeInfo = function(cardType) {
          return clone_1.clone(findType(cardType));
        };
        creditCardType.removeCard = function(name) {
          var position = getCardPosition(name);
          testOrder.splice(position, 1);
        };
        creditCardType.addCard = function(config) {
          var existingCardPosition = getCardPosition(config.type, true);
          customCards[config.type] = config;
          if (existingCardPosition === -1) {
            testOrder.push(config.type);
          }
        };
        creditCardType.updateCard = function(cardType, updates) {
          var originalObject = customCards[cardType] || cardTypes[cardType];
          if (!originalObject) {
            throw new Error('"' + cardType + "\" is not a recognized type. Use `addCard` instead.'");
          }
          if (updates.type && originalObject.type !== updates.type) {
            throw new Error("Cannot overwrite type parameter.");
          }
          var clonedCard = clone_1.clone(originalObject);
          clonedCard = __assign(__assign({}, clonedCard), updates);
          customCards[clonedCard.type] = clonedCard;
        };
        creditCardType.changeOrder = function(name, position) {
          var currentPosition = getCardPosition(name);
          testOrder.splice(currentPosition, 1);
          testOrder.splice(position, 0, name);
        };
        creditCardType.resetModifications = function() {
          testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
          customCards = {};
        };
        creditCardType.types = cardNames;
        module2.exports = creditCardType;
      }, { "./lib/add-matching-cards-to-results": 45, "./lib/card-types": 46, "./lib/clone": 47, "./lib/find-best-match": 48, "./lib/is-valid-input-type": 49 }], 45: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.addMatchingCardsToResults = void 0;
        var clone_1 = _dereq_("./clone");
        var matches_1 = _dereq_("./matches");
        function addMatchingCardsToResults(cardNumber, cardConfiguration, results) {
          var i, patternLength;
          for (i = 0; i < cardConfiguration.patterns.length; i++) {
            var pattern = cardConfiguration.patterns[i];
            if (!matches_1.matches(cardNumber, pattern)) {
              continue;
            }
            var clonedCardConfiguration = clone_1.clone(cardConfiguration);
            if (Array.isArray(pattern)) {
              patternLength = String(pattern[0]).length;
            } else {
              patternLength = String(pattern).length;
            }
            if (cardNumber.length >= patternLength) {
              clonedCardConfiguration.matchStrength = patternLength;
            }
            results.push(clonedCardConfiguration);
            break;
          }
        }
        exports2.addMatchingCardsToResults = addMatchingCardsToResults;
      }, { "./clone": 47, "./matches": 50 }], 46: [function(_dereq_, module2, exports2) {
        var cardTypes = {
          visa: {
            niceType: "Visa",
            type: "visa",
            patterns: [4],
            gaps: [4, 8, 12],
            lengths: [16, 18, 19],
            code: {
              name: "CVV",
              size: 3
            }
          },
          mastercard: {
            niceType: "Mastercard",
            type: "mastercard",
            patterns: [[51, 55], [2221, 2229], [223, 229], [23, 26], [270, 271], 2720],
            gaps: [4, 8, 12],
            lengths: [16],
            code: {
              name: "CVC",
              size: 3
            }
          },
          "american-express": {
            niceType: "American Express",
            type: "american-express",
            patterns: [34, 37],
            gaps: [4, 10],
            lengths: [15],
            code: {
              name: "CID",
              size: 4
            }
          },
          "diners-club": {
            niceType: "Diners Club",
            type: "diners-club",
            patterns: [[300, 305], 36, 38, 39],
            gaps: [4, 10],
            lengths: [14, 16, 19],
            code: {
              name: "CVV",
              size: 3
            }
          },
          discover: {
            niceType: "Discover",
            type: "discover",
            patterns: [6011, [644, 649], 65],
            gaps: [4, 8, 12],
            lengths: [16, 19],
            code: {
              name: "CID",
              size: 3
            }
          },
          jcb: {
            niceType: "JCB",
            type: "jcb",
            patterns: [2131, 1800, [3528, 3589]],
            gaps: [4, 8, 12],
            lengths: [16, 17, 18, 19],
            code: {
              name: "CVV",
              size: 3
            }
          },
          unionpay: {
            niceType: "UnionPay",
            type: "unionpay",
            patterns: [
              620,
              [624, 626],
              [62100, 62182],
              [62184, 62187],
              [62185, 62197],
              [62200, 62205],
              [622010, 622999],
              622018,
              [622019, 622999],
              [62207, 62209],
              [622126, 622925],
              [623, 626],
              6270,
              6272,
              6276,
              [627700, 627779],
              [627781, 627799],
              [6282, 6289],
              6291,
              6292,
              810,
              [8110, 8131],
              [8132, 8151],
              [8152, 8163],
              [8164, 8171]
            ],
            gaps: [4, 8, 12],
            lengths: [14, 15, 16, 17, 18, 19],
            code: {
              name: "CVN",
              size: 3
            }
          },
          maestro: {
            niceType: "Maestro",
            type: "maestro",
            patterns: [
              493698,
              [5e5, 504174],
              [504176, 506698],
              [506779, 508999],
              [56, 59],
              63,
              67,
              6
            ],
            gaps: [4, 8, 12],
            lengths: [12, 13, 14, 15, 16, 17, 18, 19],
            code: {
              name: "CVC",
              size: 3
            }
          },
          elo: {
            niceType: "Elo",
            type: "elo",
            patterns: [
              401178,
              401179,
              438935,
              457631,
              457632,
              431274,
              451416,
              457393,
              504175,
              [506699, 506778],
              [509e3, 509999],
              627780,
              636297,
              636368,
              [650031, 650033],
              [650035, 650051],
              [650405, 650439],
              [650485, 650538],
              [650541, 650598],
              [650700, 650718],
              [650720, 650727],
              [650901, 650978],
              [651652, 651679],
              [655e3, 655019],
              [655021, 655058]
            ],
            gaps: [4, 8, 12],
            lengths: [16],
            code: {
              name: "CVE",
              size: 3
            }
          },
          mir: {
            niceType: "Mir",
            type: "mir",
            patterns: [[2200, 2204]],
            gaps: [4, 8, 12],
            lengths: [16, 17, 18, 19],
            code: {
              name: "CVP2",
              size: 3
            }
          },
          hiper: {
            niceType: "Hiper",
            type: "hiper",
            patterns: [637095, 63737423, 63743358, 637568, 637599, 637609, 637612],
            gaps: [4, 8, 12],
            lengths: [16],
            code: {
              name: "CVC",
              size: 3
            }
          },
          hipercard: {
            niceType: "Hipercard",
            type: "hipercard",
            patterns: [606282],
            gaps: [4, 8, 12],
            lengths: [16],
            code: {
              name: "CVC",
              size: 3
            }
          }
        };
        module2.exports = cardTypes;
      }, {}], 47: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.clone = void 0;
        function clone2(originalObject) {
          if (!originalObject) {
            return null;
          }
          return JSON.parse(JSON.stringify(originalObject));
        }
        exports2.clone = clone2;
      }, {}], 48: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.findBestMatch = void 0;
        function hasEnoughResultsToDetermineBestMatch(results) {
          var numberOfResultsWithMaxStrengthProperty = results.filter(function(result) {
            return result.matchStrength;
          }).length;
          return numberOfResultsWithMaxStrengthProperty > 0 && numberOfResultsWithMaxStrengthProperty === results.length;
        }
        function findBestMatch(results) {
          if (!hasEnoughResultsToDetermineBestMatch(results)) {
            return null;
          }
          return results.reduce(function(bestMatch, result) {
            if (!bestMatch) {
              return result;
            }
            if (Number(bestMatch.matchStrength) < Number(result.matchStrength)) {
              return result;
            }
            return bestMatch;
          });
        }
        exports2.findBestMatch = findBestMatch;
      }, {}], 49: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isValidInputType = void 0;
        function isValidInputType(cardNumber) {
          return typeof cardNumber === "string" || cardNumber instanceof String;
        }
        exports2.isValidInputType = isValidInputType;
      }, {}], 50: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.matches = void 0;
        function matchesRange(cardNumber, min, max) {
          var maxLengthToCheck = String(min).length;
          var substr = cardNumber.substr(0, maxLengthToCheck);
          var integerRepresentationOfCardNumber = parseInt(substr, 10);
          min = parseInt(String(min).substr(0, substr.length), 10);
          max = parseInt(String(max).substr(0, substr.length), 10);
          return integerRepresentationOfCardNumber >= min && integerRepresentationOfCardNumber <= max;
        }
        function matchesPattern(cardNumber, pattern) {
          pattern = String(pattern);
          return pattern.substring(0, cardNumber.length) === cardNumber.substring(0, pattern.length);
        }
        function matches(cardNumber, pattern) {
          if (Array.isArray(pattern)) {
            return matchesRange(cardNumber, pattern[0], pattern[1]);
          }
          return matchesPattern(cardNumber, pattern);
        }
        exports2.matches = matches;
      }, {}], 51: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Framebus = void 0;
        var lib_1 = _dereq_("./lib");
        var DefaultPromise = typeof window !== "undefined" && window.Promise;
        var Framebus = function() {
          function Framebus2(options) {
            if (options === void 0) {
              options = {};
            }
            this.origin = options.origin || "*";
            this.channel = options.channel || "";
            this.verifyDomain = options.verifyDomain;
            this.targetFrames = options.targetFrames || [];
            this.limitBroadcastToFramesArray = Boolean(options.targetFrames);
            this.isDestroyed = false;
            this.listeners = [];
            this.hasAdditionalChecksForOnListeners = Boolean(this.verifyDomain || this.limitBroadcastToFramesArray);
          }
          Framebus2.setPromise = function(PromiseGlobal) {
            Framebus2.Promise = PromiseGlobal;
          };
          Framebus2.target = function(options) {
            return new Framebus2(options);
          };
          Framebus2.prototype.addTargetFrame = function(frame) {
            if (!this.limitBroadcastToFramesArray) {
              return;
            }
            this.targetFrames.push(frame);
          };
          Framebus2.prototype.include = function(childWindow) {
            if (childWindow == null) {
              return false;
            }
            if (childWindow.Window == null) {
              return false;
            }
            if (childWindow.constructor !== childWindow.Window) {
              return false;
            }
            lib_1.childWindows.push(childWindow);
            return true;
          };
          Framebus2.prototype.target = function(options) {
            return Framebus2.target(options);
          };
          Framebus2.prototype.emit = function(eventName, data2, reply) {
            if (this.isDestroyed) {
              return false;
            }
            var origin = this.origin;
            eventName = this.namespaceEvent(eventName);
            if ((0, lib_1.isntString)(eventName)) {
              return false;
            }
            if ((0, lib_1.isntString)(origin)) {
              return false;
            }
            if (typeof data2 === "function") {
              reply = data2;
              data2 = void 0;
            }
            var payload = (0, lib_1.packagePayload)(eventName, origin, data2, reply);
            if (!payload) {
              return false;
            }
            if (this.limitBroadcastToFramesArray) {
              this.targetFramesAsWindows().forEach(function(frame) {
                (0, lib_1.sendMessage)(frame, payload, origin);
              });
            } else {
              (0, lib_1.broadcast)(payload, {
                origin,
                frame: window.top || window.self
              });
            }
            return true;
          };
          Framebus2.prototype.emitAsPromise = function(eventName, data2) {
            var _this = this;
            return new Framebus2.Promise(function(resolve2, reject) {
              var didAttachListener = _this.emit(eventName, data2, function(payload) {
                resolve2(payload);
              });
              if (!didAttachListener) {
                reject(new Error('Listener not added for "'.concat(eventName, '"')));
              }
            });
          };
          Framebus2.prototype.on = function(eventName, originalHandler) {
            if (this.isDestroyed) {
              return false;
            }
            var self2 = this;
            var origin = this.origin;
            var handler = originalHandler;
            eventName = this.namespaceEvent(eventName);
            if ((0, lib_1.subscriptionArgsInvalid)(eventName, handler, origin)) {
              return false;
            }
            if (this.hasAdditionalChecksForOnListeners) {
              handler = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                if (!self2.passesVerifyDomainCheck(this && this.origin)) {
                  return;
                }
                if (!self2.hasMatchingTargetFrame(this && this.source)) {
                  return;
                }
                originalHandler.apply(void 0, args);
              };
            }
            this.listeners.push({
              eventName,
              handler,
              originalHandler
            });
            lib_1.subscribers[origin] = lib_1.subscribers[origin] || {};
            lib_1.subscribers[origin][eventName] = lib_1.subscribers[origin][eventName] || [];
            lib_1.subscribers[origin][eventName].push(handler);
            return true;
          };
          Framebus2.prototype.off = function(eventName, originalHandler) {
            var handler = originalHandler;
            if (this.isDestroyed) {
              return false;
            }
            if (this.verifyDomain) {
              for (var i = 0; i < this.listeners.length; i++) {
                var listener = this.listeners[i];
                if (listener.originalHandler === originalHandler) {
                  handler = listener.handler;
                }
              }
            }
            eventName = this.namespaceEvent(eventName);
            var origin = this.origin;
            if ((0, lib_1.subscriptionArgsInvalid)(eventName, handler, origin)) {
              return false;
            }
            var subscriberList = lib_1.subscribers[origin] && lib_1.subscribers[origin][eventName];
            if (!subscriberList) {
              return false;
            }
            for (var i = 0; i < subscriberList.length; i++) {
              if (subscriberList[i] === handler) {
                subscriberList.splice(i, 1);
                return true;
              }
            }
            return false;
          };
          Framebus2.prototype.teardown = function() {
            if (this.isDestroyed) {
              return;
            }
            this.isDestroyed = true;
            for (var i = 0; i < this.listeners.length; i++) {
              var listener = this.listeners[i];
              this.off(listener.eventName, listener.handler);
            }
            this.listeners.length = 0;
          };
          Framebus2.prototype.passesVerifyDomainCheck = function(origin) {
            if (!this.verifyDomain) {
              return true;
            }
            return this.checkOrigin(origin);
          };
          Framebus2.prototype.targetFramesAsWindows = function() {
            if (!this.limitBroadcastToFramesArray) {
              return [];
            }
            return this.targetFrames.map(function(frame) {
              if (frame instanceof HTMLIFrameElement) {
                return frame.contentWindow;
              }
              return frame;
            }).filter(function(win) {
              return win;
            });
          };
          Framebus2.prototype.hasMatchingTargetFrame = function(source2) {
            if (!this.limitBroadcastToFramesArray) {
              return true;
            }
            var matchingFrame = this.targetFramesAsWindows().find(function(frame) {
              return frame === source2;
            });
            return Boolean(matchingFrame);
          };
          Framebus2.prototype.checkOrigin = function(postMessageOrigin) {
            var merchantHost;
            var a = document.createElement("a");
            a.href = location.href;
            if (a.protocol === "https:") {
              merchantHost = a.host.replace(/:443$/, "");
            } else if (a.protocol === "http:") {
              merchantHost = a.host.replace(/:80$/, "");
            } else {
              merchantHost = a.host;
            }
            var merchantOrigin = a.protocol + "//" + merchantHost;
            if (merchantOrigin === postMessageOrigin) {
              return true;
            }
            if (this.verifyDomain) {
              return this.verifyDomain(postMessageOrigin);
            }
            return true;
          };
          Framebus2.prototype.namespaceEvent = function(eventName) {
            if (!this.channel) {
              return eventName;
            }
            return "".concat(this.channel, ":").concat(eventName);
          };
          Framebus2.Promise = DefaultPromise;
          return Framebus2;
        }();
        exports2.Framebus = Framebus;
      }, { "./lib": 59 }], 52: [function(_dereq_, module2, exports2) {
        var lib_1 = _dereq_("./lib");
        var framebus_1 = _dereq_("./framebus");
        (0, lib_1.attach)();
        module2.exports = framebus_1.Framebus;
      }, { "./framebus": 51, "./lib": 59 }], 53: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.detach = exports2.attach = void 0;
        var _1 = _dereq_("./");
        var isAttached = false;
        function attach() {
          if (isAttached || typeof window === "undefined") {
            return;
          }
          isAttached = true;
          window.addEventListener("message", _1.onMessage, false);
        }
        exports2.attach = attach;
        function detach() {
          isAttached = false;
          window.removeEventListener("message", _1.onMessage, false);
        }
        exports2.detach = detach;
      }, { "./": 59 }], 54: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.broadcastToChildWindows = void 0;
        var _1 = _dereq_("./");
        function broadcastToChildWindows(payload, origin, source2) {
          for (var i = _1.childWindows.length - 1; i >= 0; i--) {
            var childWindow = _1.childWindows[i];
            if (childWindow.closed) {
              _1.childWindows.splice(i, 1);
            } else if (source2 !== childWindow) {
              (0, _1.broadcast)(payload, {
                origin,
                frame: childWindow.top
              });
            }
          }
        }
        exports2.broadcastToChildWindows = broadcastToChildWindows;
      }, { "./": 59 }], 55: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.broadcast = void 0;
        var _1 = _dereq_("./");
        function broadcast(payload, options) {
          var i = 0;
          var frameToBroadcastTo;
          var origin = options.origin, frame = options.frame;
          try {
            frame.postMessage(payload, origin);
            if ((0, _1.hasOpener)(frame) && frame.opener.top !== window.top) {
              broadcast(payload, {
                origin,
                frame: frame.opener.top
              });
            }
            while (frameToBroadcastTo = frame.frames[i]) {
              broadcast(payload, {
                origin,
                frame: frameToBroadcastTo
              });
              i++;
            }
          } catch (_) {
          }
        }
        exports2.broadcast = broadcast;
      }, { "./": 59 }], 56: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.subscribers = exports2.childWindows = exports2.prefix = void 0;
        exports2.prefix = "/*framebus*/";
        exports2.childWindows = [];
        exports2.subscribers = {};
      }, {}], 57: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.dispatch = void 0;
        var _1 = _dereq_("./");
        function dispatch(origin, event, data2, reply, e) {
          if (!_1.subscribers[origin]) {
            return;
          }
          if (!_1.subscribers[origin][event]) {
            return;
          }
          var args = [];
          if (data2) {
            args.push(data2);
          }
          if (reply) {
            args.push(reply);
          }
          for (var i = 0; i < _1.subscribers[origin][event].length; i++) {
            _1.subscribers[origin][event][i].apply(e, args);
          }
        }
        exports2.dispatch = dispatch;
      }, { "./": 59 }], 58: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.hasOpener = void 0;
        function hasOpener(frame) {
          if (frame.top !== frame) {
            return false;
          }
          if (frame.opener == null) {
            return false;
          }
          if (frame.opener === frame) {
            return false;
          }
          if (frame.opener.closed === true) {
            return false;
          }
          return true;
        }
        exports2.hasOpener = hasOpener;
      }, {}], 59: [function(_dereq_, module2, exports2) {
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        });
        var __exportStar = this && this.__exportStar || function(m, exports3) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
              __createBinding(exports3, m, p2);
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        __exportStar(_dereq_("./attach"), exports2);
        __exportStar(_dereq_("./broadcast-to-child-windows"), exports2);
        __exportStar(_dereq_("./broadcast"), exports2);
        __exportStar(_dereq_("./constants"), exports2);
        __exportStar(_dereq_("./dispatch"), exports2);
        __exportStar(_dereq_("./has-opener"), exports2);
        __exportStar(_dereq_("./is-not-string"), exports2);
        __exportStar(_dereq_("./message"), exports2);
        __exportStar(_dereq_("./package-payload"), exports2);
        __exportStar(_dereq_("./send-message"), exports2);
        __exportStar(_dereq_("./subscribe-replier"), exports2);
        __exportStar(_dereq_("./subscription-args-invalid"), exports2);
        __exportStar(_dereq_("./types"), exports2);
        __exportStar(_dereq_("./unpack-payload"), exports2);
      }, { "./attach": 53, "./broadcast": 55, "./broadcast-to-child-windows": 54, "./constants": 56, "./dispatch": 57, "./has-opener": 58, "./is-not-string": 60, "./message": 61, "./package-payload": 62, "./send-message": 63, "./subscribe-replier": 64, "./subscription-args-invalid": 65, "./types": 66, "./unpack-payload": 67 }], 60: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isntString = void 0;
        function isntString(str) {
          return typeof str !== "string";
        }
        exports2.isntString = isntString;
      }, {}], 61: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.onMessage = void 0;
        var _1 = _dereq_("./");
        function onMessage(e) {
          if ((0, _1.isntString)(e.data)) {
            return;
          }
          var payload = (0, _1.unpackPayload)(e);
          if (!payload) {
            return;
          }
          var data2 = payload.eventData;
          var reply = payload.reply;
          (0, _1.dispatch)("*", payload.event, data2, reply, e);
          (0, _1.dispatch)(e.origin, payload.event, data2, reply, e);
          (0, _1.broadcastToChildWindows)(e.data, payload.origin, e.source);
        }
        exports2.onMessage = onMessage;
      }, { "./": 59 }], 62: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.packagePayload = void 0;
        var _1 = _dereq_("./");
        function packagePayload(event, origin, data2, reply) {
          var packaged;
          var payload = {
            event,
            origin
          };
          if (typeof reply === "function") {
            payload.reply = (0, _1.subscribeReplier)(reply, origin);
          }
          payload.eventData = data2;
          try {
            packaged = _1.prefix + JSON.stringify(payload);
          } catch (e) {
            throw new Error("Could not stringify event: ".concat(e.message));
          }
          return packaged;
        }
        exports2.packagePayload = packagePayload;
      }, { "./": 59 }], 63: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.sendMessage = void 0;
        function sendMessage(frame, payload, origin) {
          try {
            frame.postMessage(payload, origin);
          } catch (error) {
          }
        }
        exports2.sendMessage = sendMessage;
      }, {}], 64: [function(_dereq_, module2, exports2) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.subscribeReplier = void 0;
        var framebus_1 = _dereq_("../framebus");
        var uuid_1 = __importDefault(_dereq_("@braintree/uuid"));
        function subscribeReplier(fn, origin) {
          var uuid = (0, uuid_1.default)();
          function replier(data2, replyOriginHandler) {
            fn(data2, replyOriginHandler);
            framebus_1.Framebus.target({
              origin
            }).off(uuid, replier);
          }
          framebus_1.Framebus.target({
            origin
          }).on(uuid, replier);
          return uuid;
        }
        exports2.subscribeReplier = subscribeReplier;
      }, { "../framebus": 51, "@braintree/uuid": 39 }], 65: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.subscriptionArgsInvalid = void 0;
        var _1 = _dereq_("./");
        function subscriptionArgsInvalid(event, fn, origin) {
          if ((0, _1.isntString)(event)) {
            return true;
          }
          if (typeof fn !== "function") {
            return true;
          }
          return (0, _1.isntString)(origin);
        }
        exports2.subscriptionArgsInvalid = subscriptionArgsInvalid;
      }, { "./": 59 }], 66: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
      }, {}], 67: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.unpackPayload = void 0;
        var _1 = _dereq_("./");
        function unpackPayload(e) {
          var payload;
          if (e.data.slice(0, _1.prefix.length) !== _1.prefix) {
            return false;
          }
          try {
            payload = JSON.parse(e.data.slice(_1.prefix.length));
          } catch (err) {
            return false;
          }
          if (payload.reply) {
            var replyOrigin_1 = e.origin;
            var replySource_1 = e.source;
            var replyEvent_1 = payload.reply;
            payload.reply = function reply(replyData) {
              if (!replySource_1) {
                return;
              }
              var replyPayload = (0, _1.packagePayload)(replyEvent_1, replyOrigin_1, replyData);
              if (!replyPayload) {
                return;
              }
              replySource_1.postMessage(replyPayload, replyOrigin_1);
            };
          }
          return payload;
        }
        exports2.unpackPayload = unpackPayload;
      }, { "./": 59 }], 68: [function(_dereq_, module2, exports2) {
        function finallyConstructor(callback) {
          var constructor = this.constructor;
          return this.then(function(value) {
            return constructor.resolve(callback()).then(function() {
              return value;
            });
          }, function(reason) {
            return constructor.resolve(callback()).then(function() {
              return constructor.reject(reason);
            });
          });
        }
        function allSettled(arr) {
          var P = this;
          return new P(function(resolve3, reject2) {
            if (!(arr && typeof arr.length !== "undefined")) {
              return reject2(new TypeError(typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
            }
            var args = Array.prototype.slice.call(arr);
            if (args.length === 0)
              return resolve3([]);
            var remaining = args.length;
            function res(i2, val) {
              if (val && (typeof val === "object" || typeof val === "function")) {
                var then = val.then;
                if (typeof then === "function") {
                  then.call(val, function(val2) {
                    res(i2, val2);
                  }, function(e) {
                    args[i2] = { status: "rejected", reason: e };
                    if (--remaining === 0) {
                      resolve3(args);
                    }
                  });
                  return;
                }
              }
              args[i2] = { status: "fulfilled", value: val };
              if (--remaining === 0) {
                resolve3(args);
              }
            }
            for (var i = 0; i < args.length; i++) {
              res(i, args[i]);
            }
          });
        }
        var setTimeoutFunc = setTimeout;
        function isArray2(x) {
          return Boolean(x && typeof x.length !== "undefined");
        }
        function noop2() {
        }
        function bind3(fn, thisArg) {
          return function() {
            fn.apply(thisArg, arguments);
          };
        }
        function Promise2(fn) {
          if (!(this instanceof Promise2))
            throw new TypeError("Promises must be constructed via new");
          if (typeof fn !== "function")
            throw new TypeError("not a function");
          this._state = 0;
          this._handled = false;
          this._value = void 0;
          this._deferreds = [];
          doResolve(fn, this);
        }
        function handle(self2, deferred) {
          while (self2._state === 3) {
            self2 = self2._value;
          }
          if (self2._state === 0) {
            self2._deferreds.push(deferred);
            return;
          }
          self2._handled = true;
          Promise2._immediateFn(function() {
            var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
            if (cb === null) {
              (self2._state === 1 ? resolve2 : reject)(deferred.promise, self2._value);
              return;
            }
            var ret;
            try {
              ret = cb(self2._value);
            } catch (e) {
              reject(deferred.promise, e);
              return;
            }
            resolve2(deferred.promise, ret);
          });
        }
        function resolve2(self2, newValue) {
          try {
            if (newValue === self2)
              throw new TypeError("A promise cannot be resolved with itself.");
            if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
              var then = newValue.then;
              if (newValue instanceof Promise2) {
                self2._state = 3;
                self2._value = newValue;
                finale(self2);
                return;
              } else if (typeof then === "function") {
                doResolve(bind3(then, newValue), self2);
                return;
              }
            }
            self2._state = 1;
            self2._value = newValue;
            finale(self2);
          } catch (e) {
            reject(self2, e);
          }
        }
        function reject(self2, newValue) {
          self2._state = 2;
          self2._value = newValue;
          finale(self2);
        }
        function finale(self2) {
          if (self2._state === 2 && self2._deferreds.length === 0) {
            Promise2._immediateFn(function() {
              if (!self2._handled) {
                Promise2._unhandledRejectionFn(self2._value);
              }
            });
          }
          for (var i = 0, len = self2._deferreds.length; i < len; i++) {
            handle(self2, self2._deferreds[i]);
          }
          self2._deferreds = null;
        }
        function Handler(onFulfilled, onRejected, promise) {
          this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
          this.onRejected = typeof onRejected === "function" ? onRejected : null;
          this.promise = promise;
        }
        function doResolve(fn, self2) {
          var done = false;
          try {
            fn(function(value) {
              if (done)
                return;
              done = true;
              resolve2(self2, value);
            }, function(reason) {
              if (done)
                return;
              done = true;
              reject(self2, reason);
            });
          } catch (ex) {
            if (done)
              return;
            done = true;
            reject(self2, ex);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          var prom = new this.constructor(noop2);
          handle(this, new Handler(onFulfilled, onRejected, prom));
          return prom;
        };
        Promise2.prototype["finally"] = finallyConstructor;
        Promise2.all = function(arr) {
          return new Promise2(function(resolve3, reject2) {
            if (!isArray2(arr)) {
              return reject2(new TypeError("Promise.all accepts an array"));
            }
            var args = Array.prototype.slice.call(arr);
            if (args.length === 0)
              return resolve3([]);
            var remaining = args.length;
            function res(i2, val) {
              try {
                if (val && (typeof val === "object" || typeof val === "function")) {
                  var then = val.then;
                  if (typeof then === "function") {
                    then.call(val, function(val2) {
                      res(i2, val2);
                    }, reject2);
                    return;
                  }
                }
                args[i2] = val;
                if (--remaining === 0) {
                  resolve3(args);
                }
              } catch (ex) {
                reject2(ex);
              }
            }
            for (var i = 0; i < args.length; i++) {
              res(i, args[i]);
            }
          });
        };
        Promise2.allSettled = allSettled;
        Promise2.resolve = function(value) {
          if (value && typeof value === "object" && value.constructor === Promise2) {
            return value;
          }
          return new Promise2(function(resolve3) {
            resolve3(value);
          });
        };
        Promise2.reject = function(value) {
          return new Promise2(function(resolve3, reject2) {
            reject2(value);
          });
        };
        Promise2.race = function(arr) {
          return new Promise2(function(resolve3, reject2) {
            if (!isArray2(arr)) {
              return reject2(new TypeError("Promise.race accepts an array"));
            }
            for (var i = 0, len = arr.length; i < len; i++) {
              Promise2.resolve(arr[i]).then(resolve3, reject2);
            }
          });
        };
        Promise2._immediateFn = typeof setImmediate === "function" && function(fn) {
          setImmediate(fn);
        } || function(fn) {
          setTimeoutFunc(fn, 0);
        };
        Promise2._unhandledRejectionFn = function _unhandledRejectionFn(err) {
          if (typeof console !== "undefined" && console) {
            console.warn("Possible Unhandled Promise Rejection:", err);
          }
        };
        module2.exports = Promise2;
      }, {}], 69: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isIos = exports2.isIE9 = exports2.isSamsungBrowser = exports2.isAndroidChrome = exports2.isKitKatWebview = void 0;
        var UA = typeof window !== "undefined" && window.navigator && window.navigator.userAgent;
        var isAndroid = _dereq_("@braintree/browser-detection/is-android");
        var isChromeOs = _dereq_("@braintree/browser-detection/is-chrome-os");
        var isChrome = _dereq_("@braintree/browser-detection/is-chrome");
        var isIos = _dereq_("@braintree/browser-detection/is-ios");
        exports2.isIos = isIos;
        var isIE9 = _dereq_("@braintree/browser-detection/is-ie9");
        exports2.isIE9 = isIE9;
        var KITKAT_WEBVIEW_REGEX = /Version\/\d\.\d* Chrome\/\d*\.0\.0\.0/;
        function isOldSamsungBrowserOrSamsungWebview(ua) {
          return !isChrome(ua) && ua.indexOf("Samsung") > -1;
        }
        function isKitKatWebview(ua) {
          if (ua === void 0) {
            ua = UA;
          }
          return isAndroid(ua) && KITKAT_WEBVIEW_REGEX.test(ua);
        }
        exports2.isKitKatWebview = isKitKatWebview;
        function isAndroidChrome(ua) {
          if (ua === void 0) {
            ua = UA;
          }
          return (isAndroid(ua) || isChromeOs(ua)) && isChrome(ua);
        }
        exports2.isAndroidChrome = isAndroidChrome;
        function isSamsungBrowser(ua) {
          if (ua === void 0) {
            ua = UA;
          }
          return /SamsungBrowser/.test(ua) || isOldSamsungBrowserOrSamsungWebview(ua);
        }
        exports2.isSamsungBrowser = isSamsungBrowser;
      }, { "@braintree/browser-detection/is-android": 22, "@braintree/browser-detection/is-chrome": 24, "@braintree/browser-detection/is-chrome-os": 23, "@braintree/browser-detection/is-ie9": 26, "@braintree/browser-detection/is-ios": 30 }], 70: [function(_dereq_, module2, exports2) {
        var device_1 = _dereq_("./lib/device");
        module2.exports = function supportsInputFormatting() {
          return !(0, device_1.isSamsungBrowser)();
        };
      }, { "./lib/device": 69 }], 71: [function(_dereq_, module2, exports2) {
        module2.exports = _dereq_("./dist/supports-input-formatting");
      }, { "./dist/supports-input-formatting": 70 }], 72: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        var errors = _dereq_("./errors");
        var assign2 = _dereq_("../lib/assign").assign;
        var methods = _dereq_("../lib/methods");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function AmericanExpress(options) {
          this._client = options.client;
        }
        AmericanExpress.prototype.getRewardsBalance = function(options) {
          var nonce = options.nonce;
          var data2;
          if (!nonce) {
            return Promise.reject(new BraintreeError({
              type: errors.AMEX_NONCE_REQUIRED.type,
              code: errors.AMEX_NONCE_REQUIRED.code,
              message: "getRewardsBalance must be called with a nonce."
            }));
          }
          data2 = assign2({
            _meta: { source: "american-express" },
            paymentMethodNonce: nonce
          }, options);
          delete data2.nonce;
          return this._client.request({
            method: "get",
            endpoint: "payment_methods/amex_rewards_balance",
            data: data2
          }).catch(function(err) {
            return Promise.reject(new BraintreeError({
              type: errors.AMEX_NETWORK_ERROR.type,
              code: errors.AMEX_NETWORK_ERROR.code,
              message: "A network error occurred when getting the American Express rewards balance.",
              details: {
                originalError: err
              }
            }));
          });
        };
        AmericanExpress.prototype.getExpressCheckoutProfile = function(options) {
          if (!options.nonce) {
            return Promise.reject(new BraintreeError({
              type: errors.AMEX_NONCE_REQUIRED.type,
              code: errors.AMEX_NONCE_REQUIRED.code,
              message: "getExpressCheckoutProfile must be called with a nonce."
            }));
          }
          return this._client.request({
            method: "get",
            endpoint: "payment_methods/amex_express_checkout_cards/" + options.nonce,
            data: {
              _meta: { source: "american-express" },
              paymentMethodNonce: options.nonce
            }
          }).catch(function(err) {
            return Promise.reject(new BraintreeError({
              type: errors.AMEX_NETWORK_ERROR.type,
              code: errors.AMEX_NETWORK_ERROR.code,
              message: "A network error occurred when getting the American Express Checkout nonce profile.",
              details: {
                originalError: err
              }
            }));
          });
        };
        AmericanExpress.prototype.teardown = function() {
          convertMethodsToError(this, methods(AmericanExpress.prototype));
          return Promise.resolve();
        };
        module2.exports = wrapPromise.wrapPrototype(AmericanExpress);
      }, { "../lib/assign": 121, "../lib/braintree-error": 124, "../lib/convert-methods-to-error": 127, "../lib/methods": 155, "./errors": 73, "@braintree/wrap-promise": 43 }], 73: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          AMEX_NONCE_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "AMEX_NONCE_REQUIRED"
          },
          AMEX_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "AMEX_NETWORK_ERROR"
          }
        };
      }, { "../lib/braintree-error": 124 }], 74: [function(_dereq_, module2, exports2) {
        var AmericanExpress = _dereq_("./american-express");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "American Express";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            options.client = client;
            return new AmericanExpress(options);
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./american-express": 72, "@braintree/wrap-promise": 43 }], 75: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        var analytics = _dereq_("../lib/analytics");
        var errors = _dereq_("./errors");
        var methods = _dereq_("../lib/methods");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function ApplePay(options) {
          this._instantiatedWithClient = Boolean(!options.useDeferredClient);
          this._client = options.client;
          this._createPromise = options.createPromise;
          if (this._client) {
            this._setMerchantIdentifier();
          }
        }
        ApplePay.prototype._waitForClient = function() {
          if (this._client) {
            return Promise.resolve();
          }
          return this._createPromise.then(function(client) {
            this._client = client;
            this._setMerchantIdentifier();
          }.bind(this));
        };
        ApplePay.prototype._setMerchantIdentifier = function() {
          var applePayConfig = this._client.getConfiguration().gatewayConfiguration.applePayWeb;
          if (!applePayConfig) {
            return;
          }
          Object.defineProperty(this, "merchantIdentifier", {
            value: applePayConfig.merchantIdentifier,
            configurable: false,
            writable: false
          });
        };
        ApplePay.prototype.createPaymentRequest = function(paymentRequest) {
          if (this._instantiatedWithClient) {
            return this._createPaymentRequestSynchronously(paymentRequest);
          }
          return this._waitForClient().then(function() {
            return this._createPaymentRequestSynchronously(paymentRequest);
          }.bind(this));
        };
        ApplePay.prototype._createPaymentRequestSynchronously = function(paymentRequest) {
          var applePay = this._client.getConfiguration().gatewayConfiguration.applePayWeb;
          var defaults2 = {
            countryCode: applePay.countryCode,
            currencyCode: applePay.currencyCode,
            merchantCapabilities: applePay.merchantCapabilities || ["supports3DS"],
            supportedNetworks: applePay.supportedNetworks.map(function(network) {
              return network === "mastercard" ? "masterCard" : network;
            })
          };
          return Object.assign({}, defaults2, paymentRequest);
        };
        ApplePay.prototype.performValidation = function(options) {
          var self2 = this;
          if (!options || !options.validationURL) {
            return Promise.reject(new BraintreeError(errors.APPLE_PAY_VALIDATION_URL_REQUIRED));
          }
          return this._waitForClient().then(function() {
            var applePayWebSession = {
              validationUrl: options.validationURL,
              domainName: options.domainName || window.location.hostname,
              merchantIdentifier: options.merchantIdentifier || self2.merchantIdentifier
            };
            if (options.displayName != null) {
              applePayWebSession.displayName = options.displayName;
            }
            return self2._client.request({
              method: "post",
              endpoint: "apple_pay_web/sessions",
              data: {
                _meta: { source: "apple-pay" },
                applePayWebSession
              }
            });
          }).then(function(response) {
            analytics.sendEvent(self2._client, "applepay.performValidation.succeeded");
            return Promise.resolve(response);
          }).catch(function(err) {
            analytics.sendEvent(self2._client, "applepay.performValidation.failed");
            if (err.code === "CLIENT_REQUEST_ERROR") {
              return Promise.reject(new BraintreeError({
                type: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.type,
                code: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.code,
                message: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.message,
                details: {
                  originalError: err.details.originalError
                }
              }));
            }
            return Promise.reject(new BraintreeError({
              type: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.type,
              code: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.code,
              message: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.message,
              details: {
                originalError: err
              }
            }));
          });
        };
        ApplePay.prototype.tokenize = function(options) {
          var self2 = this;
          if (!options.token) {
            return Promise.reject(new BraintreeError(errors.APPLE_PAY_PAYMENT_TOKEN_REQUIRED));
          }
          return this._waitForClient().then(function() {
            return self2._client.request({
              method: "post",
              endpoint: "payment_methods/apple_payment_tokens",
              data: {
                _meta: {
                  source: "apple-pay"
                },
                applePaymentToken: Object.assign({}, options.token, {
                  paymentData: btoa(JSON.stringify(options.token.paymentData))
                })
              }
            });
          }).then(function(response) {
            analytics.sendEvent(self2._client, "applepay.tokenize.succeeded");
            return Promise.resolve(response.applePayCards[0]);
          }).catch(function(err) {
            analytics.sendEvent(self2._client, "applepay.tokenize.failed");
            return Promise.reject(new BraintreeError({
              type: errors.APPLE_PAY_TOKENIZATION.type,
              code: errors.APPLE_PAY_TOKENIZATION.code,
              message: errors.APPLE_PAY_TOKENIZATION.message,
              details: {
                originalError: err
              }
            }));
          });
        };
        ApplePay.prototype.teardown = function() {
          convertMethodsToError(this, methods(ApplePay.prototype));
          return Promise.resolve();
        };
        module2.exports = wrapPromise.wrapPrototype(ApplePay);
      }, { "../lib/analytics": 119, "../lib/braintree-error": 124, "../lib/convert-methods-to-error": 127, "../lib/methods": 155, "./errors": 76, "@braintree/wrap-promise": 43 }], 76: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          APPLE_PAY_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "APPLE_PAY_NOT_ENABLED",
            message: "Apple Pay is not enabled for this merchant."
          },
          APPLE_PAY_VALIDATION_URL_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "APPLE_PAY_VALIDATION_URL_REQUIRED",
            message: "performValidation must be called with a validationURL."
          },
          APPLE_PAY_MERCHANT_VALIDATION_NETWORK: {
            type: BraintreeError.types.NETWORK,
            code: "APPLE_PAY_MERCHANT_VALIDATION_NETWORK",
            message: "A network error occurred when validating the Apple Pay merchant."
          },
          APPLE_PAY_MERCHANT_VALIDATION_FAILED: {
            type: BraintreeError.types.MERCHANT,
            code: "APPLE_PAY_MERCHANT_VALIDATION_FAILED",
            message: "Make sure you have registered your domain name in the Braintree Control Panel."
          },
          APPLE_PAY_PAYMENT_TOKEN_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "APPLE_PAY_PAYMENT_TOKEN_REQUIRED",
            message: "tokenize must be called with a payment token."
          },
          APPLE_PAY_TOKENIZATION: {
            type: BraintreeError.types.NETWORK,
            code: "APPLE_PAY_TOKENIZATION",
            message: "A network error occurred when processing the Apple Pay payment."
          }
        };
      }, { "../lib/braintree-error": 124 }], 77: [function(_dereq_, module2, exports2) {
        var ApplePay = _dereq_("./apple-pay");
        var analytics = _dereq_("../lib/analytics");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var errors = _dereq_("./errors");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "Apple Pay";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var applePayInstance;
            var createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            }).then(function(client) {
              if (!client.getConfiguration().gatewayConfiguration.applePayWeb) {
                return Promise.reject(new BraintreeError(errors.APPLE_PAY_NOT_ENABLED));
              }
              analytics.sendEvent(client, "applepay.initialized");
              return client;
            });
            options.createPromise = createPromise;
            applePayInstance = new ApplePay(options);
            if (!options.useDeferredClient) {
              return createPromise.then(function(client) {
                applePayInstance._client = client;
                return applePayInstance;
              });
            }
            return applePayInstance;
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 119, "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./apple-pay": 75, "./errors": 76, "@braintree/wrap-promise": 43 }], 78: [function(_dereq_, module2, exports2) {
        var BRAINTREE_VERSION = _dereq_("./constants").BRAINTREE_VERSION;
        var GraphQL = _dereq_("./request/graphql");
        var request3 = _dereq_("./request");
        var isVerifiedDomain = _dereq_("../lib/is-verified-domain");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var convertToBraintreeError = _dereq_("../lib/convert-to-braintree-error");
        var getGatewayConfiguration = _dereq_("./get-configuration").getConfiguration;
        var createAuthorizationData = _dereq_("../lib/create-authorization-data");
        var addMetadata = _dereq_("../lib/add-metadata");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var once = _dereq_("../lib/once");
        var deferred = _dereq_("../lib/deferred");
        var assign2 = _dereq_("../lib/assign").assign;
        var analytics = _dereq_("../lib/analytics");
        var errors = _dereq_("./errors");
        var VERSION2 = _dereq_("../lib/constants").VERSION;
        var GRAPHQL_URLS = _dereq_("../lib/constants").GRAPHQL_URLS;
        var methods = _dereq_("../lib/methods");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var assets = _dereq_("../lib/assets");
        var FRAUDNET_FNCLS = _dereq_("../lib/constants").FRAUDNET_FNCLS;
        var FRAUDNET_SOURCE = _dereq_("../lib/constants").FRAUDNET_SOURCE;
        var FRAUDNET_URL = _dereq_("../lib/constants").FRAUDNET_URL;
        var cachedClients = {};
        function Client(configuration) {
          var configurationJSON, gatewayConfiguration;
          configuration = configuration || {};
          configurationJSON = JSON.stringify(configuration);
          gatewayConfiguration = configuration.gatewayConfiguration;
          if (!gatewayConfiguration) {
            throw new BraintreeError(errors.CLIENT_MISSING_GATEWAY_CONFIGURATION);
          }
          ["assetsUrl", "clientApiUrl", "configUrl"].forEach(function(property) {
            if (property in gatewayConfiguration && !isVerifiedDomain(gatewayConfiguration[property])) {
              throw new BraintreeError({
                type: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.type,
                code: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.code,
                message: property + " property is on an invalid domain."
              });
            }
          });
          this.getConfiguration = function() {
            return JSON.parse(configurationJSON);
          };
          this._request = request3;
          this._configuration = this.getConfiguration();
          this._clientApiBaseUrl = gatewayConfiguration.clientApiUrl + "/v1/";
          if (gatewayConfiguration.graphQL) {
            if (!isVerifiedDomain(gatewayConfiguration.graphQL.url)) {
              throw new BraintreeError({
                type: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.type,
                code: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.code,
                message: "graphQL.url property is on an invalid domain."
              });
            }
            this._graphQL = new GraphQL({
              graphQL: gatewayConfiguration.graphQL
            });
          }
        }
        Client.initialize = function(options) {
          var clientInstance, authData;
          var promise = cachedClients[options.authorization];
          if (promise) {
            analytics.sendEvent(promise, "custom.client.load.cached");
            return promise;
          }
          try {
            authData = createAuthorizationData(options.authorization);
          } catch (err) {
            return Promise.reject(new BraintreeError(errors.CLIENT_INVALID_AUTHORIZATION));
          }
          promise = getGatewayConfiguration(authData).then(function(configuration) {
            if (options.debug) {
              configuration.isDebug = true;
            }
            configuration.authorization = options.authorization;
            clientInstance = new Client(configuration);
            return clientInstance;
          });
          cachedClients[options.authorization] = promise;
          analytics.sendEvent(promise, "custom.client.load.initialized");
          return promise.then(function(client) {
            analytics.sendEvent(clientInstance, "custom.client.load.succeeded");
            return client;
          }).catch(function(err) {
            delete cachedClients[options.authorization];
            return Promise.reject(err);
          });
        };
        Client.clearCache = function() {
          cachedClients = {};
        };
        Client.prototype._findOrCreateFraudnetJSON = function(clientMetadataId) {
          var el = document.querySelector('script[fncls="' + FRAUDNET_FNCLS + '"]');
          var config, additionalData, authorizationFingerprint, parameters;
          if (!el) {
            el = document.body.appendChild(document.createElement("script"));
            el.type = "application/json";
            el.setAttribute("fncls", FRAUDNET_FNCLS);
          }
          config = this.getConfiguration();
          additionalData = {
            rda_tenant: "bt_card",
            mid: config.gatewayConfiguration.merchantId
          };
          authorizationFingerprint = config.authorizationFingerprint;
          if (authorizationFingerprint) {
            authorizationFingerprint.split("&").forEach(function(pieces) {
              var component = pieces.split("=");
              if (component[0] === "customer_id" && component.length > 1) {
                additionalData.cid = component[1];
              }
            });
          }
          parameters = {
            f: clientMetadataId.substr(0, 32),
            fp: additionalData,
            bu: false,
            s: FRAUDNET_SOURCE
          };
          el.text = JSON.stringify(parameters);
        };
        Client.prototype.request = function(options, callback) {
          var self2 = this;
          var requestPromise = new Promise(function(resolve2, reject) {
            var optionName, api, baseUrl, requestOptions;
            var shouldCollectData = Boolean(options.endpoint === "payment_methods/credit_cards" && self2.getConfiguration().gatewayConfiguration.creditCards.collectDeviceData);
            if (options.api !== "graphQLApi") {
              if (!options.method) {
                optionName = "options.method";
              } else if (!options.endpoint) {
                optionName = "options.endpoint";
              }
            }
            if (optionName) {
              throw new BraintreeError({
                type: errors.CLIENT_OPTION_REQUIRED.type,
                code: errors.CLIENT_OPTION_REQUIRED.code,
                message: optionName + " is required when making a request."
              });
            }
            if ("api" in options) {
              api = options.api;
            } else {
              api = "clientApi";
            }
            requestOptions = {
              method: options.method,
              graphQL: self2._graphQL,
              timeout: options.timeout,
              metadata: self2._configuration.analyticsMetadata
            };
            if (api === "clientApi") {
              baseUrl = self2._clientApiBaseUrl;
              requestOptions.data = addMetadata(self2._configuration, options.data);
            } else if (api === "graphQLApi") {
              baseUrl = GRAPHQL_URLS[self2._configuration.gatewayConfiguration.environment];
              options.endpoint = "";
              requestOptions.method = "post";
              requestOptions.data = assign2({
                clientSdkMetadata: {
                  platform: self2._configuration.analyticsMetadata.platform,
                  source: self2._configuration.analyticsMetadata.source,
                  integration: self2._configuration.analyticsMetadata.integration,
                  sessionId: self2._configuration.analyticsMetadata.sessionId,
                  version: VERSION2
                }
              }, options.data);
              requestOptions.headers = getAuthorizationHeadersForGraphQL(self2._configuration);
            } else {
              throw new BraintreeError({
                type: errors.CLIENT_OPTION_INVALID.type,
                code: errors.CLIENT_OPTION_INVALID.code,
                message: "options.api is invalid."
              });
            }
            requestOptions.url = baseUrl + options.endpoint;
            requestOptions.sendAnalyticsEvent = function(kind) {
              analytics.sendEvent(self2, kind);
            };
            self2._request(requestOptions, function(err, data2, status) {
              var resolvedData, requestError;
              requestError = formatRequestError(status, err);
              if (requestError) {
                reject(requestError);
                return;
              }
              if (api === "graphQLApi" && data2.errors) {
                reject(convertToBraintreeError(data2.errors, {
                  type: errors.CLIENT_GRAPHQL_REQUEST_ERROR.type,
                  code: errors.CLIENT_GRAPHQL_REQUEST_ERROR.code,
                  message: errors.CLIENT_GRAPHQL_REQUEST_ERROR.message
                }));
                return;
              }
              resolvedData = assign2({ _httpStatus: status }, data2);
              if (shouldCollectData && resolvedData.creditCards && resolvedData.creditCards.length > 0) {
                self2._findOrCreateFraudnetJSON(resolvedData.creditCards[0].nonce);
                assets.loadScript({
                  src: FRAUDNET_URL,
                  forceScriptReload: true
                });
              }
              resolve2(resolvedData);
            });
          });
          if (typeof callback === "function") {
            callback = once(deferred(callback));
            requestPromise.then(function(response) {
              callback(null, response, response._httpStatus);
            }).catch(function(err) {
              var status = err && err.details && err.details.httpStatus;
              callback(err, null, status);
            });
            return;
          }
          return requestPromise;
        };
        function formatRequestError(status, err) {
          var requestError;
          if (status === -1) {
            requestError = new BraintreeError(errors.CLIENT_REQUEST_TIMEOUT);
          } else if (status === 401) {
            requestError = new BraintreeError(errors.CLIENT_AUTHORIZATION_INVALID);
          } else if (status === 403) {
            requestError = new BraintreeError(errors.CLIENT_AUTHORIZATION_INSUFFICIENT);
          } else if (status === 429) {
            requestError = new BraintreeError(errors.CLIENT_RATE_LIMITED);
          } else if (status >= 500) {
            requestError = new BraintreeError(errors.CLIENT_GATEWAY_NETWORK);
          } else if (status < 200 || status >= 400) {
            requestError = convertToBraintreeError(err, {
              type: errors.CLIENT_REQUEST_ERROR.type,
              code: errors.CLIENT_REQUEST_ERROR.code,
              message: errors.CLIENT_REQUEST_ERROR.message
            });
          }
          if (requestError) {
            requestError.details = requestError.details || {};
            requestError.details.httpStatus = status;
            return requestError;
          }
        }
        Client.prototype.toJSON = function() {
          return this.getConfiguration();
        };
        Client.prototype.getVersion = function() {
          return VERSION2;
        };
        Client.prototype.teardown = wrapPromise(function() {
          var self2 = this;
          delete cachedClients[self2.getConfiguration().authorization];
          convertMethodsToError(self2, methods(Client.prototype));
          return Promise.resolve();
        });
        function getAuthorizationHeadersForGraphQL(configuration) {
          var token = configuration.authorizationFingerprint || configuration.authorization;
          return {
            Authorization: "Bearer " + token,
            "Braintree-Version": BRAINTREE_VERSION
          };
        }
        module2.exports = Client;
      }, { "../lib/add-metadata": 118, "../lib/analytics": 119, "../lib/assets": 120, "../lib/assign": 121, "../lib/braintree-error": 124, "../lib/constants": 126, "../lib/convert-methods-to-error": 127, "../lib/convert-to-braintree-error": 128, "../lib/create-authorization-data": 130, "../lib/deferred": 132, "../lib/is-verified-domain": 153, "../lib/methods": 155, "../lib/once": 156, "./constants": 79, "./errors": 80, "./get-configuration": 81, "./request": 92, "./request/graphql": 90, "@braintree/wrap-promise": 43 }], 79: [function(_dereq_, module2, exports2) {
        module2.exports = {
          BRAINTREE_VERSION: "2018-05-10"
        };
      }, {}], 80: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN"
          },
          CLIENT_OPTION_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_OPTION_REQUIRED"
          },
          CLIENT_OPTION_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_OPTION_INVALID"
          },
          CLIENT_MISSING_GATEWAY_CONFIGURATION: {
            type: BraintreeError.types.INTERNAL,
            code: "CLIENT_MISSING_GATEWAY_CONFIGURATION",
            message: "Missing gatewayConfiguration."
          },
          CLIENT_INVALID_AUTHORIZATION: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_INVALID_AUTHORIZATION",
            message: "Authorization is invalid. Make sure your client token or tokenization key is valid."
          },
          CLIENT_GATEWAY_NETWORK: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_GATEWAY_NETWORK",
            message: "Cannot contact the gateway at this time."
          },
          CLIENT_REQUEST_TIMEOUT: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_REQUEST_TIMEOUT",
            message: "Request timed out waiting for a reply."
          },
          CLIENT_REQUEST_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_REQUEST_ERROR",
            message: "There was a problem with your request."
          },
          CLIENT_GRAPHQL_REQUEST_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_GRAPHQL_REQUEST_ERROR",
            message: "There was a problem with your request."
          },
          CLIENT_RATE_LIMITED: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_RATE_LIMITED",
            message: "You are being rate-limited; please try again in a few minutes."
          },
          CLIENT_AUTHORIZATION_INSUFFICIENT: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_AUTHORIZATION_INSUFFICIENT",
            message: "The authorization used has insufficient privileges."
          },
          CLIENT_AUTHORIZATION_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_AUTHORIZATION_INVALID",
            message: "Either the client token has expired and a new one should be generated or the tokenization key has been deactivated or deleted."
          }
        };
      }, { "../lib/braintree-error": 124 }], 81: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var request3 = _dereq_("./request");
        var uuid = _dereq_("@braintree/uuid");
        var constants = _dereq_("../lib/constants");
        var errors = _dereq_("./errors");
        var GraphQL = _dereq_("./request/graphql");
        var GRAPHQL_URLS = _dereq_("../lib/constants").GRAPHQL_URLS;
        var isDateStringBeforeOrOn = _dereq_("../lib/is-date-string-before-or-on");
        var BRAINTREE_VERSION = _dereq_("./constants").BRAINTREE_VERSION;
        function getConfiguration(authData) {
          return new Promise(function(resolve2, reject) {
            var configuration, attrs, configUrl, reqOptions;
            var sessionId = uuid();
            var analyticsMetadata = {
              merchantAppId: window.location.host,
              platform: constants.PLATFORM,
              sdkVersion: constants.VERSION,
              source: constants.SOURCE,
              integration: constants.INTEGRATION,
              integrationType: constants.INTEGRATION,
              sessionId
            };
            attrs = authData.attrs;
            configUrl = authData.configUrl;
            attrs._meta = analyticsMetadata;
            attrs.braintreeLibraryVersion = constants.BRAINTREE_LIBRARY_VERSION;
            attrs.configVersion = "3";
            reqOptions = {
              url: configUrl,
              method: "GET",
              data: attrs
            };
            if (attrs.authorizationFingerprint && authData.graphQL) {
              if (isDateStringBeforeOrOn(authData.graphQL.date, BRAINTREE_VERSION)) {
                reqOptions.graphQL = new GraphQL({
                  graphQL: {
                    url: authData.graphQL.url,
                    features: ["configuration"]
                  }
                });
              }
              reqOptions.metadata = analyticsMetadata;
            } else if (attrs.tokenizationKey) {
              reqOptions.graphQL = new GraphQL({
                graphQL: {
                  url: GRAPHQL_URLS[authData.environment],
                  features: ["configuration"]
                }
              });
              reqOptions.metadata = analyticsMetadata;
            }
            request3(reqOptions, function(err, response, status) {
              var errorTemplate;
              if (err) {
                if (status === 403) {
                  errorTemplate = errors.CLIENT_AUTHORIZATION_INSUFFICIENT;
                } else if (status === 401) {
                  errorTemplate = errors.CLIENT_AUTHORIZATION_INVALID;
                } else {
                  errorTemplate = errors.CLIENT_GATEWAY_NETWORK;
                }
                reject(new BraintreeError({
                  type: errorTemplate.type,
                  code: errorTemplate.code,
                  message: errorTemplate.message,
                  details: {
                    originalError: err
                  }
                }));
                return;
              }
              configuration = {
                authorizationType: attrs.tokenizationKey ? "TOKENIZATION_KEY" : "CLIENT_TOKEN",
                authorizationFingerprint: attrs.authorizationFingerprint,
                analyticsMetadata,
                gatewayConfiguration: response
              };
              resolve2(configuration);
            });
          });
        }
        module2.exports = {
          getConfiguration: wrapPromise(getConfiguration)
        };
      }, { "../lib/braintree-error": 124, "../lib/constants": 126, "../lib/is-date-string-before-or-on": 151, "./constants": 79, "./errors": 80, "./request": 92, "./request/graphql": 90, "@braintree/uuid": 39, "@braintree/wrap-promise": 43 }], 82: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        var Client = _dereq_("./client");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var sharedErrors = _dereq_("../lib/errors");
        function create2(options) {
          if (!options.authorization) {
            return Promise.reject(new BraintreeError({
              type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
              code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
              message: "options.authorization is required when instantiating a client."
            }));
          }
          return Client.initialize(options);
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/braintree-error": 124, "../lib/errors": 135, "./client": 78, "@braintree/wrap-promise": 43 }], 83: [function(_dereq_, module2, exports2) {
        var querystring = _dereq_("../../lib/querystring");
        var assign2 = _dereq_("../../lib/assign").assign;
        var prepBody = _dereq_("./prep-body");
        var parseBody = _dereq_("./parse-body");
        var xhr2 = _dereq_("./xhr");
        var isXHRAvailable = xhr2.isAvailable;
        var GraphQLRequest = _dereq_("./graphql/request");
        var DefaultRequest = _dereq_("./default-request");
        var MAX_TCP_RETRYCOUNT = 1;
        var TCP_PRECONNECT_BUG_STATUS_CODE = 408;
        function requestShouldRetry(status) {
          return !status || status === TCP_PRECONNECT_BUG_STATUS_CODE;
        }
        function graphQLRequestShouldRetryWithClientApi(body) {
          var errorClass = !body.data && body.errors && body.errors[0] && body.errors[0].extensions && body.errors[0].extensions.errorClass;
          return errorClass === "UNKNOWN" || errorClass === "INTERNAL";
        }
        function _requestWithRetry(options, tcpRetryCount, cb) {
          var status, resBody, ajaxRequest, body, method, headers, parsedBody;
          var url = options.url;
          var graphQL = options.graphQL;
          var timeout = options.timeout;
          var req = xhr2.getRequestObject();
          var callback = cb;
          var isGraphQLRequest = Boolean(graphQL && graphQL.isGraphQLRequest(url, options.data));
          options.headers = assign2({ "Content-Type": "application/json" }, options.headers);
          if (isGraphQLRequest) {
            ajaxRequest = new GraphQLRequest(options);
          } else {
            ajaxRequest = new DefaultRequest(options);
          }
          url = ajaxRequest.getUrl();
          body = ajaxRequest.getBody();
          method = ajaxRequest.getMethod();
          headers = ajaxRequest.getHeaders();
          if (method === "GET") {
            url = querystring.queryify(url, body);
            body = null;
          }
          if (isXHRAvailable) {
            req.onreadystatechange = function() {
              if (req.readyState !== 4) {
                return;
              }
              if (req.status === 0 && isGraphQLRequest) {
                delete options.graphQL;
                _requestWithRetry(options, tcpRetryCount, cb);
                return;
              }
              parsedBody = parseBody(req.responseText);
              resBody = ajaxRequest.adaptResponseBody(parsedBody);
              status = ajaxRequest.determineStatus(req.status, parsedBody);
              if (status >= 400 || status < 200) {
                if (isGraphQLRequest && graphQLRequestShouldRetryWithClientApi(parsedBody)) {
                  delete options.graphQL;
                  _requestWithRetry(options, tcpRetryCount, cb);
                  return;
                }
                if (tcpRetryCount < MAX_TCP_RETRYCOUNT && requestShouldRetry(status)) {
                  tcpRetryCount++;
                  _requestWithRetry(options, tcpRetryCount, cb);
                  return;
                }
                callback(resBody || "error", null, status || 500);
              } else {
                callback(null, resBody, status);
              }
            };
          } else {
            if (options.headers) {
              url = querystring.queryify(url, headers);
            }
            req.onload = function() {
              callback(null, parseBody(req.responseText), req.status);
            };
            req.onerror = function() {
              callback("error", null, 500);
            };
            req.onprogress = function() {
            };
            req.ontimeout = function() {
              callback("timeout", null, -1);
            };
          }
          try {
            req.open(method, url, true);
          } catch (requestOpenError) {
            if (!isGraphQLRequest) {
              throw requestOpenError;
            }
            delete options.graphQL;
            _requestWithRetry(options, tcpRetryCount, cb);
            return;
          }
          req.timeout = timeout;
          if (isXHRAvailable) {
            Object.keys(headers).forEach(function(headerKey) {
              req.setRequestHeader(headerKey, headers[headerKey]);
            });
          }
          try {
            req.send(prepBody(method, body));
          } catch (e) {
          }
        }
        function request3(options, cb) {
          _requestWithRetry(options, 0, cb);
        }
        module2.exports = {
          request: request3
        };
      }, { "../../lib/assign": 121, "../../lib/querystring": 157, "./default-request": 84, "./graphql/request": 91, "./parse-body": 93, "./prep-body": 94, "./xhr": 95 }], 84: [function(_dereq_, module2, exports2) {
        function DefaultRequest(options) {
          this._url = options.url;
          this._data = options.data;
          this._method = options.method;
          this._headers = options.headers;
        }
        DefaultRequest.prototype.getUrl = function() {
          return this._url;
        };
        DefaultRequest.prototype.getBody = function() {
          return this._data;
        };
        DefaultRequest.prototype.getMethod = function() {
          return this._method;
        };
        DefaultRequest.prototype.getHeaders = function() {
          return this._headers;
        };
        DefaultRequest.prototype.adaptResponseBody = function(parsedBody) {
          return parsedBody;
        };
        DefaultRequest.prototype.determineStatus = function(status) {
          return status;
        };
        module2.exports = DefaultRequest;
      }, {}], 85: [function(_dereq_, module2, exports2) {
        var errorResponseAdapter = _dereq_("./error");
        var assign2 = _dereq_("../../../../lib/assign").assign;
        var cardTypeTransforms = {
          creditCard: {
            AMERICAN_EXPRESS: "American Express",
            DISCOVER: "Discover",
            INTERNATIONAL_MAESTRO: "Maestro",
            JCB: "JCB",
            MASTERCARD: "MasterCard",
            SOLO: "Solo",
            UK_MAESTRO: "UK Maestro",
            UNION_PAY: "UnionPay",
            VISA: "Visa",
            ELO: "Elo",
            HIPER: "Hiper",
            HIPERCARD: "Hipercard"
          },
          applePayWeb: {
            VISA: "visa",
            MASTERCARD: "mastercard",
            DISCOVER: "discover",
            AMERICAN_EXPRESS: "amex",
            INTERNATIONAL_MAESTRO: "maestro",
            ELO: "elo"
          },
          visaCheckout: {
            VISA: "Visa",
            MASTERCARD: "MasterCard",
            DISCOVER: "Discover",
            AMERICAN_EXPRESS: "American Express"
          },
          googlePay: {
            VISA: "visa",
            MASTERCARD: "mastercard",
            DISCOVER: "discover",
            AMERICAN_EXPRESS: "amex",
            INTERNATIONAL_MAESTRO: "maestro",
            ELO: "elo"
          },
          masterpass: {
            VISA: "visa",
            MASTERCARD: "master",
            DISCOVER: "discover",
            AMERICAN_EXPRESS: "amex",
            DINERS: "diners",
            INTERNATIONAL_MAESTRO: "maestro",
            JCB: "jcb"
          }
        };
        function configurationResponseAdapter(responseBody, ctx) {
          var adaptedResponse;
          if (responseBody.data && !responseBody.errors) {
            adaptedResponse = adaptConfigurationResponseBody(responseBody, ctx);
          } else {
            adaptedResponse = errorResponseAdapter(responseBody);
          }
          return adaptedResponse;
        }
        function adaptConfigurationResponseBody(body, ctx) {
          var configuration = body.data.clientConfiguration;
          var response;
          response = {
            environment: configuration.environment.toLowerCase(),
            clientApiUrl: configuration.clientApiUrl,
            assetsUrl: configuration.assetsUrl,
            analytics: {
              url: configuration.analyticsUrl
            },
            merchantId: configuration.merchantId,
            venmo: "off"
          };
          if (configuration.supportedFeatures) {
            response.graphQL = {
              url: ctx._graphQL._config.url,
              features: configuration.supportedFeatures.map(function(feature) {
                return feature.toLowerCase();
              })
            };
          }
          if (configuration.braintreeApi) {
            response.braintreeApi = configuration.braintreeApi;
          }
          if (configuration.applePayWeb) {
            response.applePayWeb = configuration.applePayWeb;
            response.applePayWeb.supportedNetworks = mapCardTypes(configuration.applePayWeb.supportedCardBrands, cardTypeTransforms.applePayWeb);
            delete response.applePayWeb.supportedCardBrands;
          }
          if (configuration.ideal) {
            response.ideal = configuration.ideal;
          }
          if (configuration.kount) {
            response.kount = {
              kountMerchantId: configuration.kount.merchantId
            };
          }
          if (configuration.creditCard) {
            response.challenges = configuration.creditCard.challenges.map(function(challenge) {
              return challenge.toLowerCase();
            });
            response.creditCards = {
              supportedCardTypes: mapCardTypes(configuration.creditCard.supportedCardBrands, cardTypeTransforms.creditCard)
            };
            response.threeDSecureEnabled = configuration.creditCard.threeDSecureEnabled;
            response.threeDSecure = configuration.creditCard.threeDSecure;
          } else {
            response.challenges = [];
            response.creditCards = {
              supportedCardTypes: []
            };
            response.threeDSecureEnabled = false;
          }
          if (configuration.googlePay) {
            response.androidPay = {
              displayName: configuration.googlePay.displayName,
              enabled: true,
              environment: configuration.googlePay.environment.toLowerCase(),
              googleAuthorizationFingerprint: configuration.googlePay.googleAuthorization,
              paypalClientId: configuration.googlePay.paypalClientId,
              supportedNetworks: mapCardTypes(configuration.googlePay.supportedCardBrands, cardTypeTransforms.googlePay)
            };
          }
          if (configuration.venmo) {
            response.payWithVenmo = {
              merchantId: configuration.venmo.merchantId,
              accessToken: configuration.venmo.accessToken,
              environment: configuration.venmo.environment.toLowerCase(),
              enrichedCustomerDataEnabled: configuration.venmo.enrichedCustomerDataEnabled
            };
          }
          if (configuration.paypal) {
            response.paypalEnabled = true;
            response.paypal = assign2({}, configuration.paypal);
            response.paypal.currencyIsoCode = response.paypal.currencyCode;
            response.paypal.environment = response.paypal.environment.toLowerCase();
            delete response.paypal.currencyCode;
          } else {
            response.paypalEnabled = false;
          }
          if (configuration.unionPay) {
            response.unionPay = {
              enabled: true,
              merchantAccountId: configuration.unionPay.merchantAccountId
            };
          }
          if (configuration.visaCheckout) {
            response.visaCheckout = {
              apikey: configuration.visaCheckout.apiKey,
              encryptionKey: configuration.visaCheckout.encryptionKey,
              externalClientId: configuration.visaCheckout.externalClientId,
              supportedCardTypes: mapCardTypes(configuration.visaCheckout.supportedCardBrands, cardTypeTransforms.visaCheckout)
            };
          }
          if (configuration.masterpass) {
            response.masterpass = {
              merchantCheckoutId: configuration.masterpass.merchantCheckoutId,
              supportedNetworks: mapCardTypes(configuration.masterpass.supportedCardBrands, cardTypeTransforms.masterpass)
            };
          }
          if (configuration.usBankAccount) {
            response.usBankAccount = {
              routeId: configuration.usBankAccount.routeId,
              plaid: {
                publicKey: configuration.usBankAccount.plaidPublicKey
              }
            };
          }
          return response;
        }
        function mapCardTypes(cardTypes, cardTypeTransformMap) {
          return cardTypes.reduce(function(acc, type) {
            if (cardTypeTransformMap.hasOwnProperty(type)) {
              return acc.concat(cardTypeTransformMap[type]);
            }
            return acc;
          }, []);
        }
        module2.exports = configurationResponseAdapter;
      }, { "../../../../lib/assign": 121, "./error": 87 }], 86: [function(_dereq_, module2, exports2) {
        var errorResponseAdapter = _dereq_("./error");
        var CARD_BRAND_MAP = {
          AMERICAN_EXPRESS: "American Express",
          DINERS: "Discover",
          DISCOVER: "Discover",
          ELO: "Elo",
          HIPER: "Hiper",
          HIPERCARD: "Hipercard",
          INTERNATIONAL_MAESTRO: "Maestro",
          JCB: "JCB",
          MASTERCARD: "MasterCard",
          UK_MAESTRO: "Maestro",
          UNION_PAY: "UnionPay",
          VISA: "Visa"
        };
        var BIN_DATA_MAP = {
          YES: "Yes",
          NO: "No",
          UNKNOWN: "Unknown"
        };
        var AUTHENTICATION_INSIGHT_MAP = {
          PSDTWO: "psd2"
        };
        function creditCardTokenizationResponseAdapter(responseBody) {
          var adaptedResponse;
          if (responseBody.data && !responseBody.errors) {
            adaptedResponse = adaptTokenizeCreditCardResponseBody(responseBody);
          } else {
            adaptedResponse = errorResponseAdapter(responseBody);
          }
          return adaptedResponse;
        }
        function adaptTokenizeCreditCardResponseBody(body) {
          var data2 = body.data.tokenizeCreditCard;
          var creditCard = data2.creditCard;
          var lastTwo = creditCard.last4 ? creditCard.last4.substr(2, 4) : "";
          var binData = creditCard.binData;
          var response, regulationEnvironment;
          if (binData) {
            [
              "commercial",
              "debit",
              "durbinRegulated",
              "healthcare",
              "payroll",
              "prepaid"
            ].forEach(function(key) {
              if (binData[key]) {
                binData[key] = BIN_DATA_MAP[binData[key]];
              } else {
                binData[key] = "Unknown";
              }
            });
            ["issuingBank", "countryOfIssuance", "productId"].forEach(function(key) {
              if (!binData[key]) {
                binData[key] = "Unknown";
              }
            });
          }
          response = {
            creditCards: [
              {
                binData,
                consumed: false,
                description: lastTwo ? "ending in " + lastTwo : "",
                nonce: data2.token,
                details: {
                  cardholderName: creditCard.cardholderName,
                  expirationMonth: creditCard.expirationMonth,
                  expirationYear: creditCard.expirationYear,
                  bin: creditCard.bin || "",
                  cardType: CARD_BRAND_MAP[creditCard.brandCode] || "Unknown",
                  lastFour: creditCard.last4 || "",
                  lastTwo
                },
                type: "CreditCard",
                threeDSecureInfo: null
              }
            ]
          };
          if (data2.authenticationInsight) {
            regulationEnvironment = data2.authenticationInsight.customerAuthenticationRegulationEnvironment;
            response.creditCards[0].authenticationInsight = {
              regulationEnvironment: AUTHENTICATION_INSIGHT_MAP[regulationEnvironment] || regulationEnvironment.toLowerCase()
            };
          }
          return response;
        }
        module2.exports = creditCardTokenizationResponseAdapter;
      }, { "./error": 87 }], 87: [function(_dereq_, module2, exports2) {
        function errorResponseAdapter(responseBody) {
          var response;
          var errorClass = responseBody.errors && responseBody.errors[0] && responseBody.errors[0].extensions && responseBody.errors[0].extensions.errorClass;
          if (errorClass === "VALIDATION") {
            response = userErrorResponseAdapter(responseBody);
          } else if (errorClass) {
            response = errorWithClassResponseAdapter(responseBody);
          } else {
            response = {
              error: { message: "There was a problem serving your request" },
              fieldErrors: []
            };
          }
          return response;
        }
        function errorWithClassResponseAdapter(responseBody) {
          return {
            error: { message: responseBody.errors[0].message },
            fieldErrors: []
          };
        }
        function userErrorResponseAdapter(responseBody) {
          var fieldErrors = buildFieldErrors(responseBody.errors);
          if (fieldErrors.length === 0) {
            return { error: { message: responseBody.errors[0].message } };
          }
          return {
            error: { message: getLegacyMessage(fieldErrors) },
            fieldErrors
          };
        }
        function buildFieldErrors(errors) {
          var fieldErrors = [];
          errors.forEach(function(error) {
            if (!(error.extensions && error.extensions.inputPath)) {
              return;
            }
            addFieldError(error.extensions.inputPath.slice(1), error, fieldErrors);
          });
          return fieldErrors;
        }
        function addFieldError(inputPath, errorDetail, fieldErrors) {
          var fieldError;
          var legacyCode = errorDetail.extensions.legacyCode;
          var inputField = inputPath[0];
          if (inputPath.length === 1) {
            fieldErrors.push({
              code: legacyCode,
              field: inputField,
              message: errorDetail.message
            });
            return;
          }
          fieldErrors.forEach(function(candidate) {
            if (candidate.field === inputField) {
              fieldError = candidate;
            }
          });
          if (!fieldError) {
            fieldError = { field: inputField, fieldErrors: [] };
            fieldErrors.push(fieldError);
          }
          addFieldError(inputPath.slice(1), errorDetail, fieldError.fieldErrors);
        }
        function getLegacyMessage(errors) {
          var legacyMessages = {
            creditCard: "Credit card is invalid"
          };
          var field = errors[0].field;
          return legacyMessages[field];
        }
        module2.exports = errorResponseAdapter;
      }, {}], 88: [function(_dereq_, module2, exports2) {
        var CONFIGURATION_QUERY = "query ClientConfiguration {   clientConfiguration {     analyticsUrl     environment     merchantId     assetsUrl     clientApiUrl     creditCard {       supportedCardBrands       challenges       threeDSecureEnabled       threeDSecure {         cardinalAuthenticationJWT       }     }     applePayWeb {       countryCode       currencyCode       merchantIdentifier       supportedCardBrands     }     googlePay {       displayName       supportedCardBrands       environment       googleAuthorization       paypalClientId     }     ideal {       routeId       assetsUrl     }     kount {       merchantId     }     masterpass {       merchantCheckoutId       supportedCardBrands     }     paypal {       displayName       clientId       assetsUrl       environment       environmentNoNetwork       unvettedMerchant       braintreeClientId       billingAgreementsEnabled       merchantAccountId       currencyCode       payeeEmail     }     unionPay {       merchantAccountId     }     usBankAccount {       routeId       plaidPublicKey     }     venmo {       merchantId       accessToken       environment       enrichedCustomerDataEnabled    }     visaCheckout {       apiKey       externalClientId       supportedCardBrands     }     braintreeApi {       accessToken       url     }     supportedFeatures   } }";
        function configuration() {
          return {
            query: CONFIGURATION_QUERY,
            operationName: "ClientConfiguration"
          };
        }
        module2.exports = configuration;
      }, {}], 89: [function(_dereq_, module2, exports2) {
        var assign2 = _dereq_("../../../../lib/assign").assign;
        function createMutation(config) {
          var hasAuthenticationInsight = config.hasAuthenticationInsight;
          var mutation = "mutation TokenizeCreditCard($input: TokenizeCreditCardInput!";
          if (hasAuthenticationInsight) {
            mutation += ", $authenticationInsightInput: AuthenticationInsightInput!";
          }
          mutation += ") {   tokenizeCreditCard(input: $input) {     token     creditCard {       bin       brandCode       last4       cardholderName       expirationMonth      expirationYear      binData {         prepaid         healthcare         debit         durbinRegulated         commercial         payroll         issuingBank         countryOfIssuance         productId       }     } ";
          if (hasAuthenticationInsight) {
            mutation += "    authenticationInsight(input: $authenticationInsightInput) {      customerAuthenticationRegulationEnvironment    }";
          }
          mutation += "  } }";
          return mutation;
        }
        function createCreditCardTokenizationBody(body, options) {
          var cc = body.creditCard;
          var billingAddress = cc && cc.billingAddress;
          var expDate = cc && cc.expirationDate;
          var expirationMonth = cc && (cc.expirationMonth || expDate && expDate.split("/")[0].trim());
          var expirationYear = cc && (cc.expirationYear || expDate && expDate.split("/")[1].trim());
          var variables = {
            input: {
              creditCard: {
                number: cc && cc.number,
                expirationMonth,
                expirationYear,
                cvv: cc && cc.cvv,
                cardholderName: cc && cc.cardholderName
              },
              options: {}
            }
          };
          if (options.hasAuthenticationInsight) {
            variables.authenticationInsightInput = {
              merchantAccountId: body.merchantAccountId
            };
          }
          if (billingAddress) {
            variables.input.creditCard.billingAddress = billingAddress;
          }
          variables.input = addValidationRule(body, variables.input);
          return variables;
        }
        function addValidationRule(body, input) {
          var validate;
          if (body.creditCard && body.creditCard.options && typeof body.creditCard.options.validate === "boolean") {
            validate = body.creditCard.options.validate;
          } else if (body.authorizationFingerprint && body.tokenizationKey || body.authorizationFingerprint) {
            validate = true;
          } else if (body.tokenizationKey) {
            validate = false;
          }
          if (typeof validate === "boolean") {
            input.options = assign2({
              validate
            }, input.options);
          }
          return input;
        }
        function creditCardTokenization(body) {
          var options = {
            hasAuthenticationInsight: Boolean(body.authenticationInsight && body.merchantAccountId)
          };
          return {
            query: createMutation(options),
            variables: createCreditCardTokenizationBody(body, options),
            operationName: "TokenizeCreditCard"
          };
        }
        module2.exports = creditCardTokenization;
      }, { "../../../../lib/assign": 121 }], 90: [function(_dereq_, module2, exports2) {
        var features = {
          tokenize_credit_cards: "payment_methods/credit_cards",
          configuration: "configuration"
        };
        var disallowedInputPaths = ["creditCard.options.unionPayEnrollment"];
        function GraphQL(config) {
          this._config = config.graphQL;
        }
        GraphQL.prototype.getGraphQLEndpoint = function() {
          return this._config.url;
        };
        GraphQL.prototype.isGraphQLRequest = function(url, body) {
          var featureEnabled;
          var path = this.getClientApiPath(url);
          if (!this._isGraphQLEnabled() || !path) {
            return false;
          }
          featureEnabled = this._config.features.some(function(feature) {
            return features[feature] === path;
          });
          if (containsDisallowedlistedKeys(body)) {
            return false;
          }
          return featureEnabled;
        };
        GraphQL.prototype.getClientApiPath = function(url) {
          var path;
          var clientApiPrefix = "/client_api/v1/";
          var pathParts = url.split(clientApiPrefix);
          if (pathParts.length > 1) {
            path = pathParts[1].split("?")[0];
          }
          return path;
        };
        GraphQL.prototype._isGraphQLEnabled = function() {
          return Boolean(this._config);
        };
        function containsDisallowedlistedKeys(body) {
          return disallowedInputPaths.some(function(keys) {
            var value = keys.split(".").reduce(function(accumulator, key) {
              return accumulator && accumulator[key];
            }, body);
            return value !== void 0;
          });
        }
        module2.exports = GraphQL;
      }, {}], 91: [function(_dereq_, module2, exports2) {
        var BRAINTREE_VERSION = _dereq_("../../constants").BRAINTREE_VERSION;
        var assign2 = _dereq_("../../../lib/assign").assign;
        var snakeCaseToCamelCase = _dereq_("../../../lib/snake-case-to-camel-case");
        var creditCardTokenizationBodyGenerator = _dereq_("./generators/credit-card-tokenization");
        var creditCardTokenizationResponseAdapter = _dereq_("./adapters/credit-card-tokenization");
        var configurationBodyGenerator = _dereq_("./generators/configuration");
        var configurationResponseAdapter = _dereq_("./adapters/configuration");
        var generators = {
          "payment_methods/credit_cards": creditCardTokenizationBodyGenerator,
          configuration: configurationBodyGenerator
        };
        var adapters = {
          "payment_methods/credit_cards": creditCardTokenizationResponseAdapter,
          configuration: configurationResponseAdapter
        };
        function GraphQLRequest(options) {
          var clientApiPath = options.graphQL.getClientApiPath(options.url);
          this._graphQL = options.graphQL;
          this._data = options.data;
          this._method = options.method;
          this._headers = options.headers;
          this._clientSdkMetadata = {
            source: options.metadata.source,
            integration: options.metadata.integration,
            sessionId: options.metadata.sessionId
          };
          this._sendAnalyticsEvent = options.sendAnalyticsEvent || Function.prototype;
          this._generator = generators[clientApiPath];
          this._adapter = adapters[clientApiPath];
          this._sendAnalyticsEvent("graphql.init");
        }
        GraphQLRequest.prototype.getUrl = function() {
          return this._graphQL.getGraphQLEndpoint();
        };
        GraphQLRequest.prototype.getBody = function() {
          var formattedBody = formatBodyKeys(this._data);
          var generatedBody = this._generator(formattedBody);
          var body = assign2({ clientSdkMetadata: this._clientSdkMetadata }, generatedBody);
          return JSON.stringify(body);
        };
        GraphQLRequest.prototype.getMethod = function() {
          return "POST";
        };
        GraphQLRequest.prototype.getHeaders = function() {
          var authorization, headers;
          if (this._data.authorizationFingerprint) {
            this._sendAnalyticsEvent("graphql.authorization-fingerprint");
            authorization = this._data.authorizationFingerprint;
          } else {
            this._sendAnalyticsEvent("graphql.tokenization-key");
            authorization = this._data.tokenizationKey;
          }
          headers = {
            Authorization: "Bearer " + authorization,
            "Braintree-Version": BRAINTREE_VERSION
          };
          return assign2({}, this._headers, headers);
        };
        GraphQLRequest.prototype.adaptResponseBody = function(parsedBody) {
          return this._adapter(parsedBody, this);
        };
        GraphQLRequest.prototype.determineStatus = function(httpStatus, parsedResponse) {
          var status, errorClass;
          if (httpStatus === 200) {
            errorClass = parsedResponse.errors && parsedResponse.errors[0] && parsedResponse.errors[0].extensions && parsedResponse.errors[0].extensions.errorClass;
            if (parsedResponse.data && !parsedResponse.errors) {
              status = 200;
            } else if (errorClass === "VALIDATION") {
              status = 422;
            } else if (errorClass === "AUTHORIZATION") {
              status = 403;
            } else if (errorClass === "AUTHENTICATION") {
              status = 401;
            } else if (isGraphQLError(errorClass, parsedResponse)) {
              status = 403;
            } else {
              status = 500;
            }
          } else if (!httpStatus) {
            status = 500;
          } else {
            status = httpStatus;
          }
          this._sendAnalyticsEvent("graphql.status." + httpStatus);
          this._sendAnalyticsEvent("graphql.determinedStatus." + status);
          return status;
        };
        function isGraphQLError(errorClass, parsedResponse) {
          return !errorClass && parsedResponse.errors[0].message;
        }
        function formatBodyKeys(originalBody) {
          var body = {};
          Object.keys(originalBody).forEach(function(key) {
            var camelCaseKey = snakeCaseToCamelCase(key);
            if (typeof originalBody[key] === "object") {
              body[camelCaseKey] = formatBodyKeys(originalBody[key]);
            } else if (typeof originalBody[key] === "number") {
              body[camelCaseKey] = String(originalBody[key]);
            } else {
              body[camelCaseKey] = originalBody[key];
            }
          });
          return body;
        }
        module2.exports = GraphQLRequest;
      }, { "../../../lib/assign": 121, "../../../lib/snake-case-to-camel-case": 159, "../../constants": 79, "./adapters/configuration": 85, "./adapters/credit-card-tokenization": 86, "./generators/configuration": 88, "./generators/credit-card-tokenization": 89 }], 92: [function(_dereq_, module2, exports2) {
        var once = _dereq_("../../lib/once");
        var AJAXDriver = _dereq_("./ajax-driver");
        module2.exports = function(options, cb) {
          cb = once(cb || Function.prototype);
          options.method = (options.method || "GET").toUpperCase();
          options.timeout = options.timeout == null ? 6e4 : options.timeout;
          options.data = options.data || {};
          AJAXDriver.request(options, cb);
        };
      }, { "../../lib/once": 156, "./ajax-driver": 83 }], 93: [function(_dereq_, module2, exports2) {
        module2.exports = function(body) {
          try {
            body = JSON.parse(body);
          } catch (e) {
          }
          return body;
        };
      }, {}], 94: [function(_dereq_, module2, exports2) {
        module2.exports = function(method, body) {
          if (typeof method !== "string") {
            throw new Error("Method must be a string");
          }
          if (method.toLowerCase() !== "get" && body != null) {
            body = typeof body === "string" ? body : JSON.stringify(body);
          }
          return body;
        };
      }, {}], 95: [function(_dereq_, module2, exports2) {
        var isXHRAvailable = typeof window !== "undefined" && window.XMLHttpRequest && "withCredentials" in new window.XMLHttpRequest();
        function getRequestObject() {
          return isXHRAvailable ? new window.XMLHttpRequest() : new window.XDomainRequest();
        }
        module2.exports = {
          isAvailable: isXHRAvailable,
          getRequestObject
        };
      }, {}], 96: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          DATA_COLLECTOR_KOUNT_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "DATA_COLLECTOR_KOUNT_NOT_ENABLED",
            message: "Kount is not enabled for this merchant."
          },
          DATA_COLLECTOR_KOUNT_ERROR: {
            type: BraintreeError.types.MERCHANT,
            code: "DATA_COLLECTOR_KOUNT_ERROR"
          },
          DATA_COLLECTOR_REQUIRES_CREATE_OPTIONS: {
            type: BraintreeError.types.MERCHANT,
            code: "DATA_COLLECTOR_REQUIRES_CREATE_OPTIONS",
            message: "Data Collector must be created with Kount and/or PayPal."
          }
        };
      }, { "../lib/braintree-error": 124 }], 97: [function(_dereq_, module2, exports2) {
        var FRAUDNET_FNCLS = _dereq_("../lib/constants").FRAUDNET_FNCLS;
        var FRAUDNET_SOURCE = _dereq_("../lib/constants").FRAUDNET_SOURCE;
        var FRAUDNET_URL = _dereq_("../lib/constants").FRAUDNET_URL;
        var loadScript = _dereq_("../lib/assets").loadScript;
        var cachedSessionId;
        function setup(options) {
          var fraudNet = new Fraudnet();
          options = options || {};
          if (!options.sessionId && cachedSessionId) {
            fraudNet.sessionId = cachedSessionId;
            return Promise.resolve(fraudNet);
          }
          return fraudNet.initialize(options);
        }
        function clearSessionIdCache() {
          cachedSessionId = null;
        }
        function Fraudnet() {
        }
        Fraudnet.prototype.initialize = function(options) {
          var environment = options.environment;
          var self2 = this;
          this.sessionId = options.sessionId || _generateSessionId();
          if (!options.sessionId) {
            cachedSessionId = this.sessionId;
          }
          this._beaconId = _generateBeaconId(this.sessionId);
          this._parameterBlock = _createParameterBlock(this.sessionId, this._beaconId, environment);
          return loadScript({
            src: FRAUDNET_URL
          }).then(function(block) {
            self2._thirdPartyBlock = block;
            return self2;
          }).catch(function() {
            return null;
          });
        };
        Fraudnet.prototype.teardown = function() {
          removeElementIfOnPage(document.querySelector('iframe[title="ppfniframe"]'));
          removeElementIfOnPage(document.querySelector('iframe[title="pbf"]'));
          removeElementIfOnPage(this._parameterBlock);
          removeElementIfOnPage(this._thirdPartyBlock);
        };
        function removeElementIfOnPage(element) {
          if (element && element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }
        function _generateSessionId() {
          var i;
          var id = "";
          for (i = 0; i < 32; i++) {
            id += Math.floor(Math.random() * 16).toString(16);
          }
          return id;
        }
        function _generateBeaconId(sessionId) {
          var timestamp = new Date().getTime() / 1e3;
          return "https://b.stats.paypal.com/counter.cgi?i=127.0.0.1&p=" + sessionId + "&t=" + timestamp + "&a=14";
        }
        function _createParameterBlock(sessionId, beaconId, environment) {
          var el = document.body.appendChild(document.createElement("script"));
          var config = {
            f: sessionId,
            s: FRAUDNET_SOURCE,
            b: beaconId
          };
          if (environment !== "production") {
            config.sandbox = true;
          }
          el.type = "application/json";
          el.setAttribute("fncls", FRAUDNET_FNCLS);
          el.text = JSON.stringify(config);
          return el;
        }
        module2.exports = {
          setup,
          clearSessionIdCache
        };
      }, { "../lib/assets": 120, "../lib/constants": 126 }], 98: [function(_dereq_, module2, exports2) {
        var kount = _dereq_("./kount");
        var fraudnet = _dereq_("./fraudnet");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var methods = _dereq_("../lib/methods");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var errors = _dereq_("./errors");
        function create2(options) {
          var name = "Data Collector";
          var result = {
            _instances: []
          };
          var data2;
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            result._instantiatedWithAClient = !options.useDeferredClient;
            result._createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            }).then(function(client) {
              var kountInstance;
              var config = client.getConfiguration();
              if (options.kount === true && config.gatewayConfiguration.kount) {
                try {
                  kountInstance = kount.setup({
                    environment: config.gatewayConfiguration.environment,
                    merchantId: config.gatewayConfiguration.kount.kountMerchantId
                  });
                } catch (err) {
                  return Promise.reject(new BraintreeError({
                    type: errors.DATA_COLLECTOR_KOUNT_ERROR.type,
                    code: errors.DATA_COLLECTOR_KOUNT_ERROR.code,
                    message: err.message
                  }));
                }
                data2 = kountInstance.deviceData;
                result._instances.push(kountInstance);
              } else {
                data2 = {};
              }
              return Promise.resolve(client);
            }).then(function(client) {
              return fraudnet.setup({
                sessionId: options.riskCorrelationId || options.clientMetadataId || options.correlationId,
                environment: client.getConfiguration().gatewayConfiguration.environment
              }).then(function(fraudnetInstance) {
                if (fraudnetInstance) {
                  data2.correlation_id = fraudnetInstance.sessionId;
                  result._instances.push(fraudnetInstance);
                }
              });
            }).then(function() {
              if (result._instances.length === 0) {
                return Promise.reject(new BraintreeError(errors.DATA_COLLECTOR_REQUIRES_CREATE_OPTIONS));
              }
              result.deviceData = JSON.stringify(data2);
              result.rawDeviceData = data2;
              return result;
            });
            result.teardown = createTeardownMethod(result);
            result.getDeviceData = createGetDeviceDataMethod(result);
            if (result._instantiatedWithAClient) {
              return result._createPromise;
            }
            return result;
          });
        }
        function createTeardownMethod(result) {
          return wrapPromise(function teardown() {
            return result._createPromise.then(function() {
              result._instances.forEach(function(instance) {
                if (instance) {
                  instance.teardown();
                }
              });
              convertMethodsToError(result, methods(result));
            });
          });
        }
        function createGetDeviceDataMethod(result) {
          return wrapPromise(function getDeviceData(options) {
            options = options || {};
            return result._createPromise.then(function() {
              if (options.raw) {
                return Promise.resolve(result.rawDeviceData);
              }
              return Promise.resolve(result.deviceData);
            });
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/convert-methods-to-error": 127, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "../lib/methods": 155, "./errors": 96, "./fraudnet": 97, "./kount": 99, "@braintree/wrap-promise": 43 }], 99: [function(_dereq_, module2, exports2) {
        var sjcl = _dereq_("./vendor/sjcl");
        var camelCaseToSnakeCase = _dereq_("../lib/camel-case-to-snake-case");
        var QA_URL = "https://assets.qa.braintreepayments.com/data";
        var IFRAME_ID_PREFIX = "braintreeDataFrame-";
        var environmentUrls = {
          development: QA_URL,
          qa: QA_URL,
          sandbox: "https://assets.braintreegateway.com/sandbox/data",
          production: "https://assets.braintreegateway.com/data"
        };
        var cachedDeviceData = {};
        function setup(o) {
          var options = o != null ? o : {};
          return new Kount(options);
        }
        function Kount(options) {
          var previouslyInitializedDeviceData = Kount.getCachedDeviceData(options.merchantId);
          if (previouslyInitializedDeviceData) {
            this.deviceData = previouslyInitializedDeviceData;
            this._isCached = true;
            return;
          }
          this._currentEnvironment = this._initializeEnvironment(options);
          sjcl.random.startCollectors();
          this._deviceSessionId = this._generateDeviceSessionId();
          this.deviceData = this._getDeviceData();
          Kount.setCachedDeviceData(options.merchantId, this.deviceData);
          this._iframe = this._setupIFrame();
        }
        Kount.getCachedDeviceData = function(merchantId) {
          return cachedDeviceData[merchantId];
        };
        Kount.setCachedDeviceData = function(merchantId, data2) {
          cachedDeviceData[merchantId] = data2;
        };
        Kount.prototype.teardown = function() {
          if (!this._isCached) {
            sjcl.random.stopCollectors();
            this._removeIframe();
          }
        };
        Kount.prototype._removeIframe = function() {
          this._iframe.parentNode.removeChild(this._iframe);
        };
        Kount.prototype._getDeviceData = function() {
          return camelCaseToSnakeCase({
            deviceSessionId: this._deviceSessionId,
            fraudMerchantId: this._currentEnvironment.id
          });
        };
        Kount.prototype._generateDeviceSessionId = function() {
          var bits, hexString;
          bits = sjcl.random.randomWords(4, 0);
          hexString = sjcl.codec.hex.fromBits(bits);
          return hexString;
        };
        Kount.prototype._setupIFrame = function() {
          var params, iframe;
          var self2 = this;
          params = "?m=" + this._currentEnvironment.id + "&s=" + this._deviceSessionId;
          iframe = document.createElement("iframe");
          iframe.width = 1;
          iframe.id = IFRAME_ID_PREFIX + this._deviceSessionId;
          iframe.height = 1;
          iframe.frameBorder = 0;
          iframe.scrolling = "no";
          iframe.style.position = "fixed";
          iframe.style.left = "-999999px";
          iframe.style.top = "-999999px";
          iframe.title = "Braintree-Kount-iframe";
          iframe.setAttribute("aria-hidden", "true");
          document.body.appendChild(iframe);
          setTimeout(function() {
            iframe.src = self2._currentEnvironment.url + "/logo.htm" + params;
            iframe.innerHTML = '<img src="' + self2._currentEnvironment.url + "/logo.gif" + params + '" alt="" />';
          }, 10);
          return iframe;
        };
        Kount.prototype._initializeEnvironment = function(options) {
          var url = environmentUrls[options.environment];
          if (url == null) {
            throw new Error(options.environment + " is not a valid environment for kount.environment");
          }
          return {
            url,
            name: options.environment,
            id: options.merchantId
          };
        };
        module2.exports = {
          setup,
          Kount,
          environmentUrls
        };
      }, { "../lib/camel-case-to-snake-case": 125, "./vendor/sjcl": 100 }], 100: [function(_dereq_, module2, exports2) {
        var sjcl = {
          cipher: {},
          hash: {},
          keyexchange: {},
          mode: {},
          misc: {},
          codec: {},
          exception: {
            corrupt: function(a) {
              this.toString = function() {
                return "CORRUPT: " + this.message;
              };
              this.message = a;
            },
            invalid: function(a) {
              this.toString = function() {
                return "INVALID: " + this.message;
              };
              this.message = a;
            },
            bug: function(a) {
              this.toString = function() {
                return "BUG: " + this.message;
              };
              this.message = a;
            },
            notReady: function(a) {
              this.toString = function() {
                return "NOT READY: " + this.message;
              };
              this.message = a;
            }
          }
        };
        sjcl.cipher.aes = function(a) {
          this.l[0][0][0] || this.G();
          var b, c, d, e, f = this.l[0][4], g = this.l[1];
          b = a.length;
          var k = 1;
          if (b !== 4 && b !== 6 && b !== 8)
            throw new sjcl.exception.invalid("invalid aes key size");
          this.b = [d = a.slice(0), e = []];
          for (a = b; a < 4 * b + 28; a++) {
            c = d[a - 1];
            if (a % b === 0 || b === 8 && a % b === 4)
              c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255], a % b === 0 && (c = c << 8 ^ c >>> 24 ^ k << 24, k = k << 1 ^ 283 * (k >> 7));
            d[a] = d[a - b] ^ c;
          }
          for (b = 0; a; b++, a--)
            c = d[b & 3 ? a : a - 4], e[b] = 4 >= a || 4 > b ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c & 255]];
        };
        sjcl.cipher.aes.prototype = {
          encrypt: function(a) {
            return t(this, a, 0);
          },
          decrypt: function(a) {
            return t(this, a, 1);
          },
          l: [
            [[], [], [], [], []],
            [[], [], [], [], []]
          ],
          G: function() {
            var a = this.l[0], b = this.l[1], c = a[4], d = b[4], e, f, g, k = [], l = [], p2, n, h2, m;
            for (e = 0; 256 > e; e++)
              l[(k[e] = e << 1 ^ 283 * (e >> 7)) ^ e] = e;
            for (f = g = 0; !c[f]; f ^= p2 || 1, g = l[g] || 1)
              for (h2 = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4, h2 = h2 >> 8 ^ h2 & 255 ^ 99, c[f] = h2, d[h2] = f, n = k[e = k[p2 = k[f]]], m = 16843009 * n ^ 65537 * e ^ 257 * p2 ^ 16843008 * f, n = 257 * k[h2] ^ 16843008 * h2, e = 0; 4 > e; e++)
                a[e][f] = n = n << 24 ^ n >>> 8, b[e][h2] = m = m << 24 ^ m >>> 8;
            for (e = 0; 5 > e; e++)
              a[e] = a[e].slice(0), b[e] = b[e].slice(0);
          }
        };
        function t(a, b, c) {
          if (b.length !== 4)
            throw new sjcl.exception.invalid("invalid aes block size");
          var d = a.b[c], e = b[0] ^ d[0], f = b[c ? 3 : 1] ^ d[1], g = b[2] ^ d[2];
          b = b[c ? 1 : 3] ^ d[3];
          var k, l, p2, n = d.length / 4 - 2, h2, m = 4, q = [0, 0, 0, 0];
          k = a.l[c];
          a = k[0];
          var r = k[1], v = k[2], w = k[3], x = k[4];
          for (h2 = 0; h2 < n; h2++)
            k = a[e >>> 24] ^ r[f >> 16 & 255] ^ v[g >> 8 & 255] ^ w[b & 255] ^ d[m], l = a[f >>> 24] ^ r[g >> 16 & 255] ^ v[b >> 8 & 255] ^ w[e & 255] ^ d[m + 1], p2 = a[g >>> 24] ^ r[b >> 16 & 255] ^ v[e >> 8 & 255] ^ w[f & 255] ^ d[m + 2], b = a[b >>> 24] ^ r[e >> 16 & 255] ^ v[f >> 8 & 255] ^ w[g & 255] ^ d[m + 3], m += 4, e = k, f = l, g = p2;
          for (h2 = 0; 4 > h2; h2++)
            q[c ? 3 & -h2 : h2] = x[e >>> 24] << 24 ^ x[f >> 16 & 255] << 16 ^ x[g >> 8 & 255] << 8 ^ x[b & 255] ^ d[m++], k = e, e = f, f = g, g = b, b = k;
          return q;
        }
        sjcl.bitArray = {
          bitSlice: function(a, b, c) {
            a = sjcl.bitArray.M(a.slice(b / 32), 32 - (b & 31)).slice(1);
            return c === void 0 ? a : sjcl.bitArray.clamp(a, c - b);
          },
          extract: function(a, b, c) {
            var d = Math.floor(-b - c & 31);
            return ((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1;
          },
          concat: function(a, b) {
            if (a.length === 0 || b.length === 0)
              return a.concat(b);
            var c = a[a.length - 1], d = sjcl.bitArray.getPartial(c);
            return d === 32 ? a.concat(b) : sjcl.bitArray.M(b, d, c | 0, a.slice(0, a.length - 1));
          },
          bitLength: function(a) {
            var b = a.length;
            return b === 0 ? 0 : 32 * (b - 1) + sjcl.bitArray.getPartial(a[b - 1]);
          },
          clamp: function(a, b) {
            if (32 * a.length < b)
              return a;
            a = a.slice(0, Math.ceil(b / 32));
            var c = a.length;
            b = b & 31;
            0 < c && b && (a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1));
            return a;
          },
          partial: function(a, b, c) {
            return a === 32 ? b : (c ? b | 0 : b << 32 - a) + 1099511627776 * a;
          },
          getPartial: function(a) {
            return Math.round(a / 1099511627776) || 32;
          },
          equal: function(a, b) {
            if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b))
              return false;
            var c = 0, d;
            for (d = 0; d < a.length; d++)
              c |= a[d] ^ b[d];
            return c === 0;
          },
          M: function(a, b, c, d) {
            var e;
            e = 0;
            for (d === void 0 && (d = []); 32 <= b; b -= 32)
              d.push(c), c = 0;
            if (b === 0)
              return d.concat(a);
            for (e = 0; e < a.length; e++)
              d.push(c | a[e] >>> b), c = a[e] << 32 - b;
            e = a.length ? a[a.length - 1] : 0;
            a = sjcl.bitArray.getPartial(e);
            d.push(sjcl.bitArray.partial(b + a & 31, 32 < b + a ? c : d.pop(), 1));
            return d;
          },
          Y: function(a, b) {
            return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]];
          },
          byteswapM: function(a) {
            var b, c;
            for (b = 0; b < a.length; ++b)
              c = a[b], a[b] = c >>> 24 | c >>> 8 & 65280 | (c & 65280) << 8 | c << 24;
            return a;
          }
        };
        sjcl.codec.utf8String = {
          fromBits: function(a) {
            var b = "", c = sjcl.bitArray.bitLength(a), d, e;
            for (d = 0; d < c / 8; d++)
              (d & 3) === 0 && (e = a[d / 4]), b += String.fromCharCode(e >>> 8 >>> 8 >>> 8), e <<= 8;
            return decodeURIComponent(escape(b));
          },
          toBits: function(a) {
            a = unescape(encodeURIComponent(a));
            var b = [], c, d = 0;
            for (c = 0; c < a.length; c++)
              d = d << 8 | a.charCodeAt(c), (c & 3) === 3 && (b.push(d), d = 0);
            c & 3 && b.push(sjcl.bitArray.partial(8 * (c & 3), d));
            return b;
          }
        };
        sjcl.codec.hex = {
          fromBits: function(a) {
            var b = "", c;
            for (c = 0; c < a.length; c++)
              b += ((a[c] | 0) + 263882790666240).toString(16).substr(4);
            return b.substr(0, sjcl.bitArray.bitLength(a) / 4);
          },
          toBits: function(a) {
            var b, c = [], d;
            a = a.replace(/\s|0x/g, "");
            d = a.length;
            a = a + "00000000";
            for (b = 0; b < a.length; b += 8)
              c.push(parseInt(a.substr(b, 8), 16) ^ 0);
            return sjcl.bitArray.clamp(c, 4 * d);
          }
        };
        sjcl.hash.sha256 = function(a) {
          this.b[0] || this.G();
          a ? (this.u = a.u.slice(0), this.o = a.o.slice(0), this.h = a.h) : this.reset();
        };
        sjcl.hash.sha256.hash = function(a) {
          return new sjcl.hash.sha256().update(a).finalize();
        };
        sjcl.hash.sha256.prototype = {
          blockSize: 512,
          reset: function() {
            this.u = this.K.slice(0);
            this.o = [];
            this.h = 0;
            return this;
          },
          update: function(a) {
            typeof a === "string" && (a = sjcl.codec.utf8String.toBits(a));
            var b, c = this.o = sjcl.bitArray.concat(this.o, a);
            b = this.h;
            a = this.h = b + sjcl.bitArray.bitLength(a);
            if (9007199254740991 < a)
              throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");
            if (typeof Uint32Array !== "undefined") {
              var d = new Uint32Array(c), e = 0;
              for (b = 512 + b - (512 + b & 511); b <= a; b += 512)
                u(this, d.subarray(16 * e, 16 * (e + 1))), e += 1;
              c.splice(0, 16 * e);
            } else
              for (b = 512 + b - (512 + b & 511); b <= a; b += 512)
                u(this, c.splice(0, 16));
            return this;
          },
          finalize: function() {
            var a, b = this.o, c = this.u, b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);
            for (a = b.length + 2; a & 15; a++)
              b.push(0);
            b.push(Math.floor(this.h / 4294967296));
            for (b.push(this.h | 0); b.length; )
              u(this, b.splice(0, 16));
            this.reset();
            return c;
          },
          K: [],
          b: [],
          G: function() {
            function a(a2) {
              return 4294967296 * (a2 - Math.floor(a2)) | 0;
            }
            for (var b = 0, c = 2, d, e; 64 > b; c++) {
              e = true;
              for (d = 2; d * d <= c; d++)
                if (c % d === 0) {
                  e = false;
                  break;
                }
              e && (8 > b && (this.K[b] = a(Math.pow(c, 0.5))), this.b[b] = a(Math.pow(c, 1 / 3)), b++);
            }
          }
        };
        function u(a, b) {
          var c, d, e, f = a.u, g = a.b, k = f[0], l = f[1], p2 = f[2], n = f[3], h2 = f[4], m = f[5], q = f[6], r = f[7];
          for (c = 0; 64 > c; c++)
            16 > c ? d = b[c] : (d = b[c + 1 & 15], e = b[c + 14 & 15], d = b[c & 15] = (d >>> 7 ^ d >>> 18 ^ d >>> 3 ^ d << 25 ^ d << 14) + (e >>> 17 ^ e >>> 19 ^ e >>> 10 ^ e << 15 ^ e << 13) + b[c & 15] + b[c + 9 & 15] | 0), d = d + r + (h2 >>> 6 ^ h2 >>> 11 ^ h2 >>> 25 ^ h2 << 26 ^ h2 << 21 ^ h2 << 7) + (q ^ h2 & (m ^ q)) + g[c], r = q, q = m, m = h2, h2 = n + d | 0, n = p2, p2 = l, l = k, k = d + (l & p2 ^ n & (l ^ p2)) + (l >>> 2 ^ l >>> 13 ^ l >>> 22 ^ l << 30 ^ l << 19 ^ l << 10) | 0;
          f[0] = f[0] + k | 0;
          f[1] = f[1] + l | 0;
          f[2] = f[2] + p2 | 0;
          f[3] = f[3] + n | 0;
          f[4] = f[4] + h2 | 0;
          f[5] = f[5] + m | 0;
          f[6] = f[6] + q | 0;
          f[7] = f[7] + r | 0;
        }
        sjcl.prng = function(a) {
          this.c = [new sjcl.hash.sha256()];
          this.i = [0];
          this.H = 0;
          this.v = {};
          this.F = 0;
          this.J = {};
          this.L = this.f = this.j = this.T = 0;
          this.b = [0, 0, 0, 0, 0, 0, 0, 0];
          this.g = [0, 0, 0, 0];
          this.C = void 0;
          this.D = a;
          this.s = false;
          this.B = { progress: {}, seeded: {} };
          this.m = this.S = 0;
          this.w = 1;
          this.A = 2;
          this.O = 65536;
          this.I = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024];
          this.P = 3e4;
          this.N = 80;
        };
        sjcl.prng.prototype = {
          randomWords: function(a, b) {
            var c = [], d;
            d = this.isReady(b);
            var e;
            if (d === this.m)
              throw new sjcl.exception.notReady("generator isn't seeded");
            if (d & this.A) {
              d = !(d & this.w);
              e = [];
              var f = 0, g;
              this.L = e[0] = new Date().valueOf() + this.P;
              for (g = 0; 16 > g; g++)
                e.push(4294967296 * Math.random() | 0);
              for (g = 0; g < this.c.length && (e = e.concat(this.c[g].finalize()), f += this.i[g], this.i[g] = 0, d || !(this.H & 1 << g)); g++)
                ;
              this.H >= 1 << this.c.length && (this.c.push(new sjcl.hash.sha256()), this.i.push(0));
              this.f -= f;
              f > this.j && (this.j = f);
              this.H++;
              this.b = sjcl.hash.sha256.hash(this.b.concat(e));
              this.C = new sjcl.cipher.aes(this.b);
              for (d = 0; 4 > d && (this.g[d] = this.g[d] + 1 | 0, !this.g[d]); d++)
                ;
            }
            for (d = 0; d < a; d += 4)
              (d + 1) % this.O === 0 && y(this), e = z(this), c.push(e[0], e[1], e[2], e[3]);
            y(this);
            return c.slice(0, a);
          },
          setDefaultParanoia: function(a, b) {
            if (a === 0 && b !== "Setting paranoia=0 will ruin your security; use it only for testing")
              throw new sjcl.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");
            this.D = a;
          },
          addEntropy: function(a, b, c) {
            c = c || "user";
            var d, e, f = new Date().valueOf(), g = this.v[c], k = this.isReady(), l = 0;
            d = this.J[c];
            d === void 0 && (d = this.J[c] = this.T++);
            g === void 0 && (g = this.v[c] = 0);
            this.v[c] = (this.v[c] + 1) % this.c.length;
            switch (typeof a) {
              case "number":
                b === void 0 && (b = 1);
                this.c[g].update([d, this.F++, 1, b, f, 1, a | 0]);
                break;
              case "object":
                c = Object.prototype.toString.call(a);
                if (c === "[object Uint32Array]") {
                  e = [];
                  for (c = 0; c < a.length; c++)
                    e.push(a[c]);
                  a = e;
                } else
                  for (c !== "[object Array]" && (l = 1), c = 0; c < a.length && !l; c++)
                    typeof a[c] !== "number" && (l = 1);
                if (!l) {
                  if (b === void 0)
                    for (c = b = 0; c < a.length; c++)
                      for (e = a[c]; 0 < e; )
                        b++, e = e >>> 1;
                  this.c[g].update([d, this.F++, 2, b, f, a.length].concat(a));
                }
                break;
              case "string":
                b === void 0 && (b = a.length);
                this.c[g].update([d, this.F++, 3, b, f, a.length]);
                this.c[g].update(a);
                break;
              default:
                l = 1;
            }
            if (l)
              throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
            this.i[g] += b;
            this.f += b;
            k === this.m && (this.isReady() !== this.m && A("seeded", Math.max(this.j, this.f)), A("progress", this.getProgress()));
          },
          isReady: function(a) {
            a = this.I[a !== void 0 ? a : this.D];
            return this.j && this.j >= a ? this.i[0] > this.N && new Date().valueOf() > this.L ? this.A | this.w : this.w : this.f >= a ? this.A | this.m : this.m;
          },
          getProgress: function(a) {
            a = this.I[a ? a : this.D];
            return this.j >= a ? 1 : this.f > a ? 1 : this.f / a;
          },
          startCollectors: function() {
            if (!this.s) {
              this.a = {
                loadTimeCollector: B(this, this.V),
                mouseCollector: B(this, this.W),
                keyboardCollector: B(this, this.U),
                accelerometerCollector: B(this, this.R),
                touchCollector: B(this, this.X)
              };
              if (window.addEventListener)
                window.addEventListener("load", this.a.loadTimeCollector, false), window.addEventListener("mousemove", this.a.mouseCollector, false), window.addEventListener("keypress", this.a.keyboardCollector, false), window.addEventListener("devicemotion", this.a.accelerometerCollector, false), window.addEventListener("touchmove", this.a.touchCollector, false);
              else if (document.attachEvent)
                document.attachEvent("onload", this.a.loadTimeCollector), document.attachEvent("onmousemove", this.a.mouseCollector), document.attachEvent("keypress", this.a.keyboardCollector);
              else
                throw new sjcl.exception.bug("can't attach event");
              this.s = true;
            }
          },
          stopCollectors: function() {
            this.s && (window.removeEventListener ? (window.removeEventListener("load", this.a.loadTimeCollector, false), window.removeEventListener("mousemove", this.a.mouseCollector, false), window.removeEventListener("keypress", this.a.keyboardCollector, false), window.removeEventListener("devicemotion", this.a.accelerometerCollector, false), window.removeEventListener("touchmove", this.a.touchCollector, false)) : document.detachEvent && (document.detachEvent("onload", this.a.loadTimeCollector), document.detachEvent("onmousemove", this.a.mouseCollector), document.detachEvent("keypress", this.a.keyboardCollector)), this.s = false);
          },
          addEventListener: function(a, b) {
            this.B[a][this.S++] = b;
          },
          removeEventListener: function(a, b) {
            var c, d, e = this.B[a], f = [];
            for (d in e)
              e.hasOwnProperty(d) && e[d] === b && f.push(d);
            for (c = 0; c < f.length; c++)
              d = f[c], delete e[d];
          },
          U: function() {
            C(this, 1);
          },
          W: function(a) {
            var b, c;
            try {
              b = a.x || a.clientX || a.offsetX || 0, c = a.y || a.clientY || a.offsetY || 0;
            } catch (d) {
              c = b = 0;
            }
            b != 0 && c != 0 && this.addEntropy([b, c], 2, "mouse");
            C(this, 0);
          },
          X: function(a) {
            a = a.touches[0] || a.changedTouches[0];
            this.addEntropy([a.pageX || a.clientX, a.pageY || a.clientY], 1, "touch");
            C(this, 0);
          },
          V: function() {
            C(this, 2);
          },
          R: function(a) {
            a = a.accelerationIncludingGravity.x || a.accelerationIncludingGravity.y || a.accelerationIncludingGravity.z;
            if (window.orientation) {
              var b = window.orientation;
              typeof b === "number" && this.addEntropy(b, 1, "accelerometer");
            }
            a && this.addEntropy(a, 2, "accelerometer");
            C(this, 0);
          }
        };
        function A(a, b) {
          var c, d = sjcl.random.B[a], e = [];
          for (c in d)
            d.hasOwnProperty(c) && e.push(d[c]);
          for (c = 0; c < e.length; c++)
            e[c](b);
        }
        function C(a, b) {
          typeof window !== "undefined" && window.performance && typeof window.performance.now === "function" ? a.addEntropy(window.performance.now(), b, "loadtime") : a.addEntropy(new Date().valueOf(), b, "loadtime");
        }
        function y(a) {
          a.b = z(a).concat(z(a));
          a.C = new sjcl.cipher.aes(a.b);
        }
        function z(a) {
          for (var b = 0; 4 > b && (a.g[b] = a.g[b] + 1 | 0, !a.g[b]); b++)
            ;
          return a.C.encrypt(a.g);
        }
        function B(a, b) {
          return function() {
            b.apply(a, arguments);
          };
        }
        sjcl.random = new sjcl.prng(6);
        a:
          try {
            var D, E, F, G;
            if (G = typeof module2 !== "undefined" && module2.exports) {
              var H;
              try {
                H = _dereq_("crypto");
              } catch (a) {
                H = null;
              }
              G = E = H;
            }
            if (G && E.randomBytes)
              D = E.randomBytes(128), D = new Uint32Array(new Uint8Array(D).buffer), sjcl.random.addEntropy(D, 1024, "crypto['randomBytes']");
            else if (typeof window !== "undefined" && typeof Uint32Array !== "undefined") {
              F = new Uint32Array(32);
              if (window.crypto && window.crypto.getRandomValues)
                window.crypto.getRandomValues(F);
              else if (window.msCrypto && window.msCrypto.getRandomValues)
                window.msCrypto.getRandomValues(F);
              else
                break a;
              sjcl.random.addEntropy(F, 1024, "crypto['getRandomValues']");
            }
          } catch (a) {
            typeof window !== "undefined" && window.console && (console.log("There was an error collecting entropy from the browser:"), console.log(a));
          }
        typeof module2 !== "undefined" && module2.exports && (module2.exports = sjcl);
      }, { "crypto": void 0 }], 101: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          GOOGLE_PAYMENT_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "GOOGLE_PAYMENT_NOT_ENABLED",
            message: "Google Pay is not enabled for this merchant."
          },
          GOOGLE_PAYMENT_GATEWAY_ERROR: {
            code: "GOOGLE_PAYMENT_GATEWAY_ERROR",
            message: "There was an error when tokenizing the Google Pay payment method.",
            type: BraintreeError.types.UNKNOWN
          },
          GOOGLE_PAYMENT_UNSUPPORTED_VERSION: {
            code: "GOOGLE_PAYMENT_UNSUPPORTED_VERSION",
            type: BraintreeError.types.MERCHANT
          }
        };
      }, { "../lib/braintree-error": 124 }], 102: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../lib/analytics");
        var assign2 = _dereq_("../lib/assign").assign;
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var find = _dereq_("../lib/find");
        var generateGooglePayConfiguration = _dereq_("../lib/generate-google-pay-configuration");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var errors = _dereq_("./errors");
        var methods = _dereq_("../lib/methods");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var CREATE_PAYMENT_DATA_REQUEST_METHODS = {
          1: "_createV1PaymentDataRequest",
          2: "_createV2PaymentDataRequest"
        };
        function GooglePayment(options) {
          this._createPromise = options.createPromise;
          this._client = options.client;
          this._useDeferredClient = options.useDeferredClient;
          this._googlePayVersion = options.googlePayVersion || 1;
          this._googleMerchantId = options.googleMerchantId;
          if (this._isUnsupportedGooglePayAPIVersion()) {
            throw new BraintreeError({
              code: errors.GOOGLE_PAYMENT_UNSUPPORTED_VERSION.code,
              message: "The Braintree SDK does not support Google Pay version " + this._googlePayVersion + ". Please upgrade the version of your Braintree SDK and contact support if this error persists.",
              type: errors.GOOGLE_PAYMENT_UNSUPPORTED_VERSION.type
            });
          }
        }
        GooglePayment.prototype._waitForClient = function() {
          if (this._client) {
            return Promise.resolve();
          }
          return this._createPromise.then(function(client) {
            this._client = client;
          }.bind(this));
        };
        GooglePayment.prototype._isUnsupportedGooglePayAPIVersion = function() {
          return !(this._googlePayVersion in CREATE_PAYMENT_DATA_REQUEST_METHODS);
        };
        GooglePayment.prototype._getDefaultConfig = function() {
          if (!this._defaultConfig) {
            this._defaultConfig = generateGooglePayConfiguration(this._client.getConfiguration(), this._googlePayVersion, this._googleMerchantId);
          }
          return this._defaultConfig;
        };
        GooglePayment.prototype._createV1PaymentDataRequest = function(paymentDataRequest) {
          var defaultConfig = this._getDefaultConfig();
          var overrideCardNetworks = paymentDataRequest.cardRequirements && paymentDataRequest.cardRequirements.allowedCardNetworks;
          var defaultConfigCardNetworks = defaultConfig.cardRequirements.allowedCardNetworks;
          var allowedCardNetworks = overrideCardNetworks || defaultConfigCardNetworks;
          paymentDataRequest = assign2({}, defaultConfig, paymentDataRequest);
          paymentDataRequest.cardRequirements.allowedCardNetworks = allowedCardNetworks;
          return paymentDataRequest;
        };
        GooglePayment.prototype._createV2PaymentDataRequest = function(paymentDataRequest) {
          var defaultConfig = this._getDefaultConfig();
          if (paymentDataRequest.allowedPaymentMethods) {
            paymentDataRequest.allowedPaymentMethods.forEach(function(paymentMethod) {
              var defaultPaymentMethod = find(defaultConfig.allowedPaymentMethods, "type", paymentMethod.type);
              if (defaultPaymentMethod) {
                applyDefaultsToPaymentMethodConfiguration(paymentMethod, defaultPaymentMethod);
              }
            });
          }
          paymentDataRequest = assign2({}, defaultConfig, paymentDataRequest);
          return paymentDataRequest;
        };
        GooglePayment.prototype.createPaymentDataRequest = function(overrides) {
          if (!this._useDeferredClient) {
            return this._createPaymentDataRequestSyncronously(overrides);
          }
          return this._waitForClient().then(function() {
            return this._createPaymentDataRequestSyncronously(overrides);
          }.bind(this));
        };
        GooglePayment.prototype._createPaymentDataRequestSyncronously = function(overrides) {
          var paymentDataRequest = assign2({}, overrides);
          var version2 = this._googlePayVersion;
          var createPaymentDataRequestMethod = CREATE_PAYMENT_DATA_REQUEST_METHODS[version2];
          analytics.sendEvent(this._createPromise, "google-payment.v" + version2 + ".createPaymentDataRequest");
          return this[createPaymentDataRequestMethod](paymentDataRequest);
        };
        GooglePayment.prototype.parseResponse = function(response) {
          var self2 = this;
          return Promise.resolve().then(function() {
            var payload;
            var rawResponse = response.apiVersion === 2 ? response.paymentMethodData.tokenizationData.token : response.paymentMethodToken.token;
            var parsedResponse = JSON.parse(rawResponse);
            var error = parsedResponse.error;
            if (error) {
              return Promise.reject(error);
            }
            analytics.sendEvent(self2._createPromise, "google-payment.parseResponse.succeeded");
            if (parsedResponse.paypalAccounts) {
              payload = parsedResponse.paypalAccounts[0];
              analytics.sendEvent(self2._createPromise, "google-payment.parseResponse.succeeded.paypal");
              return Promise.resolve({
                nonce: payload.nonce,
                type: payload.type,
                description: payload.description
              });
            }
            payload = parsedResponse.androidPayCards[0];
            analytics.sendEvent(self2._createPromise, "google-payment.parseResponse.succeeded.google-payment");
            return Promise.resolve({
              nonce: payload.nonce,
              type: payload.type,
              description: payload.description,
              details: {
                cardType: payload.details.cardType,
                lastFour: payload.details.lastFour,
                lastTwo: payload.details.lastTwo,
                isNetworkTokenized: payload.details.isNetworkTokenized,
                bin: payload.details.bin
              },
              binData: payload.binData
            });
          }).catch(function(error) {
            analytics.sendEvent(self2._createPromise, "google-payment.parseResponse.failed");
            return Promise.reject(new BraintreeError({
              code: errors.GOOGLE_PAYMENT_GATEWAY_ERROR.code,
              message: errors.GOOGLE_PAYMENT_GATEWAY_ERROR.message,
              type: errors.GOOGLE_PAYMENT_GATEWAY_ERROR.type,
              details: {
                originalError: error
              }
            }));
          });
        };
        GooglePayment.prototype.teardown = function() {
          convertMethodsToError(this, methods(GooglePayment.prototype));
          return Promise.resolve();
        };
        function applyDefaultsToPaymentMethodConfiguration(merchantSubmittedPaymentMethod, defaultPaymentMethod) {
          Object.keys(defaultPaymentMethod).forEach(function(parameter) {
            if (typeof defaultPaymentMethod[parameter] === "object") {
              merchantSubmittedPaymentMethod[parameter] = assign2({}, defaultPaymentMethod[parameter], merchantSubmittedPaymentMethod[parameter]);
            } else {
              merchantSubmittedPaymentMethod[parameter] = merchantSubmittedPaymentMethod[parameter] || defaultPaymentMethod[parameter];
            }
          });
        }
        module2.exports = wrapPromise.wrapPrototype(GooglePayment);
      }, { "../lib/analytics": 119, "../lib/assign": 121, "../lib/braintree-error": 124, "../lib/convert-methods-to-error": 127, "../lib/find": 137, "../lib/generate-google-pay-configuration": 149, "../lib/methods": 155, "./errors": 101, "@braintree/wrap-promise": 43 }], 103: [function(_dereq_, module2, exports2) {
        var GooglePayment = _dereq_("./google-payment");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var VERSION2 = "3.100.0";
        var errors = _dereq_("./errors");
        function create2(options) {
          var name = "Google Pay";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var createPromise, instance;
            createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            }).then(function(client) {
              var configuration = client.getConfiguration();
              options.client = client;
              if (!configuration.gatewayConfiguration.androidPay) {
                return Promise.reject(new BraintreeError(errors.GOOGLE_PAYMENT_NOT_ENABLED));
              }
              return client;
            });
            options.createPromise = createPromise;
            instance = new GooglePayment(options);
            if (!options.useDeferredClient) {
              return createPromise.then(function(client) {
                instance._client = client;
                return instance;
              });
            }
            return instance;
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./errors": 101, "./google-payment": 102, "@braintree/wrap-promise": 43 }], 104: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var errors = _dereq_("../shared/errors");
        var allowedAttributes = _dereq_("../shared/constants").allowedAttributes;
        function attributeValidationError(attribute, value) {
          var err;
          if (!allowedAttributes.hasOwnProperty(attribute)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED.type,
              code: errors.HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED.code,
              message: 'The "' + attribute + '" attribute is not supported in Hosted Fields.'
            });
          } else if (value != null && !_isValid(attribute, value)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED.type,
              code: errors.HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED.code,
              message: 'Value "' + value + '" is not allowed for "' + attribute + '" attribute.'
            });
          }
          return err;
        }
        function _isValid(attribute, value) {
          if (allowedAttributes[attribute] === "string") {
            return typeof value === "string" || typeof value === "number";
          } else if (allowedAttributes[attribute] === "boolean") {
            return String(value) === "true" || String(value) === "false";
          }
          return false;
        }
        module2.exports = attributeValidationError;
      }, { "../../lib/braintree-error": 124, "../shared/constants": 112, "../shared/errors": 113 }], 105: [function(_dereq_, module2, exports2) {
        var constants = _dereq_("../shared/constants");
        var useMin = _dereq_("../../lib/use-min");
        module2.exports = function composeUrl(assetsUrl, componentId, isDebug) {
          return assetsUrl + "/web/" + constants.VERSION + "/html/hosted-fields-frame" + useMin(isDebug) + ".html#" + componentId;
        };
      }, { "../../lib/use-min": 160, "../shared/constants": 112 }], 106: [function(_dereq_, module2, exports2) {
        var directions = _dereq_("../shared/constants").navigationDirections;
        var browserDetection = _dereq_("../shared/browser-detection");
        var focusIntercept = _dereq_("../shared/focus-intercept");
        var findParentTags = _dereq_("../shared/find-parent-tags");
        var userFocusableTagNames = ["INPUT", "SELECT", "TEXTAREA"];
        var unfocusedInputTypes = [
          "hidden",
          "button",
          "reset",
          "submit",
          "checkbox",
          "radio",
          "file"
        ];
        function _isUserFocusableElement(element) {
          if (!browserDetection.hasSoftwareKeyboard()) {
            return element.type !== "hidden";
          }
          return userFocusableTagNames.indexOf(element.tagName) > -1 && unfocusedInputTypes.indexOf(element.type) < 0;
        }
        function _createNavigationHelper(direction, numberOfElementsInForm) {
          switch (direction) {
            case directions.BACK:
              return {
                checkIndexBounds: function(index) {
                  return index < 0;
                },
                indexChange: -1
              };
            case directions.FORWARD:
              return {
                checkIndexBounds: function(index) {
                  return index > numberOfElementsInForm - 1;
                },
                indexChange: 1
              };
          }
          return {};
        }
        function _findFirstFocusableElement(elementsInForm) {
          var elementsIndex, element;
          for (elementsIndex = 0; elementsIndex < elementsInForm.length; elementsIndex++) {
            element = elementsInForm[elementsIndex];
            if (_isUserFocusableElement(element)) {
              return element;
            }
          }
          return null;
        }
        module2.exports = {
          removeExtraFocusElements: function(checkoutForm, onRemoveFocusIntercepts) {
            var elements = Array.prototype.slice.call(checkoutForm.elements);
            var firstFocusableInput = _findFirstFocusableElement(elements);
            var lastFocusableInput = _findFirstFocusableElement(elements.reverse());
            [firstFocusableInput, lastFocusableInput].forEach(function(input) {
              if (!input) {
                return;
              }
              if (focusIntercept.matchFocusElement(input.getAttribute("id"))) {
                onRemoveFocusIntercepts(input.getAttribute("id"));
              }
            });
          },
          createFocusChangeHandler: function(hostedFieldsId, callbacks) {
            return function(data2) {
              var currentIndex, targetElement, checkoutForm, navHelper;
              var sourceElement = document.getElementById("bt-" + data2.field + "-" + data2.direction + "-" + hostedFieldsId);
              if (!sourceElement) {
                return;
              }
              checkoutForm = findParentTags(sourceElement, "form")[0];
              if (document.forms.length < 1 || !checkoutForm) {
                callbacks.onRemoveFocusIntercepts();
                return;
              }
              checkoutForm = [].slice.call(checkoutForm.elements);
              currentIndex = checkoutForm.indexOf(sourceElement);
              navHelper = _createNavigationHelper(data2.direction, checkoutForm.length);
              do {
                currentIndex += navHelper.indexChange;
                if (navHelper.checkIndexBounds(currentIndex)) {
                  return;
                }
                targetElement = checkoutForm[currentIndex];
              } while (!_isUserFocusableElement(targetElement));
              if (focusIntercept.matchFocusElement(targetElement.getAttribute("id"))) {
                callbacks.onTriggerInputFocus(targetElement.getAttribute("data-braintree-type"));
              } else {
                targetElement.focus();
              }
            };
          }
        };
      }, { "../shared/browser-detection": 111, "../shared/constants": 112, "../shared/find-parent-tags": 114, "../shared/focus-intercept": 115 }], 107: [function(_dereq_, module2, exports2) {
        var allowedStyles = _dereq_("../shared/constants").allowedStyles;
        module2.exports = function getStylesFromClass(cssClass) {
          var element = document.createElement("input");
          var styles = {};
          var computedStyles;
          if (cssClass[0] === ".") {
            cssClass = cssClass.substring(1);
          }
          element.className = cssClass;
          element.style.display = "none !important";
          element.style.position = "fixed !important";
          element.style.left = "-99999px !important";
          element.style.top = "-99999px !important";
          document.body.appendChild(element);
          computedStyles = window.getComputedStyle(element);
          allowedStyles.forEach(function(style) {
            var value = computedStyles[style];
            if (value) {
              styles[style] = value;
            }
          });
          document.body.removeChild(element);
          return styles;
        };
      }, { "../shared/constants": 112 }], 108: [function(_dereq_, module2, exports2) {
        var assign2 = _dereq_("../../lib/assign").assign;
        var createAssetsUrl = _dereq_("../../lib/create-assets-url");
        var isVerifiedDomain = _dereq_("../../lib/is-verified-domain");
        var Destructor = _dereq_("../../lib/destructor");
        var iFramer = _dereq_("@braintree/iframer");
        var Bus = _dereq_("framebus");
        var createDeferredClient = _dereq_("../../lib/create-deferred-client");
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var composeUrl = _dereq_("./compose-url");
        var getStylesFromClass = _dereq_("./get-styles-from-class");
        var constants = _dereq_("../shared/constants");
        var errors = _dereq_("../shared/errors");
        var INTEGRATION_TIMEOUT_MS = _dereq_("../../lib/constants").INTEGRATION_TIMEOUT_MS;
        var uuid = _dereq_("@braintree/uuid");
        var findParentTags = _dereq_("../shared/find-parent-tags");
        var browserDetection = _dereq_("../shared/browser-detection");
        var events = constants.events;
        var EventEmitter = _dereq_("@braintree/event-emitter");
        var injectFrame = _dereq_("./inject-frame");
        var analytics = _dereq_("../../lib/analytics");
        var allowedFields = constants.allowedFields;
        var methods = _dereq_("../../lib/methods");
        var shadow = _dereq_("../../lib/shadow");
        var findRootNode = _dereq_("../../lib/find-root-node");
        var convertMethodsToError = _dereq_("../../lib/convert-methods-to-error");
        var sharedErrors = _dereq_("../../lib/errors");
        var getCardTypes = _dereq_("../shared/get-card-types");
        var attributeValidationError = _dereq_("./attribute-validation-error");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var focusChange = _dereq_("./focus-change");
        var destroyFocusIntercept = _dereq_("../shared/focus-intercept").destroy;
        var SAFARI_FOCUS_TIMEOUT = 5;
        function createInputEventHandler(fields) {
          return function(eventData) {
            var field;
            var merchantPayload = eventData.merchantPayload;
            var emittedBy = merchantPayload.emittedBy;
            var container = fields[emittedBy].containerElement;
            Object.keys(merchantPayload.fields).forEach(function(key) {
              merchantPayload.fields[key].container = fields[key].containerElement;
            });
            field = merchantPayload.fields[emittedBy];
            container.classList.toggle(constants.externalClasses.FOCUSED, field.isFocused);
            container.classList.toggle(constants.externalClasses.VALID, field.isValid);
            container.classList.toggle(constants.externalClasses.INVALID, !field.isPotentiallyValid);
            this._state = {
              cards: merchantPayload.cards,
              fields: merchantPayload.fields
            };
            this._emit(eventData.type, merchantPayload);
          };
        }
        function isVisibleEnough(node) {
          var boundingBox = node.getBoundingClientRect();
          var verticalMidpoint = Math.floor(boundingBox.height / 2);
          var horizontalMidpoint = Math.floor(boundingBox.width / 2);
          return boundingBox.top < (window.innerHeight - verticalMidpoint || document.documentElement.clientHeight - verticalMidpoint) && boundingBox.right > horizontalMidpoint && boundingBox.bottom > verticalMidpoint && boundingBox.left < (window.innerWidth - horizontalMidpoint || document.documentElement.clientWidth - horizontalMidpoint);
        }
        function HostedFields(options) {
          var failureTimeout, clientConfig, assetsUrl, isDebug, hostedFieldsUrl;
          var self2 = this;
          var fields = {};
          var frameReadyPromiseResolveFunctions = {};
          var frameReadyPromises = [];
          var componentId = uuid();
          this._merchantConfigurationOptions = assign2({}, options);
          if (options.client) {
            clientConfig = options.client.getConfiguration();
            assetsUrl = clientConfig.gatewayConfiguration.assetsUrl;
            isDebug = clientConfig.isDebug;
          } else {
            assetsUrl = createAssetsUrl.create(options.authorization);
            isDebug = Boolean(options.isDebug);
          }
          this._clientPromise = createDeferredClient.create({
            client: options.client,
            authorization: options.authorization,
            debug: isDebug,
            assetsUrl,
            name: "Hosted Fields"
          });
          hostedFieldsUrl = composeUrl(assetsUrl, componentId, isDebug);
          if (!options.fields || Object.keys(options.fields).length === 0) {
            throw new BraintreeError({
              type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
              code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
              message: "options.fields is required when instantiating Hosted Fields."
            });
          }
          EventEmitter.call(this);
          this._injectedNodes = [];
          this._destructor = new Destructor();
          this._fields = fields;
          this._state = {
            fields: {},
            cards: getCardTypes("")
          };
          this._bus = new Bus({
            channel: componentId,
            verifyDomain: isVerifiedDomain,
            targetFrames: [window]
          });
          this._destructor.registerFunctionForTeardown(function() {
            self2._bus.teardown();
          });
          if (!options.client) {
            analytics.sendEvent(this._clientPromise, "custom.hosted-fields.initialized.deferred-client");
          } else {
            analytics.sendEvent(this._clientPromise, "custom.hosted-fields.initialized");
          }
          Object.keys(options.fields).forEach(function(key) {
            var field, externalContainer, internalContainer, frame, frameReadyPromise;
            if (!constants.allowedFields.hasOwnProperty(key)) {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_INVALID_FIELD_KEY.type,
                code: errors.HOSTED_FIELDS_INVALID_FIELD_KEY.code,
                message: '"' + key + '" is not a valid field.'
              });
            }
            field = options.fields[key];
            externalContainer = field.container || field.selector;
            if (typeof externalContainer === "string") {
              externalContainer = document.querySelector(externalContainer);
            }
            if (!externalContainer || externalContainer.nodeType !== 1) {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.type,
                code: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.code,
                message: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.message,
                details: {
                  fieldSelector: field.selector,
                  fieldContainer: field.container,
                  fieldKey: key
                }
              });
            } else if (externalContainer.querySelector('iframe[name^="braintree-"]')) {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.type,
                code: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.code,
                message: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.message,
                details: {
                  fieldSelector: field.selector,
                  fieldContainer: field.container,
                  fieldKey: key
                }
              });
            }
            internalContainer = externalContainer;
            if (shadow.isShadowElement(internalContainer)) {
              internalContainer = shadow.transformToSlot(internalContainer, "height: 100%");
            }
            if (field.maxlength && typeof field.maxlength !== "number") {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.type,
                code: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.code,
                message: "The value for maxlength must be a number.",
                details: {
                  fieldKey: key
                }
              });
            }
            if (field.minlength && typeof field.minlength !== "number") {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.type,
                code: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.code,
                message: "The value for minlength must be a number.",
                details: {
                  fieldKey: key
                }
              });
            }
            frame = iFramer({
              type: key,
              name: "braintree-hosted-field-" + key,
              style: constants.defaultIFrameStyle,
              title: field.iframeTitle || "Secure Credit Card Frame - " + constants.allowedFields[key].label
            });
            this._bus.addTargetFrame(frame);
            this._injectedNodes.push.apply(this._injectedNodes, injectFrame(componentId, frame, internalContainer, function() {
              self2.focus(key);
            }));
            this._setupLabelFocus(key, externalContainer);
            fields[key] = {
              frameElement: frame,
              containerElement: externalContainer
            };
            frameReadyPromise = new Promise(function(resolve2) {
              frameReadyPromiseResolveFunctions[key] = resolve2;
            });
            frameReadyPromises.push(frameReadyPromise);
            this._state.fields[key] = {
              isEmpty: true,
              isValid: false,
              isPotentiallyValid: true,
              isFocused: false,
              container: externalContainer
            };
            setTimeout(function() {
              frame.src = hostedFieldsUrl;
            }, 0);
          }.bind(this));
          if (this._merchantConfigurationOptions.styles) {
            Object.keys(this._merchantConfigurationOptions.styles).forEach(function(selector) {
              var className = self2._merchantConfigurationOptions.styles[selector];
              if (typeof className === "string") {
                self2._merchantConfigurationOptions.styles[selector] = getStylesFromClass(className);
              }
            });
          }
          this._bus.on(events.REMOVE_FOCUS_INTERCEPTS, function(data2) {
            destroyFocusIntercept(data2 && data2.id);
          });
          this._bus.on(events.TRIGGER_FOCUS_CHANGE, focusChange.createFocusChangeHandler(componentId, {
            onRemoveFocusIntercepts: function(element) {
              self2._bus.emit(events.REMOVE_FOCUS_INTERCEPTS, {
                id: element
              });
            },
            onTriggerInputFocus: function(targetType) {
              self2.focus(targetType);
            }
          }));
          this._bus.on(events.READY_FOR_CLIENT, function(reply) {
            self2._clientPromise.then(function(client) {
              reply(client);
            });
          });
          this._bus.on(events.CARD_FORM_ENTRY_HAS_BEGUN, function() {
            analytics.sendEvent(self2._clientPromise, "hosted-fields.input.started");
          });
          this._bus.on(events.BIN_AVAILABLE, function(bin) {
            self2._emit("binAvailable", {
              bin
            });
          });
          failureTimeout = setTimeout(function() {
            analytics.sendEvent(self2._clientPromise, "custom.hosted-fields.load.timed-out");
            self2._emit("timeout");
          }, INTEGRATION_TIMEOUT_MS);
          Promise.all(frameReadyPromises).then(function(results) {
            var reply = results[0];
            clearTimeout(failureTimeout);
            reply(formatMerchantConfigurationForIframes(self2._merchantConfigurationOptions));
            self2._cleanUpFocusIntercepts();
            self2._emit("ready");
          });
          this._bus.on(events.FRAME_READY, function(data2, reply) {
            frameReadyPromiseResolveFunctions[data2.field](reply);
          });
          this._bus.on(events.INPUT_EVENT, createInputEventHandler(fields).bind(this));
          this._destructor.registerFunctionForTeardown(function() {
            var j, node, parent;
            for (j = 0; j < self2._injectedNodes.length; j++) {
              node = self2._injectedNodes[j];
              parent = node.parentNode;
              parent.removeChild(node);
              parent.classList.remove(constants.externalClasses.FOCUSED, constants.externalClasses.INVALID, constants.externalClasses.VALID);
            }
          });
          this._destructor.registerFunctionForTeardown(function() {
            destroyFocusIntercept();
          });
          this._destructor.registerFunctionForTeardown(function() {
            var methodNames = methods(HostedFields.prototype).concat(methods(EventEmitter.prototype));
            convertMethodsToError(self2, methodNames);
          });
        }
        EventEmitter.createChild(HostedFields);
        HostedFields.prototype._setupLabelFocus = function(type, container) {
          var labels, i;
          var self2 = this;
          var rootNode = findRootNode(container);
          if (container.id == null) {
            return;
          }
          function triggerFocus() {
            self2.focus(type);
          }
          labels = Array.prototype.slice.call(document.querySelectorAll('label[for="' + container.id + '"]'));
          if (rootNode !== document) {
            labels = labels.concat(Array.prototype.slice.call(rootNode.querySelectorAll('label[for="' + container.id + '"]')));
          }
          labels = labels.concat(findParentTags(container, "label"));
          labels = labels.filter(function(label, index, arr) {
            return arr.indexOf(label) === index;
          });
          for (i = 0; i < labels.length; i++) {
            labels[i].addEventListener("click", triggerFocus, false);
          }
          this._destructor.registerFunctionForTeardown(function() {
            for (i = 0; i < labels.length; i++) {
              labels[i].removeEventListener("click", triggerFocus, false);
            }
          });
        };
        HostedFields.prototype._getAnyFieldContainer = function() {
          var self2 = this;
          return Object.keys(this._fields).reduce(function(found, field) {
            return found || self2._fields[field].containerElement;
          }, null);
        };
        HostedFields.prototype._cleanUpFocusIntercepts = function() {
          var iframeContainer, checkoutForm;
          if (document.forms.length < 1) {
            this._bus.emit(events.REMOVE_FOCUS_INTERCEPTS);
          } else {
            iframeContainer = this._getAnyFieldContainer();
            checkoutForm = findParentTags(iframeContainer, "form")[0];
            if (checkoutForm) {
              focusChange.removeExtraFocusElements(checkoutForm, function(id) {
                this._bus.emit(events.REMOVE_FOCUS_INTERCEPTS, {
                  id
                });
              }.bind(this));
            } else {
              this._bus.emit(events.REMOVE_FOCUS_INTERCEPTS);
            }
          }
        };
        HostedFields.prototype._attachInvalidFieldContainersToError = function(err) {
          if (!(err.details && err.details.invalidFieldKeys && err.details.invalidFieldKeys.length > 0)) {
            return;
          }
          err.details.invalidFields = {};
          err.details.invalidFieldKeys.forEach(function(field) {
            err.details.invalidFields[field] = this._fields[field].containerElement;
          }.bind(this));
        };
        HostedFields.prototype.getChallenges = function() {
          return this._clientPromise.then(function(client) {
            return client.getConfiguration().gatewayConfiguration.challenges;
          });
        };
        HostedFields.prototype.getSupportedCardTypes = function() {
          return this._clientPromise.then(function(client) {
            var cards = client.getConfiguration().gatewayConfiguration.creditCards.supportedCardTypes.map(function(cardType) {
              if (cardType === "MasterCard") {
                return "Mastercard";
              }
              return cardType;
            });
            return cards;
          });
        };
        HostedFields.prototype.teardown = function() {
          var self2 = this;
          return new Promise(function(resolve2, reject) {
            self2._destructor.teardown(function(err) {
              analytics.sendEvent(self2._clientPromise, "custom.hosted-fields.teardown-completed");
              if (err) {
                reject(err);
              } else {
                resolve2();
              }
            });
          });
        };
        HostedFields.prototype.tokenize = function(options) {
          var self2 = this;
          if (!options) {
            options = {};
          }
          return new Promise(function(resolve2, reject) {
            self2._bus.emit(events.TOKENIZATION_REQUEST, options, function(response) {
              var err = response[0];
              var payload = response[1];
              if (err) {
                self2._attachInvalidFieldContainersToError(err);
                reject(new BraintreeError(err));
              } else {
                resolve2(payload);
              }
            });
          });
        };
        HostedFields.prototype.addClass = function(field, classname) {
          var err;
          if (!allowedFields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + field + '" is not a valid field. You must use a valid field option when adding a class.'
            });
          } else if (!this._fields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot add class to "' + field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            this._bus.emit(events.ADD_CLASS, {
              field,
              classname
            });
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.removeClass = function(field, classname) {
          var err;
          if (!allowedFields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + field + '" is not a valid field. You must use a valid field option when removing a class.'
            });
          } else if (!this._fields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot remove class from "' + field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            this._bus.emit(events.REMOVE_CLASS, {
              field,
              classname
            });
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.setAttribute = function(options) {
          var attributeErr, err;
          if (!allowedFields.hasOwnProperty(options.field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + options.field + '" is not a valid field. You must use a valid field option when setting an attribute.'
            });
          } else if (!this._fields.hasOwnProperty(options.field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot set attribute for "' + options.field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            attributeErr = attributeValidationError(options.attribute, options.value);
            if (attributeErr) {
              err = attributeErr;
            } else {
              this._bus.emit(events.SET_ATTRIBUTE, {
                field: options.field,
                attribute: options.attribute,
                value: options.value
              });
            }
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.setMonthOptions = function(options) {
          var self2 = this;
          var merchantOptions = this._merchantConfigurationOptions.fields;
          var errorMessage;
          if (!merchantOptions.expirationMonth) {
            errorMessage = "Expiration month field must exist to use setMonthOptions.";
          } else if (!merchantOptions.expirationMonth.select) {
            errorMessage = "Expiration month field must be a select element.";
          }
          if (errorMessage) {
            return Promise.reject(new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.code,
              message: errorMessage
            }));
          }
          return new Promise(function(resolve2) {
            self2._bus.emit(events.SET_MONTH_OPTIONS, options, resolve2);
          });
        };
        HostedFields.prototype.setMessage = function(options) {
          this._bus.emit(events.SET_MESSAGE, {
            field: options.field,
            message: options.message
          });
        };
        HostedFields.prototype.removeAttribute = function(options) {
          var attributeErr, err;
          if (!allowedFields.hasOwnProperty(options.field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + options.field + '" is not a valid field. You must use a valid field option when removing an attribute.'
            });
          } else if (!this._fields.hasOwnProperty(options.field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot remove attribute for "' + options.field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            attributeErr = attributeValidationError(options.attribute);
            if (attributeErr) {
              err = attributeErr;
            } else {
              this._bus.emit(events.REMOVE_ATTRIBUTE, {
                field: options.field,
                attribute: options.attribute
              });
            }
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.setPlaceholder = function(field, placeholder) {
          return this.setAttribute({
            field,
            attribute: "placeholder",
            value: placeholder
          });
        };
        HostedFields.prototype.clear = function(field) {
          var err;
          if (!allowedFields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + field + '" is not a valid field. You must use a valid field option when clearing a field.'
            });
          } else if (!this._fields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot clear "' + field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            this._bus.emit(events.CLEAR_FIELD, {
              field
            });
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.focus = function(field) {
          var err;
          var fieldConfig = this._fields[field];
          if (!allowedFields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + field + '" is not a valid field. You must use a valid field option when focusing a field.'
            });
          } else if (!this._fields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot focus "' + field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            fieldConfig.frameElement.focus();
            this._bus.emit(events.TRIGGER_INPUT_FOCUS, {
              field
            });
            if (browserDetection.isIos()) {
              setTimeout(function() {
                if (!isVisibleEnough(fieldConfig.containerElement)) {
                  fieldConfig.containerElement.scrollIntoView();
                }
              }, SAFARI_FOCUS_TIMEOUT);
            }
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.getState = function() {
          return this._state;
        };
        function formatMerchantConfigurationForIframes(config) {
          var formattedConfig = assign2({}, config);
          formattedConfig.fields = assign2({}, formattedConfig.fields);
          Object.keys(formattedConfig.fields).forEach(function(field) {
            formattedConfig.fields[field] = assign2({}, formattedConfig.fields[field]);
            delete formattedConfig.fields[field].container;
          });
          return formattedConfig;
        }
        module2.exports = wrapPromise.wrapPrototype(HostedFields);
      }, { "../../lib/analytics": 119, "../../lib/assign": 121, "../../lib/braintree-error": 124, "../../lib/constants": 126, "../../lib/convert-methods-to-error": 127, "../../lib/create-assets-url": 129, "../../lib/create-deferred-client": 131, "../../lib/destructor": 133, "../../lib/errors": 135, "../../lib/find-root-node": 136, "../../lib/is-verified-domain": 153, "../../lib/methods": 155, "../../lib/shadow": 158, "../shared/browser-detection": 111, "../shared/constants": 112, "../shared/errors": 113, "../shared/find-parent-tags": 114, "../shared/focus-intercept": 115, "../shared/get-card-types": 116, "./attribute-validation-error": 104, "./compose-url": 105, "./focus-change": 106, "./get-styles-from-class": 107, "./inject-frame": 109, "@braintree/event-emitter": 33, "@braintree/iframer": 35, "@braintree/uuid": 39, "@braintree/wrap-promise": 43, "framebus": 52 }], 109: [function(_dereq_, module2, exports2) {
        var focusIntercept = _dereq_("../shared/focus-intercept");
        var directions = _dereq_("../shared/constants").navigationDirections;
        module2.exports = function injectFrame(id, frame, container, focusHandler) {
          var frameType = frame.getAttribute("type");
          var clearboth = document.createElement("div");
          var fragment = document.createDocumentFragment();
          var focusInterceptBefore = focusIntercept.generate(id, frameType, directions.BACK, focusHandler);
          var focusInterceptAfter = focusIntercept.generate(id, frameType, directions.FORWARD, focusHandler);
          clearboth.style.clear = "both";
          fragment.appendChild(focusInterceptBefore);
          fragment.appendChild(frame);
          fragment.appendChild(focusInterceptAfter);
          fragment.appendChild(clearboth);
          container.appendChild(fragment);
          return [frame, clearboth];
        };
      }, { "../shared/constants": 112, "../shared/focus-intercept": 115 }], 110: [function(_dereq_, module2, exports2) {
        var HostedFields = _dereq_("./external/hosted-fields");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var errors = _dereq_("./shared/errors");
        var supportsInputFormatting = _dereq_("restricted-input/supports-input-formatting");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var VERSION2 = "3.100.0";
        function create2(options) {
          return basicComponentVerification.verify({
            name: "Hosted Fields",
            authorization: options.authorization,
            client: options.client
          }).then(function() {
            var integration = new HostedFields(options);
            return new Promise(function(resolve2, reject) {
              integration.on("ready", function() {
                resolve2(integration);
              });
              integration.on("timeout", function() {
                reject(new BraintreeError(errors.HOSTED_FIELDS_TIMEOUT));
              });
            });
          });
        }
        module2.exports = {
          supportsInputFormatting,
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "./external/hosted-fields": 108, "./shared/errors": 113, "@braintree/wrap-promise": 43, "restricted-input/supports-input-formatting": 71 }], 111: [function(_dereq_, module2, exports2) {
        var isAndroid = _dereq_("@braintree/browser-detection/is-android");
        var isChromeOS = _dereq_("@braintree/browser-detection/is-chrome-os");
        var isIos = _dereq_("@braintree/browser-detection/is-ios");
        var isChrome = _dereq_("@braintree/browser-detection/is-chrome");
        function hasSoftwareKeyboard() {
          return isAndroid() || isChromeOS() || isIos();
        }
        function isChromeIos() {
          return isChrome() && isIos();
        }
        module2.exports = {
          isAndroid,
          isChromeOS,
          isChromeIos,
          isFirefox: _dereq_("@braintree/browser-detection/is-firefox"),
          isIos,
          isIosWebview: _dereq_("@braintree/browser-detection/is-ios-webview"),
          hasSoftwareKeyboard
        };
      }, { "@braintree/browser-detection/is-android": 22, "@braintree/browser-detection/is-chrome": 24, "@braintree/browser-detection/is-chrome-os": 23, "@braintree/browser-detection/is-firefox": 25, "@braintree/browser-detection/is-ios": 30, "@braintree/browser-detection/is-ios-webview": 28 }], 112: [function(_dereq_, module2, exports2) {
        var enumerate = _dereq_("../../lib/enumerate");
        var errors = _dereq_("./errors");
        var VERSION2 = "3.100.0";
        var constants = {
          VERSION: VERSION2,
          maxExpirationYearAge: 19,
          externalEvents: {
            FOCUS: "focus",
            BLUR: "blur",
            EMPTY: "empty",
            NOT_EMPTY: "notEmpty",
            VALIDITY_CHANGE: "validityChange",
            CARD_TYPE_CHANGE: "cardTypeChange"
          },
          defaultMaxLengths: {
            number: 19,
            postalCode: 8,
            expirationDate: 7,
            expirationMonth: 2,
            expirationYear: 4,
            cvv: 3
          },
          externalClasses: {
            FOCUSED: "braintree-hosted-fields-focused",
            INVALID: "braintree-hosted-fields-invalid",
            VALID: "braintree-hosted-fields-valid"
          },
          navigationDirections: {
            BACK: "before",
            FORWARD: "after"
          },
          defaultIFrameStyle: {
            border: "none",
            width: "100%",
            height: "100%",
            float: "left"
          },
          tokenizationErrorCodes: {
            81724: errors.HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE,
            81736: errors.HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED
          },
          allowedStyles: [
            "-moz-appearance",
            "-moz-box-shadow",
            "-moz-osx-font-smoothing",
            "-moz-tap-highlight-color",
            "-moz-transition",
            "-webkit-appearance",
            "-webkit-box-shadow",
            "-webkit-font-smoothing",
            "-webkit-tap-highlight-color",
            "-webkit-transition",
            "appearance",
            "box-shadow",
            "color",
            "direction",
            "font",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-variant-alternates",
            "font-variant-caps",
            "font-variant-east-asian",
            "font-variant-ligatures",
            "font-variant-numeric",
            "font-weight",
            "letter-spacing",
            "line-height",
            "margin",
            "margin-top",
            "margin-right",
            "margin-bottom",
            "margin-left",
            "opacity",
            "outline",
            "padding",
            "padding-top",
            "padding-right",
            "padding-bottom",
            "padding-left",
            "text-align",
            "text-shadow",
            "transition"
          ],
          allowedFields: {
            cardholderName: {
              name: "cardholder-name",
              label: "Cardholder Name"
            },
            number: {
              name: "credit-card-number",
              label: "Credit Card Number"
            },
            cvv: {
              name: "cvv",
              label: "CVV"
            },
            expirationDate: {
              name: "expiration",
              label: "Expiration Date"
            },
            expirationMonth: {
              name: "expiration-month",
              label: "Expiration Month"
            },
            expirationYear: {
              name: "expiration-year",
              label: "Expiration Year"
            },
            postalCode: {
              name: "postal-code",
              label: "Postal Code"
            }
          },
          allowedAttributes: {
            "aria-invalid": "boolean",
            "aria-required": "boolean",
            disabled: "boolean",
            placeholder: "string"
          },
          autocompleteMappings: {
            "cardholder-name": "cc-name",
            "credit-card-number": "cc-number",
            expiration: "cc-exp",
            "expiration-month": "cc-exp-month",
            "expiration-year": "cc-exp-year",
            cvv: "cc-csc",
            "postal-code": "billing postal-code"
          }
        };
        constants.events = enumerate([
          "ADD_CLASS",
          "AUTOFILL_DATA_AVAILABLE",
          "BIN_AVAILABLE",
          "CARD_FORM_ENTRY_HAS_BEGUN",
          "CLEAR_FIELD",
          "CONFIGURATION",
          "FRAME_READY",
          "INPUT_EVENT",
          "READY_FOR_CLIENT",
          "REMOVE_ATTRIBUTE",
          "REMOVE_CLASS",
          "REMOVE_FOCUS_INTERCEPTS",
          "SET_ATTRIBUTE",
          "SET_MESSAGE",
          "SET_MONTH_OPTIONS",
          "TOKENIZATION_REQUEST",
          "TRIGGER_FOCUS_CHANGE",
          "TRIGGER_INPUT_FOCUS",
          "VALIDATE_STRICT"
        ], "hosted-fields:");
        module2.exports = constants;
      }, { "../../lib/enumerate": 134, "./errors": 113 }], 113: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          HOSTED_FIELDS_TIMEOUT: {
            type: BraintreeError.types.UNKNOWN,
            code: "HOSTED_FIELDS_TIMEOUT",
            message: "Hosted Fields timed out when attempting to set up."
          },
          HOSTED_FIELDS_INVALID_FIELD_KEY: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_INVALID_FIELD_KEY"
          },
          HOSTED_FIELDS_INVALID_FIELD_SELECTOR: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_INVALID_FIELD_SELECTOR",
            message: "Selector does not reference a valid DOM node."
          },
          HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME",
            message: "Element already contains a Braintree iframe."
          },
          HOSTED_FIELDS_FIELD_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_FIELD_INVALID"
          },
          HOSTED_FIELDS_FIELD_NOT_PRESENT: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_FIELD_NOT_PRESENT"
          },
          HOSTED_FIELDS_TOKENIZATION_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "HOSTED_FIELDS_TOKENIZATION_NETWORK_ERROR",
            message: "A tokenization network error occurred."
          },
          HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE",
            message: "This credit card already exists in the merchant's vault."
          },
          HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED",
            message: "CVV verification failed during tokenization."
          },
          HOSTED_FIELDS_FAILED_TOKENIZATION: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_FAILED_TOKENIZATION",
            message: "The supplied card data failed tokenization."
          },
          HOSTED_FIELDS_FIELDS_EMPTY: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_FIELDS_EMPTY",
            message: "All fields are empty. Cannot tokenize empty card fields."
          },
          HOSTED_FIELDS_FIELDS_INVALID: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_FIELDS_INVALID",
            message: "Some payment input fields are invalid. Cannot tokenize invalid card fields."
          },
          HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED"
          },
          HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED"
          },
          HOSTED_FIELDS_FIELD_PROPERTY_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_FIELD_PROPERTY_INVALID"
          }
        };
      }, { "../../lib/braintree-error": 124 }], 114: [function(_dereq_, module2, exports2) {
        function findParentTags(element, tag) {
          var parent = element.parentNode;
          var parents = [];
          while (parent != null) {
            if (parent.tagName != null && parent.tagName.toLowerCase() === tag) {
              parents.push(parent);
            }
            parent = parent.parentNode;
          }
          return parents;
        }
        module2.exports = findParentTags;
      }, {}], 115: [function(_dereq_, module2, exports2) {
        var browserDetection = _dereq_("./browser-detection");
        var constants = _dereq_("./constants");
        var allowedFields = Object.keys(constants.allowedFields);
        var directions = constants.navigationDirections;
        var focusIntercept = {
          generate: function(hostedFieldsId, type, direction, handler) {
            var input = document.createElement("input");
            var focusInterceptStyles = {
              border: "none !important",
              display: "block !important",
              height: "1px !important",
              left: "-1px !important",
              opacity: "0 !important",
              position: "absolute !important",
              top: "-1px !important",
              width: "1px !important"
            };
            var shouldCreateFocusIntercept = browserDetection.hasSoftwareKeyboard() || browserDetection.isFirefox();
            if (!shouldCreateFocusIntercept) {
              return document.createDocumentFragment();
            }
            input.setAttribute("aria-hidden", "true");
            input.setAttribute("autocomplete", "off");
            input.setAttribute("data-braintree-direction", direction);
            input.setAttribute("data-braintree-type", type);
            input.setAttribute("id", "bt-" + type + "-" + direction + "-" + hostedFieldsId);
            input.setAttribute("style", JSON.stringify(focusInterceptStyles).replace(/[{}"]/g, "").replace(/,/g, ";"));
            input.classList.add("focus-intercept");
            input.addEventListener("focus", function(event) {
              handler(event);
              if (!browserDetection.hasSoftwareKeyboard()) {
                input.blur();
              }
            });
            return input;
          },
          destroy: function(idString) {
            var focusInputs;
            if (!idString) {
              focusInputs = document.querySelectorAll("[data-braintree-direction]");
              focusInputs = [].slice.call(focusInputs);
            } else {
              focusInputs = [document.getElementById(idString)];
            }
            focusInputs.forEach(function(node) {
              if (node && node.nodeType === 1 && focusIntercept.matchFocusElement(node.getAttribute("id"))) {
                node.parentNode.removeChild(node);
              }
            });
          },
          matchFocusElement: function(idString) {
            var idComponents, hasBTPrefix, isAllowedType, isValidDirection;
            if (!idString) {
              return false;
            }
            idComponents = idString.split("-");
            if (idComponents.length < 4) {
              return false;
            }
            hasBTPrefix = idComponents[0] === "bt";
            isAllowedType = allowedFields.indexOf(idComponents[1]) > -1;
            isValidDirection = idComponents[2] === directions.BACK || idComponents[2] === directions.FORWARD;
            return Boolean(hasBTPrefix && isAllowedType && isValidDirection);
          }
        };
        module2.exports = focusIntercept;
      }, { "./browser-detection": 111, "./constants": 112 }], 116: [function(_dereq_, module2, exports2) {
        var creditCardType = _dereq_("credit-card-type");
        module2.exports = function(number2) {
          var results = creditCardType(number2);
          results.forEach(function(card) {
            if (card.type === "mastercard") {
              card.type = "master-card";
            }
          });
          return results;
        };
      }, { "credit-card-type": 44 }], 117: [function(_dereq_, module2, exports2) {
        var americanExpress = _dereq_("./american-express");
        var applePay = _dereq_("./apple-pay");
        var client = _dereq_("./client");
        var dataCollector = _dereq_("./data-collector");
        var hostedFields = _dereq_("./hosted-fields");
        var localPayment = _dereq_("./local-payment");
        var masterpass = _dereq_("./masterpass");
        var paymentRequest = _dereq_("./payment-request");
        var paypal = _dereq_("./paypal");
        var paypalCheckout = _dereq_("./paypal-checkout");
        var googlePayment = _dereq_("./google-payment");
        var sepa2 = _dereq_("./sepa");
        var threeDSecure = _dereq_("./three-d-secure");
        var unionpay = _dereq_("./unionpay");
        var usBankAccount = _dereq_("./us-bank-account");
        var vaultManager = _dereq_("./vault-manager");
        var venmo = _dereq_("./venmo");
        var visaCheckout = _dereq_("./visa-checkout");
        var preferredPaymentMethods = _dereq_("./preferred-payment-methods");
        var VERSION2 = "3.100.0";
        module2.exports = {
          americanExpress,
          applePay,
          client,
          dataCollector,
          hostedFields,
          localPayment,
          masterpass,
          googlePayment,
          paymentRequest,
          paypal,
          paypalCheckout,
          threeDSecure,
          unionpay,
          usBankAccount,
          vaultManager,
          venmo,
          visaCheckout,
          sepa: sepa2,
          preferredPaymentMethods,
          VERSION: VERSION2
        };
      }, { "./american-express": 74, "./apple-pay": 77, "./client": 82, "./data-collector": 98, "./google-payment": 103, "./hosted-fields": 110, "./local-payment": 164, "./masterpass": 167, "./payment-request": 172, "./paypal": 179, "./paypal-checkout": 176, "./preferred-payment-methods": 182, "./sepa": 186, "./three-d-secure": 198, "./unionpay": 202, "./us-bank-account": 208, "./vault-manager": 211, "./venmo": 216, "./visa-checkout": 226 }], 118: [function(_dereq_, module2, exports2) {
        var createAuthorizationData = _dereq_("./create-authorization-data");
        var jsonClone = _dereq_("./json-clone");
        var constants = _dereq_("./constants");
        function addMetadata(configuration, data2) {
          var key;
          var attrs = data2 ? jsonClone(data2) : {};
          var authAttrs = createAuthorizationData(configuration.authorization).attrs;
          var _meta = jsonClone(configuration.analyticsMetadata);
          attrs.braintreeLibraryVersion = constants.BRAINTREE_LIBRARY_VERSION;
          for (key in attrs._meta) {
            if (attrs._meta.hasOwnProperty(key)) {
              _meta[key] = attrs._meta[key];
            }
          }
          attrs._meta = _meta;
          if (authAttrs.tokenizationKey) {
            attrs.tokenizationKey = authAttrs.tokenizationKey;
          } else {
            attrs.authorizationFingerprint = authAttrs.authorizationFingerprint;
          }
          return attrs;
        }
        module2.exports = addMetadata;
      }, { "./constants": 126, "./create-authorization-data": 130, "./json-clone": 154 }], 119: [function(_dereq_, module2, exports2) {
        var constants = _dereq_("./constants");
        var addMetadata = _dereq_("./add-metadata");
        function sendAnalyticsEvent(clientInstanceOrPromise, kind, callback) {
          var timestamp = Date.now();
          return Promise.resolve(clientInstanceOrPromise).then(function(client) {
            var timestampInPromise = Date.now();
            var configuration = client.getConfiguration();
            var request3 = client._request;
            var url = configuration.gatewayConfiguration.analytics.url;
            var data2 = {
              analytics: [
                {
                  kind: constants.ANALYTICS_PREFIX + kind,
                  isAsync: Math.floor(timestampInPromise / 1e3) !== Math.floor(timestamp / 1e3),
                  timestamp
                }
              ]
            };
            request3({
              url,
              method: "post",
              data: addMetadata(configuration, data2),
              timeout: constants.ANALYTICS_REQUEST_TIMEOUT_MS
            }, callback);
          }).catch(function(err) {
            if (callback) {
              callback(err);
            }
          });
        }
        module2.exports = {
          sendEvent: sendAnalyticsEvent
        };
      }, { "./add-metadata": 118, "./constants": 126 }], 120: [function(_dereq_, module2, exports2) {
        var loadScript = _dereq_("@braintree/asset-loader/load-script");
        module2.exports = {
          loadScript
        };
      }, { "@braintree/asset-loader/load-script": 3 }], 121: [function(_dereq_, module2, exports2) {
        var assignNormalized = typeof Object.assign === "function" ? Object.assign : assignPolyfill;
        function assignPolyfill(destination) {
          var i, source2, key;
          for (i = 1; i < arguments.length; i++) {
            source2 = arguments[i];
            for (key in source2) {
              if (source2.hasOwnProperty(key)) {
                destination[key] = source2[key];
              }
            }
          }
          return destination;
        }
        module2.exports = {
          assign: assignNormalized,
          _assign: assignPolyfill
        };
      }, {}], 122: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("./braintree-error");
        var sharedErrors = _dereq_("./errors");
        var VERSION2 = "3.100.0";
        function basicComponentVerification(options) {
          var client, authorization, name;
          if (!options) {
            return Promise.reject(new BraintreeError({
              type: sharedErrors.INVALID_USE_OF_INTERNAL_FUNCTION.type,
              code: sharedErrors.INVALID_USE_OF_INTERNAL_FUNCTION.code,
              message: "Options must be passed to basicComponentVerification function."
            }));
          }
          name = options.name;
          client = options.client;
          authorization = options.authorization;
          if (!client && !authorization) {
            return Promise.reject(new BraintreeError({
              type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
              code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
              message: "options.client is required when instantiating " + name + "."
            }));
          }
          if (!authorization && client.getVersion() !== VERSION2) {
            return Promise.reject(new BraintreeError({
              type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
              code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
              message: "Client (version " + client.getVersion() + ") and " + name + " (version " + VERSION2 + ") components must be from the same SDK version."
            }));
          }
          return Promise.resolve();
        }
        module2.exports = {
          verify: basicComponentVerification
        };
      }, { "./braintree-error": 124, "./errors": 135 }], 123: [function(_dereq_, module2, exports2) {
        var once = _dereq_("./once");
        function call(fn, callback) {
          var isSync = fn.length === 0;
          if (isSync) {
            fn();
            callback(null);
          } else {
            fn(callback);
          }
        }
        module2.exports = function(functions, cb) {
          var i;
          var length = functions.length;
          var remaining = length;
          var callback = once(cb);
          if (length === 0) {
            callback(null);
            return;
          }
          function finish(err) {
            if (err) {
              callback(err);
              return;
            }
            remaining -= 1;
            if (remaining === 0) {
              callback(null);
            }
          }
          for (i = 0; i < length; i++) {
            call(functions[i], finish);
          }
        };
      }, { "./once": 156 }], 124: [function(_dereq_, module2, exports2) {
        var enumerate = _dereq_("./enumerate");
        function BraintreeError(options) {
          if (!BraintreeError.types.hasOwnProperty(options.type)) {
            throw new Error(options.type + " is not a valid type.");
          }
          if (!options.code) {
            throw new Error("Error code required.");
          }
          if (!options.message) {
            throw new Error("Error message required.");
          }
          this.name = "BraintreeError";
          this.code = options.code;
          this.message = options.message;
          this.type = options.type;
          this.details = options.details;
        }
        BraintreeError.prototype = Object.create(Error.prototype);
        BraintreeError.prototype.constructor = BraintreeError;
        BraintreeError.types = enumerate([
          "CUSTOMER",
          "MERCHANT",
          "NETWORK",
          "INTERNAL",
          "UNKNOWN"
        ]);
        BraintreeError.findRootError = function(err) {
          if (err instanceof BraintreeError && err.details && err.details.originalError) {
            return BraintreeError.findRootError(err.details.originalError);
          }
          return err;
        };
        module2.exports = BraintreeError;
      }, { "./enumerate": 134 }], 125: [function(_dereq_, module2, exports2) {
        function transformKey(key) {
          return key.replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1_$2").toLowerCase();
        }
        module2.exports = function(obj) {
          return Object.keys(obj).reduce(function(newObj, key) {
            var transformedKey = transformKey(key);
            newObj[transformedKey] = obj[key];
            return newObj;
          }, {});
        };
      }, {}], 126: [function(_dereq_, module2, exports2) {
        var VERSION2 = "3.100.0";
        var PLATFORM = "web";
        var CLIENT_API_URLS = {
          production: "https://api.braintreegateway.com:443",
          sandbox: "https://api.sandbox.braintreegateway.com:443"
        };
        var ASSETS_URLS = {
          production: "https://assets.braintreegateway.com",
          sandbox: "https://assets.braintreegateway.com"
        };
        var GRAPHQL_URLS = {
          production: "https://payments.braintree-api.com/graphql",
          sandbox: "https://payments.sandbox.braintree-api.com/graphql"
        };
        module2.exports = {
          ANALYTICS_PREFIX: PLATFORM + ".",
          ANALYTICS_REQUEST_TIMEOUT_MS: 2e3,
          ASSETS_URLS,
          CLIENT_API_URLS,
          FRAUDNET_SOURCE: "BRAINTREE_SIGNIN",
          FRAUDNET_FNCLS: "fnparams-dede7cc5-15fd-4c75-a9f4-36c430ee3a99",
          FRAUDNET_URL: "https://c.paypal.com/da/r/fb.js",
          BUS_CONFIGURATION_REQUEST_EVENT: "BUS_CONFIGURATION_REQUEST",
          GRAPHQL_URLS,
          INTEGRATION_TIMEOUT_MS: 6e4,
          VERSION: VERSION2,
          INTEGRATION: "custom",
          SOURCE: "client",
          PLATFORM,
          BRAINTREE_LIBRARY_VERSION: "braintree/" + PLATFORM + "/" + VERSION2
        };
      }, {}], 127: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("./braintree-error");
        var sharedErrors = _dereq_("./errors");
        module2.exports = function(instance, methodNames) {
          methodNames.forEach(function(methodName) {
            instance[methodName] = function() {
              throw new BraintreeError({
                type: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.type,
                code: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.code,
                message: methodName + " cannot be called after teardown."
              });
            };
          });
        };
      }, { "./braintree-error": 124, "./errors": 135 }], 128: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("./braintree-error");
        function convertToBraintreeError(originalErr, btErrorObject) {
          if (originalErr instanceof BraintreeError) {
            return originalErr;
          }
          return new BraintreeError({
            type: btErrorObject.type,
            code: btErrorObject.code,
            message: btErrorObject.message,
            details: {
              originalError: originalErr
            }
          });
        }
        module2.exports = convertToBraintreeError;
      }, { "./braintree-error": 124 }], 129: [function(_dereq_, module2, exports2) {
        var ASSETS_URLS = _dereq_("./constants").ASSETS_URLS;
        function createAssetsUrl(authorization) {
          return ASSETS_URLS.production;
        }
        module2.exports = {
          create: createAssetsUrl
        };
      }, { "./constants": 126 }], 130: [function(_dereq_, module2, exports2) {
        var atob2 = _dereq_("../lib/vendor/polyfill").atob;
        var CLIENT_API_URLS = _dereq_("../lib/constants").CLIENT_API_URLS;
        function _isTokenizationKey(str) {
          return /^[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9_]+$/.test(str);
        }
        function _parseTokenizationKey(tokenizationKey) {
          var tokens = tokenizationKey.split("_");
          var environment = tokens[0];
          var merchantId = tokens.slice(2).join("_");
          return {
            merchantId,
            environment
          };
        }
        function createAuthorizationData(authorization) {
          var parsedClientToken, parsedTokenizationKey;
          var data2 = {
            attrs: {},
            configUrl: ""
          };
          if (_isTokenizationKey(authorization)) {
            parsedTokenizationKey = _parseTokenizationKey(authorization);
            data2.environment = parsedTokenizationKey.environment;
            data2.attrs.tokenizationKey = authorization;
            data2.configUrl = CLIENT_API_URLS[parsedTokenizationKey.environment] + "/merchants/" + parsedTokenizationKey.merchantId + "/client_api/v1/configuration";
          } else {
            parsedClientToken = JSON.parse(atob2(authorization));
            data2.environment = parsedClientToken.environment;
            data2.attrs.authorizationFingerprint = parsedClientToken.authorizationFingerprint;
            data2.configUrl = parsedClientToken.configUrl;
            data2.graphQL = parsedClientToken.graphQL;
          }
          return data2;
        }
        module2.exports = createAuthorizationData;
      }, { "../lib/constants": 126, "../lib/vendor/polyfill": 161 }], 131: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("./braintree-error");
        var assets = _dereq_("./assets");
        var sharedErrors = _dereq_("./errors");
        var VERSION2 = "3.100.0";
        function createDeferredClient(options) {
          var promise = Promise.resolve();
          if (options.client) {
            return Promise.resolve(options.client);
          }
          if (!(window.braintree && window.braintree.client)) {
            promise = assets.loadScript({
              src: options.assetsUrl + "/web/" + VERSION2 + "/js/client.min.js"
            }).catch(function(err) {
              return Promise.reject(new BraintreeError({
                type: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.type,
                code: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.code,
                message: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.message,
                details: {
                  originalError: err
                }
              }));
            });
          }
          return promise.then(function() {
            if (window.braintree.client.VERSION !== VERSION2) {
              return Promise.reject(new BraintreeError({
                type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
                code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
                message: "Client (version " + window.braintree.client.VERSION + ") and " + options.name + " (version " + VERSION2 + ") components must be from the same SDK version."
              }));
            }
            return window.braintree.client.create({
              authorization: options.authorization,
              debug: options.debug
            });
          });
        }
        module2.exports = {
          create: createDeferredClient
        };
      }, { "./assets": 120, "./braintree-error": 124, "./errors": 135 }], 132: [function(_dereq_, module2, exports2) {
        module2.exports = function(fn) {
          return function() {
            var args = arguments;
            setTimeout(function() {
              fn.apply(null, args);
            }, 1);
          };
        };
      }, {}], 133: [function(_dereq_, module2, exports2) {
        var batchExecuteFunctions = _dereq_("./batch-execute-functions");
        function Destructor() {
          this._teardownRegistry = [];
          this._isTearingDown = false;
        }
        Destructor.prototype.registerFunctionForTeardown = function(fn) {
          if (typeof fn === "function") {
            this._teardownRegistry.push(fn);
          }
        };
        Destructor.prototype.teardown = function(callback) {
          if (this._isTearingDown) {
            callback(new Error("Destructor is already tearing down"));
            return;
          }
          this._isTearingDown = true;
          batchExecuteFunctions(this._teardownRegistry, function(err) {
            this._teardownRegistry = [];
            this._isTearingDown = false;
            if (typeof callback === "function") {
              callback(err);
            }
          }.bind(this));
        };
        module2.exports = Destructor;
      }, { "./batch-execute-functions": 123 }], 134: [function(_dereq_, module2, exports2) {
        function enumerate(values, prefix) {
          prefix = prefix == null ? "" : prefix;
          return values.reduce(function(enumeration, value) {
            enumeration[value] = prefix + value;
            return enumeration;
          }, {});
        }
        module2.exports = enumerate;
      }, {}], 135: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("./braintree-error");
        module2.exports = {
          INVALID_USE_OF_INTERNAL_FUNCTION: {
            type: BraintreeError.types.INTERNAL,
            code: "INVALID_USE_OF_INTERNAL_FUNCTION"
          },
          INSTANTIATION_OPTION_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "INSTANTIATION_OPTION_REQUIRED"
          },
          INCOMPATIBLE_VERSIONS: {
            type: BraintreeError.types.MERCHANT,
            code: "INCOMPATIBLE_VERSIONS"
          },
          CLIENT_SCRIPT_FAILED_TO_LOAD: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_SCRIPT_FAILED_TO_LOAD",
            message: "Braintree client script could not be loaded."
          },
          METHOD_CALLED_AFTER_TEARDOWN: {
            type: BraintreeError.types.MERCHANT,
            code: "METHOD_CALLED_AFTER_TEARDOWN"
          }
        };
      }, { "./braintree-error": 124 }], 136: [function(_dereq_, module2, exports2) {
        module2.exports = function findRootNode(element) {
          while (element.parentNode) {
            element = element.parentNode;
          }
          return element;
        };
      }, {}], 137: [function(_dereq_, module2, exports2) {
        module2.exports = function(array, key, value) {
          var i;
          for (i = 0; i < array.length; i++) {
            if (array[i].hasOwnProperty(key) && array[i][key] === value) {
              return array[i];
            }
          }
          return null;
        };
      }, {}], 138: [function(_dereq_, module2, exports2) {
        var Popup = _dereq_("./strategies/popup");
        var PopupBridge = _dereq_("./strategies/popup-bridge");
        var Modal2 = _dereq_("./strategies/modal");
        var Bus = _dereq_("framebus");
        var events = _dereq_("../shared/events");
        var errors = _dereq_("../shared/errors");
        var constants = _dereq_("../shared/constants");
        var uuid = _dereq_("@braintree/uuid");
        var iFramer = _dereq_("@braintree/iframer");
        var BraintreeError = _dereq_("../../braintree-error");
        var browserDetection = _dereq_("../shared/browser-detection");
        var assign2 = _dereq_("./../../assign").assign;
        var BUS_CONFIGURATION_REQUEST_EVENT = _dereq_("../../constants").BUS_CONFIGURATION_REQUEST_EVENT;
        var REQUIRED_CONFIG_KEYS = ["name", "dispatchFrameUrl", "openFrameUrl"];
        function noop2() {
        }
        function _validateFrameConfiguration(options) {
          if (!options) {
            throw new Error("Valid configuration is required");
          }
          REQUIRED_CONFIG_KEYS.forEach(function(key) {
            if (!options.hasOwnProperty(key)) {
              throw new Error("A valid frame " + key + " must be provided");
            }
          });
          if (!/^[\w_]+$/.test(options.name)) {
            throw new Error("A valid frame name must be provided");
          }
        }
        function FrameService(options) {
          _validateFrameConfiguration(options);
          this._serviceId = uuid().replace(/-/g, "");
          this._options = {
            name: options.name + "_" + this._serviceId,
            dispatchFrameUrl: options.dispatchFrameUrl,
            openFrameUrl: options.openFrameUrl,
            height: options.height,
            width: options.width,
            top: options.top,
            left: options.left
          };
          this.state = options.state || {};
          this._bus = new Bus({ channel: this._serviceId });
          this._setBusEvents();
        }
        FrameService.prototype.initialize = function(callback) {
          var dispatchFrameReadyHandler = function() {
            callback();
            this._bus.off(events.DISPATCH_FRAME_READY, dispatchFrameReadyHandler);
          }.bind(this);
          this._bus.on(events.DISPATCH_FRAME_READY, dispatchFrameReadyHandler);
          this._writeDispatchFrame();
        };
        FrameService.prototype._writeDispatchFrame = function() {
          var frameName = constants.DISPATCH_FRAME_NAME + "_" + this._serviceId;
          var frameSrc = this._options.dispatchFrameUrl;
          this._dispatchFrame = iFramer({
            "aria-hidden": true,
            name: frameName,
            title: frameName,
            src: frameSrc,
            class: constants.DISPATCH_FRAME_CLASS,
            height: 0,
            width: 0,
            style: {
              position: "absolute",
              left: "-9999px"
            }
          });
          document.body.appendChild(this._dispatchFrame);
        };
        FrameService.prototype._setBusEvents = function() {
          this._bus.on(events.DISPATCH_FRAME_REPORT, function(res, reply) {
            if (this._onCompleteCallback) {
              this._onCompleteCallback.call(null, res.err, res.payload);
            }
            this._frame.close();
            this._onCompleteCallback = null;
            if (reply) {
              reply();
            }
          }.bind(this));
          this._bus.on(BUS_CONFIGURATION_REQUEST_EVENT, function(reply) {
            reply(this.state);
          }.bind(this));
        };
        FrameService.prototype.open = function(options, callback) {
          options = options || {};
          this._frame = this._getFrameForEnvironment(options);
          this._frame.initialize(callback);
          if (this._frame instanceof PopupBridge) {
            return;
          }
          assign2(this.state, options.state);
          this._onCompleteCallback = callback;
          this._frame.open();
          if (this.isFrameClosed()) {
            this._cleanupFrame();
            if (callback) {
              callback(new BraintreeError(errors.FRAME_SERVICE_FRAME_OPEN_FAILED));
            }
            return;
          }
          this._pollForPopupClose();
        };
        FrameService.prototype.redirect = function(url) {
          if (this._frame && !this.isFrameClosed()) {
            this._frame.redirect(url);
          }
        };
        FrameService.prototype.close = function() {
          if (!this.isFrameClosed()) {
            this._frame.close();
          }
        };
        FrameService.prototype.focus = function() {
          if (!this.isFrameClosed()) {
            this._frame.focus();
          }
        };
        FrameService.prototype.createHandler = function(options) {
          options = options || {};
          return {
            close: function() {
              if (options.beforeClose) {
                options.beforeClose();
              }
              this.close();
            }.bind(this),
            focus: function() {
              if (options.beforeFocus) {
                options.beforeFocus();
              }
              this.focus();
            }.bind(this)
          };
        };
        FrameService.prototype.createNoopHandler = function() {
          return {
            close: noop2,
            focus: noop2
          };
        };
        FrameService.prototype.teardown = function() {
          this.close();
          this._dispatchFrame.parentNode.removeChild(this._dispatchFrame);
          this._dispatchFrame = null;
          this._cleanupFrame();
        };
        FrameService.prototype.isFrameClosed = function() {
          return this._frame == null || this._frame.isClosed();
        };
        FrameService.prototype._cleanupFrame = function() {
          this._frame = null;
          clearInterval(this._popupInterval);
          this._popupInterval = null;
        };
        FrameService.prototype._pollForPopupClose = function() {
          this._popupInterval = setInterval(function() {
            if (this.isFrameClosed()) {
              this._cleanupFrame();
              if (this._onCompleteCallback) {
                this._onCompleteCallback(new BraintreeError(errors.FRAME_SERVICE_FRAME_CLOSED));
              }
            }
          }.bind(this), constants.POPUP_POLL_INTERVAL);
          return this._popupInterval;
        };
        FrameService.prototype._getFrameForEnvironment = function(options) {
          var usePopup = browserDetection.supportsPopups();
          var popupBridgeExists = Boolean(window.popupBridge);
          var initOptions = assign2({}, this._options, options);
          if (popupBridgeExists) {
            return new PopupBridge(initOptions);
          } else if (usePopup) {
            return new Popup(initOptions);
          }
          return new Modal2(initOptions);
        };
        module2.exports = FrameService;
      }, { "../../braintree-error": 124, "../../constants": 126, "../shared/browser-detection": 145, "../shared/constants": 146, "../shared/errors": 147, "../shared/events": 148, "./../../assign": 121, "./strategies/modal": 140, "./strategies/popup": 143, "./strategies/popup-bridge": 141, "@braintree/iframer": 35, "@braintree/uuid": 39, "framebus": 52 }], 139: [function(_dereq_, module2, exports2) {
        var FrameService = _dereq_("./frame-service");
        module2.exports = {
          create: function createFrameService(options, callback) {
            var frameService = new FrameService(options);
            frameService.initialize(function() {
              callback(frameService);
            });
          }
        };
      }, { "./frame-service": 138 }], 140: [function(_dereq_, module2, exports2) {
        var iFramer = _dereq_("@braintree/iframer");
        var assign2 = _dereq_("../../../assign").assign;
        var browserDetection = _dereq_("../../shared/browser-detection");
        var ELEMENT_STYLES = {
          position: "fixed",
          top: 0,
          left: 0,
          bottom: 0,
          padding: 0,
          margin: 0,
          border: 0,
          outline: "none",
          zIndex: 20001,
          background: "#FFFFFF"
        };
        function noop2() {
        }
        function Modal2(options) {
          this._closed = null;
          this._frame = null;
          this._options = options || {};
          this._container = this._options.container || document.body;
        }
        Modal2.prototype.initialize = noop2;
        Modal2.prototype.open = function() {
          var iframerConfig = {
            src: this._options.openFrameUrl,
            name: this._options.name,
            scrolling: "yes",
            height: "100%",
            width: "100%",
            style: assign2({}, ELEMENT_STYLES),
            title: "Lightbox Frame"
          };
          if (browserDetection.isIos()) {
            if (browserDetection.isIosWKWebview()) {
              this._lockScrolling();
              iframerConfig.style = {};
            }
            this._el = document.createElement("div");
            assign2(this._el.style, ELEMENT_STYLES, {
              height: "100%",
              width: "100%",
              overflow: "auto",
              "-webkit-overflow-scrolling": "touch"
            });
            this._frame = iFramer(iframerConfig);
            this._el.appendChild(this._frame);
          } else {
            this._el = this._frame = iFramer(iframerConfig);
          }
          this._closed = false;
          this._container.appendChild(this._el);
        };
        Modal2.prototype.focus = noop2;
        Modal2.prototype.close = function() {
          this._container.removeChild(this._el);
          this._frame = null;
          this._closed = true;
          if (browserDetection.isIosWKWebview()) {
            this._unlockScrolling();
          }
        };
        Modal2.prototype.isClosed = function() {
          return Boolean(this._closed);
        };
        Modal2.prototype.redirect = function(redirectUrl) {
          this._frame.src = redirectUrl;
        };
        Modal2.prototype._unlockScrolling = function() {
          document.body.style.overflow = this._savedBodyProperties.overflowStyle;
          document.body.style.position = this._savedBodyProperties.positionStyle;
          window.scrollTo(this._savedBodyProperties.left, this._savedBodyProperties.top);
          delete this._savedBodyProperties;
        };
        Modal2.prototype._lockScrolling = function() {
          var doc2 = document.documentElement;
          this._savedBodyProperties = {
            left: (window.pageXOffset || doc2.scrollLeft) - (doc2.clientLeft || 0),
            top: (window.pageYOffset || doc2.scrollTop) - (doc2.clientTop || 0),
            overflowStyle: document.body.style.overflow,
            positionStyle: document.body.style.position
          };
          document.body.style.overflow = "hidden";
          document.body.style.position = "fixed";
          window.scrollTo(0, 0);
        };
        module2.exports = Modal2;
      }, { "../../../assign": 121, "../../shared/browser-detection": 145, "@braintree/iframer": 35 }], 141: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../../braintree-error");
        var errors = _dereq_("../../shared/errors");
        function noop2() {
        }
        function PopupBridge(options) {
          this._closed = null;
          this._options = options;
        }
        PopupBridge.prototype.initialize = function(callback) {
          var self2 = this;
          window.popupBridge.onComplete = function(err, payload) {
            var popupDismissed = !payload && !err;
            self2._closed = true;
            if (err || popupDismissed) {
              callback(new BraintreeError(errors.FRAME_SERVICE_FRAME_CLOSED));
              return;
            }
            callback(null, payload);
          };
        };
        PopupBridge.prototype.open = function(options) {
          var url;
          options = options || {};
          url = options.openFrameUrl || this._options.openFrameUrl;
          this._closed = false;
          window.popupBridge.open(url);
        };
        PopupBridge.prototype.focus = noop2;
        PopupBridge.prototype.close = noop2;
        PopupBridge.prototype.isClosed = function() {
          return Boolean(this._closed);
        };
        PopupBridge.prototype.redirect = function(redirectUrl) {
          this.open({ openFrameUrl: redirectUrl });
        };
        module2.exports = PopupBridge;
      }, { "../../../braintree-error": 124, "../../shared/errors": 147 }], 142: [function(_dereq_, module2, exports2) {
        var constants = _dereq_("../../../shared/constants");
        var position = _dereq_("./position");
        function calculatePosition(type, userDefinedPosition, size2) {
          if (typeof userDefinedPosition !== "undefined") {
            return userDefinedPosition;
          }
          return position[type](size2);
        }
        module2.exports = function composePopupOptions(options) {
          var height = options.height || constants.DEFAULT_POPUP_HEIGHT;
          var width = options.width || constants.DEFAULT_POPUP_WIDTH;
          var top = calculatePosition("top", options.top, height);
          var left = calculatePosition("left", options.left, width);
          return [
            constants.POPUP_BASE_OPTIONS,
            "height=" + height,
            "width=" + width,
            "top=" + top,
            "left=" + left
          ].join(",");
        };
      }, { "../../../shared/constants": 146, "./position": 144 }], 143: [function(_dereq_, module2, exports2) {
        var composeOptions = _dereq_("./compose-options");
        function noop2() {
        }
        function Popup(options) {
          this._frame = null;
          this._options = options || {};
        }
        Popup.prototype.initialize = noop2;
        Popup.prototype.open = function() {
          this._frame = window.open(this._options.openFrameUrl, this._options.name, composeOptions(this._options));
        };
        Popup.prototype.focus = function() {
          this._frame.focus();
        };
        Popup.prototype.close = function() {
          if (this._frame.closed) {
            return;
          }
          this._frame.close();
        };
        Popup.prototype.isClosed = function() {
          return !this._frame || Boolean(this._frame.closed);
        };
        Popup.prototype.redirect = function(redirectUrl) {
          this._frame.location.href = redirectUrl;
        };
        module2.exports = Popup;
      }, { "./compose-options": 142 }], 144: [function(_dereq_, module2, exports2) {
        function top(height) {
          var windowHeight = window.outerHeight || document.documentElement.clientHeight;
          var windowTop = window.screenY == null ? window.screenTop : window.screenY;
          return center(windowHeight, height, windowTop);
        }
        function left(width) {
          var windowWidth = window.outerWidth || document.documentElement.clientWidth;
          var windowLeft = window.screenX == null ? window.screenLeft : window.screenX;
          return center(windowWidth, width, windowLeft);
        }
        function center(windowMetric, popupMetric, offset) {
          return (windowMetric - popupMetric) / 2 + offset;
        }
        module2.exports = {
          top,
          left,
          center
        };
      }, {}], 145: [function(_dereq_, module2, exports2) {
        module2.exports = {
          isIos: _dereq_("@braintree/browser-detection/is-ios"),
          isIosWKWebview: _dereq_("@braintree/browser-detection/is-ios-wkwebview"),
          supportsPopups: _dereq_("@braintree/browser-detection/supports-popups")
        };
      }, { "@braintree/browser-detection/is-ios": 30, "@braintree/browser-detection/is-ios-wkwebview": 29, "@braintree/browser-detection/supports-popups": 32 }], 146: [function(_dereq_, module2, exports2) {
        module2.exports = {
          DISPATCH_FRAME_NAME: "dispatch",
          DISPATCH_FRAME_CLASS: "braintree-dispatch-frame",
          POPUP_BASE_OPTIONS: "resizable,scrollbars",
          DEFAULT_POPUP_WIDTH: 450,
          DEFAULT_POPUP_HEIGHT: 535,
          POPUP_POLL_INTERVAL: 100,
          POPUP_CLOSE_TIMEOUT: 100
        };
      }, {}], 147: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../braintree-error");
        module2.exports = {
          FRAME_SERVICE_FRAME_CLOSED: {
            type: BraintreeError.types.INTERNAL,
            code: "FRAME_SERVICE_FRAME_CLOSED",
            message: "Frame closed before tokenization could occur."
          },
          FRAME_SERVICE_FRAME_OPEN_FAILED: {
            type: BraintreeError.types.INTERNAL,
            code: "FRAME_SERVICE_FRAME_OPEN_FAILED",
            message: "Frame failed to open."
          }
        };
      }, { "../../braintree-error": 124 }], 148: [function(_dereq_, module2, exports2) {
        var enumerate = _dereq_("../../enumerate");
        module2.exports = enumerate(["DISPATCH_FRAME_READY", "DISPATCH_FRAME_REPORT"], "frameService:");
      }, { "../../enumerate": 134 }], 149: [function(_dereq_, module2, exports2) {
        var VERSION2 = "3.100.0";
        var assign2 = _dereq_("./assign").assign;
        function generateTokenizationParameters(configuration, overrides) {
          var metadata = configuration.analyticsMetadata;
          var basicTokenizationParameters = {
            gateway: "braintree",
            "braintree:merchantId": configuration.gatewayConfiguration.merchantId,
            "braintree:apiVersion": "v1",
            "braintree:sdkVersion": VERSION2,
            "braintree:metadata": JSON.stringify({
              source: metadata.source,
              integration: metadata.integration,
              sessionId: metadata.sessionId,
              version: VERSION2,
              platform: metadata.platform
            })
          };
          return assign2({}, basicTokenizationParameters, overrides);
        }
        module2.exports = function(configuration, googlePayVersion, googleMerchantId) {
          var data2, paypalPaymentMethod;
          var androidPayConfiguration = configuration.gatewayConfiguration.androidPay;
          var environment = configuration.gatewayConfiguration.environment === "production" ? "PRODUCTION" : "TEST";
          if (googlePayVersion === 2) {
            data2 = {
              apiVersion: 2,
              apiVersionMinor: 0,
              environment,
              allowedPaymentMethods: [
                {
                  type: "CARD",
                  parameters: {
                    allowedAuthMethods: ["PAN_ONLY", "CRYPTOGRAM_3DS"],
                    allowedCardNetworks: androidPayConfiguration.supportedNetworks.map(function(card) {
                      return card.toUpperCase();
                    })
                  },
                  tokenizationSpecification: {
                    type: "PAYMENT_GATEWAY",
                    parameters: generateTokenizationParameters(configuration, {
                      "braintree:authorizationFingerprint": androidPayConfiguration.googleAuthorizationFingerprint
                    })
                  }
                }
              ]
            };
            if (googleMerchantId) {
              data2.merchantInfo = {
                merchantId: googleMerchantId
              };
            }
            if (androidPayConfiguration.paypalClientId) {
              paypalPaymentMethod = {
                type: "PAYPAL",
                parameters: {
                  purchase_context: {
                    purchase_units: [
                      {
                        payee: {
                          client_id: androidPayConfiguration.paypalClientId
                        },
                        recurring_payment: true
                      }
                    ]
                  }
                },
                tokenizationSpecification: {
                  type: "PAYMENT_GATEWAY",
                  parameters: generateTokenizationParameters(configuration, {
                    "braintree:paypalClientId": androidPayConfiguration.paypalClientId
                  })
                }
              };
              data2.allowedPaymentMethods.push(paypalPaymentMethod);
            }
          } else {
            data2 = {
              environment,
              allowedPaymentMethods: ["CARD", "TOKENIZED_CARD"],
              paymentMethodTokenizationParameters: {
                tokenizationType: "PAYMENT_GATEWAY",
                parameters: generateTokenizationParameters(configuration, {
                  "braintree:authorizationFingerprint": androidPayConfiguration.googleAuthorizationFingerprint
                })
              },
              cardRequirements: {
                allowedCardNetworks: androidPayConfiguration.supportedNetworks.map(function(card) {
                  return card.toUpperCase();
                })
              }
            };
            if (configuration.authorizationType === "TOKENIZATION_KEY") {
              data2.paymentMethodTokenizationParameters.parameters["braintree:clientKey"] = configuration.authorization;
            }
            if (googleMerchantId) {
              data2.merchantId = googleMerchantId;
            }
            if (googlePayVersion) {
              data2.apiVersion = googlePayVersion;
            }
          }
          return data2;
        };
      }, { "./assign": 121 }], 150: [function(_dereq_, module2, exports2) {
        module2.exports = function inIframe(win) {
          win = win || window;
          try {
            return win.self !== win.top;
          } catch (e) {
            return true;
          }
        };
      }, {}], 151: [function(_dereq_, module2, exports2) {
        function convertDateStringToDate(dateString) {
          var splitDate = dateString.split("-");
          return new Date(splitDate[0], splitDate[1], splitDate[2]);
        }
        function isDateStringBeforeOrOn(firstDate, secondDate) {
          return convertDateStringToDate(firstDate) <= convertDateStringToDate(secondDate);
        }
        module2.exports = isDateStringBeforeOrOn;
      }, {}], 152: [function(_dereq_, module2, exports2) {
        function isHTTPS(protocol) {
          protocol = protocol || window.location.protocol;
          return protocol === "https:";
        }
        module2.exports = {
          isHTTPS
        };
      }, {}], 153: [function(_dereq_, module2, exports2) {
        var parser;
        var legalHosts = {
          "paypal.com": 1,
          "braintreepayments.com": 1,
          "braintreegateway.com": 1,
          "braintree-api.com": 1
        };
        function stripSubdomains(domain) {
          return domain.split(".").slice(-2).join(".");
        }
        function isVerifiedDomain(url) {
          var mainDomain;
          url = url.toLowerCase();
          if (!/^https:/.test(url)) {
            return false;
          }
          parser = parser || document.createElement("a");
          parser.href = url;
          mainDomain = stripSubdomains(parser.hostname);
          return legalHosts.hasOwnProperty(mainDomain);
        }
        module2.exports = isVerifiedDomain;
      }, {}], 154: [function(_dereq_, module2, exports2) {
        module2.exports = function(value) {
          return JSON.parse(JSON.stringify(value));
        };
      }, {}], 155: [function(_dereq_, module2, exports2) {
        module2.exports = function(obj) {
          return Object.keys(obj).filter(function(key) {
            return typeof obj[key] === "function";
          });
        };
      }, {}], 156: [function(_dereq_, module2, exports2) {
        function once(fn) {
          var called = false;
          return function() {
            if (!called) {
              called = true;
              fn.apply(null, arguments);
            }
          };
        }
        module2.exports = once;
      }, {}], 157: [function(_dereq_, module2, exports2) {
        function _notEmpty(obj) {
          var key;
          for (key in obj) {
            if (obj.hasOwnProperty(key)) {
              return true;
            }
          }
          return false;
        }
        function _isArray(value) {
          return value && typeof value === "object" && typeof value.length === "number" && Object.prototype.toString.call(value) === "[object Array]" || false;
        }
        function hasQueryParams(url) {
          url = url || window.location.href;
          return /\?/.test(url);
        }
        function parse2(url) {
          var query, params;
          url = url || window.location.href;
          if (!hasQueryParams(url)) {
            return {};
          }
          query = url.split("?")[1] || "";
          query = query.replace(/#.*$/, "").split("&");
          params = query.reduce(function(toReturn, keyValue) {
            var parts = keyValue.split("=");
            var key = decodeURIComponent(parts[0]);
            var value = decodeURIComponent(parts[1]);
            toReturn[key] = value;
            return toReturn;
          }, {});
          return params;
        }
        function stringify(params, namespace) {
          var k, v, p2;
          var query = [];
          for (p2 in params) {
            if (!params.hasOwnProperty(p2)) {
              continue;
            }
            v = params[p2];
            if (namespace) {
              if (_isArray(params)) {
                k = namespace + "[]";
              } else {
                k = namespace + "[" + p2 + "]";
              }
            } else {
              k = p2;
            }
            if (typeof v === "object") {
              query.push(stringify(v, k));
            } else {
              query.push(encodeURIComponent(k) + "=" + encodeURIComponent(v));
            }
          }
          return query.join("&");
        }
        function queryify(url, params) {
          url = url || "";
          if (params != null && typeof params === "object" && _notEmpty(params)) {
            url += url.indexOf("?") === -1 ? "?" : "";
            url += url.indexOf("=") !== -1 ? "&" : "";
            url += stringify(params);
          }
          return url;
        }
        module2.exports = {
          parse: parse2,
          stringify,
          queryify,
          hasQueryParams
        };
      }, {}], 158: [function(_dereq_, module2, exports2) {
        var uuid = _dereq_("@braintree/uuid");
        var findRootNode = _dereq_("./find-root-node");
        function isShadowElement(element) {
          element = findRootNode(element);
          return element.toString() === "[object ShadowRoot]";
        }
        function getShadowHost(element) {
          element = findRootNode(element);
          if (!isShadowElement(element)) {
            return null;
          }
          return element.host;
        }
        function transformToSlot(element, styles) {
          var styleNode = findRootNode(element).querySelector("style");
          var shadowHost = getShadowHost(element);
          var slotName = "shadow-slot-" + uuid();
          var slot = document.createElement("slot");
          var slotProvider = document.createElement("div");
          slot.setAttribute("name", slotName);
          element.appendChild(slot);
          slotProvider.setAttribute("slot", slotName);
          shadowHost.appendChild(slotProvider);
          if (styles) {
            if (!styleNode) {
              styleNode = document.createElement("style");
              element.appendChild(styleNode);
            }
            styleNode.sheet.insertRule('::slotted([slot="' + slotName + '"]) { ' + styles + " }");
          }
          if (isShadowElement(shadowHost)) {
            return transformToSlot(slotProvider, styles);
          }
          return slotProvider;
        }
        module2.exports = {
          isShadowElement,
          getShadowHost,
          transformToSlot
        };
      }, { "./find-root-node": 136, "@braintree/uuid": 39 }], 159: [function(_dereq_, module2, exports2) {
        module2.exports = function(snakeString) {
          if (snakeString.indexOf("_") === -1) {
            return snakeString;
          }
          return snakeString.toLowerCase().replace(/(\_\w)/g, function(match) {
            return match[1].toUpperCase();
          });
        };
      }, {}], 160: [function(_dereq_, module2, exports2) {
        function useMin(isDebug) {
          return isDebug ? "" : ".min";
        }
        module2.exports = useMin;
      }, {}], 161: [function(_dereq_, module2, exports2) {
        var atobNormalized = typeof atob === "function" ? atob : atobPolyfill;
        function atobPolyfill(base64String) {
          var a, b, c, b1, b2, b3, b4, i;
          var base64Matcher = new RegExp("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})([=]{1,2})?$");
          var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var result = "";
          if (!base64Matcher.test(base64String)) {
            throw new Error("Non base64 encoded input passed to window.atob polyfill");
          }
          i = 0;
          do {
            b1 = characters.indexOf(base64String.charAt(i++));
            b2 = characters.indexOf(base64String.charAt(i++));
            b3 = characters.indexOf(base64String.charAt(i++));
            b4 = characters.indexOf(base64String.charAt(i++));
            a = (b1 & 63) << 2 | b2 >> 4 & 3;
            b = (b2 & 15) << 4 | b3 >> 2 & 15;
            c = (b3 & 3) << 6 | b4 & 63;
            result += String.fromCharCode(a) + (b ? String.fromCharCode(b) : "") + (c ? String.fromCharCode(c) : "");
          } while (i < base64String.length);
          return result;
        }
        module2.exports = {
          atob: function(base64String) {
            return atobNormalized.call(window, base64String);
          },
          _atob: atobPolyfill
        };
      }, {}], 162: [function(_dereq_, module2, exports2) {
        module2.exports = {
          REQUIRED_OPTIONS_FOR_START_PAYMENT: [
            "givenName",
            "surname",
            "currencyCode",
            "onPaymentStart",
            "paymentType",
            "amount",
            "fallback"
          ],
          REQUIRED_OPTIONS_FOR_PAY_UPON_INVOICE_PAYMENT_TYPE: [
            "givenName",
            "surname",
            "currencyCode",
            "onPaymentStart",
            "paymentType",
            "amount",
            "address",
            "billingAddress",
            "birthDate",
            "email",
            "locale",
            "customerServiceInstructions",
            "correlationId",
            "phone",
            "phoneCountryCode",
            "lineItems"
          ],
          REQUIRED_OPTIONS_FOR_ADDRESS: [
            "streetAddress",
            "locality",
            "postalCode",
            "countryCode"
          ],
          REQUIRED_OPTIONS_FOR_LINE_ITEMS: [
            "category",
            "name",
            "quantity",
            "unitAmount",
            "unitTaxAmount"
          ],
          REQUIRED_OPTIONS_FOR_BLIK_SEAMLESS_PAYMENT_TYPE: [
            "givenName",
            "surname",
            "currencyCode",
            "onPaymentStart",
            "paymentType",
            "amount"
          ],
          REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_LEVEL_0: ["authCode"],
          REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_ONE_CLICK_FIRST: [
            "authCode",
            "consumerReference",
            "aliasLabel"
          ],
          REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_ONE_CLICK_SUBSEQUENT: [
            "consumerReference",
            "aliasKey"
          ]
        };
      }, {}], 163: [function(_dereq_, module2, exports2) {
        var frameService = _dereq_("../../lib/frame-service/external");
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var useMin = _dereq_("../../lib/use-min");
        var VERSION2 = "3.100.0";
        var INTEGRATION_TIMEOUT_MS = _dereq_("../../lib/constants").INTEGRATION_TIMEOUT_MS;
        var analytics = _dereq_("../../lib/analytics");
        var methods = _dereq_("../../lib/methods");
        var convertMethodsToError = _dereq_("../../lib/convert-methods-to-error");
        var convertToBraintreeError = _dereq_("../../lib/convert-to-braintree-error");
        var ExtendedPromise = _dereq_("@braintree/extended-promise");
        var querystring = _dereq_("../../lib/querystring");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var constants = _dereq_("./constants");
        var errors = _dereq_("../shared/errors");
        var DEFAULT_WINDOW_WIDTH = 1282;
        var DEFAULT_WINDOW_HEIGHT = 720;
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function LocalPayment(options) {
          this._client = options.client;
          this._assetsUrl = options.client.getConfiguration().gatewayConfiguration.assetsUrl + "/web/" + VERSION2;
          this._isDebug = options.client.getConfiguration().isDebug;
          this._loadingFrameUrl = this._assetsUrl + "/html/local-payment-landing-frame" + useMin(this._isDebug) + ".html";
          this._authorizationInProgress = false;
          this._paymentType = "unknown";
          this._merchantAccountId = options.merchantAccountId;
        }
        LocalPayment.prototype._initialize = function() {
          var self2 = this;
          var client = this._client;
          var failureTimeout = setTimeout(function() {
            analytics.sendEvent(client, "local-payment.load.timed-out");
          }, INTEGRATION_TIMEOUT_MS);
          return new Promise(function(resolve2) {
            frameService.create({
              name: "localpaymentlandingpage",
              dispatchFrameUrl: self2._assetsUrl + "/html/dispatch-frame" + useMin(self2._isDebug) + ".html",
              openFrameUrl: self2._loadingFrameUrl
            }, function(service) {
              self2._frameService = service;
              clearTimeout(failureTimeout);
              analytics.sendEvent(client, "local-payment.load.succeeded");
              resolve2(self2);
            });
          });
        };
        LocalPayment.prototype.startPayment = function(options) {
          var missingOption, missingError, address, fallback, params, promise, billingAddress, windowOptions, onPaymentStartPromise;
          var self2 = this;
          var serviceId = this._frameService._serviceId;
          missingOption = hasMissingOption(options);
          if (missingOption) {
            missingError = new BraintreeError(errors.LOCAL_PAYMENT_START_PAYMENT_MISSING_REQUIRED_OPTION);
            if (typeof missingOption === "string") {
              missingError.details = "Missing required '" + missingOption + "' option.";
            }
            return Promise.reject(missingError);
          }
          windowOptions = options.windowOptions || {};
          address = options.address || {};
          fallback = options.fallback || {};
          billingAddress = options.billingAddress || {};
          params = {
            amount: options.amount,
            bic: options.bic,
            billingAddress: {
              line1: billingAddress.streetAddress,
              line2: billingAddress.extendedAddress,
              city: billingAddress.locality,
              state: billingAddress.region,
              postalCode: billingAddress.postalCode,
              countryCode: billingAddress.countryCode
            },
            birthDate: options.birthDate,
            blikOptions: options.blikOptions,
            cancelUrl: querystring.queryify(self2._assetsUrl + "/html/local-payment-redirect-frame" + useMin(self2._isDebug) + ".html", {
              channel: serviceId,
              r: fallback.cancelUrl || fallback.url,
              t: fallback.cancelButtonText || fallback.buttonText,
              c: 1
            }),
            city: address.locality,
            correlationId: options.correlationId,
            countryCode: address.countryCode,
            currencyIsoCode: options.currencyCode,
            discountAmount: options.discountAmount,
            experienceProfile: {
              brandName: options.displayName,
              customerServiceInstructions: options.customerServiceInstructions,
              locale: options.locale,
              noShipping: !options.shippingAddressRequired
            },
            firstName: options.givenName,
            fundingSource: options.paymentType,
            intent: "sale",
            lastName: options.surname,
            line1: address.streetAddress,
            line2: address.extendedAddress,
            lineItems: options.lineItems,
            merchantAccountId: self2._merchantAccountId,
            merchantOrPartnerCustomerId: options.customerId,
            payerEmail: options.email,
            paymentTypeCountryCode: options.paymentTypeCountryCode,
            phone: options.phone,
            phoneCountryCode: options.phoneCountryCode,
            postalCode: address.postalCode,
            recurrent: options.recurrent,
            returnUrl: querystring.queryify(self2._assetsUrl + "/html/local-payment-redirect-frame" + useMin(self2._isDebug) + ".html", {
              channel: serviceId,
              r: fallback.url,
              t: fallback.buttonText
            }),
            shippingAmount: options.shippingAmount,
            state: address.region
          };
          self2._paymentType = options.paymentType.toLowerCase();
          if (self2._authorizationInProgress) {
            analytics.sendEvent(self2._client, self2._paymentType + ".local-payment.start-payment.error.already-opened");
            return Promise.reject(new BraintreeError(errors.LOCAL_PAYMENT_ALREADY_IN_PROGRESS));
          }
          self2._authorizationInProgress = true;
          promise = new ExtendedPromise();
          if (!isDeferredPaymentTypeOptions(options)) {
            self2._startPaymentCallback = self2._createStartPaymentCallback(function(val) {
              promise.resolve(val);
            }, function(err) {
              promise.reject(err);
            });
            self2._frameService.open({
              width: windowOptions.width || DEFAULT_WINDOW_WIDTH,
              height: windowOptions.height || DEFAULT_WINDOW_HEIGHT
            }, self2._startPaymentCallback);
          }
          self2._client.request({
            method: "post",
            endpoint: "local_payments/create",
            data: params
          }).then(function(response) {
            var redirectUrl = response.paymentResource.redirectUrl;
            analytics.sendEvent(self2._client, self2._paymentType + ".local-payment.start-payment.opened");
            self2._startPaymentOptions = options;
            if (isDeferredPaymentTypeOptions(options)) {
              self2._authorizationInProgress = false;
              if (typeof redirectUrl === "string" && redirectUrl.length) {
                promise.reject(new BraintreeError(errors.LOCAL_PAYMENT_START_PAYMENT_DEFERRED_PAYMENT_FAILED));
              } else {
                onPaymentStartPromise = options.onPaymentStart({
                  paymentId: response.paymentResource.paymentToken
                });
                if (onPaymentStartPromise instanceof Promise) {
                  onPaymentStartPromise.then(function() {
                    promise.resolve();
                  });
                } else {
                  promise.resolve();
                }
              }
            } else {
              options.onPaymentStart({ paymentId: response.paymentResource.paymentToken }, function() {
                self2._frameService.redirect(response.paymentResource.redirectUrl);
              });
            }
          }).catch(function(err) {
            var status = err.details && err.details.httpStatus;
            self2._frameService.close();
            self2._authorizationInProgress = false;
            if (status === 422) {
              promise.reject(new BraintreeError({
                type: errors.LOCAL_PAYMENT_INVALID_PAYMENT_OPTION.type,
                code: errors.LOCAL_PAYMENT_INVALID_PAYMENT_OPTION.code,
                message: errors.LOCAL_PAYMENT_INVALID_PAYMENT_OPTION.message,
                details: {
                  originalError: err
                }
              }));
              return;
            }
            promise.reject(convertToBraintreeError(err, {
              type: errors.LOCAL_PAYMENT_START_PAYMENT_FAILED.type,
              code: errors.LOCAL_PAYMENT_START_PAYMENT_FAILED.code,
              message: errors.LOCAL_PAYMENT_START_PAYMENT_FAILED.message
            }));
          });
          return promise;
        };
        LocalPayment.prototype.tokenize = function(params) {
          var self2 = this;
          var client = this._client;
          params = params || querystring.parse();
          if (params.queryItems) {
            params = params.queryItems;
          }
          if (params.c || params.wasCanceled) {
            return Promise.reject(new BraintreeError({
              type: errors.LOCAL_PAYMENT_CANCELED.type,
              code: errors.LOCAL_PAYMENT_CANCELED.code,
              message: errors.LOCAL_PAYMENT_CANCELED.message,
              details: {
                originalError: {
                  errorcode: params.errorcode,
                  token: params.btLpToken
                }
              }
            }));
          } else if (params.errorcode) {
            return Promise.reject(new BraintreeError({
              type: errors.LOCAL_PAYMENT_START_PAYMENT_FAILED.type,
              code: errors.LOCAL_PAYMENT_START_PAYMENT_FAILED.code,
              message: errors.LOCAL_PAYMENT_START_PAYMENT_FAILED.message,
              details: {
                originalError: {
                  errorcode: params.errorcode,
                  token: params.btLpToken
                }
              }
            }));
          }
          return client.request({
            endpoint: "payment_methods/paypal_accounts",
            method: "post",
            data: this._formatTokenizeData(params)
          }).then(function(response) {
            var payload = self2._formatTokenizePayload(response);
            if (window.popupBridge) {
              analytics.sendEvent(client, self2._paymentType + ".local-payment.tokenization.success-popupbridge");
            } else {
              analytics.sendEvent(client, self2._paymentType + ".local-payment.tokenization.success");
            }
            return payload;
          }).catch(function(err) {
            analytics.sendEvent(client, self2._paymentType + ".local-payment.tokenization.failed");
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.LOCAL_PAYMENT_TOKENIZATION_FAILED.type,
              code: errors.LOCAL_PAYMENT_TOKENIZATION_FAILED.code,
              message: errors.LOCAL_PAYMENT_TOKENIZATION_FAILED.message
            }));
          });
        };
        LocalPayment.prototype.closeWindow = function() {
          if (this._authoriztionInProgress) {
            analytics.sendEvent(this._client, this._paymentType + ".local-payment.start-payment.closed.by-merchant");
          }
          this._frameService.close();
        };
        LocalPayment.prototype.focusWindow = function() {
          this._frameService.focus();
        };
        LocalPayment.prototype._createStartPaymentCallback = function(resolve2, reject) {
          var self2 = this;
          var client = this._client;
          return function(err, params) {
            self2._authorizationInProgress = false;
            if (err) {
              if (err.code === "FRAME_SERVICE_FRAME_CLOSED") {
                if (params && params.errorcode === "processing_error") {
                  analytics.sendEvent(client, self2._paymentType + ".local-payment.failed-in-window");
                  reject(new BraintreeError(errors.LOCAL_PAYMENT_START_PAYMENT_FAILED));
                  return;
                }
                analytics.sendEvent(client, self2._paymentType + ".local-payment.tokenization.closed.by-user");
                reject(new BraintreeError(errors.LOCAL_PAYMENT_WINDOW_CLOSED));
              } else if (err.code && err.code.indexOf("FRAME_SERVICE_FRAME_OPEN_FAILED") > -1) {
                reject(new BraintreeError({
                  code: errors.LOCAL_PAYMENT_WINDOW_OPEN_FAILED.code,
                  type: errors.LOCAL_PAYMENT_WINDOW_OPEN_FAILED.type,
                  message: errors.LOCAL_PAYMENT_WINDOW_OPEN_FAILED.message,
                  details: {
                    originalError: err
                  }
                }));
              }
            } else if (params) {
              if (!window.popupBridge) {
                self2._frameService.redirect(self2._loadingFrameUrl);
              }
              self2.tokenize(params).then(resolve2).catch(reject).then(function() {
                self2._frameService.close();
              });
            }
          };
        };
        LocalPayment.prototype._formatTokenizePayload = function(response) {
          var payload;
          var account = {};
          if (response.paypalAccounts) {
            account = response.paypalAccounts[0];
          }
          payload = {
            nonce: account.nonce,
            details: {},
            type: account.type
          };
          if (account.details) {
            if (account.details.payerInfo) {
              payload.details = account.details.payerInfo;
            }
            if (account.details.correlationId) {
              payload.correlationId = account.details.correlationId;
            }
          }
          return payload;
        };
        LocalPayment.prototype.hasTokenizationParams = function() {
          var params = querystring.parse();
          if (params.errorcode) {
            return true;
          }
          return Boolean(params.btLpToken && params.btLpPaymentId && params.btLpPayerId);
        };
        LocalPayment.prototype._formatTokenizeData = function(params) {
          var clientConfiguration = this._client.getConfiguration();
          var gatewayConfiguration = clientConfiguration.gatewayConfiguration;
          var data2 = {
            merchantAccountId: this._merchantAccountId,
            paypalAccount: {
              correlationId: params.btLpToken || params.token,
              paymentToken: params.btLpPaymentId || params.paymentId,
              payerId: params.btLpPayerId || params.PayerID,
              unilateral: gatewayConfiguration.paypal.unvettedMerchant,
              intent: "sale"
            }
          };
          return data2;
        };
        function isDeferredPaymentTypeOptions(options) {
          var blikOptions = options.blikOptions || {};
          var paymentType = typeof options.paymentType === "string" ? options.paymentType.toLowerCase() : options.paymentType;
          if (paymentType === "pay_upon_invoice") {
            return true;
          } else if (paymentType === "blik") {
            return blikOptions.hasOwnProperty("level_0") || blikOptions.hasOwnProperty("oneClick");
          }
          return false;
        }
        function hasMissingAddressOption(options) {
          var i, option;
          for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_ADDRESS.length; i++) {
            option = constants.REQUIRED_OPTIONS_FOR_ADDRESS[i];
            if (!options.hasOwnProperty(option)) {
              return option;
            }
          }
          return false;
        }
        function hasMissingLineItemsOption(items) {
          var i, j, item, option;
          for (j = 0; j < items.length; j++) {
            item = items[j];
            for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_LINE_ITEMS.length; i++) {
              option = constants.REQUIRED_OPTIONS_FOR_LINE_ITEMS[i];
              if (!item.hasOwnProperty(option)) {
                return option;
              }
            }
          }
          return false;
        }
        function hasMissingBlikOptions(options) {
          var i, option, oneClick;
          var blikOptions = options.blikOptions || {};
          for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_BLIK_SEAMLESS_PAYMENT_TYPE.length; i++) {
            option = constants.REQUIRED_OPTIONS_FOR_BLIK_SEAMLESS_PAYMENT_TYPE[i];
            if (!options.hasOwnProperty(option)) {
              return option;
            }
          }
          if (blikOptions.hasOwnProperty("level_0")) {
            for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_LEVEL_0.length; i++) {
              option = constants.REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_LEVEL_0[i];
              if (!blikOptions.level_0.hasOwnProperty(option)) {
                return "blikOptions.level_0." + option;
              }
            }
          } else if (blikOptions.hasOwnProperty("oneClick")) {
            oneClick = blikOptions.oneClick || {};
            if (oneClick.hasOwnProperty("aliasKey")) {
              for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_ONE_CLICK_SUBSEQUENT.length; i++) {
                option = constants.REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_ONE_CLICK_SUBSEQUENT[i];
                if (!oneClick.hasOwnProperty(option)) {
                  return "blikOptions.oneClick." + option;
                }
              }
            } else {
              for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_ONE_CLICK_FIRST.length; i++) {
                option = constants.REQUIRED_OPTIONS_FOR_BLIK_OPTIONS_ONE_CLICK_FIRST[i];
                if (!oneClick.hasOwnProperty(option)) {
                  return "blikOptions.oneClick." + option;
                }
              }
            }
          }
          return false;
        }
        function hasMissingOption(options) {
          var i, option, missingAddressOption, missingLineItemOption, paymentType;
          if (!options) {
            return true;
          }
          if (isDeferredPaymentTypeOptions(options)) {
            paymentType = options.paymentType || "";
            if (paymentType.toLowerCase() === "pay_upon_invoice") {
              for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_PAY_UPON_INVOICE_PAYMENT_TYPE.length; i++) {
                option = constants.REQUIRED_OPTIONS_FOR_PAY_UPON_INVOICE_PAYMENT_TYPE[i];
                if (!options.hasOwnProperty(option)) {
                  return option;
                }
                if (option === "address" || option === "billingAddress") {
                  missingAddressOption = hasMissingAddressOption(options[option]);
                  if (missingAddressOption) {
                    return option + "." + missingAddressOption;
                  }
                } else if (option === "lineItems") {
                  missingLineItemOption = hasMissingLineItemsOption(options[option]);
                  if (missingLineItemOption) {
                    return option + "." + missingLineItemOption;
                  }
                }
              }
            } else if (paymentType.toLowerCase() === "blik") {
              return hasMissingBlikOptions(options);
            }
          } else {
            for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_START_PAYMENT.length; i++) {
              option = constants.REQUIRED_OPTIONS_FOR_START_PAYMENT[i];
              if (!options.hasOwnProperty(option)) {
                return option;
              }
            }
            if (!options.fallback.url) {
              return "fallback.url";
            }
            if (!options.fallback.buttonText) {
              return "fallback.buttonText";
            }
            if (options.recurrent === true && !options.customerId) {
              return "customerId";
            }
          }
          return false;
        }
        LocalPayment.prototype.teardown = function() {
          var self2 = this;
          self2._frameService.teardown();
          convertMethodsToError(self2, methods(LocalPayment.prototype));
          analytics.sendEvent(self2._client, "local-payment.teardown-completed");
          return Promise.resolve();
        };
        module2.exports = wrapPromise.wrapPrototype(LocalPayment);
      }, { "../../lib/analytics": 119, "../../lib/braintree-error": 124, "../../lib/constants": 126, "../../lib/convert-methods-to-error": 127, "../../lib/convert-to-braintree-error": 128, "../../lib/frame-service/external": 139, "../../lib/methods": 155, "../../lib/querystring": 157, "../../lib/use-min": 160, "../shared/errors": 165, "./constants": 162, "@braintree/extended-promise": 34, "@braintree/wrap-promise": 43 }], 164: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../lib/analytics");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var LocalPayment = _dereq_("./external/local-payment");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var errors = _dereq_("./shared/errors");
        function create2(options) {
          var name = "Local Payment";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            var localPaymentInstance;
            var config = client.getConfiguration();
            options.client = client;
            if (config.gatewayConfiguration.paypalEnabled !== true) {
              return Promise.reject(new BraintreeError(errors.LOCAL_PAYMENT_NOT_ENABLED));
            }
            analytics.sendEvent(client, "local-payment.initialized");
            localPaymentInstance = new LocalPayment(options);
            return localPaymentInstance._initialize();
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 119, "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./external/local-payment": 163, "./shared/errors": 165, "@braintree/wrap-promise": 43 }], 165: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          LOCAL_PAYMENT_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "LOCAL_PAYMENT_NOT_ENABLED",
            message: "LocalPayment is not enabled for this merchant."
          },
          LOCAL_PAYMENT_ALREADY_IN_PROGRESS: {
            type: BraintreeError.types.MERCHANT,
            code: "LOCAL_PAYMENT_ALREADY_IN_PROGRESS",
            message: "LocalPayment payment is already in progress."
          },
          LOCAL_PAYMENT_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "LOCAL_PAYMENT_CANCELED",
            message: "Customer canceled the LocalPayment before authorizing."
          },
          LOCAL_PAYMENT_WINDOW_CLOSED: {
            type: BraintreeError.types.CUSTOMER,
            code: "LOCAL_PAYMENT_WINDOW_CLOSED",
            message: "Customer closed LocalPayment window before authorizing."
          },
          LOCAL_PAYMENT_WINDOW_OPEN_FAILED: {
            type: BraintreeError.types.MERCHANT,
            code: "LOCAL_PAYMENT_WINDOW_OPEN_FAILED",
            message: "LocalPayment window failed to open; make sure startPayment was called in response to a user action."
          },
          LOCAL_PAYMENT_START_PAYMENT_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "LOCAL_PAYMENT_START_PAYMENT_FAILED",
            message: "LocalPayment startPayment failed."
          },
          LOCAL_PAYMENT_START_PAYMENT_MISSING_REQUIRED_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "LOCAL_PAYMENT_START_PAYMENT_MISSING_REQUIRED_OPTION",
            message: "Missing required option for startPayment."
          },
          LOCAL_PAYMENT_START_PAYMENT_DEFERRED_PAYMENT_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "LOCAL_PAYMENT_START_PAYMENT_DEFERRED_PAYMENT_FAILED",
            message: "LocalPayment startPayment deferred payment failed."
          },
          LOCAL_PAYMENT_TOKENIZATION_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "LOCAL_PAYMENT_TOKENIZATION_FAILED",
            message: "Could not tokenize user's local payment method."
          },
          LOCAL_PAYMENT_INVALID_PAYMENT_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "LOCAL_PAYMENT_INVALID_PAYMENT_OPTION",
            message: "Local payment options are invalid."
          }
        };
      }, { "../../lib/braintree-error": 124 }], 166: [function(_dereq_, module2, exports2) {
        var frameService = _dereq_("../../lib/frame-service/external");
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var errors = _dereq_("../shared/errors");
        var VERSION2 = "3.100.0";
        var methods = _dereq_("../../lib/methods");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var analytics = _dereq_("../../lib/analytics");
        var convertMethodsToError = _dereq_("../../lib/convert-methods-to-error");
        var convertToBraintreeError = _dereq_("../../lib/convert-to-braintree-error");
        var constants = _dereq_("../shared/constants");
        var INTEGRATION_TIMEOUT_MS = _dereq_("../../lib/constants").INTEGRATION_TIMEOUT_MS;
        function Masterpass(options) {
          var configuration = options.client.getConfiguration();
          this._client = options.client;
          this._assetsUrl = configuration.gatewayConfiguration.assetsUrl + "/web/" + VERSION2;
          this._isDebug = configuration.isDebug;
          this._authInProgress = false;
          if (window.popupBridge && typeof window.popupBridge.getReturnUrlPrefix === "function") {
            this._callbackUrl = window.popupBridge.getReturnUrlPrefix() + "return";
          } else {
            this._callbackUrl = this._assetsUrl + "/html/redirect-frame" + (this._isDebug ? "" : ".min") + ".html";
          }
        }
        Masterpass.prototype._initialize = function() {
          var self2 = this;
          return new Promise(function(resolve2) {
            var failureTimeout = setTimeout(function() {
              analytics.sendEvent(self2._client, "masterpass.load.timed-out");
            }, INTEGRATION_TIMEOUT_MS);
            frameService.create({
              name: constants.LANDING_FRAME_NAME,
              height: constants.POPUP_HEIGHT,
              width: constants.POPUP_WIDTH,
              dispatchFrameUrl: self2._assetsUrl + "/html/dispatch-frame" + (self2._isDebug ? "" : ".min") + ".html",
              openFrameUrl: self2._assetsUrl + "/html/masterpass-landing-frame" + (self2._isDebug ? "" : ".min") + ".html"
            }, function(service) {
              self2._frameService = service;
              clearTimeout(failureTimeout);
              analytics.sendEvent(self2._client, "masterpass.load.succeeded");
              resolve2(self2);
            });
          });
        };
        Masterpass.prototype.tokenize = function(options) {
          var self2 = this;
          if (!options || hasMissingOption(options)) {
            return Promise.reject(new BraintreeError(errors.MASTERPASS_TOKENIZE_MISSING_REQUIRED_OPTION));
          }
          if (self2._authInProgress) {
            return Promise.reject(new BraintreeError(errors.MASTERPASS_TOKENIZATION_ALREADY_IN_PROGRESS));
          }
          return new Promise(function(resolve2, reject) {
            self2._navigateFrameToLoadingPage(options).catch(reject);
            self2._frameService.open(options.frameOptions, self2._createFrameOpenHandler(resolve2, reject));
          });
        };
        Masterpass.prototype._navigateFrameToLoadingPage = function(options) {
          var self2 = this;
          this._authInProgress = true;
          return this._client.request({
            method: "post",
            endpoint: "masterpass/request_token",
            data: {
              requestToken: {
                originUrl: window.location.protocol + "//" + window.location.hostname,
                subtotal: options.subtotal,
                currencyCode: options.currencyCode,
                callbackUrl: this._callbackUrl
              }
            }
          }).then(function(response) {
            var redirectUrl = self2._assetsUrl + "/html/masterpass-loading-frame" + (self2._isDebug ? "" : ".min") + ".html?";
            var gatewayConfiguration = self2._client.getConfiguration().gatewayConfiguration;
            var config = options.config || {};
            var queryParams;
            queryParams = {
              environment: gatewayConfiguration.environment,
              requestToken: response.requestToken,
              callbackUrl: self2._callbackUrl,
              merchantCheckoutId: gatewayConfiguration.masterpass.merchantCheckoutId,
              allowedCardTypes: gatewayConfiguration.masterpass.supportedNetworks,
              version: constants.MASTERPASS_VERSION
            };
            Object.keys(config).forEach(function(key) {
              if (typeof config[key] !== "function") {
                queryParams[key] = config[key];
              }
            });
            redirectUrl += Object.keys(queryParams).map(function(key) {
              return key + "=" + queryParams[key];
            }).join("&");
            self2._frameService.redirect(redirectUrl);
          }).catch(function(err) {
            var status = err.details && err.details.httpStatus;
            self2._closeWindow();
            if (status === 422) {
              return Promise.reject(convertToBraintreeError(err, errors.MASTERPASS_INVALID_PAYMENT_OPTION));
            }
            return Promise.reject(convertToBraintreeError(err, errors.MASTERPASS_FLOW_FAILED));
          });
        };
        Masterpass.prototype._createFrameOpenHandler = function(resolve2, reject) {
          var self2 = this;
          if (window.popupBridge) {
            return function(popupBridgeErr, payload) {
              self2._authInProgress = false;
              if (popupBridgeErr) {
                analytics.sendEvent(self2._client, "masterpass.tokenization.closed-popupbridge.by-user");
                reject(convertToBraintreeError(popupBridgeErr, errors.MASTERPASS_POPUP_CLOSED));
                return;
              } else if (!payload.queryItems) {
                analytics.sendEvent(self2._client, "masterpass.tokenization.failed-popupbridge");
                reject(new BraintreeError(errors.MASTERPASS_FLOW_FAILED));
                return;
              }
              self2._tokenizeMasterpass(payload.queryItems).then(resolve2).catch(reject);
            };
          }
          return function(frameServiceErr, payload) {
            if (frameServiceErr) {
              self2._authInProgress = false;
              if (frameServiceErr.code === "FRAME_SERVICE_FRAME_CLOSED") {
                analytics.sendEvent(self2._client, "masterpass.tokenization.closed.by-user");
                reject(new BraintreeError(errors.MASTERPASS_POPUP_CLOSED));
                return;
              }
              if (frameServiceErr.code && frameServiceErr.code.indexOf("FRAME_SERVICE_FRAME_OPEN_FAILED") > -1) {
                analytics.sendEvent(self2._client, "masterpass.tokenization.failed.to-open");
                reject(new BraintreeError({
                  code: errors.MASTERPASS_POPUP_OPEN_FAILED.code,
                  type: errors.MASTERPASS_POPUP_OPEN_FAILED.type,
                  message: errors.MASTERPASS_POPUP_OPEN_FAILED.message,
                  details: {
                    originalError: frameServiceErr
                  }
                }));
                return;
              }
              analytics.sendEvent(self2._client, "masterpass.tokenization.failed");
              self2._closeWindow();
              reject(convertToBraintreeError(frameServiceErr, errors.MASTERPASS_FLOW_FAILED));
              return;
            }
            self2._tokenizeMasterpass(payload).then(resolve2).catch(reject);
          };
        };
        Masterpass.prototype._tokenizeMasterpass = function(payload) {
          var self2 = this;
          if (payload.mpstatus !== "success") {
            analytics.sendEvent(self2._client, "masterpass.tokenization.closed.by-user");
            self2._closeWindow();
            return Promise.reject(new BraintreeError(errors.MASTERPASS_POPUP_CLOSED));
          }
          if (isMissingRequiredPayload(payload)) {
            analytics.sendEvent(self2._client, "masterpass.tokenization.closed.missing-payload");
            self2._closeWindow();
            return Promise.reject(new BraintreeError(errors.MASTERPASS_POPUP_MISSING_REQUIRED_PARAMETERS));
          }
          return self2._client.request({
            endpoint: "payment_methods/masterpass_cards",
            method: "post",
            data: {
              masterpassCard: {
                checkoutResourceUrl: payload.checkout_resource_url,
                requestToken: payload.oauth_token,
                verifierToken: payload.oauth_verifier
              }
            }
          }).then(function(response) {
            self2._closeWindow();
            if (window.popupBridge) {
              analytics.sendEvent(self2._client, "masterpass.tokenization.success-popupbridge");
            } else {
              analytics.sendEvent(self2._client, "masterpass.tokenization.success");
            }
            return response.masterpassCards[0];
          }).catch(function(tokenizeErr) {
            self2._closeWindow();
            if (window.popupBridge) {
              analytics.sendEvent(self2._client, "masterpass.tokenization.failed-popupbridge");
            } else {
              analytics.sendEvent(self2._client, "masterpass.tokenization.failed");
            }
            return Promise.reject(convertToBraintreeError(tokenizeErr, errors.MASTERPASS_ACCOUNT_TOKENIZATION_FAILED));
          });
        };
        function isMissingRequiredPayload(payload) {
          return [
            payload.oauth_verifier,
            payload.oauth_token,
            payload.checkout_resource_url
          ].some(function(element) {
            return element == null || element === "null";
          });
        }
        Masterpass.prototype._closeWindow = function() {
          this._authInProgress = false;
          this._frameService.close();
        };
        Masterpass.prototype.teardown = function() {
          var self2 = this;
          return new Promise(function(resolve2) {
            self2._frameService.teardown();
            convertMethodsToError(self2, methods(Masterpass.prototype));
            analytics.sendEvent(self2._client, "masterpass.teardown-completed");
            resolve2();
          });
        };
        function hasMissingOption(options) {
          var i, option;
          for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_TOKENIZE.length; i++) {
            option = constants.REQUIRED_OPTIONS_FOR_TOKENIZE[i];
            if (!options.hasOwnProperty(option)) {
              return true;
            }
          }
          return false;
        }
        module2.exports = wrapPromise.wrapPrototype(Masterpass);
      }, { "../../lib/analytics": 119, "../../lib/braintree-error": 124, "../../lib/constants": 126, "../../lib/convert-methods-to-error": 127, "../../lib/convert-to-braintree-error": 128, "../../lib/frame-service/external": 139, "../../lib/methods": 155, "../shared/constants": 169, "../shared/errors": 170, "@braintree/wrap-promise": 43 }], 167: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var browserDetection = _dereq_("./shared/browser-detection");
        var Masterpass = _dereq_("./external/masterpass");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var VERSION2 = "3.100.0";
        var errors = _dereq_("./shared/errors");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "Masterpass";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            if (!isSupported()) {
              return Promise.reject(new BraintreeError(errors.MASTERPASS_BROWSER_NOT_SUPPORTED));
            }
            return Promise.resolve();
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            var masterpassInstance, configuration;
            options.client = client;
            configuration = options.client.getConfiguration().gatewayConfiguration;
            if (!configuration.masterpass) {
              return Promise.reject(new BraintreeError(errors.MASTERPASS_NOT_ENABLED));
            }
            masterpassInstance = new Masterpass(options);
            return masterpassInstance._initialize();
          });
        }
        function isSupported() {
          return Boolean(window.popupBridge || browserDetection.supportsPopups());
        }
        module2.exports = {
          create: wrapPromise(create2),
          isSupported,
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./external/masterpass": 166, "./shared/browser-detection": 168, "./shared/errors": 170, "@braintree/wrap-promise": 43 }], 168: [function(_dereq_, module2, exports2) {
        module2.exports = {
          supportsPopups: _dereq_("@braintree/browser-detection/supports-popups")
        };
      }, { "@braintree/browser-detection/supports-popups": 32 }], 169: [function(_dereq_, module2, exports2) {
        module2.exports = {
          LANDING_FRAME_NAME: "braintreemasterpasslanding",
          POPUP_WIDTH: 450,
          POPUP_HEIGHT: 660,
          MASTERPASS_VERSION: "v6",
          REQUIRED_OPTIONS_FOR_TOKENIZE: ["subtotal", "currencyCode"]
        };
      }, {}], 170: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          MASTERPASS_BROWSER_NOT_SUPPORTED: {
            type: BraintreeError.types.CUSTOMER,
            code: "MASTERPASS_BROWSER_NOT_SUPPORTED",
            message: "Browser is not supported."
          },
          MASTERPASS_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "MASTERPASS_NOT_ENABLED",
            message: "Masterpass is not enabled for this merchant."
          },
          MASTERPASS_TOKENIZE_MISSING_REQUIRED_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "MASTERPASS_TOKENIZE_MISSING_REQUIRED_OPTION",
            message: "Missing required option for tokenize."
          },
          MASTERPASS_TOKENIZATION_ALREADY_IN_PROGRESS: {
            type: BraintreeError.types.MERCHANT,
            code: "MASTERPASS_TOKENIZATION_ALREADY_IN_PROGRESS",
            message: "Masterpass tokenization is already in progress."
          },
          MASTERPASS_ACCOUNT_TOKENIZATION_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "MASTERPASS_ACCOUNT_TOKENIZATION_FAILED",
            message: "Could not tokenize user's Masterpass account."
          },
          MASTERPASS_POPUP_OPEN_FAILED: {
            type: BraintreeError.types.MERCHANT,
            code: "MASTERPASS_POPUP_OPEN_FAILED",
            message: "Masterpass popup failed to open. Make sure to tokenize in response to a user action, such as a click."
          },
          MASTERPASS_POPUP_MISSING_REQUIRED_PARAMETERS: {
            type: BraintreeError.types.MERCHANT,
            code: "MASTERPASS_POPUP_MISSING_REQUIRED_PARAMETERS",
            message: "Masterpass popup failed to return all required parameters needed to continue tokenization."
          },
          MASTERPASS_POPUP_CLOSED: {
            type: BraintreeError.types.CUSTOMER,
            code: "MASTERPASS_POPUP_CLOSED",
            message: "Customer closed Masterpass popup before authorizing."
          },
          MASTERPASS_INVALID_PAYMENT_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "MASTERPASS_INVALID_PAYMENT_OPTION",
            message: "Masterpass payment options are invalid."
          },
          MASTERPASS_FLOW_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "MASTERPASS_FLOW_FAILED",
            message: "Could not initialize Masterpass flow."
          }
        };
      }, { "../../lib/braintree-error": 124 }], 171: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../../lib/analytics");
        var assign2 = _dereq_("../../lib/assign").assign;
        var Bus = _dereq_("framebus");
        var convertMethodsToError = _dereq_("../../lib/convert-methods-to-error");
        var generateGooglePayConfiguration = _dereq_("../../lib/generate-google-pay-configuration");
        var iFramer = _dereq_("@braintree/iframer");
        var uuid = _dereq_("@braintree/uuid");
        var useMin = _dereq_("../../lib/use-min");
        var methods = _dereq_("../../lib/methods");
        var EventEmitter = _dereq_("@braintree/event-emitter");
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var VERSION2 = "3.100.0";
        var constants = _dereq_("../shared/constants");
        var events = constants.events;
        var errors = constants.errors;
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var CARD_TYPE_MAPPINGS = {
          Visa: "visa",
          MasterCard: "mastercard",
          "American Express": "amex",
          "Diners Club": "diners",
          Discover: "discover",
          JCB: "jcb",
          UnionPay: "unionpay",
          Maestro: "maestro"
        };
        var BRAINTREE_GOOGLE_PAY_MERCHANT_ID = "18278000977346790994";
        function composeUrl(assetsUrl, componentId, isDebug) {
          var baseUrl = assetsUrl;
          return baseUrl + "/web/" + VERSION2 + "/html/payment-request-frame" + useMin(isDebug) + ".html#" + componentId;
        }
        function PaymentRequestComponent(options) {
          var enabledPaymentMethods = options.enabledPaymentMethods || {};
          EventEmitter.call(this);
          this._componentId = uuid();
          this._client = options.client;
          this._enabledPaymentMethods = {
            basicCard: enabledPaymentMethods.basicCard !== false,
            googlePay: enabledPaymentMethods.googlePay !== false
          };
          this._googlePayVersion = options.googlePayVersion === 2 ? 2 : 1;
          this._googleMerchantId = BRAINTREE_GOOGLE_PAY_MERCHANT_ID;
          this._supportedPaymentMethods = this._constructDefaultSupportedPaymentMethods();
          this._defaultSupportedPaymentMethods = Object.keys(this._supportedPaymentMethods).map(function(key) {
            return this._supportedPaymentMethods[key];
          }.bind(this));
          this._bus = new Bus({ channel: this._componentId });
        }
        EventEmitter.createChild(PaymentRequestComponent);
        PaymentRequestComponent.prototype._constructDefaultSupportedPaymentMethods = function() {
          var configuration = this._client.getConfiguration();
          var androidPayConfiguration = configuration.gatewayConfiguration.androidPay;
          var cardConfiguration = configuration.gatewayConfiguration.creditCards;
          var supportedPaymentMethods = {};
          if (this._enabledPaymentMethods.basicCard && cardConfiguration && cardConfiguration.supportedCardTypes.length > 0) {
            supportedPaymentMethods.basicCard = {
              supportedMethods: "basic-card",
              data: {
                supportedNetworks: cardConfiguration.supportedCardTypes.reduce(function(types, cardType) {
                  if (cardType in CARD_TYPE_MAPPINGS) {
                    types.push(CARD_TYPE_MAPPINGS[cardType]);
                  }
                  return types;
                }, [])
              }
            };
          }
          if (this._enabledPaymentMethods.googlePay && androidPayConfiguration && androidPayConfiguration.enabled) {
            supportedPaymentMethods.googlePay = {
              supportedMethods: "https://google.com/pay",
              data: generateGooglePayConfiguration(configuration, this._googlePayVersion, this._googleMerchantId)
            };
          }
          return supportedPaymentMethods;
        };
        PaymentRequestComponent.prototype.initialize = function() {
          var clientConfiguration = this._client.getConfiguration();
          var self2 = this;
          this._frame = iFramer({
            allowPaymentRequest: true,
            name: "braintree-payment-request-frame",
            class: "braintree-payment-request-frame",
            height: 0,
            width: 0,
            style: {
              position: "absolute",
              left: "-9999px"
            },
            title: "Secure Payment Frame"
          });
          if (this._defaultSupportedPaymentMethods.length === 0) {
            return Promise.reject(new BraintreeError(errors.PAYMENT_REQUEST_NO_VALID_SUPPORTED_PAYMENT_METHODS));
          }
          return new Promise(function(resolve2) {
            self2._bus.on(events.FRAME_READY, function(reply) {
              reply(self2._client);
            });
            self2._bus.on(events.FRAME_CAN_MAKE_REQUESTS, function() {
              analytics.sendEvent(self2._client, "payment-request.initialized");
              self2._bus.on(events.SHIPPING_ADDRESS_CHANGE, function(shippingAddress) {
                var shippingAddressChangeEvent = {
                  target: {
                    shippingAddress
                  },
                  updateWith: function(paymentDetails) {
                    self2._bus.emit(events.UPDATE_SHIPPING_ADDRESS, paymentDetails);
                  }
                };
                self2._emit("shippingAddressChange", shippingAddressChangeEvent);
                self2._emit("shippingaddresschange", shippingAddressChangeEvent);
              });
              self2._bus.on(events.SHIPPING_OPTION_CHANGE, function(shippingOption) {
                var shippingOptionChangeEvent = {
                  target: {
                    shippingOption
                  },
                  updateWith: function(paymentDetails) {
                    self2._bus.emit(events.UPDATE_SHIPPING_OPTION, paymentDetails);
                  }
                };
                self2._emit("shippingOptionChange", shippingOptionChangeEvent);
                self2._emit("shippingoptionchange", shippingOptionChangeEvent);
              });
              resolve2(self2);
            });
            self2._frame.src = composeUrl(clientConfiguration.gatewayConfiguration.assetsUrl, self2._componentId, clientConfiguration.isDebug);
            document.body.appendChild(self2._frame);
          });
        };
        PaymentRequestComponent.prototype.createSupportedPaymentMethodsConfiguration = function(type, overrides) {
          var configuration;
          if (!type) {
            throw new BraintreeError(errors.PAYMENT_REQUEST_CREATE_SUPPORTED_PAYMENT_METHODS_CONFIGURATION_MUST_INCLUDE_TYPE);
          }
          if (!this._enabledPaymentMethods[type]) {
            throw new BraintreeError(errors.PAYMENT_REQUEST_CREATE_SUPPORTED_PAYMENT_METHODS_CONFIGURATION_TYPE_NOT_ENABLED);
          }
          configuration = assign2({}, this._supportedPaymentMethods[type]);
          configuration.data = assign2({}, configuration.data, overrides);
          return configuration;
        };
        PaymentRequestComponent.prototype.tokenize = function(configuration) {
          var self2 = this;
          return new Promise(function(resolve2, reject) {
            self2._bus.emit(events.PAYMENT_REQUEST_INITIALIZED, {
              supportedPaymentMethods: configuration.supportedPaymentMethods || self2._defaultSupportedPaymentMethods,
              details: configuration.details,
              options: configuration.options
            }, function(response) {
              var rawError = response[0];
              var payload = response[1];
              if (rawError) {
                reject(self2._formatTokenizationError(rawError));
                return;
              }
              analytics.sendEvent(self2._client, "payment-request.tokenize.succeeded");
              resolve2({
                nonce: payload.nonce,
                type: payload.type,
                description: payload.description,
                details: {
                  rawPaymentResponse: payload.details.rawPaymentResponse,
                  cardType: payload.details.cardType,
                  lastFour: payload.details.lastFour,
                  lastTwo: payload.details.lastTwo
                },
                binData: payload.binData
              });
            });
          });
        };
        PaymentRequestComponent.prototype.canMakePayment = function(configuration) {
          var self2 = this;
          var unsupportedPaymentMethod;
          if (!window.PaymentRequest) {
            analytics.sendEvent(self2._client, "payment-request.can-make-payment.not-available");
            return Promise.resolve(false);
          }
          if (configuration.supportedPaymentMethods) {
            configuration.supportedPaymentMethods.forEach(function(config) {
              var supportedMethods = config.supportedMethods;
              if (!(supportedMethods in constants.SUPPORTED_METHODS)) {
                unsupportedPaymentMethod = supportedMethods;
              }
            });
            if (unsupportedPaymentMethod) {
              return Promise.reject(new BraintreeError({
                type: errors.PAYMENT_REQUEST_UNSUPPORTED_PAYMENT_METHOD.type,
                code: errors.PAYMENT_REQUEST_UNSUPPORTED_PAYMENT_METHOD.code,
                message: unsupportedPaymentMethod + " is not a supported payment method."
              }));
            }
          }
          return new Promise(function(resolve2, reject) {
            self2._bus.emit(events.CAN_MAKE_PAYMENT, {
              supportedPaymentMethods: configuration.supportedPaymentMethods || self2._defaultSupportedPaymentMethods,
              details: configuration.details,
              options: configuration.options
            }, function(response) {
              var error = response[0];
              var payload = response[1];
              if (error) {
                reject(self2._formatCanMakePaymentError(error));
                return;
              }
              analytics.sendEvent(self2._client, "payment-request.can-make-payment." + payload);
              resolve2(payload);
            });
          });
        };
        PaymentRequestComponent.prototype.teardown = function() {
          this._bus.teardown();
          this._frame.parentNode.removeChild(this._frame);
          convertMethodsToError(this, methods(PaymentRequestComponent.prototype));
          analytics.sendEvent(this._client, "payment-request.teardown-completed");
          return Promise.resolve();
        };
        PaymentRequestComponent.prototype._formatTokenizationError = function(error) {
          var formattedError;
          switch (error.name) {
            case "AbortError":
              formattedError = new BraintreeError({
                type: errors.PAYMENT_REQUEST_CANCELED.type,
                code: errors.PAYMENT_REQUEST_CANCELED.code,
                message: errors.PAYMENT_REQUEST_CANCELED.message,
                details: {
                  originalError: error
                }
              });
              analytics.sendEvent(this._client, "payment-request.tokenize.canceled");
              return formattedError;
            case "PAYMENT_REQUEST_INITIALIZATION_FAILED":
              formattedError = new BraintreeError({
                type: errors.PAYMENT_REQUEST_INITIALIZATION_MISCONFIGURED.type,
                code: errors.PAYMENT_REQUEST_INITIALIZATION_MISCONFIGURED.code,
                message: errors.PAYMENT_REQUEST_INITIALIZATION_MISCONFIGURED.message,
                details: {
                  originalError: error
                }
              });
              break;
            case "BRAINTREE_GATEWAY_GOOGLE_PAYMENT_TOKENIZATION_ERROR":
              formattedError = new BraintreeError({
                type: errors.PAYMENT_REQUEST_GOOGLE_PAYMENT_FAILED_TO_TOKENIZE.type,
                code: errors.PAYMENT_REQUEST_GOOGLE_PAYMENT_FAILED_TO_TOKENIZE.code,
                message: errors.PAYMENT_REQUEST_GOOGLE_PAYMENT_FAILED_TO_TOKENIZE.message,
                details: {
                  originalError: error
                }
              });
              break;
            case "BRAINTREE_GATEWAY_GOOGLE_PAYMENT_PARSING_ERROR":
              formattedError = new BraintreeError({
                type: errors.PAYMENT_REQUEST_GOOGLE_PAYMENT_PARSING_ERROR.type,
                code: errors.PAYMENT_REQUEST_GOOGLE_PAYMENT_PARSING_ERROR.code,
                message: errors.PAYMENT_REQUEST_GOOGLE_PAYMENT_PARSING_ERROR.message,
                details: {
                  originalError: error
                }
              });
              break;
            default:
              formattedError = new BraintreeError({
                code: errors.PAYMENT_REQUEST_NOT_COMPLETED.code,
                type: error.type || BraintreeError.types.CUSTOMER,
                message: errors.PAYMENT_REQUEST_NOT_COMPLETED.message,
                details: {
                  originalError: error
                }
              });
          }
          analytics.sendEvent(this._client, "payment-request.tokenize.failed");
          return formattedError;
        };
        PaymentRequestComponent.prototype._formatCanMakePaymentError = function(error) {
          var formattedError;
          switch (error.name) {
            case "PAYMENT_REQUEST_INITIALIZATION_FAILED":
              formattedError = new BraintreeError({
                type: errors.PAYMENT_REQUEST_INITIALIZATION_MISCONFIGURED.type,
                code: errors.PAYMENT_REQUEST_INITIALIZATION_MISCONFIGURED.code,
                message: errors.PAYMENT_REQUEST_INITIALIZATION_MISCONFIGURED.message,
                details: {
                  originalError: error
                }
              });
              break;
            case "NotAllowedError":
              formattedError = new BraintreeError({
                type: errors.PAYMENT_REQUEST_CAN_MAKE_PAYMENT_NOT_ALLOWED.type,
                code: errors.PAYMENT_REQUEST_CAN_MAKE_PAYMENT_NOT_ALLOWED.code,
                message: errors.PAYMENT_REQUEST_CAN_MAKE_PAYMENT_NOT_ALLOWED.message,
                details: {
                  originalError: error
                }
              });
              break;
            default:
              formattedError = new BraintreeError({
                code: errors.PAYMENT_REQUEST_CAN_MAKE_PAYMENT_FAILED.code,
                type: errors.PAYMENT_REQUEST_CAN_MAKE_PAYMENT_FAILED.type,
                message: errors.PAYMENT_REQUEST_CAN_MAKE_PAYMENT_FAILED.message,
                details: {
                  originalError: error
                }
              });
          }
          analytics.sendEvent(this._client, "payment-request.can-make-payment.failed");
          return formattedError;
        };
        module2.exports = wrapPromise.wrapPrototype(PaymentRequestComponent);
      }, { "../../lib/analytics": 119, "../../lib/assign": 121, "../../lib/braintree-error": 124, "../../lib/convert-methods-to-error": 127, "../../lib/generate-google-pay-configuration": 149, "../../lib/methods": 155, "../../lib/use-min": 160, "../shared/constants": 173, "@braintree/event-emitter": 33, "@braintree/iframer": 35, "@braintree/uuid": 39, "@braintree/wrap-promise": 43, "framebus": 52 }], 172: [function(_dereq_, module2, exports2) {
        var PaymentRequestComponent = _dereq_("./external/payment-request");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var VERSION2 = "3.100.0";
        function create2(options) {
          var name = "Payment Request";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            var paymentRequestInstance;
            options.client = client;
            paymentRequestInstance = new PaymentRequestComponent(options);
            return paymentRequestInstance.initialize();
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./external/payment-request": 171, "@braintree/wrap-promise": 43 }], 173: [function(_dereq_, module2, exports2) {
        var enumerate = _dereq_("../../lib/enumerate");
        var errors = _dereq_("./errors");
        var constants = {};
        constants.events = enumerate([
          "CAN_MAKE_PAYMENT",
          "FRAME_READY",
          "FRAME_CAN_MAKE_REQUESTS",
          "PAYMENT_REQUEST_INITIALIZED",
          "SHIPPING_ADDRESS_CHANGE",
          "UPDATE_SHIPPING_ADDRESS",
          "SHIPPING_OPTION_CHANGE",
          "UPDATE_SHIPPING_OPTION"
        ], "payment-request:");
        constants.errors = errors;
        constants.SUPPORTED_METHODS = {
          "basic-card": true,
          "https://google.com/pay": true
        };
        module2.exports = constants;
      }, { "../../lib/enumerate": 134, "./errors": 174 }], 174: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          PAYMENT_REQUEST_NO_VALID_SUPPORTED_PAYMENT_METHODS: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYMENT_REQUEST_NO_VALID_SUPPORTED_PAYMENT_METHODS",
            message: "There are no supported payment methods associated with this account."
          },
          PAYMENT_REQUEST_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "PAYMENT_REQUEST_CANCELED",
            message: "Payment request was canceled."
          },
          PAYMENT_REQUEST_INITIALIZATION_MISCONFIGURED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYMENT_REQUEST_INITIALIZATION_MISCONFIGURED",
            message: "Something went wrong when configuring the payment request."
          },
          PAYMENT_REQUEST_CAN_MAKE_PAYMENT_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "PAYMENT_REQUEST_CAN_MAKE_PAYMENT_FAILED",
            message: "Something went wrong when calling `canMakePayment`"
          },
          PAYMENT_REQUEST_CAN_MAKE_PAYMENT_NOT_ALLOWED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYMENT_REQUEST_CAN_MAKE_PAYMENT_NOT_ALLOWED",
            message: "Something went wrong when calling `canMakePayment`. Most likely, `canMakePayment` was called multiple times with different supportedMethods configurations."
          },
          PAYMENT_REQUEST_UNSUPPORTED_PAYMENT_METHOD: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYMENT_REQUEST_UNSUPPORTED_PAYMENT_METHOD"
          },
          PAYMENT_REQUEST_GOOGLE_PAYMENT_FAILED_TO_TOKENIZE: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYMENT_REQUEST_GOOGLE_PAYMENT_FAILED_TO_TOKENIZE",
            message: "Something went wrong when tokenizing the Google Pay card."
          },
          PAYMENT_REQUEST_GOOGLE_PAYMENT_PARSING_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "PAYMENT_REQUEST_GOOGLE_PAYMENT_PARSING_ERROR",
            message: "Something went wrong when tokenizing the Google Pay card."
          },
          PAYMENT_REQUEST_NOT_COMPLETED: {
            code: "PAYMENT_REQUEST_NOT_COMPLETED",
            message: "Payment request could not be completed."
          },
          PAYMENT_REQUEST_CREATE_SUPPORTED_PAYMENT_METHODS_CONFIGURATION_MUST_INCLUDE_TYPE: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYMENT_REQUEST_CREATE_SUPPORTED_PAYMENT_METHODS_CONFIGURATION_MUST_INCLUDE_TYPE",
            message: "createSupportedPaymentMethodsConfiguration must include a type parameter."
          },
          PAYMENT_REQUEST_CREATE_SUPPORTED_PAYMENT_METHODS_CONFIGURATION_TYPE_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYMENT_REQUEST_CREATE_SUPPORTED_PAYMENT_METHODS_CONFIGURATION_TYPE_NOT_ENABLED",
            message: "createSupportedPaymentMethodsConfiguration type parameter must be valid or enabled."
          }
        };
      }, { "../../lib/braintree-error": 124 }], 175: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          PAYPAL_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_NOT_ENABLED",
            message: "PayPal is not enabled for this merchant."
          },
          PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED",
            message: "A linked PayPal Sandbox account is required to use PayPal Checkout in Sandbox. See https://developer.paypal.com/braintree/docs/guides/paypal/testing-go-live#linked-paypal-testing for details on linking your PayPal sandbox with Braintree."
          },
          PAYPAL_ACCOUNT_TOKENIZATION_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "PAYPAL_ACCOUNT_TOKENIZATION_FAILED",
            message: "Could not tokenize user's PayPal account."
          },
          PAYPAL_FLOW_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "PAYPAL_FLOW_FAILED",
            message: "Could not initialize PayPal flow."
          },
          PAYPAL_FLOW_OPTION_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_FLOW_OPTION_REQUIRED",
            message: "PayPal flow property is invalid or missing."
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_PARAM_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_PARAM_REQUIRED"
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_SETUP_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_SETUP_FAILED",
            message: "Something went wrong when setting up the checkout workflow."
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED",
            message: "PayPal popup failed to open, make sure to initiate the vault checkout in response to a user action."
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_CANCELED",
            message: "Customer closed PayPal popup before authorizing."
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_IN_PROGRESS: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_IN_PROGRESS",
            message: "Vault initiated checkout already in progress."
          },
          PAYPAL_INVALID_PAYMENT_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_INVALID_PAYMENT_OPTION",
            message: "PayPal payment options are invalid."
          },
          PAYPAL_MISSING_REQUIRED_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_MISSING_REQUIRED_OPTION",
            message: "Missing required option."
          }
        };
      }, { "../lib/braintree-error": 124 }], 176: [function(_dereq_, module2, exports2) {
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var PayPalCheckout = _dereq_("./paypal-checkout");
        var VERSION2 = "3.100.0";
        function create2(options) {
          var name = "PayPal Checkout";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var instance = new PayPalCheckout(options);
            return instance._initialize(options);
          });
        }
        function isSupported() {
          return true;
        }
        module2.exports = {
          create: wrapPromise(create2),
          isSupported,
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "./paypal-checkout": 177, "@braintree/wrap-promise": 43 }], 177: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../lib/analytics");
        var assign2 = _dereq_("../lib/assign").assign;
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var ExtendedPromise = _dereq_("@braintree/extended-promise");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var convertToBraintreeError = _dereq_("../lib/convert-to-braintree-error");
        var errors = _dereq_("./errors");
        var constants = _dereq_("../paypal/shared/constants");
        var frameService = _dereq_("../lib/frame-service/external");
        var createAuthorizationData = _dereq_("../lib/create-authorization-data");
        var methods = _dereq_("../lib/methods");
        var useMin = _dereq_("../lib/use-min");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var querystring = _dereq_("../lib/querystring");
        var VERSION2 = "3.100.0";
        var INTEGRATION_TIMEOUT_MS = _dereq_("../lib/constants").INTEGRATION_TIMEOUT_MS;
        var REQUIRED_PARAMS_FOR_START_VAULT_INITIATED_CHECKOUT = [
          "amount",
          "currency",
          "vaultInitiatedCheckoutPaymentMethodToken"
        ];
        var PAYPAL_SDK_PRELOAD_URL = "https://www.{ENV}paypal.com/smart/buttons/preload";
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function PayPalCheckout(options) {
          this._merchantAccountId = options.merchantAccountId;
          this._autoSetDataUserIdToken = Boolean(options.autoSetDataUserIdToken);
        }
        PayPalCheckout.prototype._initialize = function(options) {
          var config;
          if (options.client) {
            config = options.client.getConfiguration();
            this._authorizationInformation = {
              fingerprint: config.authorizationFingerprint,
              environment: config.gatewayConfiguration.environment
            };
          } else {
            config = createAuthorizationData(options.authorization);
            this._authorizationInformation = {
              fingerprint: config.attrs.authorizationFingerprint,
              environment: config.environment
            };
          }
          this._clientPromise = createDeferredClient.create({
            authorization: options.authorization,
            client: options.client,
            debug: options.debug,
            assetsUrl: createAssetsUrl.create(options.authorization),
            name: "PayPal Checkout"
          }).then(function(client) {
            this._configuration = client.getConfiguration();
            if (!this._merchantAccountId) {
              if (!this._configuration.gatewayConfiguration.paypalEnabled) {
                this._setupError = new BraintreeError(errors.PAYPAL_NOT_ENABLED);
              } else if (this._configuration.gatewayConfiguration.paypal.environmentNoNetwork === true) {
                this._setupError = new BraintreeError(errors.PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED);
              }
            }
            if (this._setupError) {
              return Promise.reject(this._setupError);
            }
            analytics.sendEvent(client, "paypal-checkout.initialized");
            this._frameServicePromise = this._setupFrameService(client);
            return client;
          }.bind(this));
          if (options.client) {
            return this._clientPromise.then(function() {
              return this;
            }.bind(this));
          }
          return Promise.resolve(this);
        };
        PayPalCheckout.prototype._setupFrameService = function(client) {
          var frameServicePromise = new ExtendedPromise();
          var config = client.getConfiguration();
          var timeoutRef = setTimeout(function() {
            analytics.sendEvent(client, "paypal-checkout.frame-service.timed-out");
            frameServicePromise.reject(new BraintreeError(errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_SETUP_FAILED));
          }, INTEGRATION_TIMEOUT_MS);
          this._assetsUrl = config.gatewayConfiguration.paypal.assetsUrl + "/web/" + VERSION2;
          this._isDebug = config.isDebug;
          this._loadingFrameUrl = this._assetsUrl + "/html/paypal-landing-frame" + useMin(this._isDebug) + ".html";
          frameService.create({
            name: "braintreepaypallanding",
            dispatchFrameUrl: this._assetsUrl + "/html/dispatch-frame" + useMin(this._isDebug) + ".html",
            openFrameUrl: this._loadingFrameUrl
          }, function(service) {
            this._frameService = service;
            clearTimeout(timeoutRef);
            frameServicePromise.resolve();
          }.bind(this));
          return frameServicePromise;
        };
        PayPalCheckout.prototype.createPayment = function(options) {
          if (!options || !constants.FLOW_ENDPOINTS.hasOwnProperty(options.flow)) {
            return Promise.reject(new BraintreeError(errors.PAYPAL_FLOW_OPTION_REQUIRED));
          }
          analytics.sendEvent(this._clientPromise, "paypal-checkout.createPayment");
          return this._createPaymentResource(options).then(function(response) {
            var flowToken, urlParams;
            if (options.flow === "checkout") {
              urlParams = querystring.parse(response.paymentResource.redirectUrl);
              flowToken = urlParams.token;
            } else {
              flowToken = response.agreementSetup.tokenId;
            }
            return flowToken;
          });
        };
        PayPalCheckout.prototype._createPaymentResource = function(options, config) {
          var self2 = this;
          var endpoint = "paypal_hermes/" + constants.FLOW_ENDPOINTS[options.flow];
          delete this.intentFromCreatePayment;
          config = config || {};
          if (options.offerCredit === true) {
            analytics.sendEvent(this._clientPromise, "paypal-checkout.credit.offered");
          }
          return this._clientPromise.then(function(client) {
            return client.request({
              endpoint,
              method: "post",
              data: self2._formatPaymentResourceData(options, config)
            }).then(function(data2) {
              self2.intentFromCreatePayment = options.intent;
              return data2;
            });
          }).catch(function(err) {
            var status;
            if (self2._setupError) {
              return Promise.reject(self2._setupError);
            }
            status = err.details && err.details.httpStatus;
            if (status === 422) {
              return Promise.reject(new BraintreeError({
                type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
                code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
                message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
                details: {
                  originalError: err
                }
              }));
            }
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.PAYPAL_FLOW_FAILED.type,
              code: errors.PAYPAL_FLOW_FAILED.code,
              message: errors.PAYPAL_FLOW_FAILED.message
            }));
          });
        };
        PayPalCheckout.prototype.updatePayment = function(options) {
          var self2 = this;
          var endpoint = "paypal_hermes/patch_payment_resource";
          if (!options || this._hasMissingOption(options, constants.REQUIRED_OPTIONS)) {
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment.missing-options");
            return Promise.reject(new BraintreeError(errors.PAYPAL_MISSING_REQUIRED_OPTION));
          }
          if (!this._verifyConsistentCurrency(options)) {
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment.inconsistent-currencies");
            return Promise.reject(new BraintreeError({
              type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
              code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
              message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
              details: {
                originalError: new Error("One or more shipping option currencies differ from checkout currency.")
              }
            }));
          }
          analytics.sendEvent(this._clientPromise, "paypal-checkout.updatePayment");
          return this._clientPromise.then(function(client) {
            return client.request({
              endpoint,
              method: "post",
              data: self2._formatUpdatePaymentData(options)
            });
          }).catch(function(err) {
            var status = err.details && err.details.httpStatus;
            if (status === 422) {
              analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment.invalid");
              return Promise.reject(new BraintreeError({
                type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
                code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
                message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
                details: {
                  originalError: err
                }
              }));
            }
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment." + errors.PAYPAL_FLOW_FAILED.code);
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.PAYPAL_FLOW_FAILED.type,
              code: errors.PAYPAL_FLOW_FAILED.code,
              message: errors.PAYPAL_FLOW_FAILED.message
            }));
          });
        };
        PayPalCheckout.prototype.startVaultInitiatedCheckout = function(options) {
          var missingRequiredParam;
          var self2 = this;
          if (this._vaultInitiatedCheckoutInProgress) {
            analytics.sendEvent(this._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.error.already-in-progress");
            return Promise.reject(new BraintreeError(errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_IN_PROGRESS));
          }
          REQUIRED_PARAMS_FOR_START_VAULT_INITIATED_CHECKOUT.forEach(function(param) {
            if (!options.hasOwnProperty(param)) {
              missingRequiredParam = param;
            }
          });
          if (missingRequiredParam) {
            return Promise.reject(new BraintreeError({
              type: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_PARAM_REQUIRED.type,
              code: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_PARAM_REQUIRED.code,
              message: "Required param " + missingRequiredParam + " is missing."
            }));
          }
          this._vaultInitiatedCheckoutInProgress = true;
          this._addModalBackdrop(options);
          options = assign2({}, options, {
            flow: "checkout"
          });
          analytics.sendEvent(this._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.started");
          return this._waitForVaultInitiatedCheckoutDependencies().then(function() {
            var frameCommunicationPromise = new ExtendedPromise();
            var startVaultInitiatedCheckoutPromise = self2._createPaymentResource(options, {
              returnUrl: self2._constructVaultCheckutUrl("redirect-frame"),
              cancelUrl: self2._constructVaultCheckutUrl("cancel-frame")
            }).then(function(response) {
              var redirectUrl = response.paymentResource.redirectUrl;
              self2._frameService.redirect(redirectUrl);
              return frameCommunicationPromise;
            });
            self2._frameService.open({}, self2._createFrameServiceCallback(frameCommunicationPromise));
            return startVaultInitiatedCheckoutPromise;
          }).catch(function(err) {
            self2._vaultInitiatedCheckoutInProgress = false;
            self2._removeModalBackdrop();
            if (err.code === "FRAME_SERVICE_FRAME_CLOSED") {
              analytics.sendEvent(self2._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.canceled.by-customer");
              return Promise.reject(new BraintreeError(errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_CANCELED));
            }
            if (self2._frameService) {
              self2._frameService.close();
            }
            if (err.code && err.code.indexOf("FRAME_SERVICE_FRAME_OPEN_FAILED") > -1) {
              analytics.sendEvent(self2._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.failed.popup-not-opened");
              return Promise.reject(new BraintreeError({
                code: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED.code,
                type: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED.type,
                message: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED.message,
                details: {
                  originalError: err
                }
              }));
            }
            return Promise.reject(err);
          }).then(function(response) {
            self2._frameService.close();
            self2._vaultInitiatedCheckoutInProgress = false;
            self2._removeModalBackdrop();
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.succeeded");
            return Promise.resolve(response);
          });
        };
        PayPalCheckout.prototype._addModalBackdrop = function(options) {
          if (options.optOutOfModalBackdrop) {
            return;
          }
          if (!this._modalBackdrop) {
            this._modalBackdrop = document.createElement("div");
            this._modalBackdrop.setAttribute("data-braintree-paypal-vault-initiated-checkout-modal", true);
            this._modalBackdrop.style.position = "fixed";
            this._modalBackdrop.style.top = 0;
            this._modalBackdrop.style.bottom = 0;
            this._modalBackdrop.style.left = 0;
            this._modalBackdrop.style.right = 0;
            this._modalBackdrop.style.zIndex = 9999;
            this._modalBackdrop.style.background = "black";
            this._modalBackdrop.style.opacity = "0.7";
            this._modalBackdrop.addEventListener("click", function() {
              this.focusVaultInitiatedCheckoutWindow();
            }.bind(this));
          }
          document.body.appendChild(this._modalBackdrop);
        };
        PayPalCheckout.prototype._removeModalBackdrop = function() {
          if (!(this._modalBackdrop && this._modalBackdrop.parentNode)) {
            return;
          }
          this._modalBackdrop.parentNode.removeChild(this._modalBackdrop);
        };
        PayPalCheckout.prototype.closeVaultInitiatedCheckoutWindow = function() {
          if (this._vaultInitiatedCheckoutInProgress) {
            analytics.sendEvent(this._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.canceled.by-merchant");
          }
          return this._waitForVaultInitiatedCheckoutDependencies().then(function() {
            this._frameService.close();
          }.bind(this));
        };
        PayPalCheckout.prototype.focusVaultInitiatedCheckoutWindow = function() {
          return this._waitForVaultInitiatedCheckoutDependencies().then(function() {
            this._frameService.focus();
          }.bind(this));
        };
        PayPalCheckout.prototype._createFrameServiceCallback = function(frameCommunicationPromise) {
          var self2 = this;
          return function(err, payload) {
            if (err) {
              frameCommunicationPromise.reject(err);
            } else if (payload) {
              self2._frameService.redirect(self2._loadingFrameUrl);
              self2.tokenizePayment({
                paymentToken: payload.token,
                payerID: payload.PayerID,
                paymentID: payload.paymentId,
                orderID: payload.orderId
              }).then(function(res) {
                frameCommunicationPromise.resolve(res);
              }).catch(function(tokenizationError) {
                frameCommunicationPromise.reject(tokenizationError);
              });
            }
          };
        };
        PayPalCheckout.prototype._waitForVaultInitiatedCheckoutDependencies = function() {
          var self2 = this;
          return this._clientPromise.then(function() {
            return self2._frameServicePromise;
          });
        };
        PayPalCheckout.prototype._constructVaultCheckutUrl = function(frameName) {
          var serviceId = this._frameService._serviceId;
          return this._assetsUrl + "/html/" + frameName + useMin(this._isDebug) + ".html?channel=" + serviceId;
        };
        PayPalCheckout.prototype.tokenizePayment = function(tokenizeOptions) {
          var self2 = this;
          var shouldVault = true;
          var payload;
          var options = {
            flow: tokenizeOptions.billingToken && !tokenizeOptions.paymentID ? "vault" : "checkout",
            intent: tokenizeOptions.intent || this.intentFromCreatePayment
          };
          var params = {
            ecToken: tokenizeOptions.paymentToken,
            billingToken: tokenizeOptions.billingToken,
            payerId: tokenizeOptions.payerID,
            paymentId: tokenizeOptions.paymentID,
            orderId: tokenizeOptions.orderID,
            shippingOptionsId: tokenizeOptions.shippingOptionsId
          };
          if (tokenizeOptions.hasOwnProperty("vault")) {
            shouldVault = tokenizeOptions.vault;
          }
          options.vault = shouldVault;
          analytics.sendEvent(this._clientPromise, "paypal-checkout.tokenization.started");
          return this._clientPromise.then(function(client) {
            return client.request({
              endpoint: "payment_methods/paypal_accounts",
              method: "post",
              data: self2._formatTokenizeData(options, params)
            });
          }).then(function(response) {
            payload = self2._formatTokenizePayload(response);
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.tokenization.success");
            if (payload.creditFinancingOffered) {
              analytics.sendEvent(self2._clientPromise, "paypal-checkout.credit.accepted");
            }
            return payload;
          }).catch(function(err) {
            if (self2._setupError) {
              return Promise.reject(self2._setupError);
            }
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.tokenization.failed");
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.type,
              code: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.code,
              message: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.message
            }));
          });
        };
        PayPalCheckout.prototype.getClientId = function() {
          return this._clientPromise.then(function(client) {
            return client.getConfiguration().gatewayConfiguration.paypal.clientId;
          });
        };
        PayPalCheckout.prototype.loadPayPalSDK = function(options) {
          var idPromise, src;
          var loadPromise = new ExtendedPromise();
          var dataAttributes = options && options.dataAttributes || {};
          var userIdToken = dataAttributes["user-id-token"] || dataAttributes["data-user-id-token"];
          if (!userIdToken) {
            userIdToken = this._authorizationInformation.fingerprint && this._authorizationInformation.fingerprint.split("?")[0];
          }
          this._paypalScript = document.createElement("script");
          options = assign2({}, {
            components: "buttons"
          }, options);
          delete options.dataAttributes;
          if (options.vault) {
            options.intent = options.intent || "tokenize";
          } else {
            options.intent = options.intent || "authorize";
            options.currency = options.currency || "USD";
          }
          src = "https://www.paypal.com/sdk/js?";
          this._paypalScript.onload = function() {
            loadPromise.resolve();
          };
          Object.keys(dataAttributes).forEach(function(attribute) {
            this._paypalScript.setAttribute("data-" + attribute.replace(/^data\-/, ""), dataAttributes[attribute]);
          }.bind(this));
          if (options["client-id"]) {
            idPromise = Promise.resolve(options["client-id"]);
          } else {
            idPromise = this.getClientId();
          }
          idPromise.then(function(id) {
            options["client-id"] = id;
            if (this._autoSetDataUserIdToken && userIdToken) {
              this._paypalScript.setAttribute("data-user-id-token", userIdToken);
              this._attachPreloadPixel({
                id,
                userIdToken,
                amount: dataAttributes.amount,
                currency: options.currency,
                merchantId: options["merchant-id"]
              });
            }
            this._paypalScript.src = querystring.queryify(src, options);
            document.head.insertBefore(this._paypalScript, document.head.firstElementChild);
          }.bind(this));
          return loadPromise.then(function() {
            return this;
          }.bind(this));
        };
        PayPalCheckout.prototype._attachPreloadPixel = function(options) {
          var request3;
          var id = options.id;
          var userIdToken = options.userIdToken;
          var env = this._authorizationInformation.environment;
          var subdomain = env === "production" ? "" : "sandbox.";
          var url = PAYPAL_SDK_PRELOAD_URL.replace("{ENV}", subdomain);
          var preloadOptions = {
            "client-id": id,
            "user-id-token": userIdToken
          };
          if (options.amount) {
            preloadOptions.amount = options.amount;
          }
          if (options.currency) {
            preloadOptions.currency = options.currency;
          }
          if (options.merchantId) {
            preloadOptions["merchant-id"] = options.merchantId;
          }
          request3 = new XMLHttpRequest();
          request3.open("GET", querystring.queryify(url, preloadOptions));
          request3.send();
        };
        PayPalCheckout.prototype._formatPaymentResourceData = function(options, config) {
          var key;
          var gatewayConfiguration = this._configuration.gatewayConfiguration;
          var intent = options.intent;
          var paymentResource = {
            returnUrl: config.returnUrl || "https://www.paypal.com/checkoutnow/error",
            cancelUrl: config.cancelUrl || "https://www.paypal.com/checkoutnow/error",
            offerPaypalCredit: options.offerCredit === true,
            merchantAccountId: this._merchantAccountId,
            experienceProfile: {
              brandName: options.displayName || gatewayConfiguration.paypal.displayName,
              localeCode: options.locale,
              noShipping: (!options.enableShippingAddress).toString(),
              addressOverride: options.shippingAddressEditable === false,
              landingPageType: options.landingPageType
            },
            shippingOptions: options.shippingOptions
          };
          if (options.flow === "checkout") {
            paymentResource.amount = options.amount;
            paymentResource.currencyIsoCode = options.currency;
            paymentResource.requestBillingAgreement = options.requestBillingAgreement;
            if (intent) {
              if (intent === "capture") {
                intent = "sale";
              }
              paymentResource.intent = intent;
            }
            if (options.hasOwnProperty("lineItems")) {
              paymentResource.lineItems = options.lineItems;
            }
            if (options.hasOwnProperty("vaultInitiatedCheckoutPaymentMethodToken")) {
              paymentResource.vaultInitiatedCheckoutPaymentMethodToken = options.vaultInitiatedCheckoutPaymentMethodToken;
            }
            if (options.hasOwnProperty("shippingOptions")) {
              paymentResource.shippingOptions = options.shippingOptions;
            }
            for (key in options.shippingAddressOverride) {
              if (options.shippingAddressOverride.hasOwnProperty(key)) {
                paymentResource[key] = options.shippingAddressOverride[key];
              }
            }
            if (options.hasOwnProperty("billingAgreementDetails")) {
              paymentResource.billingAgreementDetails = options.billingAgreementDetails;
            }
          } else {
            paymentResource.shippingAddress = options.shippingAddressOverride;
            if (options.billingAgreementDescription) {
              paymentResource.description = options.billingAgreementDescription;
            }
          }
          this._riskCorrelationId = options.riskCorrelationId;
          if (options.riskCorrelationId) {
            paymentResource.correlationId = this._riskCorrelationId;
          }
          return paymentResource;
        };
        PayPalCheckout.prototype._verifyConsistentCurrency = function(options) {
          if (options.currency && options.hasOwnProperty("shippingOptions") && Array.isArray(options.shippingOptions)) {
            return options.shippingOptions.every(function(item) {
              return item.amount && item.amount.currency && options.currency.toLowerCase() === item.amount.currency.toLowerCase();
            });
          }
          return true;
        };
        PayPalCheckout.prototype._hasMissingOption = function(options, required) {
          var i, option;
          required = required || [];
          if (!options.hasOwnProperty("amount") && !options.hasOwnProperty("lineItems")) {
            return true;
          }
          for (i = 0; i < required.length; i++) {
            option = required[i];
            if (!options.hasOwnProperty(option)) {
              return true;
            }
          }
          return false;
        };
        PayPalCheckout.prototype._formatUpdatePaymentData = function(options) {
          var self2 = this;
          var paymentResource = {
            merchantAccountId: this._merchantAccountId,
            paymentId: options.paymentId || options.orderId,
            currencyIsoCode: options.currency
          };
          if (options.hasOwnProperty("amount")) {
            paymentResource.amount = options.amount;
          }
          if (options.hasOwnProperty("lineItems")) {
            paymentResource.lineItems = options.lineItems;
          }
          if (options.hasOwnProperty("shippingOptions")) {
            paymentResource.shippingOptions = options.shippingOptions;
          }
          if (options.hasOwnProperty("shippingAddress")) {
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment.shippingAddress.provided.by-the-merchant");
            paymentResource.line1 = options.shippingAddress.line1;
            if (options.shippingAddress.hasOwnProperty("line2")) {
              paymentResource.line2 = options.shippingAddress.line2;
            }
            paymentResource.city = options.shippingAddress.city;
            paymentResource.state = options.shippingAddress.state;
            paymentResource.postalCode = options.shippingAddress.postalCode;
            paymentResource.countryCode = options.shippingAddress.countryCode;
            if (options.shippingAddress.hasOwnProperty("phone")) {
              paymentResource.phone = options.shippingAddress.phone;
            }
            if (options.shippingAddress.hasOwnProperty("recipientName")) {
              paymentResource.recipientName = options.shippingAddress.recipientName;
            }
          }
          return paymentResource;
        };
        PayPalCheckout.prototype._formatTokenizeData = function(options, params) {
          var clientConfiguration = this._configuration;
          var gatewayConfiguration = clientConfiguration.gatewayConfiguration;
          var isTokenizationKey = clientConfiguration.authorizationType === "TOKENIZATION_KEY";
          var isVaultFlow = options.flow === "vault";
          var correlationId = this._riskCorrelationId || params.billingToken || params.ecToken;
          var data2 = {
            paypalAccount: {
              correlationId,
              options: {
                validate: isVaultFlow && !isTokenizationKey && options.vault
              }
            }
          };
          if (isVaultFlow) {
            data2.paypalAccount.billingAgreementToken = params.billingToken;
          } else {
            data2.paypalAccount.paymentToken = params.paymentId || params.orderId;
            data2.paypalAccount.payerId = params.payerId;
            data2.paypalAccount.unilateral = gatewayConfiguration.paypal.unvettedMerchant;
            if (options.intent) {
              data2.paypalAccount.intent = options.intent;
            }
          }
          if (this._merchantAccountId) {
            data2.merchantAccountId = this._merchantAccountId;
          }
          return data2;
        };
        PayPalCheckout.prototype._formatTokenizePayload = function(response) {
          var payload;
          var account = {};
          if (response.paypalAccounts) {
            account = response.paypalAccounts[0];
          }
          payload = {
            nonce: account.nonce,
            details: {},
            type: account.type
          };
          if (account.details && account.details.payerInfo) {
            payload.details = account.details.payerInfo;
          }
          if (account.details && account.details.creditFinancingOffered) {
            payload.creditFinancingOffered = account.details.creditFinancingOffered;
          }
          if (account.details && account.details.shippingOptionId) {
            payload.shippingOptionId = account.details.shippingOptionId;
          }
          if (account.details && account.details.cobrandedCardLabel) {
            payload.cobrandedCardLabel = account.details.cobrandedCardLabel;
          }
          return payload;
        };
        PayPalCheckout.prototype.teardown = function() {
          var self2 = this;
          convertMethodsToError(this, methods(PayPalCheckout.prototype));
          if (this._paypalScript && this._paypalScript.parentNode) {
            this._paypalScript.parentNode.removeChild(this._paypalScript);
          }
          return this._frameServicePromise.catch(function() {
          }).then(function() {
            if (!self2._frameService) {
              return Promise.resolve();
            }
            return self2._frameService.teardown();
          });
        };
        module2.exports = wrapPromise.wrapPrototype(PayPalCheckout);
      }, { "../lib/analytics": 119, "../lib/assign": 121, "../lib/braintree-error": 124, "../lib/constants": 126, "../lib/convert-methods-to-error": 127, "../lib/convert-to-braintree-error": 128, "../lib/create-assets-url": 129, "../lib/create-authorization-data": 130, "../lib/create-deferred-client": 131, "../lib/frame-service/external": 139, "../lib/methods": 155, "../lib/querystring": 157, "../lib/use-min": 160, "../paypal/shared/constants": 180, "./errors": 175, "@braintree/extended-promise": 34, "@braintree/wrap-promise": 43 }], 178: [function(_dereq_, module2, exports2) {
        var frameService = _dereq_("../../lib/frame-service/external");
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var convertToBraintreeError = _dereq_("../../lib/convert-to-braintree-error");
        var useMin = _dereq_("../../lib/use-min");
        var once = _dereq_("../../lib/once");
        var VERSION2 = "3.100.0";
        var constants = _dereq_("../shared/constants");
        var INTEGRATION_TIMEOUT_MS = _dereq_("../../lib/constants").INTEGRATION_TIMEOUT_MS;
        var analytics = _dereq_("../../lib/analytics");
        var methods = _dereq_("../../lib/methods");
        var deferred = _dereq_("../../lib/deferred");
        var errors = _dereq_("../shared/errors");
        var convertMethodsToError = _dereq_("../../lib/convert-methods-to-error");
        var querystring = _dereq_("../../lib/querystring");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function PayPal(options) {
          this._client = options.client;
          this._assetsUrl = options.client.getConfiguration().gatewayConfiguration.paypal.assetsUrl + "/web/" + VERSION2;
          this._isDebug = options.client.getConfiguration().isDebug;
          this._loadingFrameUrl = this._assetsUrl + "/html/paypal-landing-frame" + useMin(this._isDebug) + ".html";
          this._authorizationInProgress = false;
        }
        PayPal.prototype._initialize = function() {
          var self2 = this;
          var client = this._client;
          var failureTimeout = setTimeout(function() {
            analytics.sendEvent(client, "paypal.load.timed-out");
          }, INTEGRATION_TIMEOUT_MS);
          return new Promise(function(resolve2) {
            frameService.create({
              name: constants.LANDING_FRAME_NAME,
              dispatchFrameUrl: self2._assetsUrl + "/html/dispatch-frame" + useMin(self2._isDebug) + ".html",
              openFrameUrl: self2._loadingFrameUrl
            }, function(service) {
              self2._frameService = service;
              clearTimeout(failureTimeout);
              analytics.sendEvent(client, "paypal.load.succeeded");
              resolve2(self2);
            });
          });
        };
        PayPal.prototype.tokenize = function(options, callback) {
          var self2 = this;
          var client = this._client;
          var tokenizePromise, optionError;
          if (callback) {
            callback = once(deferred(callback));
          }
          if (!options || !constants.FLOW_ENDPOINTS.hasOwnProperty(options.flow)) {
            optionError = new BraintreeError(errors.PAYPAL_FLOW_OPTION_REQUIRED);
            if (callback) {
              callback(optionError);
              return this._frameService.createNoopHandler();
            }
            return Promise.reject(optionError);
          }
          tokenizePromise = new Promise(function(resolve2, reject) {
            if (self2._authorizationInProgress) {
              analytics.sendEvent(client, "paypal.tokenization.error.already-opened");
              reject(new BraintreeError(errors.PAYPAL_TOKENIZATION_REQUEST_ACTIVE));
            } else {
              self2._authorizationInProgress = true;
              if (!window.popupBridge) {
                analytics.sendEvent(client, "paypal.tokenization.opened");
              }
              if (options.offerCredit === true) {
                analytics.sendEvent(client, "paypal.credit.offered");
              }
              if (options.offerPayLater === true) {
                analytics.sendEvent(client, "paypal.paylater.offered");
              }
              self2._navigateFrameToAuth(options).catch(reject);
              self2._frameService.open({}, self2._createFrameServiceCallback(options, resolve2, reject));
            }
          });
          if (callback) {
            tokenizePromise.then(function(res) {
              callback(null, res);
            }).catch(callback);
            return this._frameService.createHandler({
              beforeClose: function() {
                analytics.sendEvent(client, "paypal.tokenization.closed.by-merchant");
              }
            });
          }
          return tokenizePromise;
        };
        PayPal.prototype._createFrameServiceCallback = function(options, resolve2, reject) {
          var self2 = this;
          var client = this._client;
          if (window.popupBridge) {
            return function(err, payload) {
              var canceled = payload && payload.path && payload.path.substring(0, 7) === "/cancel";
              self2._authorizationInProgress = false;
              if (err || canceled) {
                analytics.sendEvent(client, "paypal.tokenization.closed-popupbridge.by-user");
                reject(new BraintreeError(errors.PAYPAL_POPUP_CLOSED));
              } else if (payload) {
                self2._tokenizePayPal(options, payload.queryItems).then(resolve2).catch(reject);
              }
            };
          }
          return function(err, params) {
            self2._authorizationInProgress = false;
            if (err) {
              if (err.code === "FRAME_SERVICE_FRAME_CLOSED") {
                analytics.sendEvent(client, "paypal.tokenization.closed.by-user");
                reject(new BraintreeError(errors.PAYPAL_POPUP_CLOSED));
              } else if (err.code && err.code.indexOf("FRAME_SERVICE_FRAME_OPEN_FAILED") > -1) {
                reject(new BraintreeError({
                  code: errors.PAYPAL_POPUP_OPEN_FAILED.code,
                  type: errors.PAYPAL_POPUP_OPEN_FAILED.type,
                  message: errors.PAYPAL_POPUP_OPEN_FAILED.message,
                  details: {
                    originalError: err
                  }
                }));
              }
            } else if (params) {
              self2._tokenizePayPal(options, params).then(resolve2).catch(reject);
            }
          };
        };
        PayPal.prototype._tokenizePayPal = function(options, params) {
          var self2 = this;
          var client = this._client;
          if (!window.popupBridge) {
            this._frameService.redirect(this._loadingFrameUrl);
          }
          return client.request({
            endpoint: "payment_methods/paypal_accounts",
            method: "post",
            data: this._formatTokenizeData(options, params)
          }).then(function(response) {
            var payload = self2._formatTokenizePayload(response);
            if (window.popupBridge) {
              analytics.sendEvent(client, "paypal.tokenization.success-popupbridge");
            } else {
              analytics.sendEvent(client, "paypal.tokenization.success");
            }
            if (payload.creditFinancingOffered) {
              analytics.sendEvent(client, "paypal.credit.accepted");
            }
            self2._frameService.close();
            return payload;
          }).catch(function(err) {
            if (window.popupBridge) {
              analytics.sendEvent(client, "paypal.tokenization.failed-popupbridge");
            } else {
              analytics.sendEvent(client, "paypal.tokenization.failed");
            }
            self2._frameService.close();
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.type,
              code: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.code,
              message: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.message
            }));
          });
        };
        PayPal.prototype._formatTokenizePayload = function(response) {
          var payload;
          var account = {};
          if (response.paypalAccounts) {
            account = response.paypalAccounts[0];
          }
          payload = {
            nonce: account.nonce,
            details: {},
            type: account.type
          };
          if (account.details && account.details.payerInfo) {
            payload.details = account.details.payerInfo;
          }
          if (account.details && account.details.creditFinancingOffered) {
            payload.creditFinancingOffered = account.details.creditFinancingOffered;
          }
          return payload;
        };
        PayPal.prototype._formatTokenizeData = function(options, params) {
          var clientConfiguration = this._client.getConfiguration();
          var gatewayConfiguration = clientConfiguration.gatewayConfiguration;
          var isTokenizationKey = clientConfiguration.authorizationType === "TOKENIZATION_KEY";
          var data2 = {
            paypalAccount: {
              correlationId: params.ba_token || params.token,
              options: {
                validate: options.flow === "vault" && !isTokenizationKey
              }
            }
          };
          if (params.ba_token) {
            data2.paypalAccount.billingAgreementToken = params.ba_token;
          } else {
            data2.paypalAccount.paymentToken = params.paymentId;
            data2.paypalAccount.payerId = params.PayerID;
            data2.paypalAccount.unilateral = gatewayConfiguration.paypal.unvettedMerchant;
            if (options.hasOwnProperty("intent")) {
              data2.paypalAccount.intent = options.intent;
            }
          }
          return data2;
        };
        PayPal.prototype._navigateFrameToAuth = function(options) {
          var self2 = this;
          var client = this._client;
          var endpoint = "paypal_hermes/" + constants.FLOW_ENDPOINTS[options.flow];
          return client.request({
            endpoint,
            method: "post",
            data: this._formatPaymentResourceData(options)
          }).then(function(response) {
            var redirectUrl;
            if (options.flow === "checkout") {
              redirectUrl = response.paymentResource.redirectUrl;
            } else {
              redirectUrl = response.agreementSetup.approvalUrl;
            }
            if (options.useraction === "commit") {
              redirectUrl = querystring.queryify(redirectUrl, {
                useraction: "commit"
              });
            }
            if (window.popupBridge) {
              analytics.sendEvent(client, "paypal.tokenization.opened-popupbridge");
            }
            self2._frameService.redirect(redirectUrl);
          }).catch(function(err) {
            var status = err.details && err.details.httpStatus;
            self2._frameService.close();
            self2._authorizationInProgress = false;
            if (status === 422) {
              return Promise.reject(new BraintreeError({
                type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
                code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
                message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
                details: {
                  originalError: err
                }
              }));
            }
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.PAYPAL_FLOW_FAILED.type,
              code: errors.PAYPAL_FLOW_FAILED.code,
              message: errors.PAYPAL_FLOW_FAILED.message
            }));
          });
        };
        PayPal.prototype._formatPaymentResourceData = function(options) {
          var key;
          var gatewayConfiguration = this._client.getConfiguration().gatewayConfiguration;
          var serviceId = this._frameService._serviceId;
          var paymentResource = {
            returnUrl: gatewayConfiguration.paypal.assetsUrl + "/web/" + VERSION2 + "/html/redirect-frame" + useMin(this._isDebug) + ".html?channel=" + serviceId,
            cancelUrl: gatewayConfiguration.paypal.assetsUrl + "/web/" + VERSION2 + "/html/cancel-frame" + useMin(this._isDebug) + ".html?channel=" + serviceId,
            offerPaypalCredit: options.offerCredit === true,
            offerPayLater: options.offerPayLater === true,
            experienceProfile: {
              brandName: options.displayName || gatewayConfiguration.paypal.displayName,
              localeCode: options.locale,
              noShipping: (!options.enableShippingAddress).toString(),
              addressOverride: options.shippingAddressEditable === false,
              landingPageType: options.landingPageType
            }
          };
          if (window.popupBridge && typeof window.popupBridge.getReturnUrlPrefix === "function") {
            paymentResource.returnUrl = window.popupBridge.getReturnUrlPrefix() + "return";
            paymentResource.cancelUrl = window.popupBridge.getReturnUrlPrefix() + "cancel";
          }
          if (options.flow === "checkout") {
            paymentResource.amount = options.amount;
            paymentResource.currencyIsoCode = options.currency;
            if (options.hasOwnProperty("intent")) {
              paymentResource.intent = options.intent;
            }
            for (key in options.shippingAddressOverride) {
              if (options.shippingAddressOverride.hasOwnProperty(key)) {
                paymentResource[key] = options.shippingAddressOverride[key];
              }
            }
          } else {
            paymentResource.shippingAddress = options.shippingAddressOverride;
            if (options.billingAgreementDescription) {
              paymentResource.description = options.billingAgreementDescription;
            }
          }
          return paymentResource;
        };
        PayPal.prototype.closeWindow = function() {
          if (this._authorizationInProgress) {
            analytics.sendEvent(this._client, "paypal.tokenize.closed.by-merchant");
          }
          this._frameService.close();
        };
        PayPal.prototype.focusWindow = function() {
          this._frameService.focus();
        };
        PayPal.prototype.teardown = wrapPromise(function() {
          var self2 = this;
          self2._frameService.teardown();
          convertMethodsToError(self2, methods(PayPal.prototype));
          analytics.sendEvent(self2._client, "paypal.teardown-completed");
          return Promise.resolve();
        });
        module2.exports = PayPal;
      }, { "../../lib/analytics": 119, "../../lib/braintree-error": 124, "../../lib/constants": 126, "../../lib/convert-methods-to-error": 127, "../../lib/convert-to-braintree-error": 128, "../../lib/deferred": 132, "../../lib/frame-service/external": 139, "../../lib/methods": 155, "../../lib/once": 156, "../../lib/querystring": 157, "../../lib/use-min": 160, "../shared/constants": 180, "../shared/errors": 181, "@braintree/wrap-promise": 43 }], 179: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../lib/analytics");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var errors = _dereq_("./shared/errors");
        var PayPal = _dereq_("./external/paypal");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "PayPal";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            var pp;
            var config = client.getConfiguration();
            options.client = client;
            if (config.gatewayConfiguration.paypalEnabled !== true) {
              return Promise.reject(new BraintreeError(errors.PAYPAL_NOT_ENABLED));
            }
            analytics.sendEvent(options.client, "paypal.initialized");
            pp = new PayPal(options);
            return pp._initialize();
          });
        }
        function isSupported() {
          return true;
        }
        module2.exports = {
          create: wrapPromise(create2),
          isSupported,
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 119, "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./external/paypal": 178, "./shared/errors": 181, "@braintree/wrap-promise": 43 }], 180: [function(_dereq_, module2, exports2) {
        module2.exports = {
          LANDING_FRAME_NAME: "braintreepaypallanding",
          FLOW_ENDPOINTS: {
            checkout: "create_payment_resource",
            vault: "setup_billing_agreement"
          },
          REQUIRED_OPTIONS: ["paymentId", "currency"]
        };
      }, {}], 181: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          PAYPAL_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_NOT_ENABLED",
            message: "PayPal is not enabled for this merchant."
          },
          PAYPAL_TOKENIZATION_REQUEST_ACTIVE: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_TOKENIZATION_REQUEST_ACTIVE",
            message: "Another tokenization request is active."
          },
          PAYPAL_ACCOUNT_TOKENIZATION_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "PAYPAL_ACCOUNT_TOKENIZATION_FAILED",
            message: "Could not tokenize user's PayPal account."
          },
          PAYPAL_FLOW_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "PAYPAL_FLOW_FAILED",
            message: "Could not initialize PayPal flow."
          },
          PAYPAL_FLOW_OPTION_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_FLOW_OPTION_REQUIRED",
            message: "PayPal flow property is invalid or missing."
          },
          PAYPAL_POPUP_OPEN_FAILED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_POPUP_OPEN_FAILED",
            message: "PayPal popup failed to open, make sure to tokenize in response to a user action."
          },
          PAYPAL_POPUP_CLOSED: {
            type: BraintreeError.types.CUSTOMER,
            code: "PAYPAL_POPUP_CLOSED",
            message: "Customer closed PayPal popup before authorizing."
          },
          PAYPAL_INVALID_PAYMENT_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_INVALID_PAYMENT_OPTION",
            message: "PayPal payment options are invalid."
          }
        };
      }, { "../../lib/braintree-error": 124 }], 182: [function(_dereq_, module2, exports2) {
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var PreferredPaymentMethods = _dereq_("./preferred-payment-methods");
        var VERSION2 = "3.100.0";
        function create2(options) {
          var name = "PreferredPaymentMethods";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var instance = new PreferredPaymentMethods();
            return instance.initialize(options);
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "./preferred-payment-methods": 183, "@braintree/wrap-promise": 43 }], 183: [function(_dereq_, module2, exports2) {
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var analytics = _dereq_("../lib/analytics");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        function PreferredPaymentMethods() {
        }
        PreferredPaymentMethods.prototype.initialize = function(options) {
          var self2 = this;
          this._clientPromise = createDeferredClient.create({
            authorization: options.authorization,
            client: options.client,
            debug: options.debug,
            assetsUrl: createAssetsUrl.create(options.authorization),
            name: "PreferredPaymentMethods"
          }).catch(function(err) {
            self2._setupError = err;
            return Promise.reject(err);
          });
          analytics.sendEvent(this._clientPromise, "preferred-payment-methods.initialized");
          return Promise.resolve(this);
        };
        PreferredPaymentMethods.prototype.fetchPreferredPaymentMethods = function() {
          var client;
          var self2 = this;
          return this._clientPromise.then(function(clientInstance) {
            client = clientInstance;
            return client.request({
              api: "graphQLApi",
              data: {
                query: "query PreferredPaymentMethods { preferredPaymentMethods { paypalPreferred venmoPreferred } }"
              }
            });
          }).then(function(result) {
            var paypalPreferred = result.data.preferredPaymentMethods.paypalPreferred;
            var venmoPreferred = result.data.preferredPaymentMethods.venmoPreferred;
            analytics.sendEvent(client, "preferred-payment-methods.paypal.api-detected." + paypalPreferred);
            analytics.sendEvent(client, "preferred-payment-methods.venmo.api-detected." + venmoPreferred);
            return {
              paypalPreferred,
              venmoPreferred
            };
          }).catch(function() {
            if (self2._setupError) {
              return Promise.reject(self2._setupError);
            }
            analytics.sendEvent(client, "preferred-payment-methods.api-error");
            return {
              paypalPreferred: false,
              venmoPreferred: false
            };
          });
        };
        module2.exports = wrapPromise.wrapPrototype(PreferredPaymentMethods);
      }, { "../lib/analytics": 119, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "@braintree/wrap-promise": 43 }], 184: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var sepaErrors = _dereq_("../shared/errors");
        var frameService = _dereq_("../../lib/frame-service/external");
        var analytics = _dereq_("../../lib/analytics");
        var useMin = _dereq_("../../lib/use-min");
        var billingAddressOptions = _dereq_("../shared/constants").BILLING_ADDRESS_OPTIONS;
        var snakeCaseToCamelCase = _dereq_("../../lib/snake-case-to-camel-case");
        var POPUP_WIDTH = 400;
        var POPUP_HEIGHT = 570;
        function createMandate(client, options) {
          var data2 = {
            sepa_debit: {
              account_holder_name: options.accountHolderName,
              billing_address: {
                country_code: options.countryCode
              },
              iban: options.iban,
              merchant_or_partner_customer_id: options.customerId,
              mandate_type: options.mandateType
            },
            locale: options.locale,
            cancel_url: options.cancelUrl,
            return_url: options.returnUrl,
            merchant_account_id: options.merchantAccountId
          };
          if (options.billingAddress) {
            billingAddressOptions.forEach(function(option) {
              var ccOption = snakeCaseToCamelCase(option);
              if (ccOption in options.billingAddress) {
                data2.sepa_debit.billing_address[option] = options.billingAddress[ccOption];
              }
            });
          }
          return client.request({
            api: "clientApi",
            method: "post",
            endpoint: "sepa_debit",
            data: data2
          }).then(function(response) {
            var sepaDebitAccount = response.message.body.sepaDebitAccount;
            if (!sepaDebitAccount) {
              throw new BraintreeError(sepaErrors.SEPA_CREATE_MANDATE_FAILED);
            }
            return {
              approvalUrl: sepaDebitAccount.approvalUrl,
              last4: sepaDebitAccount.last4,
              bankReferenceToken: sepaDebitAccount.bankReferenceToken
            };
          }).catch(function() {
            throw new BraintreeError(sepaErrors.SEPA_CREATE_MANDATE_FAILED);
          });
        }
        function openPopup(client, options) {
          var popupName = "sepadirectdebit";
          var assetsBaseUrl = options.assetsUrl + "/html";
          var debug = options.debug || false;
          return new Promise(function(resolve2, reject) {
            var popupLocation = centeredPopupDimensions();
            frameService.create({
              name: popupName,
              dispatchFrameUrl: assetsBaseUrl + "/dispatch-frame" + useMin(debug) + ".html",
              openFrameUrl: assetsBaseUrl + "/sepa-landing-frame" + useMin(debug) + ".html",
              top: popupLocation.top,
              left: popupLocation.left,
              height: POPUP_HEIGHT,
              width: POPUP_WIDTH
            }, function(frameServiceInstance) {
              analytics.sendEvent(client, "sepa.popup.initialized");
              frameServiceInstance.open({}, function(err, params) {
                if (mandateApproved(params)) {
                  frameServiceInstance.close();
                  return resolve2();
                }
                if (customerCanceled(params, err)) {
                  frameServiceInstance.close();
                  return reject(new BraintreeError(sepaErrors.SEPA_CUSTOMER_CANCELED));
                }
                frameServiceInstance.close();
                return reject(new BraintreeError(sepaErrors.SEPA_TOKENIZATION_FAILED));
              });
              frameServiceInstance.redirect(options.approvalUrl);
            });
          });
        }
        function mandateApproved(params) {
          return params && params.success;
        }
        function customerCanceled(params, error) {
          return params && params.cancel || error && error.code === "FRAME_SERVICE_FRAME_CLOSED";
        }
        function centeredPopupDimensions() {
          var popupTop = Math.round((window.outerHeight - POPUP_HEIGHT) / 2) + window.screenTop;
          var popupLeft = Math.round((window.outerWidth - POPUP_WIDTH) / 2) + window.screenLeft;
          return {
            top: popupTop,
            left: popupLeft
          };
        }
        function handleApproval(client, options) {
          var data2 = {
            sepa_debit_account: {
              last_4: options.last4,
              merchant_or_partner_customer_id: options.customerId,
              bank_reference_token: options.bankReferenceToken,
              mandate_type: options.mandateType
            },
            merchant_account_id: options.merchantAccountId
          };
          return client.request({
            api: "clientApi",
            method: "post",
            endpoint: "payment_methods/sepa_debit_accounts",
            data: data2
          }).then(function(response) {
            if (!response.nonce) {
              throw new BraintreeError(sepaErrors.SEPA_TRANSACTION_FAILED);
            }
            return {
              nonce: response.nonce,
              ibanLastFour: options.last4,
              customerId: options.customerId,
              mandateType: options.mandateType
            };
          }).catch(function() {
            throw new BraintreeError(sepaErrors.SEPA_TRANSACTION_FAILED);
          });
        }
        module2.exports = {
          createMandate,
          openPopup,
          handleApproval,
          POPUP_WIDTH,
          POPUP_HEIGHT
        };
      }, { "../../lib/analytics": 119, "../../lib/braintree-error": 124, "../../lib/frame-service/external": 139, "../../lib/snake-case-to-camel-case": 159, "../../lib/use-min": 160, "../shared/constants": 187, "../shared/errors": 188 }], 185: [function(_dereq_, module2, exports2) {
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var sepaErrors = _dereq_("../shared/errors");
        var constants = _dereq_("../shared/constants");
        var mandates = _dereq_("./mandate");
        var hasMissingOption = _dereq_("../shared/has-missing-option");
        var analytics = _dereq_("../../lib/analytics");
        var VERSION2 = "3.100.0";
        var assign2 = _dereq_("../../lib/assign").assign;
        function SEPA(options) {
          var getConfiguration = options.client.getConfiguration();
          this._client = options.client;
          this._assetsUrl = getConfiguration.gatewayConfiguration.assetsUrl + "/web/" + VERSION2;
          this._isDebug = getConfiguration.isDebug;
          this._returnUrl = this._assetsUrl + "/html/redirect-frame.html?success=1";
          this._cancelUrl = this._assetsUrl + "/html/redirect-frame.html?cancel=1";
          analytics.sendEvent(this._client, "sepa.component.initialized");
        }
        SEPA.prototype.tokenize = function(options) {
          var self2 = this;
          var createMandateOptions = assign2({ cancelUrl: self2._cancelUrl, returnUrl: self2._returnUrl }, options);
          if (!options || hasMissingOption(options, constants.REQUIRED_OPTIONS)) {
            analytics.sendEvent(self2._client, "sepa.input-validation.missing-options");
            return Promise.reject(new BraintreeError(sepaErrors.SEPA_TOKENIZE_MISSING_REQUIRED_OPTION));
          }
          if (!constants.MANDATE_TYPE_ENUM.includes(options.mandateType)) {
            analytics.sendEvent(self2._client, "sepa.input-validation.invalid-mandate");
            return Promise.reject(new BraintreeError(sepaErrors.SEPA_INVALID_MANDATE_TYPE));
          }
          return mandates.createMandate(self2._client, createMandateOptions).then(function(mandateResponse) {
            analytics.sendEvent(self2._client, "sepa.create-mandate.success");
            options.last4 = mandateResponse.last4;
            options.bankReferenceToken = mandateResponse.bankReferenceToken;
            return mandates.openPopup(self2._client, {
              approvalUrl: mandateResponse.approvalUrl,
              assetsUrl: self2._assetsUrl
            });
          }).then(function() {
            analytics.sendEvent(self2._client, "sepa.mandate.approved");
            return mandates.handleApproval(self2._client, {
              bankReferenceToken: options.bankReferenceToken,
              last4: options.last4,
              customerId: options.customerId,
              mandateType: options.mandateType,
              merchantAccountId: options.merchantAccountId
            });
          }).then(function(approval) {
            analytics.sendEvent(self2._client, "sepa.tokenization.success");
            return Promise.resolve(approval);
          }).catch(function(err) {
            analytics.sendEvent(self2._client, "sepa." + err.details + ".failed");
            return Promise.reject(err);
          });
        };
        module2.exports = wrapPromise.wrapPrototype(SEPA);
      }, { "../../lib/analytics": 119, "../../lib/assign": 121, "../../lib/braintree-error": 124, "../shared/constants": 187, "../shared/errors": 188, "../shared/has-missing-option": 189, "./mandate": 184, "@braintree/wrap-promise": 43 }], 186: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../lib/analytics");
        var SEPA = _dereq_("./external/sepa");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var VERSION2 = "3.100.0";
        function create2(options) {
          var name = "SEPA";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            options.client = client;
            analytics.sendEvent(options.client, "sepa.client.initialized");
            return new SEPA(options);
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 119, "../lib/basic-component-verification": 122, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./external/sepa": 185, "@braintree/wrap-promise": 43 }], 187: [function(_dereq_, module2, exports2) {
        module2.exports = {
          REQUIRED_OPTIONS: [
            "iban",
            "merchantAccountId",
            "mandateType",
            "customerId",
            "accountHolderName",
            "countryCode"
          ],
          BILLING_ADDRESS_OPTIONS: [
            "address_line_1",
            "address_line_2",
            "admin_area_1",
            "admin_area_2",
            "postal_code"
          ],
          MANDATE_TYPE_ENUM: ["ONE_OFF", "RECURRENT"]
        };
      }, {}], 188: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          SEPA_CREATE_MANDATE_FAILED: {
            type: BraintreeError.types.MERCHANT,
            code: "SEPA_CREATE_MANDATE_FAILED",
            message: "SEPA create mandate failed.",
            details: "create-mandate"
          },
          SEPA_CUSTOMER_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "SEPA_CUSTOMER_CANCELED",
            message: "User canceled SEPA authorization",
            details: "customer-canceled"
          },
          SEPA_INVALID_MANDATE_TYPE: {
            type: BraintreeError.types.MERCHANT,
            code: "SEPA_INVALID_MANDATE_TYPE",
            message: "SEPA mandate type is invalid"
          },
          SEPA_TOKENIZATION_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "SEPA_TOKENIZATION_FAILED",
            message: "SEPA encountered a problem",
            details: "open-popup"
          },
          SEPA_TOKENIZE_MISSING_REQUIRED_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "SEPA_TOKENIZE_MISSING_REQUIRED_OPTION",
            message: "Missing required option for tokenize."
          },
          SEPA_TRANSACTION_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "SEPA_TRANSACTION_FAILED",
            message: "SEPA transaction failed",
            details: "handle-approval"
          }
        };
      }, { "../../lib/braintree-error": 124 }], 189: [function(_dereq_, module2, exports2) {
        function hasMissingOption(options, required) {
          var i, option;
          required = required || [];
          for (i = 0; i < required.length; i++) {
            option = required[i];
            if (!options.hasOwnProperty(option)) {
              return true;
            }
          }
          return false;
        }
        module2.exports = hasMissingOption;
      }, {}], 190: [function(_dereq_, module2, exports2) {
        var assign2 = _dereq_("../../../lib/assign").assign;
        var analytics = _dereq_("../../../lib/analytics");
        var BraintreeError = _dereq_("../../../lib/braintree-error");
        var isVerifiedDomain = _dereq_("../../../lib/is-verified-domain");
        var ExtendedPromise = _dereq_("@braintree/extended-promise");
        var EventEmitter = _dereq_("@braintree/event-emitter");
        var errors = _dereq_("../../shared/errors");
        var iFramer = _dereq_("@braintree/iframer");
        var Bus = _dereq_("framebus");
        var constants = _dereq_("../../shared/constants");
        var uuid = _dereq_("@braintree/uuid");
        var events = _dereq_("../../shared/events");
        var useMin = _dereq_("../../../lib/use-min");
        var BUS_CONFIGURATION_REQUEST_EVENT = _dereq_("../../../lib/constants").BUS_CONFIGURATION_REQUEST_EVENT;
        var VERSION2 = "3.100.0";
        var IFRAME_HEIGHT = 400;
        var IFRAME_WIDTH = 400;
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function BaseFramework(options) {
          EventEmitter.call(this);
          this._client = options.client;
          this._createPromise = options.createPromise;
          this._createOptions = options;
          if (this._client) {
            this._isDebug = this._client.getConfiguration().isDebug;
            this._assetsUrl = this._client.getConfiguration().gatewayConfiguration.assetsUrl;
          } else {
            this._isDebug = Boolean(options.isDebug);
            this._assetsUrl = options.assetsUrl;
          }
          this._assetsUrl = this._assetsUrl + "/web/" + VERSION2;
        }
        EventEmitter.createChild(BaseFramework);
        BaseFramework.prototype._waitForClient = function() {
          if (this._client) {
            return Promise.resolve();
          }
          return this._createPromise.then(function(client) {
            this._client = client;
          }.bind(this));
        };
        BaseFramework.prototype.setUpEventListeners = function() {
          throw new BraintreeError(errors.THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED);
        };
        BaseFramework.prototype.verifyCard = function(options, privateOptions) {
          var formattedOptions, error;
          var self2 = this;
          privateOptions = privateOptions || {};
          error = this._checkForVerifyCardError(options, privateOptions);
          if (error) {
            return Promise.reject(error);
          }
          this._verifyCardInProgress = true;
          formattedOptions = this._formatVerifyCardOptions(options);
          return this._formatLookupData(formattedOptions).then(function(data2) {
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.started");
            return self2._performLookup(formattedOptions.nonce, data2);
          }).then(function(response) {
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.3ds-version." + response.lookup.threeDSecureVersion);
            return self2._onLookupComplete(response, formattedOptions);
          }).then(function(response) {
            return self2.initializeChallengeWithLookupResponse(response, formattedOptions);
          }).then(function(payload) {
            self2._resetVerificationState();
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.completed");
            return payload;
          }).catch(function(err) {
            self2._resetVerificationState();
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.failed");
            return Promise.reject(err);
          });
        };
        BaseFramework.prototype._checkForFrameworkSpecificVerifyCardErrors = function() {
          throw new BraintreeError(errors.THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED);
        };
        BaseFramework.prototype._presentChallenge = function() {
          throw new BraintreeError(errors.THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED);
        };
        BaseFramework.prototype.prepareLookup = function() {
          throw new BraintreeError(errors.THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED);
        };
        BaseFramework.prototype._resetVerificationState = function() {
          this._verifyCardInProgress = false;
          this._verifyCardPromisePlus = null;
          if (typeof this._reloadThreeDSecure === "function") {
            this._reloadThreeDSecure();
          }
        };
        BaseFramework.prototype._performLookup = function(nonce, data2) {
          var self2 = this;
          var url = "payment_methods/" + nonce + "/three_d_secure/lookup";
          return this._waitForClient().then(function() {
            return self2._client.request({
              endpoint: url,
              method: "post",
              data: data2
            }).catch(function(err) {
              var status = err && err.details && err.details.httpStatus;
              var analyticsMessage = "three-d-secure.verification-flow.lookup-failed";
              var lookupError;
              if (status === 404) {
                lookupError = errors.THREEDS_LOOKUP_TOKENIZED_CARD_NOT_FOUND_ERROR;
                analyticsMessage += ".404";
              } else if (status === 422) {
                lookupError = errors.THREEDS_LOOKUP_VALIDATION_ERROR;
                analyticsMessage += ".422";
              } else {
                lookupError = errors.THREEDS_LOOKUP_ERROR;
              }
              analytics.sendEvent(self2._createPromise, analyticsMessage);
              return Promise.reject(new BraintreeError({
                type: lookupError.type,
                code: lookupError.code,
                message: lookupError.message,
                details: {
                  originalError: err
                }
              }));
            });
          });
        };
        BaseFramework.prototype._checkForVerifyCardError = function(options, privateOptions) {
          var errorOption;
          if (this._verifyCardInProgress === true) {
            return new BraintreeError(errors.THREEDS_AUTHENTICATION_IN_PROGRESS);
          } else if (!options.nonce) {
            errorOption = "a nonce";
          } else if (!options.amount) {
            errorOption = "an amount";
          }
          if (!errorOption) {
            errorOption = this._checkForFrameworkSpecificVerifyCardErrors(options, privateOptions);
          }
          if (errorOption) {
            return new BraintreeError({
              type: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.type,
              code: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.code,
              message: "verifyCard options must include " + errorOption + "."
            });
          }
          return null;
        };
        BaseFramework.prototype.initializeChallengeWithLookupResponse = function(lookupResponse, options) {
          var self2 = this;
          options = options || {};
          this._lookupPaymentMethod = lookupResponse.paymentMethod;
          self2._verifyCardPromisePlus = self2._verifyCardPromisePlus || new ExtendedPromise();
          self2._handleLookupResponse(lookupResponse, options);
          return self2._verifyCardPromisePlus.then(function(payload) {
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.liability-shifted." + String(payload.liabilityShifted));
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.liability-shift-possible." + String(payload.liabilityShiftPossible));
            return payload;
          });
        };
        BaseFramework.prototype._handleLookupResponse = function(lookupResponse, options) {
          var challengeShouldBePresented = Boolean(lookupResponse.lookup && lookupResponse.lookup.acsUrl);
          var details;
          analytics.sendEvent(this._createPromise, "three-d-secure.verification-flow.challenge-presented." + String(challengeShouldBePresented));
          if (challengeShouldBePresented) {
            this._presentChallenge(lookupResponse, options);
          } else {
            details = this._formatAuthResponse(lookupResponse.paymentMethod, lookupResponse.threeDSecureInfo);
            details.verificationDetails = lookupResponse.threeDSecureInfo;
            this._verifyCardPromisePlus.resolve(details);
          }
        };
        BaseFramework.prototype._onLookupComplete = function(response) {
          this._lookupPaymentMethod = response.paymentMethod;
          this._verifyCardPromisePlus = new ExtendedPromise();
          return Promise.resolve(response);
        };
        BaseFramework.prototype._formatAuthResponse = function(paymentMethod, threeDSecureInfo) {
          return {
            nonce: paymentMethod.nonce,
            type: paymentMethod.type,
            binData: paymentMethod.binData,
            details: paymentMethod.details,
            description: paymentMethod.description && paymentMethod.description.replace(/\+/g, " "),
            liabilityShifted: threeDSecureInfo && threeDSecureInfo.liabilityShifted,
            liabilityShiftPossible: threeDSecureInfo && threeDSecureInfo.liabilityShiftPossible,
            threeDSecureInfo: paymentMethod.threeDSecureInfo
          };
        };
        BaseFramework.prototype._formatVerifyCardOptions = function(options) {
          return assign2({}, options);
        };
        BaseFramework.prototype._formatLookupData = function(options) {
          var data2 = {
            amount: options.amount
          };
          if (options.collectDeviceData === true) {
            data2.browserColorDepth = window.screen.colorDepth;
            data2.browserJavaEnabled = window.navigator.javaEnabled();
            data2.browserJavascriptEnabled = true;
            data2.browserLanguage = window.navigator.language;
            data2.browserScreenHeight = window.screen.height;
            data2.browserScreenWidth = window.screen.width;
            data2.browserTimeZone = new Date().getTimezoneOffset();
            data2.deviceChannel = "Browser";
          }
          return Promise.resolve(data2);
        };
        BaseFramework.prototype._handleV1AuthResponse = function(data2) {
          var authResponse = JSON.parse(data2.auth_response);
          if (authResponse.success) {
            this._verifyCardPromisePlus.resolve(this._formatAuthResponse(authResponse.paymentMethod, authResponse.threeDSecureInfo));
          } else if (authResponse.threeDSecureInfo && authResponse.threeDSecureInfo.liabilityShiftPossible) {
            this._verifyCardPromisePlus.resolve(this._formatAuthResponse(this._lookupPaymentMethod, authResponse.threeDSecureInfo));
          } else {
            this._verifyCardPromisePlus.reject(new BraintreeError({
              type: BraintreeError.types.UNKNOWN,
              code: "UNKNOWN_AUTH_RESPONSE",
              message: authResponse.error.message
            }));
          }
        };
        BaseFramework.prototype.cancelVerifyCard = function() {
          var response, threeDSecureInfo;
          this._verifyCardInProgress = false;
          if (!this._lookupPaymentMethod) {
            return Promise.reject(new BraintreeError(errors.THREEDS_NO_VERIFICATION_PAYLOAD));
          }
          threeDSecureInfo = this._lookupPaymentMethod.threeDSecureInfo;
          response = assign2({}, this._lookupPaymentMethod, {
            liabilityShiftPossible: threeDSecureInfo && threeDSecureInfo.liabilityShiftPossible,
            liabilityShifted: threeDSecureInfo && threeDSecureInfo.liabilityShifted,
            verificationDetails: threeDSecureInfo && threeDSecureInfo.verificationDetails
          });
          return Promise.resolve(response);
        };
        BaseFramework.prototype._setupV1Bus = function(options) {
          var clientConfiguration = this._client.getConfiguration();
          var parentURL = window.location.href.split("#")[0];
          var lookupResponse = options.lookupResponse;
          var channel = uuid();
          var bus = new Bus({
            channel,
            verifyDomain: isVerifiedDomain
          });
          var authenticationCompleteBaseUrl = this._assetsUrl + "/html/three-d-secure-authentication-complete-frame.html?channel=" + encodeURIComponent(channel) + "&";
          bus.on(BUS_CONFIGURATION_REQUEST_EVENT, function(reply) {
            reply({
              clientConfiguration,
              nonce: options.nonce,
              acsUrl: lookupResponse.acsUrl,
              pareq: lookupResponse.pareq,
              termUrl: lookupResponse.termUrl + "&three_d_secure_version=" + VERSION2 + "&authentication_complete_base_url=" + encodeURIComponent(authenticationCompleteBaseUrl),
              md: lookupResponse.md,
              parentUrl: parentURL
            });
          });
          bus.on(events.AUTHENTICATION_COMPLETE, options.handleAuthResponse);
          return bus;
        };
        BaseFramework.prototype._setupV1Iframe = function(options) {
          var url = this._assetsUrl + "/html/three-d-secure-bank-frame" + useMin(this._isDebug) + ".html?showLoader=" + options.showLoader;
          var bankIframe = iFramer({
            src: url,
            height: IFRAME_HEIGHT,
            width: IFRAME_WIDTH,
            name: constants.LANDING_FRAME_NAME + "_" + this._v1Bus.channel,
            title: "3D Secure Authorization Frame"
          });
          return bankIframe;
        };
        BaseFramework.prototype._setupV1Elements = function(options) {
          this._v1Bus = this._setupV1Bus(options);
          this._v1Iframe = this._setupV1Iframe(options);
        };
        BaseFramework.prototype._teardownV1Elements = function() {
          if (this._v1Bus) {
            this._v1Bus.teardown();
            this._v1Bus = null;
          }
          if (this._v1Iframe && this._v1Iframe.parentNode) {
            this._v1Iframe.parentNode.removeChild(this._v1Iframe);
            this._v1Iframe = null;
          }
          if (this._onV1Keyup) {
            document.removeEventListener("keyup", this._onV1Keyup);
            this._onV1Keyup = null;
          }
        };
        BaseFramework.prototype.teardown = function() {
          analytics.sendEvent(this._createPromise, "three-d-secure.teardown-completed");
          this._teardownV1Elements();
          return Promise.resolve();
        };
        module2.exports = BaseFramework;
      }, { "../../../lib/analytics": 119, "../../../lib/assign": 121, "../../../lib/braintree-error": 124, "../../../lib/constants": 126, "../../../lib/is-verified-domain": 153, "../../../lib/use-min": 160, "../../shared/constants": 199, "../../shared/errors": 200, "../../shared/events": 201, "@braintree/event-emitter": 33, "@braintree/extended-promise": 34, "@braintree/iframer": 35, "@braintree/uuid": 39, "framebus": 52 }], 191: [function(_dereq_, module2, exports2) {
        var SongbirdFramework = _dereq_("./songbird");
        function Bootstrap3ModalFramework(options) {
          SongbirdFramework.call(this, options);
        }
        Bootstrap3ModalFramework.prototype = Object.create(SongbirdFramework.prototype, {
          constructor: SongbirdFramework
        });
        Bootstrap3ModalFramework.prototype._createV1IframeModalElement = function(iframe) {
          var modal = document.createElement("div");
          modal.innerHTML = '<div class="modal fade in" tabindex="-1" role="dialog" aria-labelledby="CCAFrameModal-label" aria-hidden="true" style="display: block;"><div class="modal-dialog" style="width:440px;z-index:999999;"><div class="modal-content"><div class="modal-body" data-braintree-v1-fallback-iframe-container><button type="button" data-braintree-v1-fallback-close-button class="close" data-dismiss="modal" aria-hidden="true">\xD7</button></div></div></div><div data-braintree-v1-fallback-backdrop style="position: fixed;cursor: pointer;z-index: 999998;top: 0;left: 0;width: 100%;height: 100%;"></div></div>';
          modal.querySelector("[data-braintree-v1-fallback-iframe-container]").appendChild(iframe);
          return modal;
        };
        Bootstrap3ModalFramework.prototype._createCardinalConfigurationOptions = function(setupOptions) {
          var options = SongbirdFramework.prototype._createCardinalConfigurationOptions.call(this, setupOptions);
          options.payment.framework = "bootstrap3";
          return options;
        };
        module2.exports = Bootstrap3ModalFramework;
      }, { "./songbird": 196 }], 192: [function(_dereq_, module2, exports2) {
        var SongbirdFramework = _dereq_("./songbird");
        function CardinalModalFramework(options) {
          SongbirdFramework.call(this, options);
        }
        CardinalModalFramework.prototype = Object.create(SongbirdFramework.prototype, {
          constructor: SongbirdFramework
        });
        CardinalModalFramework.prototype._createV1IframeModalElement = function(iframe) {
          var modal = document.createElement("div");
          var addCloseButton = Boolean(this._createOptions && this._createOptions.cardinalSDKConfig && this._createOptions.cardinalSDKConfig.payment && this._createOptions.cardinalSDKConfig.payment.displayExitButton);
          modal.innerHTML = `<div style="position: fixed;z-index: 999999;top: 50%;left: 50%;padding: 24px 20px;transform: translate(-50%,-50%);border-radius: 2px;background: #fff;max-width: 100%;overflow: auto;"><div><button data-braintree-v1-fallback-close-button style="font-family: Helvetica,Arial,sans-serif;font-size: 25px;line-height: 12px;position: absolute;top: 2px;right: 0px;cursor: pointer;color: #999;border: 0;outline: none;background: none;" onMouseOver="this.style.color='#000'" onMouseOut="this.style.color='#999'">\xD7</button></div><div data-braintree-v1-fallback-iframe-container style="height: 400px;"></div></div><div data-braintree-v1-fallback-backdrop style="position: fixed;z-index: 999998;cursor: pointer;top: 0;left: 0;width: 100%;height: 100%;transition: opacity 1ms ease;background: rgba(0,0,0,.6);"></div>`;
          if (!addCloseButton) {
            modal.querySelector("[data-braintree-v1-fallback-close-button]").style.display = "none";
          }
          modal.querySelector("[data-braintree-v1-fallback-iframe-container]").appendChild(iframe);
          return modal;
        };
        module2.exports = CardinalModalFramework;
      }, { "./songbird": 196 }], 193: [function(_dereq_, module2, exports2) {
        var LegacyFramework = _dereq_("./legacy");
        var CardinalModalFramework = _dereq_("./cardinal-modal");
        var Bootstrap3ModalFramework = _dereq_("./bootstrap3-modal");
        var InlineIframeFramework = _dereq_("./inline-iframe");
        module2.exports = {
          legacy: LegacyFramework,
          "cardinal-modal": CardinalModalFramework,
          "bootstrap3-modal": Bootstrap3ModalFramework,
          "inline-iframe": InlineIframeFramework
        };
      }, { "./bootstrap3-modal": 191, "./cardinal-modal": 192, "./inline-iframe": 194, "./legacy": 195 }], 194: [function(_dereq_, module2, exports2) {
        var SongbirdFramework = _dereq_("./songbird");
        var BraintreeError = _dereq_("../../../lib/braintree-error");
        var errors = _dereq_("../../shared/errors");
        var enumerate = _dereq_("../../../lib/enumerate");
        function InlineIframeFramework(options) {
          SongbirdFramework.call(this, options);
        }
        InlineIframeFramework.prototype = Object.create(SongbirdFramework.prototype, {
          constructor: SongbirdFramework
        });
        InlineIframeFramework.events = enumerate(["AUTHENTICATION_IFRAME_AVAILABLE"], "inline-iframe-framework:");
        InlineIframeFramework.prototype.setUpEventListeners = function(reply) {
          SongbirdFramework.prototype.setUpEventListeners.call(this, reply);
          this.on(InlineIframeFramework.events.AUTHENTICATION_IFRAME_AVAILABLE, function(payload, next) {
            reply("authentication-iframe-available", payload, next);
          });
        };
        InlineIframeFramework.prototype._createCardinalConfigurationOptions = function(setupOptions) {
          var options = SongbirdFramework.prototype._createCardinalConfigurationOptions.call(this, setupOptions);
          options.payment.framework = "inline";
          return options;
        };
        InlineIframeFramework.prototype._addV1IframeToPage = function() {
          this._emit(InlineIframeFramework.events.AUTHENTICATION_IFRAME_AVAILABLE, {
            element: this._v1Modal
          }, function() {
          });
        };
        InlineIframeFramework.prototype._setupFrameworkSpecificListeners = function() {
          this.setCardinalListener("ui.inline.setup", this._onInlineSetup.bind(this));
        };
        InlineIframeFramework.prototype._onInlineSetup = function(htmlTemplate, details, resolve2, reject) {
          var container, hasError;
          if (!htmlTemplate || !details) {
            hasError = true;
          } else if (details.paymentType !== "CCA") {
            hasError = true;
          } else if (!(details.data.mode === "suppress" || details.data.mode === "static")) {
            hasError = true;
          }
          if (hasError) {
            reject(new BraintreeError(errors.THREEDS_INLINE_IFRAME_DETAILS_INCORRECT));
            return;
          }
          container = document.createElement("div");
          container.innerHTML = htmlTemplate;
          if (details.data.mode === "suppress") {
            container.style.display = "none";
            document.body.appendChild(container);
            resolve2();
          } else if (details.data.mode === "static") {
            this._emit(InlineIframeFramework.events.AUTHENTICATION_IFRAME_AVAILABLE, {
              element: container
            }, function() {
              resolve2();
            });
          }
        };
        module2.exports = InlineIframeFramework;
      }, { "../../../lib/braintree-error": 124, "../../../lib/enumerate": 134, "../../shared/errors": 200, "./songbird": 196 }], 195: [function(_dereq_, module2, exports2) {
        var BaseFramework = _dereq_("./base");
        var deferred = _dereq_("../../../lib/deferred");
        function LegacyFramework(options) {
          BaseFramework.call(this, options);
        }
        LegacyFramework.prototype = Object.create(BaseFramework.prototype, {
          constructor: LegacyFramework
        });
        LegacyFramework.prototype.setUpEventListeners = function() {
        };
        LegacyFramework.prototype.transformV1CustomerBillingAddress = function(customer) {
          customer.billingAddress.line1 = customer.billingAddress.streetAddress;
          customer.billingAddress.line2 = customer.billingAddress.extendedAddress;
          customer.billingAddress.city = customer.billingAddress.locality;
          customer.billingAddress.state = customer.billingAddress.region;
          customer.billingAddress.countryCode = customer.billingAddress.countryCodeAlpha2;
          delete customer.billingAddress.streetAddress;
          delete customer.billingAddress.extendedAddress;
          delete customer.billingAddress.locality;
          delete customer.billingAddress.region;
          delete customer.billingAddress.countryCodeAlpha2;
          return customer;
        };
        LegacyFramework.prototype._createIframe = function(options) {
          var self2 = this;
          this._setupV1Elements({
            nonce: options.nonce,
            lookupResponse: options.lookupResponse,
            showLoader: options.showLoader,
            handleAuthResponse: function(data2) {
              self2._handleAuthResponse(data2, options);
            }
          });
          return this._v1Iframe;
        };
        LegacyFramework.prototype._handleAuthResponse = function(data2, options) {
          this._v1Bus.teardown();
          options.removeFrame();
          deferred(function() {
            this._handleV1AuthResponse(data2);
          }.bind(this))();
        };
        LegacyFramework.prototype._checkForFrameworkSpecificVerifyCardErrors = function(options) {
          var errorOption;
          if (typeof options.addFrame !== "function") {
            errorOption = "an addFrame function";
          } else if (typeof options.removeFrame !== "function") {
            errorOption = "a removeFrame function";
          }
          return errorOption;
        };
        LegacyFramework.prototype._formatVerifyCardOptions = function(options) {
          var modifiedOptions = BaseFramework.prototype._formatVerifyCardOptions.call(this, options);
          modifiedOptions.addFrame = deferred(options.addFrame);
          modifiedOptions.removeFrame = deferred(options.removeFrame);
          modifiedOptions.showLoader = options.showLoader !== false;
          return modifiedOptions;
        };
        LegacyFramework.prototype._formatLookupData = function(options) {
          var self2 = this;
          return BaseFramework.prototype._formatLookupData.call(this, options).then(function(data2) {
            if (options.customer && options.customer.billingAddress) {
              data2.customer = self2.transformV1CustomerBillingAddress(options.customer);
            }
            return data2;
          });
        };
        LegacyFramework.prototype._presentChallenge = function(lookupResponse, options) {
          options.addFrame(null, this._createIframe({
            showLoader: options.showLoader,
            lookupResponse: lookupResponse.lookup,
            nonce: lookupResponse.paymentMethod.nonce,
            removeFrame: options.removeFrame
          }));
        };
        module2.exports = LegacyFramework;
      }, { "../../../lib/deferred": 132, "./base": 190 }], 196: [function(_dereq_, module2, exports2) {
        var BaseFramework = _dereq_("./base");
        var assign2 = _dereq_("../../../lib/assign").assign;
        var deferred = _dereq_("../../../lib/deferred");
        var BraintreeError = _dereq_("../../../lib/braintree-error");
        var convertToBraintreeError = _dereq_("../../../lib/convert-to-braintree-error");
        var analytics = _dereq_("../../../lib/analytics");
        var assets = _dereq_("../../../lib/assets");
        var errors = _dereq_("../../shared/errors");
        var enumerate = _dereq_("../../../lib/enumerate");
        var constants = _dereq_("../../shared/constants");
        var ExtendedPromise = _dereq_("@braintree/extended-promise");
        var INTEGRATION_TIMEOUT_MS = _dereq_("../../../lib/constants").INTEGRATION_TIMEOUT_MS;
        var PLATFORM = _dereq_("../../../lib/constants").PLATFORM;
        var VERSION2 = "3.100.0";
        var CUSTOMER_CANCELED_SONGBIRD_MODAL = "01";
        var SONGBIRD_UI_EVENTS = [
          "ui.close",
          "ui.render",
          "ui.renderHidden",
          "ui.loading.close",
          "ui.loading.render"
        ];
        var SCA_EXEMPTION_TYPES = ["low_value", "transaction_risk_analysis"];
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function SongbirdFramework(options) {
          BaseFramework.call(this, options);
          this._songbirdInitFailed = false;
          this._clientMetadata = {
            requestedThreeDSecureVersion: "2",
            sdkVersion: PLATFORM + "/" + VERSION2
          };
          this.originalSetupOptions = options;
          this._getDfReferenceIdPromisePlus = new ExtendedPromise();
          this.setupSongbird(options);
          this._cardinalEvents = [];
        }
        SongbirdFramework.prototype = Object.create(BaseFramework.prototype, {
          constructor: SongbirdFramework
        });
        SongbirdFramework.events = enumerate([
          "LOOKUP_COMPLETE",
          "CUSTOMER_CANCELED",
          "UI.CLOSE",
          "UI.RENDER",
          "UI.RENDERHIDDEN",
          "UI.LOADING.CLOSE",
          "UI.LOADING.RENDER"
        ], "songbird-framework:");
        SongbirdFramework.prototype.setUpEventListeners = function(reply) {
          this.on(SongbirdFramework.events.LOOKUP_COMPLETE, function(data2, next) {
            reply("lookup-complete", data2, next);
          });
          this.on(SongbirdFramework.events.CUSTOMER_CANCELED, function() {
            reply("customer-canceled");
          });
          this.on(SongbirdFramework.events["UI.CLOSE"], function() {
            reply("authentication-modal-close");
          });
          this.on(SongbirdFramework.events["UI.RENDER"], function() {
            reply("authentication-modal-render");
          });
          this.on(SongbirdFramework.events["UI.RENDERHIDDEN"], function() {
            reply("authentication-modal-render-hidden");
          });
          this.on(SongbirdFramework.events["UI.LOADING.CLOSE"], function() {
            reply("authentication-modal-loader-close");
          });
          this.on(SongbirdFramework.events["UI.LOADING.RENDER"], function() {
            reply("authentication-modal-loader-render");
          });
        };
        SongbirdFramework.prototype.prepareLookup = function(options) {
          var data2 = assign2({}, options);
          var self2 = this;
          return this.getDfReferenceId().then(function(id) {
            data2.dfReferenceId = id;
          }).then(function() {
            return self2._triggerCardinalBinProcess(options.bin);
          }).catch(function() {
          }).then(function() {
            return self2._waitForClient();
          }).then(function() {
            data2.clientMetadata = self2._clientMetadata;
            data2.authorizationFingerprint = self2._client.getConfiguration().authorizationFingerprint;
            data2.braintreeLibraryVersion = "braintree/web/" + VERSION2;
            return data2;
          });
        };
        SongbirdFramework.prototype.initializeChallengeWithLookupResponse = function(lookupResponse, options) {
          return this.setupSongbird().then(function() {
            return BaseFramework.prototype.initializeChallengeWithLookupResponse.call(this, lookupResponse, options);
          }.bind(this));
        };
        SongbirdFramework.prototype.handleSongbirdError = function(errorType) {
          this._songbirdInitFailed = true;
          this._removeSongbirdListeners();
          analytics.sendEvent(this._createPromise, "three-d-secure.cardinal-sdk.songbird-error." + errorType);
          if (this._songbirdPromise) {
            this._songbirdPromise.resolve();
          }
        };
        SongbirdFramework.prototype._triggerCardinalBinProcess = function(bin) {
          var self2 = this;
          var issuerStartTime = Date.now();
          return window.Cardinal.trigger("bin.process", bin).then(function(binResults) {
            self2._clientMetadata.issuerDeviceDataCollectionTimeElapsed = Date.now() - issuerStartTime;
            self2._clientMetadata.issuerDeviceDataCollectionResult = binResults && binResults.Status;
          });
        };
        SongbirdFramework.prototype.transformBillingAddress = function(additionalInformation, billingAddress) {
          if (billingAddress) {
            extractAddressData(billingAddress, additionalInformation, "billing");
            additionalInformation.billingPhoneNumber = billingAddress.phoneNumber;
            additionalInformation.billingGivenName = billingAddress.givenName;
            additionalInformation.billingSurname = billingAddress.surname;
          }
          return additionalInformation;
        };
        SongbirdFramework.prototype.transformShippingAddress = function(additionalInformation) {
          var shippingAddress = additionalInformation.shippingAddress;
          if (shippingAddress) {
            extractAddressData(shippingAddress, additionalInformation, "shipping");
            delete additionalInformation.shippingAddress;
          }
          return additionalInformation;
        };
        SongbirdFramework.prototype._createV1IframeModalElement = function(iframe) {
          var modal = document.createElement("div");
          modal.innerHTML = '<div data-braintree-v1-fallback-iframe-container="true" style="height: 400px;"></div>';
          modal.querySelector('[data-braintree-v1-fallback-iframe-container="true"]').appendChild(iframe);
          return modal;
        };
        SongbirdFramework.prototype._createV1IframeModal = function(iframe) {
          var modal = this._createV1IframeModalElement(iframe);
          var btn = modal.querySelector("[data-braintree-v1-fallback-close-button]");
          var backdrop = modal.querySelector("[data-braintree-v1-fallback-backdrop]");
          var self2 = this;
          function closeHandler() {
            modal.parentNode.removeChild(modal);
            self2.cancelVerifyCard(errors.THREEDS_CARDINAL_SDK_CANCELED);
            document.removeEventListener("keyup", self2._onV1Keyup);
            self2._onV1Keyup = null;
          }
          this._onV1Keyup = function(e) {
            if (e.key !== "Escape") {
              return;
            }
            if (!modal.parentNode) {
              return;
            }
            closeHandler();
          };
          if (btn) {
            btn.addEventListener("click", closeHandler);
          }
          if (backdrop) {
            backdrop.addEventListener("click", closeHandler);
          }
          document.addEventListener("keyup", this._onV1Keyup);
          return modal;
        };
        SongbirdFramework.prototype._addV1IframeToPage = function() {
          document.body.appendChild(this._v1Modal);
        };
        SongbirdFramework.prototype.setupSongbird = function(setupOptions) {
          var self2 = this;
          var startTime = Date.now();
          if (this._songbirdPromise) {
            return this._songbirdPromise;
          }
          setupOptions = setupOptions || {};
          this._songbirdPromise = new ExtendedPromise();
          this._v2SetupFailureReason = "reason-unknown";
          self2._loadCardinalScript(setupOptions).then(function() {
            if (!window.Cardinal) {
              self2._v2SetupFailureReason = "cardinal-global-unavailable";
              return Promise.reject(new BraintreeError(errors.THREEDS_CARDINAL_SDK_SETUP_FAILED));
            }
            return self2._configureCardinalSdk({
              setupOptions,
              setupStartTime: startTime
            });
          }).catch(function(err) {
            var error = convertToBraintreeError(err, {
              type: errors.THREEDS_CARDINAL_SDK_SETUP_FAILED.type,
              code: errors.THREEDS_CARDINAL_SDK_SETUP_FAILED.code,
              message: errors.THREEDS_CARDINAL_SDK_SETUP_FAILED.message
            });
            self2._getDfReferenceIdPromisePlus.reject(error);
            window.clearTimeout(self2._songbirdSetupTimeoutReference);
            analytics.sendEvent(self2._client, "three-d-secure.cardinal-sdk.init.setup-failed");
            self2.handleSongbirdError("cardinal-sdk-setup-failed." + self2._v2SetupFailureReason);
          });
          return this._songbirdPromise;
        };
        SongbirdFramework.prototype._configureCardinalSdk = function(config) {
          var self2 = this;
          return this._waitForClient().then(function() {
            var threeDSConfig = self2._client.getConfiguration().gatewayConfiguration.threeDSecure;
            return threeDSConfig;
          }).then(function(threeDSConfig) {
            var jwt = threeDSConfig.cardinalAuthenticationJWT;
            var setupOptions = config.setupOptions;
            var setupStartTime = config.setupStartTime;
            var cardinalConfiguration = self2._createCardinalConfigurationOptions(setupOptions);
            SONGBIRD_UI_EVENTS.forEach(function(eventName) {
              self2.setCardinalListener(eventName, function() {
                self2._emit(SongbirdFramework.events[eventName.toUpperCase()]);
              });
            });
            self2.setCardinalListener("payments.setupComplete", self2._createPaymentsSetupCompleteCallback());
            self2._setupFrameworkSpecificListeners();
            window.Cardinal.configure(cardinalConfiguration);
            window.Cardinal.setup("init", {
              jwt
            });
            self2._clientMetadata.cardinalDeviceDataCollectionTimeElapsed = Date.now() - setupStartTime;
            self2.setCardinalListener("payments.validated", self2._createPaymentsValidatedCallback());
          }).catch(function(err) {
            self2._v2SetupFailureReason = "cardinal-configuration-threw-error";
            return Promise.reject(err);
          });
        };
        SongbirdFramework.prototype.setCardinalListener = function(eventName, cb) {
          this._cardinalEvents.push(eventName);
          window.Cardinal.on(eventName, cb);
        };
        SongbirdFramework.prototype._setupFrameworkSpecificListeners = function() {
        };
        SongbirdFramework.prototype._createCardinalConfigurationOptions = function(setupOptions) {
          var cardinalConfiguration = setupOptions.cardinalSDKConfig || {};
          var paymentSettings = cardinalConfiguration.payment || {};
          if (!cardinalConfiguration.logging && setupOptions.loggingEnabled) {
            cardinalConfiguration.logging = {
              level: "verbose"
            };
          }
          cardinalConfiguration.payment = {};
          if (paymentSettings.hasOwnProperty("displayLoading")) {
            cardinalConfiguration.payment.displayLoading = paymentSettings.displayLoading;
          }
          if (paymentSettings.hasOwnProperty("displayExitButton")) {
            cardinalConfiguration.payment.displayExitButton = paymentSettings.displayExitButton;
          }
          return cardinalConfiguration;
        };
        SongbirdFramework.prototype._loadCardinalScript = function(setupOptions) {
          var self2 = this;
          return this._waitForClient().then(function() {
            var scriptSource = self2._getCardinalScriptSource();
            self2._songbirdSetupTimeoutReference = window.setTimeout(function() {
              analytics.sendEvent(self2._client, "three-d-secure.cardinal-sdk.init.setup-timeout");
              self2.handleSongbirdError("cardinal-sdk-setup-timeout");
            }, setupOptions.timeout || INTEGRATION_TIMEOUT_MS);
            return assets.loadScript({ src: scriptSource });
          }).catch(function(err) {
            self2._v2SetupFailureReason = "songbird-js-failed-to-load";
            return Promise.reject(convertToBraintreeError(err, errors.THREEDS_CARDINAL_SDK_SCRIPT_LOAD_FAILED));
          });
        };
        SongbirdFramework.prototype._getCardinalScriptSource = function() {
          var gatewayConfig = this._client.getConfiguration().gatewayConfiguration;
          if (gatewayConfig && gatewayConfig.environment === "production") {
            return constants.CARDINAL_SCRIPT_SOURCE.production;
          }
          return constants.CARDINAL_SCRIPT_SOURCE.sandbox;
        };
        SongbirdFramework.prototype._createPaymentsSetupCompleteCallback = function() {
          var self2 = this;
          return function(data2) {
            self2._getDfReferenceIdPromisePlus.resolve(data2.sessionId);
            window.clearTimeout(self2._songbirdSetupTimeoutReference);
            analytics.sendEvent(self2._createPromise, "three-d-secure.cardinal-sdk.init.setup-completed");
            self2._songbirdPromise.resolve();
          };
        };
        SongbirdFramework.prototype.getDfReferenceId = function() {
          return this._getDfReferenceIdPromisePlus;
        };
        SongbirdFramework.prototype._performJWTValidation = function(rawCardinalSDKVerificationData, jwt) {
          var self2 = this;
          var nonce = this._lookupPaymentMethod.nonce;
          var url = "payment_methods/" + nonce + "/three_d_secure/authenticate_from_jwt";
          var cancelCode = rawCardinalSDKVerificationData && rawCardinalSDKVerificationData.Payment && rawCardinalSDKVerificationData.Payment.ExtendedData && rawCardinalSDKVerificationData.Payment.ExtendedData.ChallengeCancel;
          if (cancelCode) {
            analytics.sendEvent(this._createPromise, "three-d-secure.verification-flow.cardinal-sdk.cancel-code." + cancelCode);
            if (cancelCode === CUSTOMER_CANCELED_SONGBIRD_MODAL) {
              this._emit(SongbirdFramework.events.CUSTOMER_CANCELED);
            }
          }
          analytics.sendEvent(this._createPromise, "three-d-secure.verification-flow.upgrade-payment-method.started");
          return this._waitForClient().then(function() {
            return self2._client.request({
              method: "post",
              endpoint: url,
              data: {
                jwt,
                paymentMethodNonce: nonce
              }
            });
          }).then(function(response) {
            var paymentMethod = response.paymentMethod || self2._lookupPaymentMethod;
            var formattedResponse = self2._formatAuthResponse(paymentMethod, response.threeDSecureInfo);
            formattedResponse.rawCardinalSDKVerificationData = rawCardinalSDKVerificationData;
            analytics.sendEvent(self2._client, "three-d-secure.verification-flow.upgrade-payment-method.succeeded");
            return Promise.resolve(formattedResponse);
          }).catch(function(err) {
            var error = new BraintreeError({
              type: errors.THREEDS_JWT_AUTHENTICATION_FAILED.type,
              code: errors.THREEDS_JWT_AUTHENTICATION_FAILED.code,
              message: errors.THREEDS_JWT_AUTHENTICATION_FAILED.message,
              details: {
                originalError: err
              }
            });
            analytics.sendEvent(self2._client, "three-d-secure.verification-flow.upgrade-payment-method.errored");
            return Promise.reject(error);
          });
        };
        SongbirdFramework.prototype._createPaymentsValidatedCallback = function() {
          var self2 = this;
          return function(data2, validatedJwt) {
            var formattedError;
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.cardinal-sdk.action-code." + data2.ActionCode.toLowerCase());
            if (!self2._verifyCardPromisePlus) {
              self2.handleSongbirdError("cardinal-sdk-setup-error.number-" + data2.ErrorNumber);
              return;
            }
            switch (data2.ActionCode) {
              case "SUCCESS":
              case "NOACTION":
              case "FAILURE":
                self2._performJWTValidation(data2, validatedJwt).then(function(result) {
                  self2._verifyCardPromisePlus.resolve(result);
                }).catch(function(err) {
                  self2._verifyCardPromisePlus.reject(err);
                });
                break;
              case "ERROR":
                analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.cardinal-sdk-error." + data2.ErrorNumber);
                switch (data2.ErrorNumber) {
                  case 10001:
                  case 10002:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_SETUP_TIMEDOUT);
                    break;
                  case 10003:
                  case 10007:
                  case 10009:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_RESPONSE_TIMEDOUT);
                    break;
                  case 10005:
                  case 10006:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_BAD_CONFIG);
                    break;
                  case 10008:
                  case 10010:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_BAD_JWT);
                    break;
                  case 10011:
                    analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.canceled");
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_CANCELED);
                    break;
                  default:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_ERROR);
                }
                formattedError.details = {
                  originalError: {
                    code: data2.ErrorNumber,
                    description: data2.ErrorDescription
                  }
                };
                self2._verifyCardPromisePlus.reject(formattedError);
                break;
            }
          };
        };
        SongbirdFramework.prototype._checkForVerifyCardError = function(options, privateOptions) {
          if (!options.bin) {
            return new BraintreeError({
              type: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.type,
              code: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.code,
              message: "verifyCard options must include a BIN."
            });
          }
          return BaseFramework.prototype._checkForVerifyCardError.call(this, options, privateOptions);
        };
        SongbirdFramework.prototype._checkForFrameworkSpecificVerifyCardErrors = function(options, privateOptions) {
          var errorOption;
          if (typeof options.onLookupComplete !== "function" && !privateOptions.ignoreOnLookupCompleteRequirement) {
            errorOption = "an onLookupComplete function";
          }
          return errorOption;
        };
        SongbirdFramework.prototype._formatVerifyCardOptions = function(options) {
          var modifiedOptions = BaseFramework.prototype._formatVerifyCardOptions.call(this, options);
          var additionalInformation = modifiedOptions.additionalInformation || {};
          additionalInformation = this.transformBillingAddress(additionalInformation, options.billingAddress);
          additionalInformation = this.transformShippingAddress(additionalInformation);
          if (options.onLookupComplete) {
            modifiedOptions.onLookupComplete = deferred(options.onLookupComplete);
          }
          if (options.email) {
            additionalInformation.email = options.email;
          }
          if (options.mobilePhoneNumber) {
            additionalInformation.mobilePhoneNumber = options.mobilePhoneNumber;
          }
          modifiedOptions.additionalInformation = additionalInformation;
          return modifiedOptions;
        };
        SongbirdFramework.prototype._onLookupComplete = function(lookupResponse, options) {
          var self2 = this;
          return BaseFramework.prototype._onLookupComplete.call(this, lookupResponse).then(function(response) {
            return new Promise(function(resolve2, reject) {
              response.requiresUserAuthentication = Boolean(response.lookup && response.lookup.acsUrl);
              function next() {
                resolve2(response);
              }
              self2._verifyCardPromisePlus.catch(reject);
              if (options.onLookupComplete) {
                options.onLookupComplete(response, next);
              } else {
                self2._emit(SongbirdFramework.events.LOOKUP_COMPLETE, response, next);
              }
            });
          });
        };
        SongbirdFramework.prototype._presentChallenge = function(lookupResponse) {
          if (this._songbirdInitFailed || !lookupResponse.lookup.transactionId) {
            return;
          }
          window.Cardinal.continue("cca", {
            AcsUrl: lookupResponse.lookup.acsUrl,
            Payload: lookupResponse.lookup.pareq
          }, {
            OrderDetails: { TransactionId: lookupResponse.lookup.transactionId }
          });
        };
        SongbirdFramework.prototype._formatLookupData = function(options) {
          var self2 = this;
          return BaseFramework.prototype._formatLookupData.call(this, options).then(function(data2) {
            data2.additionalInfo = options.additionalInformation;
            if (options.accountType) {
              data2.accountType = options.accountType;
            }
            if (options.challengeRequested) {
              data2.challengeRequested = options.challengeRequested;
            }
            if (options.requestedExemptionType) {
              if (!SCA_EXEMPTION_TYPES.includes(options.requestedExemptionType)) {
                throw new BraintreeError({
                  code: errors.THREEDS_REQUESTED_EXEMPTION_TYPE_INVALID.code,
                  type: errors.THREEDS_REQUESTED_EXEMPTION_TYPE_INVALID.type,
                  message: "requestedExemptionType `" + options.requestedExemptionType + "` is not a valid exemption. The accepted values are: `" + SCA_EXEMPTION_TYPES.join("`, `") + "`"
                });
              }
              data2.requestedExemptionType = options.requestedExemptionType;
            }
            if (options.customFields) {
              data2.customFields = options.customFields;
            }
            if (options.dataOnlyRequested) {
              data2.dataOnlyRequested = options.dataOnlyRequested;
            }
            if (options.exemptionRequested) {
              data2.exemptionRequested = options.exemptionRequested;
            }
            if (options.requestVisaDAF) {
              data2.requestVisaDAF = options.requestVisaDAF;
            }
            if (options.bin) {
              data2.bin = options.bin;
            }
            if (options.cardAdd != null) {
              data2.cardAdd = options.cardAdd;
            }
            if (options.cardAddChallengeRequested != null) {
              data2.cardAdd = options.cardAddChallengeRequested;
            }
            if (options.merchantName) {
              data2.merchantName = options.merchantName;
            }
            return self2.prepareLookup(data2);
          });
        };
        SongbirdFramework.prototype.cancelVerifyCard = function(verifyCardError) {
          var self2 = this;
          return BaseFramework.prototype.cancelVerifyCard.call(this).then(function(response) {
            if (self2._verifyCardPromisePlus) {
              verifyCardError = verifyCardError || new BraintreeError(errors.THREEDS_VERIFY_CARD_CANCELED_BY_MERCHANT);
              self2._verifyCardPromisePlus.reject(verifyCardError);
            }
            return response;
          });
        };
        SongbirdFramework.prototype._removeSongbirdListeners = function() {
          this._cardinalEvents.forEach(function(eventName) {
            window.Cardinal.off(eventName);
          });
          this._cardinalEvents = [];
        };
        SongbirdFramework.prototype.teardown = function() {
          if (window.Cardinal) {
            this._removeSongbirdListeners();
          }
          return BaseFramework.prototype.teardown.call(this);
        };
        SongbirdFramework.prototype._reloadThreeDSecure = function() {
          var self2 = this;
          var startTime = Date.now();
          return self2.teardown().then(function() {
            self2._configureCardinalSdk({
              setupOptions: self2.originalSetupOptions,
              setupStartTime: startTime
            });
          });
        };
        function extractAddressData(source2, target, prefix) {
          target[prefix + "Line1"] = source2.streetAddress;
          target[prefix + "Line2"] = source2.extendedAddress;
          target[prefix + "Line3"] = source2.line3;
          target[prefix + "City"] = source2.locality;
          target[prefix + "State"] = source2.region;
          target[prefix + "PostalCode"] = source2.postalCode;
          target[prefix + "CountryCode"] = source2.countryCodeAlpha2;
        }
        module2.exports = SongbirdFramework;
      }, { "../../../lib/analytics": 119, "../../../lib/assets": 120, "../../../lib/assign": 121, "../../../lib/braintree-error": 124, "../../../lib/constants": 126, "../../../lib/convert-to-braintree-error": 128, "../../../lib/deferred": 132, "../../../lib/enumerate": 134, "../../shared/constants": 199, "../../shared/errors": 200, "./base": 190, "@braintree/extended-promise": 34 }], 197: [function(_dereq_, module2, exports2) {
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var methods = _dereq_("../../lib/methods");
        var convertMethodsToError = _dereq_("../../lib/convert-methods-to-error");
        var EventEmitter = _dereq_("@braintree/event-emitter");
        var FRAMEWORKS = _dereq_("./frameworks");
        function ThreeDSecure(options) {
          var self2 = this;
          var Framework = FRAMEWORKS[options.framework];
          EventEmitter.call(this);
          this._framework = new Framework(options);
          this._framework.setUpEventListeners(function() {
            self2._emit.apply(self2, arguments);
          });
        }
        EventEmitter.createChild(ThreeDSecure);
        ThreeDSecure.prototype.verifyCard = function(options) {
          var privateOptions;
          if (this.hasListener("lookup-complete")) {
            privateOptions = {
              ignoreOnLookupCompleteRequirement: true
            };
          }
          return this._framework.verifyCard(options, privateOptions);
        };
        ThreeDSecure.prototype.initializeChallengeWithLookupResponse = function(lookupResponse) {
          if (typeof lookupResponse === "string") {
            lookupResponse = JSON.parse(lookupResponse);
          }
          return this._framework.initializeChallengeWithLookupResponse(lookupResponse);
        };
        ThreeDSecure.prototype.prepareLookup = function(options) {
          return this._framework.prepareLookup(options).then(function(data2) {
            return JSON.stringify(data2);
          });
        };
        ThreeDSecure.prototype.cancelVerifyCard = function() {
          return this._framework.cancelVerifyCard();
        };
        ThreeDSecure.prototype.teardown = function() {
          var methodNames = methods(ThreeDSecure.prototype).concat(methods(EventEmitter.prototype));
          convertMethodsToError(this, methodNames);
          return this._framework.teardown();
        };
        module2.exports = wrapPromise.wrapPrototype(ThreeDSecure);
      }, { "../../lib/convert-methods-to-error": 127, "../../lib/methods": 155, "./frameworks": 193, "@braintree/event-emitter": 33, "@braintree/wrap-promise": 43 }], 198: [function(_dereq_, module2, exports2) {
        var ThreeDSecure = _dereq_("./external/three-d-secure");
        var isHTTPS = _dereq_("../lib/is-https").isHTTPS;
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var analytics = _dereq_("../lib/analytics");
        var errors = _dereq_("./shared/errors");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "3D Secure";
          var framework = getFramework(options);
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var assetsUrl = createAssetsUrl.create(options.authorization);
            var createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl,
              name
            }).then(function(client) {
              var error, isProduction;
              var config = client.getConfiguration();
              var gwConfig = config.gatewayConfiguration;
              options.client = client;
              if (!gwConfig.threeDSecureEnabled) {
                error = errors.THREEDS_NOT_ENABLED;
              }
              if (config.authorizationType === "TOKENIZATION_KEY") {
                error = errors.THREEDS_CAN_NOT_USE_TOKENIZATION_KEY;
              }
              isProduction = gwConfig.environment === "production";
              if (isProduction && !isHTTPS()) {
                error = errors.THREEDS_HTTPS_REQUIRED;
              }
              if (framework !== "legacy" && !(gwConfig.threeDSecure && gwConfig.threeDSecure.cardinalAuthenticationJWT)) {
                analytics.sendEvent(options.client, "three-d-secure.initialization.failed.missing-cardinalAuthenticationJWT");
                error = errors.THREEDS_NOT_ENABLED_FOR_V2;
              }
              if (error) {
                return Promise.reject(new BraintreeError(error));
              }
              analytics.sendEvent(options.client, "three-d-secure.initialized");
              return client;
            });
            var instance = new ThreeDSecure({
              client: options.client,
              assetsUrl,
              createPromise,
              loggingEnabled: options.loggingEnabled,
              cardinalSDKConfig: options.cardinalSDKConfig,
              framework
            });
            if (options.client) {
              return createPromise.then(function() {
                return instance;
              });
            }
            return instance;
          });
        }
        function getFramework(options) {
          var version2 = String(options.version || "");
          if (!version2 || version2 === "1") {
            throw new BraintreeError({
              code: errors.THREEDS_UNSUPPORTED_VERSION.code,
              type: errors.THREEDS_UNSUPPORTED_VERSION.type,
              message: errors.THREEDS_UNSUPPORTED_VERSION.message
            });
          }
          switch (version2) {
            case "2":
            case "2-cardinal-modal":
              return "cardinal-modal";
            case "2-bootstrap3-modal":
              return "bootstrap3-modal";
            case "2-inline-iframe":
              return "inline-iframe";
            default:
              throw new BraintreeError({
                code: errors.THREEDS_UNRECOGNIZED_VERSION.code,
                type: errors.THREEDS_UNRECOGNIZED_VERSION.type,
                message: "Version `" + options.version + "` is not a recognized version. You may need to update the version of your Braintree SDK to support this version."
              });
          }
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 119, "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "../lib/is-https": 152, "./external/three-d-secure": 197, "./shared/errors": 200, "@braintree/wrap-promise": 43 }], 199: [function(_dereq_, module2, exports2) {
        module2.exports = {
          LANDING_FRAME_NAME: "braintreethreedsecurelanding",
          CARDINAL_SCRIPT_SOURCE: {
            production: "https://songbird.cardinalcommerce.com/edge/v1/songbird.js",
            sandbox: "https://songbirdstag.cardinalcommerce.com/edge/v1/songbird.js"
          }
        };
      }, {}], 200: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          THREEDS_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_NOT_ENABLED",
            message: "3D Secure is not enabled for this merchant."
          },
          THREEDS_CAN_NOT_USE_TOKENIZATION_KEY: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_CAN_NOT_USE_TOKENIZATION_KEY",
            message: "3D Secure can not use a tokenization key for authorization."
          },
          THREEDS_HTTPS_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_HTTPS_REQUIRED",
            message: "3D Secure requires HTTPS."
          },
          THREEDS_NOT_ENABLED_FOR_V2: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_NOT_ENABLED_FOR_V2",
            message: "3D Secure version 2 is not enabled for this merchant. Contact Braintree Support for assistance at https://help.braintreepayments.com/"
          },
          THREEDS_UNRECOGNIZED_VERSION: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_UNRECOGNIZED_VERSION"
          },
          THREEDS_CARDINAL_SDK_SETUP_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_CARDINAL_SDK_SETUP_FAILED",
            message: "Something went wrong setting up Cardinal's Songbird.js library."
          },
          THREEDS_CARDINAL_SDK_SCRIPT_LOAD_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "THREEDS_CARDINAL_SDK_SCRIPT_LOAD_FAILED",
            message: "Cardinal's Songbird.js library could not be loaded."
          },
          THREEDS_CARDINAL_SDK_SETUP_TIMEDOUT: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_CARDINAL_SDK_SETUP_TIMEDOUT",
            message: "Cardinal's Songbird.js took too long to setup."
          },
          THREEDS_CARDINAL_SDK_RESPONSE_TIMEDOUT: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_CARDINAL_SDK_RESPONSE_TIMEDOUT",
            message: "Cardinal's API took too long to respond."
          },
          THREEDS_CARDINAL_SDK_BAD_CONFIG: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_CARDINAL_SDK_BAD_CONFIG",
            message: "JWT or other required field missing. Please check your setup configuration."
          },
          THREEDS_CARDINAL_SDK_BAD_JWT: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_CARDINAL_SDK_BAD_JWT",
            message: "Cardinal JWT missing or malformed. Please check your setup configuration."
          },
          THREEDS_CARDINAL_SDK_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_CARDINAL_SDK_ERROR",
            message: "A general error has occurred with Cardinal. See description for more information."
          },
          THREEDS_CARDINAL_SDK_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "THREEDS_CARDINAL_SDK_CANCELED",
            message: "Canceled by user."
          },
          THREEDS_VERIFY_CARD_CANCELED_BY_MERCHANT: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_VERIFY_CARD_CANCELED_BY_MERCHANT",
            message: "3D Secure verfication canceled by merchant."
          },
          THREEDS_AUTHENTICATION_IN_PROGRESS: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_AUTHENTICATION_IN_PROGRESS",
            message: "Cannot call verifyCard while existing authentication is in progress."
          },
          THREEDS_MISSING_VERIFY_CARD_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_MISSING_VERIFY_CARD_OPTION"
          },
          THREEDS_JWT_AUTHENTICATION_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_JWT_AUTHENTICATION_FAILED",
            message: "Something went wrong authenticating the JWT from Cardinal"
          },
          THREEDS_LOOKUP_TOKENIZED_CARD_NOT_FOUND_ERROR: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_LOOKUP_TOKENIZED_CARD_NOT_FOUND_ERROR",
            message: "Either the payment method nonce passed to `verifyCard` does not exist, or it was already consumed"
          },
          THREEDS_LOOKUP_VALIDATION_ERROR: {
            type: BraintreeError.types.CUSTOMER,
            code: "THREEDS_LOOKUP_VALIDATION_ERROR",
            message: "The data passed in `verifyCard` did not pass validation checks. See details for more info"
          },
          THREEDS_LOOKUP_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_LOOKUP_ERROR",
            message: "Something went wrong during the 3D Secure lookup"
          },
          THREEDS_INLINE_IFRAME_DETAILS_INCORRECT: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_INLINE_IFRAME_DETAILS_INCORRECT",
            message: "Something went wrong when attempting to add the authentication iframe to the page."
          },
          THREEDS_NO_VERIFICATION_PAYLOAD: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_NO_VERIFICATION_PAYLOAD",
            message: "No verification payload available."
          },
          THREEDS_TERM_URL_REQUIRES_BRAINTREE_DOMAIN: {
            type: BraintreeError.types.INTERNAL,
            code: "THREEDS_TERM_URL_REQUIRES_BRAINTREE_DOMAIN",
            message: "Term Url must be on a Braintree domain."
          },
          THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED: {
            type: BraintreeError.types.INTERNAL,
            code: "THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED",
            message: "Method not implemented for this framework."
          },
          THREEDS_REQUESTED_EXEMPTION_TYPE_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_REQUESTED_EXEMPTION_TYPE_INVALID",
            message: "Requested Exemption Type is invalid."
          },
          THREEDS_UNSUPPORTED_VERSION: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_UNSUPPORTED_VERSION",
            message: "3D Secure `1` is deprecated and no longer supported. See available versions at https://braintree.github.io/braintree-web/current/module-braintree-web_three-d-secure.html#.create"
          }
        };
      }, { "../../lib/braintree-error": 124 }], 201: [function(_dereq_, module2, exports2) {
        var enumerate = _dereq_("../../lib/enumerate");
        module2.exports = enumerate(["AUTHENTICATION_COMPLETE"], "threedsecure:");
      }, { "../../lib/enumerate": 134 }], 202: [function(_dereq_, module2, exports2) {
        var UnionPay = _dereq_("./shared/unionpay");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var analytics = _dereq_("../lib/analytics");
        var errors = _dereq_("./shared/errors");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "UnionPay";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            var config = client.getConfiguration();
            options.client = client;
            if (!config.gatewayConfiguration.unionPay || config.gatewayConfiguration.unionPay.enabled !== true) {
              return Promise.reject(new BraintreeError(errors.UNIONPAY_NOT_ENABLED));
            }
            analytics.sendEvent(options.client, "unionpay.initialized");
            return new UnionPay(options);
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 119, "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./shared/errors": 204, "./shared/unionpay": 205, "@braintree/wrap-promise": 43 }], 203: [function(_dereq_, module2, exports2) {
        var enumerate = _dereq_("../../lib/enumerate");
        module2.exports = {
          events: enumerate([
            "HOSTED_FIELDS_FETCH_CAPABILITIES",
            "HOSTED_FIELDS_ENROLL",
            "HOSTED_FIELDS_TOKENIZE"
          ], "union-pay:"),
          HOSTED_FIELDS_FRAME_NAME: "braintreeunionpayhostedfields"
        };
      }, { "../../lib/enumerate": 134 }], 204: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          UNIONPAY_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "UNIONPAY_NOT_ENABLED",
            message: "UnionPay is not enabled for this merchant."
          },
          UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID",
            message: "Found an invalid Hosted Fields instance. Please use a valid Hosted Fields instance."
          },
          UNIONPAY_HOSTED_FIELDS_INSTANCE_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "UNIONPAY_HOSTED_FIELDS_INSTANCE_REQUIRED",
            message: "Could not find the Hosted Fields instance."
          },
          UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED",
            message: "A card or a Hosted Fields instance is required. Please supply a card or a Hosted Fields instance."
          },
          UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES: {
            type: BraintreeError.types.MERCHANT,
            code: "UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES",
            message: "Please supply either a card or a Hosted Fields instance, not both."
          },
          UNIONPAY_EXPIRATION_DATE_INCOMPLETE: {
            type: BraintreeError.types.MERCHANT,
            code: "UNIONPAY_EXPIRATION_DATE_INCOMPLETE",
            message: "You must supply expiration month and year or neither."
          },
          UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID: {
            type: BraintreeError.types.CUSTOMER,
            code: "UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID",
            message: "Enrollment failed due to user input error."
          },
          UNIONPAY_ENROLLMENT_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "UNIONPAY_ENROLLMENT_NETWORK_ERROR",
            message: "Could not enroll UnionPay card."
          },
          UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR",
            message: "Could not fetch card capabilities."
          },
          UNIONPAY_TOKENIZATION_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "UNIONPAY_TOKENIZATION_NETWORK_ERROR",
            message: "A tokenization network error occurred."
          },
          UNIONPAY_MISSING_MOBILE_PHONE_DATA: {
            type: BraintreeError.types.MERCHANT,
            code: "UNIONPAY_MISSING_MOBILE_PHONE_DATA",
            message: "A `mobile` with `countryCode` and `number` is required."
          },
          UNIONPAY_FAILED_TOKENIZATION: {
            type: BraintreeError.types.CUSTOMER,
            code: "UNIONPAY_FAILED_TOKENIZATION",
            message: "The supplied card data failed tokenization."
          }
        };
      }, { "../../lib/braintree-error": 124 }], 205: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../../lib/analytics");
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var Bus = _dereq_("framebus");
        var constants = _dereq_("./constants");
        var isVerifiedDomain = _dereq_("../../lib/is-verified-domain");
        var useMin = _dereq_("../../lib/use-min");
        var convertMethodsToError = _dereq_("../../lib/convert-methods-to-error");
        var errors = _dereq_("./errors");
        var events = constants.events;
        var iFramer = _dereq_("@braintree/iframer");
        var methods = _dereq_("../../lib/methods");
        var VERSION2 = "3.100.0";
        var uuid = _dereq_("@braintree/uuid");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var BUS_CONFIGURATION_REQUEST_EVENT = _dereq_("../../lib/constants").BUS_CONFIGURATION_REQUEST_EVENT;
        function UnionPay(options) {
          this._options = options;
        }
        UnionPay.prototype.fetchCapabilities = function(options) {
          var self2 = this;
          var client = this._options.client;
          var cardNumber = options.card ? options.card.number : null;
          var hostedFields = options.hostedFields;
          if (cardNumber && hostedFields) {
            return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES));
          } else if (cardNumber) {
            return client.request({
              method: "get",
              endpoint: "payment_methods/credit_cards/capabilities",
              data: {
                _meta: { source: "unionpay" },
                creditCard: {
                  number: cardNumber
                }
              }
            }).then(function(response) {
              analytics.sendEvent(client, "unionpay.capabilities-received");
              return response;
            }).catch(function(err) {
              var status = err.details && err.details.httpStatus;
              analytics.sendEvent(client, "unionpay.capabilities-failed");
              if (status === 403) {
                return Promise.reject(err);
              }
              return Promise.reject(new BraintreeError({
                type: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.type,
                code: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.code,
                message: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.message,
                details: {
                  originalError: err
                }
              }));
            });
          } else if (hostedFields) {
            if (!hostedFields._bus) {
              return Promise.reject(new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID));
            }
            return self2._initializeHostedFields().then(function() {
              return new Promise(function(resolve2, reject) {
                self2._bus.emit(events.HOSTED_FIELDS_FETCH_CAPABILITIES, { hostedFields }, function(response) {
                  if (response.err) {
                    reject(new BraintreeError(response.err));
                    return;
                  }
                  resolve2(response.payload);
                });
              });
            });
          }
          return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED));
        };
        UnionPay.prototype.enroll = function(options) {
          var self2 = this;
          var client = this._options.client;
          var card = options.card;
          var mobile = options.mobile;
          var hostedFields = options.hostedFields;
          var data2;
          if (!mobile) {
            return Promise.reject(new BraintreeError(errors.UNIONPAY_MISSING_MOBILE_PHONE_DATA));
          }
          if (hostedFields) {
            if (!hostedFields._bus) {
              return Promise.reject(new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID));
            } else if (card) {
              return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES));
            }
            return new Promise(function(resolve2, reject) {
              self2._initializeHostedFields().then(function() {
                self2._bus.emit(events.HOSTED_FIELDS_ENROLL, { hostedFields, mobile }, function(response) {
                  if (response.err) {
                    reject(new BraintreeError(response.err));
                    return;
                  }
                  resolve2(response.payload);
                });
              });
            });
          } else if (card && card.number) {
            data2 = {
              _meta: { source: "unionpay" },
              unionPayEnrollment: {
                number: card.number,
                mobileCountryCode: mobile.countryCode,
                mobileNumber: mobile.number
              }
            };
            if (card.expirationDate) {
              data2.unionPayEnrollment.expirationDate = card.expirationDate;
            } else if (card.expirationMonth || card.expirationYear) {
              if (card.expirationMonth && card.expirationYear) {
                data2.unionPayEnrollment.expirationYear = card.expirationYear;
                data2.unionPayEnrollment.expirationMonth = card.expirationMonth;
              } else {
                return Promise.reject(new BraintreeError(errors.UNIONPAY_EXPIRATION_DATE_INCOMPLETE));
              }
            }
            return client.request({
              method: "post",
              endpoint: "union_pay_enrollments",
              data: data2
            }).then(function(response) {
              analytics.sendEvent(client, "unionpay.enrollment-succeeded");
              return {
                enrollmentId: response.unionPayEnrollmentId,
                smsCodeRequired: response.smsCodeRequired
              };
            }).catch(function(err) {
              var error;
              var status = err.details && err.details.httpStatus;
              if (status === 403) {
                error = err;
              } else if (status < 500) {
                error = new BraintreeError(errors.UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID);
                error.details = { originalError: err };
              } else {
                error = new BraintreeError(errors.UNIONPAY_ENROLLMENT_NETWORK_ERROR);
                error.details = { originalError: err };
              }
              analytics.sendEvent(client, "unionpay.enrollment-failed");
              return Promise.reject(error);
            });
          }
          return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED));
        };
        UnionPay.prototype.tokenize = function(options) {
          var data2;
          var self2 = this;
          var client = this._options.client;
          var card = options.card;
          var hostedFields = options.hostedFields;
          if (card && hostedFields) {
            return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES));
          } else if (card) {
            data2 = {
              _meta: { source: "unionpay" },
              creditCard: {
                number: options.card.number,
                options: {
                  unionPayEnrollment: {
                    id: options.enrollmentId
                  }
                }
              }
            };
            if (options.smsCode) {
              data2.creditCard.options.unionPayEnrollment.smsCode = options.smsCode;
            }
            if (card.expirationDate) {
              data2.creditCard.expirationDate = card.expirationDate;
            } else if (card.expirationMonth && card.expirationYear) {
              data2.creditCard.expirationYear = card.expirationYear;
              data2.creditCard.expirationMonth = card.expirationMonth;
            }
            if (options.card.cvv) {
              data2.creditCard.cvv = options.card.cvv;
            }
            return client.request({
              method: "post",
              endpoint: "payment_methods/credit_cards",
              data: data2
            }).then(function(response) {
              var tokenizedCard = response.creditCards[0];
              delete tokenizedCard.consumed;
              delete tokenizedCard.threeDSecureInfo;
              analytics.sendEvent(client, "unionpay.nonce-received");
              return tokenizedCard;
            }).catch(function(err) {
              var error;
              var status = err.details && err.details.httpStatus;
              analytics.sendEvent(client, "unionpay.nonce-failed");
              if (status === 403) {
                error = err;
              } else if (status < 500) {
                error = new BraintreeError(errors.UNIONPAY_FAILED_TOKENIZATION);
                error.details = { originalError: err };
              } else {
                error = new BraintreeError(errors.UNIONPAY_TOKENIZATION_NETWORK_ERROR);
                error.details = { originalError: err };
              }
              return Promise.reject(error);
            });
          } else if (hostedFields) {
            if (!hostedFields._bus) {
              return Promise.reject(new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID));
            }
            return new Promise(function(resolve2, reject) {
              self2._initializeHostedFields().then(function() {
                self2._bus.emit(events.HOSTED_FIELDS_TOKENIZE, options, function(response) {
                  if (response.err) {
                    reject(new BraintreeError(response.err));
                    return;
                  }
                  resolve2(response.payload);
                });
              });
            });
          }
          return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED));
        };
        UnionPay.prototype.teardown = function() {
          if (this._bus) {
            this._hostedFieldsFrame.parentNode.removeChild(this._hostedFieldsFrame);
            this._bus.teardown();
          }
          convertMethodsToError(this, methods(UnionPay.prototype));
          return Promise.resolve();
        };
        UnionPay.prototype._initializeHostedFields = function() {
          var assetsUrl, isDebug;
          var componentId = uuid();
          var self2 = this;
          if (this._hostedFieldsInitializePromise) {
            return this._hostedFieldsInitializePromise;
          }
          this._hostedFieldsInitializePromise = new Promise(function(resolve2) {
            assetsUrl = self2._options.client.getConfiguration().gatewayConfiguration.assetsUrl;
            isDebug = self2._options.client.getConfiguration().isDebug;
            self2._bus = new Bus({
              channel: componentId,
              verifyDomain: isVerifiedDomain
            });
            self2._hostedFieldsFrame = iFramer({
              name: constants.HOSTED_FIELDS_FRAME_NAME + "_" + componentId,
              src: assetsUrl + "/web/" + VERSION2 + "/html/unionpay-hosted-fields-frame" + useMin(isDebug) + ".html",
              height: 0,
              width: 0
            });
            self2._bus.on(BUS_CONFIGURATION_REQUEST_EVENT, function(reply) {
              reply(self2._options.client);
              resolve2();
            });
            document.body.appendChild(self2._hostedFieldsFrame);
          });
          return this._hostedFieldsInitializePromise;
        };
        module2.exports = wrapPromise.wrapPrototype(UnionPay);
      }, { "../../lib/analytics": 119, "../../lib/braintree-error": 124, "../../lib/constants": 126, "../../lib/convert-methods-to-error": 127, "../../lib/is-verified-domain": 153, "../../lib/methods": 155, "../../lib/use-min": 160, "./constants": 203, "./errors": 204, "@braintree/iframer": 35, "@braintree/uuid": 39, "@braintree/wrap-promise": 43, "framebus": 52 }], 206: [function(_dereq_, module2, exports2) {
        module2.exports = {
          PLAID_LINK_JS: "https://cdn.plaid.com/link/v2/stable/link-initialize.js"
        };
      }, {}], 207: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          US_BANK_ACCOUNT_OPTION_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "US_BANK_ACCOUNT_OPTION_REQUIRED"
          },
          US_BANK_ACCOUNT_MUTUALLY_EXCLUSIVE_OPTIONS: {
            type: BraintreeError.types.MERCHANT,
            code: "US_BANK_ACCOUNT_MUTUALLY_EXCLUSIVE_OPTIONS"
          },
          US_BANK_ACCOUNT_LOGIN_LOAD_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "US_BANK_ACCOUNT_LOGIN_LOAD_FAILED",
            message: "Bank login flow failed to load."
          },
          US_BANK_ACCOUNT_LOGIN_CLOSED: {
            type: BraintreeError.types.CUSTOMER,
            code: "US_BANK_ACCOUNT_LOGIN_CLOSED",
            message: "Customer closed bank login flow before authorizing."
          },
          US_BANK_ACCOUNT_LOGIN_REQUEST_ACTIVE: {
            type: BraintreeError.types.MERCHANT,
            code: "US_BANK_ACCOUNT_LOGIN_REQUEST_ACTIVE",
            message: "Another bank login tokenization request is active."
          },
          US_BANK_ACCOUNT_TOKENIZATION_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "US_BANK_ACCOUNT_TOKENIZATION_NETWORK_ERROR",
            message: "A tokenization network error occurred."
          },
          US_BANK_ACCOUNT_FAILED_TOKENIZATION: {
            type: BraintreeError.types.CUSTOMER,
            code: "US_BANK_ACCOUNT_FAILED_TOKENIZATION",
            message: "The supplied data failed tokenization."
          },
          US_BANK_ACCOUNT_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "US_BANK_ACCOUNT_NOT_ENABLED",
            message: "US bank account is not enabled."
          },
          US_BANK_ACCOUNT_BANK_LOGIN_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "US_BANK_ACCOUNT_BANK_LOGIN_NOT_ENABLED",
            message: "Bank login is not enabled."
          }
        };
      }, { "../lib/braintree-error": 124 }], 208: [function(_dereq_, module2, exports2) {
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var errors = _dereq_("./errors");
        var USBankAccount = _dereq_("./us-bank-account");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "US Bank Account";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            var usBankAccount;
            options.client = client;
            usBankAccount = options.client.getConfiguration().gatewayConfiguration.usBankAccount;
            if (!usBankAccount) {
              return Promise.reject(new BraintreeError(errors.US_BANK_ACCOUNT_NOT_ENABLED));
            }
            return new USBankAccount(options);
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./errors": 207, "./us-bank-account": 209, "@braintree/wrap-promise": 43 }], 209: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        var constants = _dereq_("./constants");
        var errors = _dereq_("./errors");
        var sharedErrors = _dereq_("../lib/errors");
        var analytics = _dereq_("../lib/analytics");
        var once = _dereq_("../lib/once");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var methods = _dereq_("../lib/methods");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var TOKENIZE_BANK_DETAILS_MUTATION = createGraphQLMutation("UsBankAccount");
        var TOKENIZE_BANK_LOGIN_MUTATION = createGraphQLMutation("UsBankLogin");
        function USBankAccount(options) {
          this._client = options.client;
          this._isTokenizingBankLogin = false;
          analytics.sendEvent(this._client, "usbankaccount.initialized");
        }
        USBankAccount.prototype.tokenize = function(options) {
          options = options || {};
          if (!options.mandateText) {
            return Promise.reject(new BraintreeError({
              type: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.type,
              code: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.code,
              message: "mandateText property is required."
            }));
          }
          if (options.bankDetails && options.bankLogin) {
            return Promise.reject(new BraintreeError({
              type: errors.US_BANK_ACCOUNT_MUTUALLY_EXCLUSIVE_OPTIONS.type,
              code: errors.US_BANK_ACCOUNT_MUTUALLY_EXCLUSIVE_OPTIONS.code,
              message: "tokenize must be called with bankDetails or bankLogin, not both."
            }));
          } else if (options.bankDetails) {
            return this._tokenizeBankDetails(options);
          } else if (options.bankLogin) {
            return this._tokenizeBankLogin(options);
          }
          return Promise.reject(new BraintreeError({
            type: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.type,
            code: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.code,
            message: "tokenize must be called with bankDetails or bankLogin."
          }));
        };
        USBankAccount.prototype._tokenizeBankDetails = function(options) {
          var client = this._client;
          var bankDetails = options.bankDetails;
          var data2 = {
            achMandate: options.mandateText,
            routingNumber: bankDetails.routingNumber,
            accountNumber: bankDetails.accountNumber,
            accountType: bankDetails.accountType.toUpperCase(),
            billingAddress: formatBillingAddressForGraphQL(bankDetails.billingAddress || {})
          };
          formatDataForOwnershipType(data2, bankDetails);
          return client.request({
            api: "graphQLApi",
            data: {
              query: TOKENIZE_BANK_DETAILS_MUTATION,
              variables: {
                input: {
                  usBankAccount: data2
                }
              }
            }
          }).then(function(response) {
            analytics.sendEvent(client, "usbankaccount.bankdetails.tokenization.succeeded");
            return Promise.resolve(formatTokenizeResponseFromGraphQL(response, "tokenizeUsBankAccount"));
          }).catch(function(err) {
            var error = errorFrom(err);
            analytics.sendEvent(client, "usbankaccount.bankdetails.tokenization.failed");
            return Promise.reject(error);
          });
        };
        USBankAccount.prototype._tokenizeBankLogin = function(options) {
          var self2 = this;
          var client = this._client;
          var gatewayConfiguration = client.getConfiguration().gatewayConfiguration;
          var isProduction = gatewayConfiguration.environment === "production";
          var plaidConfig = gatewayConfiguration.usBankAccount.plaid;
          if (!options.bankLogin.displayName) {
            return Promise.reject(new BraintreeError({
              type: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.type,
              code: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.code,
              message: "displayName property is required when using bankLogin."
            }));
          }
          if (!plaidConfig) {
            return Promise.reject(new BraintreeError(errors.US_BANK_ACCOUNT_BANK_LOGIN_NOT_ENABLED));
          }
          if (this._isTokenizingBankLogin) {
            return Promise.reject(new BraintreeError(errors.US_BANK_ACCOUNT_LOGIN_REQUEST_ACTIVE));
          }
          this._isTokenizingBankLogin = true;
          return new Promise(function(resolve2, reject) {
            self2._loadPlaid(function(plaidLoadErr, plaid) {
              if (plaidLoadErr) {
                reject(plaidLoadErr);
                return;
              }
              plaid.create({
                clientName: options.bankLogin.displayName,
                apiVersion: "v2",
                env: isProduction ? "production" : "sandbox",
                key: plaidConfig.publicKey,
                product: "auth",
                selectAccount: true,
                onExit: function() {
                  self2._isTokenizingBankLogin = false;
                  analytics.sendEvent(client, "usbankaccount.banklogin.tokenization.closed.by-user");
                  reject(new BraintreeError(errors.US_BANK_ACCOUNT_LOGIN_CLOSED));
                },
                onSuccess: function(publicToken, metadata) {
                  var bankLogin = options.bankLogin;
                  var data2 = {
                    publicToken,
                    accountId: isProduction ? metadata.account_id : "plaid_account_id",
                    accountType: metadata.account.subtype.toUpperCase(),
                    achMandate: options.mandateText,
                    billingAddress: formatBillingAddressForGraphQL(bankLogin.billingAddress || {})
                  };
                  formatDataForOwnershipType(data2, bankLogin);
                  client.request({
                    api: "graphQLApi",
                    data: {
                      query: TOKENIZE_BANK_LOGIN_MUTATION,
                      variables: {
                        input: {
                          usBankLogin: data2
                        }
                      }
                    }
                  }).then(function(response) {
                    self2._isTokenizingBankLogin = false;
                    analytics.sendEvent(client, "usbankaccount.banklogin.tokenization.succeeded");
                    resolve2(formatTokenizeResponseFromGraphQL(response, "tokenizeUsBankLogin"));
                  }).catch(function(tokenizeErr) {
                    var error;
                    self2._isTokenizingBankLogin = false;
                    error = errorFrom(tokenizeErr);
                    analytics.sendEvent(client, "usbankaccount.banklogin.tokenization.failed");
                    reject(error);
                  });
                }
              }).open();
              analytics.sendEvent(client, "usbankaccount.banklogin.tokenization.started");
            });
          });
        };
        function errorFrom(err) {
          var error;
          var status = err.details && err.details.httpStatus;
          if (status === 401) {
            error = new BraintreeError(sharedErrors.BRAINTREE_API_ACCESS_RESTRICTED);
          } else if (status < 500) {
            error = new BraintreeError(errors.US_BANK_ACCOUNT_FAILED_TOKENIZATION);
          } else {
            error = new BraintreeError(errors.US_BANK_ACCOUNT_TOKENIZATION_NETWORK_ERROR);
          }
          error.details = { originalError: err };
          return error;
        }
        function formatTokenizeResponseFromGraphQL(response, type) {
          var data2 = response.data[type].paymentMethod;
          var last4 = data2.details.last4;
          var description = "US bank account ending in - " + last4;
          return {
            nonce: data2.id,
            details: {},
            description,
            type: "us_bank_account"
          };
        }
        USBankAccount.prototype._loadPlaid = function(callback) {
          var existingScript, script;
          callback = once(callback);
          if (window.Plaid) {
            callback(null, window.Plaid);
            return;
          }
          existingScript = document.querySelector('script[src="' + constants.PLAID_LINK_JS + '"]');
          if (existingScript) {
            addLoadListeners(existingScript, callback);
          } else {
            script = document.createElement("script");
            script.src = constants.PLAID_LINK_JS;
            script.async = true;
            addLoadListeners(script, callback);
            document.body.appendChild(script);
            this._plaidScript = script;
          }
        };
        function addLoadListeners(script, callback) {
          function loadHandler() {
            var readyState = this.readyState;
            if (!readyState || readyState === "loaded" || readyState === "complete") {
              removeLoadListeners();
              callback(null, window.Plaid);
            }
          }
          function errorHandler() {
            script.parentNode.removeChild(script);
            callback(new BraintreeError(errors.US_BANK_ACCOUNT_LOGIN_LOAD_FAILED));
          }
          function removeLoadListeners() {
            script.removeEventListener("error", errorHandler);
            script.removeEventListener("load", loadHandler);
            script.removeEventListener("readystatechange", loadHandler);
          }
          script.addEventListener("error", errorHandler);
          script.addEventListener("load", loadHandler);
          script.addEventListener("readystatechange", loadHandler);
        }
        function formatBillingAddressForGraphQL(address) {
          return {
            streetAddress: address.streetAddress,
            extendedAddress: address.extendedAddress,
            city: address.locality,
            state: address.region,
            zipCode: address.postalCode
          };
        }
        function formatDataForOwnershipType(data2, details) {
          if (details.ownershipType === "personal") {
            data2.individualOwner = {
              firstName: details.firstName,
              lastName: details.lastName
            };
          } else if (details.ownershipType === "business") {
            data2.businessOwner = {
              businessName: details.businessName
            };
          }
        }
        function createGraphQLMutation(type) {
          return "mutation Tokenize" + type + "($input: Tokenize" + type + "Input!) {  tokenize" + type + "(input: $input) {    paymentMethod {      id      details {        ... on UsBankAccountDetails {          last4        }      }    }  }}";
        }
        USBankAccount.prototype.teardown = function() {
          if (this._plaidScript) {
            document.body.removeChild(this._plaidScript);
          }
          convertMethodsToError(this, methods(USBankAccount.prototype));
          return Promise.resolve();
        };
        module2.exports = wrapPromise.wrapPrototype(USBankAccount);
      }, { "../lib/analytics": 119, "../lib/braintree-error": 124, "../lib/convert-methods-to-error": 127, "../lib/errors": 135, "../lib/methods": 155, "../lib/once": 156, "./constants": 206, "./errors": 207, "@braintree/wrap-promise": 43 }], 210: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          VAULT_MANAGER_DELETE_PAYMENT_METHOD_NONCE_REQUIRES_CLIENT_TOKEN: {
            type: BraintreeError.types.MERCHANT,
            code: "VAULT_MANAGER_DELETE_PAYMENT_METHOD_NONCE_REQUIRES_CLIENT_TOKEN",
            message: "A client token with a customer id must be used to delete a payment method nonce."
          },
          VAULT_MANAGER_PAYMENT_METHOD_NONCE_NOT_FOUND: {
            type: BraintreeError.types.MERCHANT,
            code: "VAULT_MANAGER_PAYMENT_METHOD_NONCE_NOT_FOUND"
          },
          VAULT_MANAGER_DELETE_PAYMENT_METHOD_UNKNOWN_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "VAULT_MANAGER_DELETE_PAYMENT_METHOD_UNKNOWN_ERROR"
          }
        };
      }, { "../lib/braintree-error": 124 }], 211: [function(_dereq_, module2, exports2) {
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var VaultManager = _dereq_("./vault-manager");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "Vault Manager";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return new VaultManager({
              createPromise: createDeferredClient.create({
                authorization: options.authorization,
                client: options.client,
                debug: options.debug,
                assetsUrl: createAssetsUrl.create(options.authorization),
                name
              })
            });
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 122, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./vault-manager": 212, "@braintree/wrap-promise": 43 }], 212: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../lib/analytics");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var errors = _dereq_("./errors");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var methods = _dereq_("../lib/methods");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var DELETE_PAYMENT_METHOD_MUTATION = "mutation DeletePaymentMethodFromSingleUseToken($input: DeletePaymentMethodFromSingleUseTokenInput!) {  deletePaymentMethodFromSingleUseToken(input: $input) {    clientMutationId  }}";
        function VaultManager(options) {
          this._createPromise = options.createPromise;
        }
        VaultManager.prototype.fetchPaymentMethods = function(options) {
          var defaultFirst;
          options = options || {};
          defaultFirst = options.defaultFirst === true ? 1 : 0;
          return this._createPromise.then(function(client) {
            return client.request({
              endpoint: "payment_methods",
              method: "get",
              data: {
                defaultFirst
              }
            });
          }).then(function(paymentMethodsPayload) {
            analytics.sendEvent(this._createPromise, "vault-manager.fetch-payment-methods.succeeded");
            return paymentMethodsPayload.paymentMethods.map(formatPaymentMethodPayload);
          }.bind(this));
        };
        VaultManager.prototype.deletePaymentMethod = function(paymentMethodNonce) {
          return this._createPromise.then(function(client) {
            var usesClientToken = client.getConfiguration().authorizationType === "CLIENT_TOKEN";
            if (!usesClientToken) {
              return Promise.reject(new BraintreeError(errors.VAULT_MANAGER_DELETE_PAYMENT_METHOD_NONCE_REQUIRES_CLIENT_TOKEN));
            }
            return client.request({
              api: "graphQLApi",
              data: {
                query: DELETE_PAYMENT_METHOD_MUTATION,
                variables: {
                  input: {
                    singleUseTokenId: paymentMethodNonce
                  }
                },
                operationName: "DeletePaymentMethodFromSingleUseToken"
              }
            }).then(function() {
              analytics.sendEvent(client, "vault-manager.delete-payment-method.succeeded");
            }).catch(function(error) {
              var originalError = error.details.originalError;
              var formattedError;
              analytics.sendEvent(client, "vault-manager.delete-payment-method.failed");
              if (originalError[0] && originalError[0].extensions.errorClass === "NOT_FOUND") {
                formattedError = new BraintreeError({
                  type: errors.VAULT_MANAGER_PAYMENT_METHOD_NONCE_NOT_FOUND.type,
                  code: errors.VAULT_MANAGER_PAYMENT_METHOD_NONCE_NOT_FOUND.code,
                  message: "A payment method for payment method nonce `" + paymentMethodNonce + "` could not be found.",
                  details: {
                    originalError
                  }
                });
              }
              if (!formattedError) {
                formattedError = new BraintreeError({
                  type: errors.VAULT_MANAGER_DELETE_PAYMENT_METHOD_UNKNOWN_ERROR.type,
                  code: errors.VAULT_MANAGER_DELETE_PAYMENT_METHOD_UNKNOWN_ERROR.code,
                  message: "An unknown error occured when attempting to delete the payment method assocaited with the payment method nonce `" + paymentMethodNonce + "`.",
                  details: {
                    originalError
                  }
                });
              }
              return Promise.reject(formattedError);
            });
          });
        };
        function formatPaymentMethodPayload(paymentMethod) {
          var formattedPaymentMethod = {
            nonce: paymentMethod.nonce,
            default: paymentMethod.default,
            details: paymentMethod.details,
            hasSubscription: paymentMethod.hasSubscription,
            type: paymentMethod.type
          };
          if (paymentMethod.description) {
            formattedPaymentMethod.description = paymentMethod.description;
          }
          if (paymentMethod.binData) {
            formattedPaymentMethod.binData = paymentMethod.binData;
          }
          return formattedPaymentMethod;
        }
        VaultManager.prototype.teardown = function() {
          convertMethodsToError(this, methods(VaultManager.prototype));
          return Promise.resolve();
        };
        module2.exports = wrapPromise.wrapPrototype(VaultManager);
      }, { "../lib/analytics": 119, "../lib/braintree-error": 124, "../lib/convert-methods-to-error": 127, "../lib/methods": 155, "./errors": 210, "@braintree/wrap-promise": 43 }], 213: [function(_dereq_, module2, exports2) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
        var venmo_desktop_1 = __importDefault(_dereq_("./venmo-desktop"));
        module2.exports = function createVenmoDesktop(options) {
          var instance = new venmo_desktop_1.default(options);
          return instance.initialize();
        };
      }, { "./venmo-desktop": 215 }], 214: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.VENMO_PAYMENT_CONTEXT_STATUS_QUERY = exports2.LEGACY_VENMO_PAYMENT_CONTEXT_STATUS_QUERY = exports2.UPDATE_PAYMENT_CONTEXT_QUERY = exports2.LEGACY_UPDATE_PAYMENT_CONTEXT_QUERY = exports2.CREATE_PAYMENT_CONTEXT_QUERY = exports2.LEGACY_CREATE_PAYMENT_CONTEXT_QUERY = void 0;
        exports2.LEGACY_CREATE_PAYMENT_CONTEXT_QUERY = "mutation CreateVenmoQRCodePaymentContext($input: CreateVenmoQRCodePaymentContextInput!) {\n  createVenmoQRCodePaymentContext(input: $input) {\n    clientMutationId\n    venmoQRCodePaymentContext {\n      id\n      merchantId\n      createdAt\n      expiresAt\n    }\n  }\n}";
        exports2.CREATE_PAYMENT_CONTEXT_QUERY = "mutation CreateVenmoPaymentContext($input: CreateVenmoPaymentContextInput!) {\n  createVenmoPaymentContext(input: $input) {\n    clientMutationId\n    venmoPaymentContext {\n      id\n      merchantId\n      createdAt\n      expiresAt\n    }\n  }\n}";
        exports2.LEGACY_UPDATE_PAYMENT_CONTEXT_QUERY = "mutation UpdateVenmoQRCodePaymentContext($input: UpdateVenmoQRCodePaymentContextInput!) {\n  updateVenmoQRCodePaymentContext(input: $input) {\n    clientMutationId\n  }\n}";
        exports2.UPDATE_PAYMENT_CONTEXT_QUERY = "mutation UpdateVenmoPaymentContextStatus($input: UpdateVenmoPaymentContextStatusInput!) {\n  updateVenmoPaymentContextStatus(input: $input) {\n    clientMutationId\n  }\n}";
        exports2.LEGACY_VENMO_PAYMENT_CONTEXT_STATUS_QUERY = "query PaymentContext($id: ID!) {\n  node(id: $id) {\n    ... on VenmoQRCodePaymentContext {\n      status\n      paymentMethodId\n      userName\n    }\n  }\n}";
        exports2.VENMO_PAYMENT_CONTEXT_STATUS_QUERY = "query PaymentContext($id: ID!) {\n  node(id: $id) {\n    ... on VenmoPaymentContext {\n      status\n      paymentMethodId\n      userName\n      payerInfo {\n        firstName\n        lastName\n        phoneNumber\n        email\n        externalId\n        userName\n        billingAddress {\n          fullName\n          addressLine1\n          addressLine2\n          adminArea1\n          adminArea2\n          postalCode\n          countryCode\n        }\n        shippingAddress {\n          fullName\n          addressLine1\n          addressLine2\n          adminArea1\n          adminArea2\n          postalCode\n          countryCode\n        }\n      }\n    }\n  }\n}";
      }, {}], 215: [function(_dereq_, module2, exports2) {
        var __assign = this && this.__assign || function() {
          __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p2 in s)
                if (Object.prototype.hasOwnProperty.call(s, p2))
                  t[p2] = s[p2];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        var framebus_1 = __importDefault(_dereq_("framebus"));
        var iframer_1 = __importDefault(_dereq_("@braintree/iframer"));
        var uuid_1 = __importDefault(_dereq_("@braintree/uuid"));
        var events_1 = _dereq_("../shared/events");
        var queries_1 = _dereq_("./queries");
        var VENMO_DESKTOP_POLLING_INTERVAL = 1e3;
        var VISUAL_DELAY_BEFORE_SIGNALLING_COMPLETION = 2e3;
        var VenmoDesktop = function() {
          function VenmoDesktop2(options) {
            this.isHidden = true;
            this.env = options.environment;
            this.id = uuid_1.default();
            this.profileId = options.profileId;
            this.displayName = options.displayName;
            this.paymentMethodUsage = options.paymentMethodUsage;
            this.shouldUseLegacyQRCodeMutation = !this.paymentMethodUsage;
            var frameUrl = options.url + "#" + this.env + "_" + this.id;
            this.bus = new framebus_1.default({
              channel: this.id,
              verifyDomain: options.verifyDomain,
              targetFrames: []
            });
            this.apiRequest = options.apiRequest;
            this.sendEvent = options.sendEvent;
            this.Promise = options.Promise;
            this.alertBox = document.createElement("div");
            this.alertBox.setAttribute("data-venmo-desktop-id", this.id);
            this.alertBox.setAttribute("role", "alert");
            this.alertBox.style.position = "fixed";
            this.alertBox.style.display = "none";
            this.alertBox.style.height = "1px";
            this.alertBox.style.width = "1px";
            this.alertBox.style.overflow = "hidden";
            this.alertBox.style.zIndex = "0";
            this.iframe = iframer_1.default({
              src: frameUrl,
              name: "venmo-desktop-iframe",
              style: {
                display: "none",
                position: "fixed",
                top: "0",
                bottom: "0",
                right: "0",
                left: "0",
                height: "100%",
                width: "100%",
                zIndex: "9999999"
              },
              title: "Venmo Desktop"
            });
            this.bus.addTargetFrame(this.iframe);
          }
          VenmoDesktop2.prototype.initialize = function() {
            var _this = this;
            return new this.Promise(function(resolve2) {
              _this.bus.on(events_1.VENMO_DESKTOP_IFRAME_READY, function() {
                resolve2(_this);
              });
              _this.bus.on(events_1.VENMO_DESKTOP_REQUEST_NEW_QR_CODE, function() {
                _this.sendEvent("venmo.tokenize.desktop.restarted-from-error-view");
                _this.startPolling();
              });
              document.body.appendChild(_this.iframe);
              document.body.appendChild(_this.alertBox);
            });
          };
          VenmoDesktop2.prototype.launchDesktopFlow = function() {
            var _this = this;
            this.isHidden = false;
            var promise = new this.Promise(function(resolve2, reject) {
              _this.launchDesktopPromiseRejectFunction = reject;
              var removeListeners = function() {
                _this.bus.off(events_1.VENMO_DESKTOP_CUSTOMER_CANCELED, customerCancelledHandler);
                _this.bus.off(events_1.VENMO_DESKTOP_UNKNOWN_ERROR, unknownErrorHandler);
              };
              var unknownErrorHandler = function(err) {
                removeListeners();
                _this.sendEvent("venmo.tokenize.desktop.unknown-error");
                reject({
                  allowUIToHandleError: false,
                  reason: "UNKNOWN_ERROR",
                  err
                });
              };
              var customerCancelledHandler = function() {
                removeListeners();
                _this.updateVenmoDesktopPaymentContext("CANCELED");
                _this.sendEvent("venmo.tokenize.desktop.status-change.canceled-from-modal");
                reject({
                  allowUIToHandleError: false,
                  reason: "CUSTOMER_CANCELED"
                });
              };
              _this.completedHandler = function(payload) {
                removeListeners();
                resolve2(payload);
              };
              _this.bus.on(events_1.VENMO_DESKTOP_CUSTOMER_CANCELED, customerCancelledHandler);
              _this.bus.on(events_1.VENMO_DESKTOP_UNKNOWN_ERROR, unknownErrorHandler);
            });
            this.iframe.style.display = "block";
            this.setAlert("Generating a QR code, get your Venmo app ready");
            this.iframe.focus();
            this.startPolling();
            return promise.then(function(result) {
              delete _this.venmoContextId;
              delete _this.launchDesktopPromiseRejectFunction;
              return result;
            }).catch(function(err) {
              delete _this.venmoContextId;
              delete _this.launchDesktopPromiseRejectFunction;
              return _this.Promise.reject(err);
            });
          };
          VenmoDesktop2.prototype.triggerCompleted = function(result) {
            var _this = this;
            if (this.isHidden) {
              return;
            }
            setTimeout(function() {
              if (_this.completedHandler) {
                _this.completedHandler(result);
              }
              delete _this.completedHandler;
            }, VISUAL_DELAY_BEFORE_SIGNALLING_COMPLETION);
          };
          VenmoDesktop2.prototype.triggerRejected = function(err) {
            if (this.launchDesktopPromiseRejectFunction) {
              this.launchDesktopPromiseRejectFunction(err);
            }
          };
          VenmoDesktop2.prototype.hideDesktopFlow = function() {
            this.setAlert("");
            this.iframe.style.display = "none";
            this.bus.emit(events_1.VENMO_DESKTOP_CLOSED_FROM_PARENT);
            this.isHidden = true;
          };
          VenmoDesktop2.prototype.displayError = function(message) {
            if (this.isHidden) {
              return;
            }
            this.bus.emit(events_1.VENMO_DESKTOP_DISPLAY_ERROR, {
              message
            });
            this.setAlert(message);
          };
          VenmoDesktop2.prototype.displayQRCode = function(id, merchantId) {
            if (this.isHidden) {
              return;
            }
            this.bus.emit(events_1.VENMO_DESKTOP_DISPLAY_QR_CODE, {
              id,
              merchantId
            });
            this.setAlert("To scan the QR code, open your Venmo app");
          };
          VenmoDesktop2.prototype.authorize = function() {
            if (this.isHidden) {
              return;
            }
            this.bus.emit(events_1.VENMO_DESKTOP_AUTHORIZE);
            this.setAlert("Venmo account authorized");
          };
          VenmoDesktop2.prototype.authorizing = function() {
            if (this.isHidden) {
              return;
            }
            this.bus.emit(events_1.VENMO_DESKTOP_AUTHORIZING);
            this.setAlert("Authorize on your Venmo app");
          };
          VenmoDesktop2.prototype.startPolling = function() {
            var _this = this;
            return this.createVenmoDesktopPaymentContext().then(function(result) {
              var expiresIn = new Date(result.expiresAt).getTime() - new Date(result.createdAt).getTime();
              var expiredTime = Date.now() + expiresIn;
              _this.displayQRCode(result.id, result.merchantId);
              return _this.pollForStatusChange(result.status, expiredTime);
            }).then(function(result) {
              if (!result) {
                return;
              }
              var username = result.userName || "";
              username = "@" + username.replace("@", "");
              _this.triggerCompleted({
                paymentMethodNonce: result.paymentMethodId,
                username,
                payerInfo: result.payerInfo,
                id: _this.venmoContextId || ""
              });
            }).catch(function(err) {
              if (err.allowUIToHandleError) {
                return;
              }
              _this.sendEvent("venmo.tokenize.desktop.unhandled-error");
              _this.triggerRejected(err);
            });
          };
          VenmoDesktop2.prototype.pollForStatusChange = function(status, expiredTime) {
            var _this = this;
            if (!this.venmoContextId) {
              return this.Promise.resolve();
            }
            if (Date.now() > expiredTime) {
              return this.updateVenmoDesktopPaymentContext("EXPIRED").then(function() {
                _this.displayError("Something went wrong");
                _this.sendEvent("venmo.tokenize.desktop.status-change.sdk-timeout");
                return _this.Promise.reject({
                  allowUIToHandleError: true,
                  reason: "TIMEOUT"
                });
              });
            }
            return this.lookupVenmoDesktopPaymentContext().then(function(response) {
              if (!_this.venmoContextId || !response) {
                return _this.Promise.resolve();
              }
              var newStatus = response.status;
              if (newStatus !== status) {
                status = newStatus;
                _this.sendEvent("venmo.tokenize.desktop.status-change." + status.toLowerCase());
                switch (status) {
                  case "CREATED":
                    break;
                  case "EXPIRED":
                  case "FAILED":
                  case "CANCELED":
                    var message = status === "CANCELED" ? "The authorization was canceled" : "Something went wrong";
                    _this.displayError(message);
                    return _this.Promise.reject({
                      allowUIToHandleError: true,
                      reason: status
                    });
                  case "SCANNED":
                    _this.authorizing();
                    break;
                  case "APPROVED":
                    _this.authorize();
                    return _this.Promise.resolve(response);
                }
              }
              return new _this.Promise(function(resolve2, reject) {
                setTimeout(function() {
                  _this.pollForStatusChange(status, expiredTime).then(resolve2).catch(reject);
                }, VENMO_DESKTOP_POLLING_INTERVAL);
              });
            });
          };
          VenmoDesktop2.prototype.teardown = function() {
            this.bus.teardown();
            if (this.iframe.parentNode) {
              this.iframe.parentNode.removeChild(this.iframe);
            }
            if (this.alertBox.parentNode) {
              this.alertBox.parentNode.removeChild(this.alertBox);
            }
          };
          VenmoDesktop2.prototype.setAlert = function(message) {
            this.alertBox.style.display = message ? "block" : "none";
            this.alertBox.textContent = message;
          };
          VenmoDesktop2.prototype.createPaymentContextFromGraphqlLegacyQRCodeMutation = function(intent) {
            return this.apiRequest(queries_1.LEGACY_CREATE_PAYMENT_CONTEXT_QUERY, {
              input: {
                environment: this.env,
                intent
              }
            }).then(function(response) {
              return response.createVenmoQRCodePaymentContext.venmoQRCodePaymentContext;
            });
          };
          VenmoDesktop2.prototype.createPaymentContextFromGraphQL = function(intent) {
            var input = {
              intent,
              paymentMethodUsage: this.paymentMethodUsage,
              customerClient: "DESKTOP"
            };
            if (this.profileId) {
              input.merchantProfileId = this.profileId;
            }
            if (this.displayName) {
              input.displayName = this.displayName;
            }
            return this.apiRequest(queries_1.CREATE_PAYMENT_CONTEXT_QUERY, {
              input
            }).then(function(response) {
              return response.createVenmoPaymentContext.venmoPaymentContext;
            });
          };
          VenmoDesktop2.prototype.createVenmoDesktopPaymentContext = function() {
            var _this = this;
            var contextPromise = this.shouldUseLegacyQRCodeMutation ? this.createPaymentContextFromGraphqlLegacyQRCodeMutation("PAY_FROM_APP") : this.createPaymentContextFromGraphQL("PAY_FROM_APP");
            return contextPromise.then(function(context) {
              _this.venmoContextId = context.id;
              var merchantId = _this.profileId || context.merchantId;
              return {
                id: context.id,
                status: context.status,
                merchantId,
                createdAt: context.createdAt,
                expiresAt: context.expiresAt
              };
            });
          };
          VenmoDesktop2.prototype.updateVenmoDesktopPaymentContext = function(status, additionalOptions) {
            if (additionalOptions === void 0) {
              additionalOptions = {};
            }
            if (!this.venmoContextId) {
              return this.Promise.resolve();
            }
            var data2 = {
              input: __assign({ id: this.venmoContextId, status }, additionalOptions)
            };
            var query = this.shouldUseLegacyQRCodeMutation ? queries_1.LEGACY_UPDATE_PAYMENT_CONTEXT_QUERY : queries_1.UPDATE_PAYMENT_CONTEXT_QUERY;
            return this.apiRequest(query, data2).then(function() {
            });
          };
          VenmoDesktop2.prototype.lookupVenmoDesktopPaymentContext = function() {
            if (!this.venmoContextId) {
              return this.Promise.resolve();
            }
            var query = this.shouldUseLegacyQRCodeMutation ? queries_1.LEGACY_VENMO_PAYMENT_CONTEXT_STATUS_QUERY : queries_1.VENMO_PAYMENT_CONTEXT_STATUS_QUERY;
            return this.apiRequest(query, {
              id: this.venmoContextId
            }).then(function(response) {
              return response.node;
            });
          };
          return VenmoDesktop2;
        }();
        exports2.default = VenmoDesktop;
      }, { "../shared/events": 220, "./queries": 214, "@braintree/iframer": 35, "@braintree/uuid": 39, "framebus": 52 }], 216: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../lib/analytics");
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var errors = _dereq_("./shared/errors");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var Venmo = _dereq_("./venmo");
        var supportsVenmo = _dereq_("./shared/supports-venmo");
        var VERSION2 = "3.100.0";
        function create2(options) {
          var name = "Venmo";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var createPromise, instance;
            if (options.profileId && typeof options.profileId !== "string") {
              return Promise.reject(new BraintreeError(errors.VENMO_INVALID_PROFILE_ID));
            }
            if (options.deepLinkReturnUrl && typeof options.deepLinkReturnUrl !== "string") {
              return Promise.reject(new BraintreeError(errors.VENMO_INVALID_DEEP_LINK_RETURN_URL));
            }
            createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            }).then(function(client) {
              var configuration = client.getConfiguration();
              options.client = client;
              if (!configuration.gatewayConfiguration.payWithVenmo) {
                return Promise.reject(new BraintreeError(errors.VENMO_NOT_ENABLED));
              }
              return client;
            });
            options.createPromise = createPromise;
            instance = new Venmo(options);
            analytics.sendEvent(createPromise, "venmo.initialized");
            return createPromise.then(function() {
              return instance;
            });
          });
        }
        function isBrowserSupported(options) {
          return supportsVenmo.isBrowserSupported(options);
        }
        module2.exports = {
          create: wrapPromise(create2),
          isBrowserSupported,
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 119, "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./shared/errors": 219, "./shared/supports-venmo": 222, "./venmo": 224, "@braintree/wrap-promise": 43 }], 217: [function(_dereq_, module2, exports2) {
        var isAndroid = _dereq_("@braintree/browser-detection/is-android");
        var isChrome = _dereq_("@braintree/browser-detection/is-chrome");
        var isIos = _dereq_("@braintree/browser-detection/is-ios");
        var isIosSafari = _dereq_("@braintree/browser-detection/is-ios-safari");
        var isIosWebview = _dereq_("@braintree/browser-detection/is-ios-webview");
        var isSamsung = _dereq_("@braintree/browser-detection/is-samsung");
        function isAndroidWebview() {
          return isAndroid() && window.navigator.userAgent.toLowerCase().indexOf("wv") > -1;
        }
        function doesNotSupportWindowOpenInIos() {
          if (!isIos()) {
            return false;
          }
          return isIosWebview() || !isIosSafari();
        }
        function isFacebookOwnedBrowserOnAndroid() {
          var ua = window.navigator.userAgent.toLowerCase();
          if (ua.indexOf("huawei") > -1 && ua.indexOf("fban") > -1) {
            return true;
          }
          if (!isAndroid()) {
            return false;
          }
          return ua.indexOf("fb_iab") > -1 || ua.indexOf("instagram") > -1;
        }
        function isIosChrome() {
          return isIos() && isChrome();
        }
        module2.exports = {
          isAndroid,
          isAndroidWebview,
          isChrome,
          isIos,
          isIosChrome,
          isSamsung,
          isIosSafari,
          isIosWebview,
          isFacebookOwnedBrowserOnAndroid,
          doesNotSupportWindowOpenInIos
        };
      }, { "@braintree/browser-detection/is-android": 22, "@braintree/browser-detection/is-chrome": 24, "@braintree/browser-detection/is-ios": 30, "@braintree/browser-detection/is-ios-safari": 27, "@braintree/browser-detection/is-ios-webview": 28, "@braintree/browser-detection/is-samsung": 31 }], 218: [function(_dereq_, module2, exports2) {
        module2.exports = {
          DOCUMENT_VISIBILITY_CHANGE_EVENT_DELAY: 500,
          DEFAULT_PROCESS_RESULTS_DELAY: 1e3,
          VENMO_APP_OR_MOBILE_AUTH_URL: "https://venmo.com/go/checkout",
          VENMO_MOBILE_APP_AUTH_ONLY_URL: "https://venmo.com/braintree/checkout",
          VENMO_WEB_LOGIN_URL: "https://account.venmo.com/go/web"
        };
      }, {}], 219: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../../lib/braintree-error");
        module2.exports = {
          VENMO_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_NOT_ENABLED",
            message: "Venmo is not enabled for this merchant."
          },
          VENMO_TOKENIZATION_REQUEST_ACTIVE: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_TOKENIZATION_REQUEST_ACTIVE",
            message: "Another tokenization request is active."
          },
          VENMO_TOKENIZATION_REQUEST_NOT_ACTIVE: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_TOKENIZATION_REQUEST_NOT_ACTIVE",
            message: "No tokenization in progress."
          },
          VENMO_APP_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_APP_FAILED",
            message: "Venmo app encountered a problem."
          },
          VENMO_APP_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_APP_CANCELED",
            message: "Venmo app authorization was canceled."
          },
          VENMO_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_CANCELED",
            message: "User canceled Venmo authorization, or Venmo app is not available."
          },
          VENMO_CUSTOMER_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_CUSTOMER_CANCELED",
            message: "User canceled Venmo authorization."
          },
          VENMO_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "VENMO_NETWORK_ERROR",
            message: "Something went wrong making the request"
          },
          VENMO_DESKTOP_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_DESKTOP_CANCELED",
            message: "User canceled Venmo authorization by closing the Venmo Desktop modal."
          },
          VENMO_TOKENIZATION_CANCELED_BY_MERCHANT: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_TOKENIZATION_CANCELED_BY_MERCHANT",
            message: "The Venmo tokenization was canceled by the merchant."
          },
          VENMO_DESKTOP_UNKNOWN_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_DESKTOP_UNKNOWN_ERROR",
            message: "Something went wrong with the Venmo Desktop flow."
          },
          VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED",
            message: "Something went wrong creating the Venmo Payment Context."
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR",
            message: "Something went wrong during mobile polling."
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_EXPIRED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_EXPIRED",
            message: "The Venmo authorization request is expired."
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_CANCELED",
            message: "The Venmo authorization was canceled"
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_TIMEOUT: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_TIMEOUT",
            message: "Customer took too long to authorize Venmo payment."
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_FAILED",
            message: "The Venmo authorization failed."
          },
          VENMO_INVALID_PROFILE_ID: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_INVALID_PROFILE_ID",
            message: "Venmo profile ID is invalid."
          },
          VENMO_INVALID_DEEP_LINK_RETURN_URL: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_INVALID_DEEP_LINK_RETURN_URL",
            message: "Venmo deep link return URL is invalid."
          },
          VENMO_TOKENIZATION_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_TOKENIZATION_FAILED",
            message: "Venmo encountered a problem"
          },
          VENMO_ECD_DISABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "ECD_DISABLED",
            message: "Cannot collect customer data when ECD is disabled. Enable this feature in the Control Panel to collect this data."
          }
        };
      }, { "../../lib/braintree-error": 124 }], 220: [function(_dereq_, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.VENMO_DESKTOP_UNKNOWN_ERROR = exports2.VENMO_DESKTOP_REQUEST_NEW_QR_CODE = exports2.VENMO_DESKTOP_CLOSED_FROM_PARENT = exports2.VENMO_DESKTOP_IFRAME_READY = exports2.VENMO_DESKTOP_DISPLAY_QR_CODE = exports2.VENMO_DESKTOP_DISPLAY_ERROR = exports2.VENMO_DESKTOP_CUSTOMER_CANCELED = exports2.VENMO_DESKTOP_AUTHORIZING = exports2.VENMO_DESKTOP_AUTHORIZE = exports2.VENMO_DESKTOP_AUTHORIZATION_TIMED_OUT = void 0;
        exports2.VENMO_DESKTOP_AUTHORIZATION_TIMED_OUT = "VENMO_DESKTOP_AUTHORIZATION_TIMED_OUT";
        exports2.VENMO_DESKTOP_AUTHORIZE = "VENMO_DESKTOP_AUTHORIZE";
        exports2.VENMO_DESKTOP_AUTHORIZING = "VENMO_DESKTOP_AUTHORIZING";
        exports2.VENMO_DESKTOP_CUSTOMER_CANCELED = "VENMO_DESKTOP_CUSTOMER_CANCELED";
        exports2.VENMO_DESKTOP_DISPLAY_ERROR = "VENMO_DESKTOP_DISPLAY_ERROR";
        exports2.VENMO_DESKTOP_DISPLAY_QR_CODE = "VENMO_DESKTOP_DISPLAY_QR_CODE";
        exports2.VENMO_DESKTOP_IFRAME_READY = "VENMO_DESKTOP_IFRAME_READY";
        exports2.VENMO_DESKTOP_CLOSED_FROM_PARENT = "VENMO_DESKTOP_CLOSED_FROM_PARENT";
        exports2.VENMO_DESKTOP_REQUEST_NEW_QR_CODE = "VENMO_DESKTOP_REQUEST_NEW_QR_CODE";
        exports2.VENMO_DESKTOP_UNKNOWN_ERROR = "VENMO_DESKTOP_UNKNOWN_ERROR";
      }, {}], 221: [function(_dereq_, module2, exports2) {
        var venmoConstants = _dereq_("./constants");
        function getVenmoUrl(options) {
          if (options.useAllowDesktopWebLogin)
            return venmoConstants.VENMO_WEB_LOGIN_URL;
          if (options.mobileWebFallBack)
            return venmoConstants.VENMO_APP_OR_MOBILE_AUTH_URL;
          return venmoConstants.VENMO_MOBILE_APP_AUTH_ONLY_URL;
        }
        module2.exports = getVenmoUrl;
      }, { "./constants": 218 }], 222: [function(_dereq_, module2, exports2) {
        var browserDetection = _dereq_("./browser-detection");
        var inIframe = _dereq_("../../lib/in-iframe");
        function isBrowserSupported(options) {
          var isKnownUnsupportedMobileBrowser, merchantAllowsDesktopBrowsers, merchantAllowsIosChrome, merchantAllowsReturningToNewBrowserTab, merchantAllowsWebviews;
          var isAndroid = browserDetection.isAndroid();
          var isMobileDevice = isAndroid || browserDetection.isIos();
          var isAndroidChrome = isAndroid && browserDetection.isChrome();
          var isMobileDeviceThatSupportsReturnToSameTab = browserDetection.isIosSafari() || isAndroidChrome;
          options = options || {};
          merchantAllowsDesktopBrowsers = (options.allowDesktopWebLogin || options.allowDesktop) === true;
          merchantAllowsReturningToNewBrowserTab = options.hasOwnProperty("allowNewBrowserTab") ? options.allowNewBrowserTab : true;
          merchantAllowsWebviews = options.hasOwnProperty("allowWebviews") ? options.allowWebviews : true;
          merchantAllowsIosChrome = merchantAllowsReturningToNewBrowserTab && !inIframe();
          isKnownUnsupportedMobileBrowser = !merchantAllowsIosChrome && browserDetection.isIosChrome() || browserDetection.isFacebookOwnedBrowserOnAndroid() || browserDetection.isSamsung();
          if (isKnownUnsupportedMobileBrowser) {
            return false;
          }
          if (!merchantAllowsWebviews && (browserDetection.isAndroidWebview() || browserDetection.isIosWebview())) {
            return false;
          }
          if (!isMobileDevice) {
            return merchantAllowsDesktopBrowsers;
          }
          if (!merchantAllowsReturningToNewBrowserTab) {
            return isMobileDeviceThatSupportsReturnToSameTab;
          }
          return isMobileDevice;
        }
        module2.exports = {
          isBrowserSupported
        };
      }, { "../../lib/in-iframe": 150, "./browser-detection": 217 }], 223: [function(_dereq_, module2, exports2) {
        var frameService = _dereq_("../../lib/frame-service/external");
        var useMin = _dereq_("../../lib/use-min");
        var ExtendedPromise = _dereq_("@braintree/extended-promise");
        var errors = _dereq_("../shared/errors");
        var BraintreeError = _dereq_("../../lib/braintree-error");
        var VERSION2 = "3.100.0";
        var VENMO_LOGO_SVG = '<svg width="198" height="58" viewBox="0 0 198 58" fill="none" xmlns="http://www.w3.org/2000/svg">\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M43.0702 13.6572C44.1935 15.4585 44.6999 17.3139 44.6999 19.6576C44.6999 27.1328 38.1277 36.8436 32.7935 43.6625H20.6099L15.7236 15.2939L26.3917 14.3105L28.9751 34.4966C31.389 30.6783 34.3678 24.6779 34.3678 20.587C34.3678 18.3477 33.9727 16.8225 33.3553 15.5666L43.0702 13.6572Z" fill="white"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M56.8965 26.1491C58.8596 26.1491 63.8018 25.2772 63.8018 22.5499C63.8018 21.2402 62.8481 20.587 61.7242 20.587C59.7579 20.587 57.1776 22.8763 56.8965 26.1491ZM56.6715 31.5506C56.6715 34.8807 58.5787 36.1873 61.107 36.1873C63.8603 36.1873 66.4966 35.534 69.923 33.8433L68.6324 42.3523C66.2183 43.4976 62.4559 44.2617 58.8039 44.2617C49.5403 44.2617 46.2249 38.8071 46.2249 31.9879C46.2249 23.1496 51.6179 13.765 62.7365 13.765C68.858 13.765 72.2809 17.0949 72.2809 21.7317C72.2815 29.2066 62.4005 31.4965 56.6715 31.5506Z" fill="white"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M103.067 20.3142C103.067 21.4052 102.897 22.9875 102.727 24.0216L99.5262 43.6622H89.1385L92.0585 25.658C92.1139 25.1696 92.284 24.1865 92.284 23.6411C92.284 22.3314 91.4414 22.0047 90.4282 22.0047C89.0826 22.0047 87.7337 22.6042 86.8354 23.0418L83.5234 43.6625H73.0772L77.8495 14.257H86.8908L87.0052 16.6041C89.1382 15.2404 91.9469 13.7656 95.932 13.7656C101.212 13.765 103.067 16.3845 103.067 20.3142Z" fill="white"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M133.906 16.9841C136.881 14.9131 139.69 13.765 143.563 13.765C148.897 13.765 150.753 16.3845 150.753 20.3142C150.753 21.4052 150.583 22.9875 150.413 24.0216L147.216 43.6622H136.825L139.801 25.2774C139.855 24.786 139.971 24.1865 139.971 23.8063C139.971 22.3317 139.128 22.0047 138.115 22.0047C136.824 22.0047 135.535 22.5501 134.577 23.0418L131.266 43.6625H120.878L123.854 25.2777C123.908 24.7863 124.02 24.1868 124.02 23.8065C124.02 22.332 123.177 22.0049 122.167 22.0049C120.819 22.0049 119.473 22.6045 118.574 23.0421L115.26 43.6628H104.817L109.589 14.2573H118.52L118.8 16.7122C120.878 15.241 123.684 13.7662 127.446 13.7662C130.704 13.765 132.837 15.129 133.906 16.9841Z" fill="white"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M171.426 25.5502C171.426 23.1496 170.808 21.513 168.956 21.513C164.857 21.513 164.015 28.55 164.015 32.1498C164.015 34.8807 164.802 36.5709 166.653 36.5709C170.528 36.5709 171.426 29.1497 171.426 25.5502ZM153.458 31.7152C153.458 22.442 158.511 13.765 170.136 13.765C178.896 13.765 182.098 18.7854 182.098 25.7148C182.098 34.8805 177.099 44.3723 165.194 44.3723C156.378 44.3723 153.458 38.7525 153.458 31.7152Z" fill="white"/>\n</svg>';
        var CONTINUE_OR_CANCEL_INSTRUCTIONS = "Tap cancel payment to cancel and return to the business. Continue payment will relaunch the payment window.";
        var POPUP_WIDTH = 400;
        var POPUP_HEIGHT = 570;
        var ELEMENT_IDS = {
          backdrop: "venmo-desktop-web-backdrop",
          backdropHidden: "venmo-desktop-web-backdrop.hidden",
          backdropContainer: "venmo-backdrop-container",
          cancelButton: "venmo-popup-cancel-button",
          continueButton: "venmo-popup-continue-button",
          message: "venmo-message",
          instructions: "venmo-instructions",
          venmoLogo: "venmo-full-logo"
        };
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function openPopup(options) {
          var frameServiceInstance = options.frameServiceInstance;
          var venmoUrl = options.venmoUrl;
          var checkForStatusChange = options.checkForStatusChange;
          var cancelTokenization = options.cancelTokenization;
          var checkPaymentContextStatus = options.checkPaymentContextStatus;
          var extendedPromise = new ExtendedPromise();
          document.getElementById(ELEMENT_IDS.continueButton).addEventListener("click", function() {
            frameServiceInstance.focus();
          });
          document.getElementById(ELEMENT_IDS.cancelButton).addEventListener("click", function() {
            frameServiceInstance.close();
            cancelTokenization();
            closeBackdrop();
          });
          frameServiceInstance.open({}, function(frameServiceErr) {
            var retryStartingCount = 1;
            if (frameServiceErr) {
              extendedPromise.reject(frameServiceErr);
            } else {
              checkForStatusChange(retryStartingCount).then(function(data2) {
                extendedPromise.resolve(data2);
              }).catch(function(statusCheckError) {
                checkPaymentContextStatus().then(function(node) {
                  if (node.status === "CREATED") {
                    extendedPromise.reject(new BraintreeError(errors.VENMO_CUSTOMER_CANCELED));
                  } else {
                    extendedPromise.reject(statusCheckError);
                  }
                });
              });
            }
            frameServiceInstance.close();
            closeBackdrop();
          });
          frameServiceInstance.redirect(venmoUrl);
          return extendedPromise;
        }
        function centeredPopupDimensions() {
          var popupTop = Math.round((window.outerHeight - POPUP_HEIGHT) / 2) + window.screenTop;
          var popupLeft = Math.round((window.outerWidth - POPUP_WIDTH) / 2) + window.screenLeft;
          return {
            top: popupTop,
            left: popupLeft
          };
        }
        function closeBackdrop() {
          document.getElementById("venmo-desktop-web-backdrop").classList.add("hidden");
        }
        function getElementStyles() {
          var backdropStyles = [
            "#" + ELEMENT_IDS.backdropHidden + " {",
            "display: none;",
            "}",
            "#" + ELEMENT_IDS.backdrop + " {",
            "z-index: 3141592632;",
            "cursor: pointer;",
            "position: fixed;",
            "top: 0;",
            "left: 0;",
            "bottom: 0;",
            "width: 100%;",
            "background: rgba(0, 0, 0, 0.8);",
            "}"
          ];
          var backdropContainerStyles = [
            "#" + ELEMENT_IDS.backdropContainer + " {",
            "display: flex;",
            "align-content: center;",
            "justify-content: center;",
            "align-items: center;",
            "width: 100%;",
            "height: 100%;",
            "flex-direction: column;",
            "}"
          ];
          var cancelButtonStyles = [
            "#" + ELEMENT_IDS.cancelButton + " {",
            "height: 24px;",
            "width: 380px;",
            "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;",
            "font-style: normal;",
            "font-weight: 700;",
            "font-size: 18px;",
            "line-height: 24px;",
            "text-align: center;",
            "background-color: transparent;",
            "border: none;",
            "color: #FFFFFF;",
            "margin-top: 28px;",
            "}"
          ];
          var continueButtonStyles = [
            "#" + ELEMENT_IDS.continueButton + " {",
            "width: 400px;",
            "height: 50px;",
            "background: #0074DE;",
            "border-radius: 24px;",
            "border: none;",
            "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;",
            "font-style: normal;",
            "font-weight: 700;",
            "font-size: 18px;",
            "color: #FFFFFF;",
            "margin-top: 44px;",
            "}"
          ];
          var messageStyles = [
            "#" + ELEMENT_IDS.message + " {",
            "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;",
            "font-style: normal;",
            "font-weight: 500;",
            "font-size: 24px;",
            "line-height: 32px;",
            "text-align: center;",
            "color: #FFFFFF;",
            "margin-top: 32px;",
            "}"
          ];
          var instructionStyles = [
            "#" + ELEMENT_IDS.instructions + " {",
            "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;",
            "font-style: normal;",
            "font-weight: 400;",
            "font-size: 16px;",
            "line-height: 20px;",
            "text-align: center;",
            "color: #FFFFFF;",
            "margin-top: 16px;",
            "width: 400px;",
            "}"
          ];
          var allStyles = backdropStyles.concat(backdropContainerStyles, cancelButtonStyles, continueButtonStyles, messageStyles, instructionStyles);
          return allStyles.join("\n");
        }
        function buildAndStyleElements() {
          var alreadyRenderedBackdrop = document.getElementById(ELEMENT_IDS.backdrop);
          var backdropStylesElement, backdropDiv, backDropContentContainer, venmoLogoDiv, venmoMessageDiv, instructionsDiv, continueButton, cancelButton;
          if (alreadyRenderedBackdrop) {
            alreadyRenderedBackdrop.classList.remove("hidden");
            return;
          }
          backdropStylesElement = document.createElement("style");
          backdropDiv = document.createElement("div");
          backDropContentContainer = document.createElement("div");
          venmoLogoDiv = document.createElement("div");
          venmoMessageDiv = document.createElement("div");
          instructionsDiv = document.createElement("div");
          continueButton = document.createElement("button");
          cancelButton = document.createElement("button");
          backdropStylesElement.id = "venmo-desktop-web__injected-styles";
          backdropStylesElement.innerHTML = getElementStyles();
          backdropDiv.id = ELEMENT_IDS.backdrop;
          backDropContentContainer.id = ELEMENT_IDS.backdropContainer;
          venmoLogoDiv.id = ELEMENT_IDS.venmoLogo;
          venmoLogoDiv.innerHTML = VENMO_LOGO_SVG;
          venmoMessageDiv.id = ELEMENT_IDS.message;
          venmoMessageDiv.innerText = "What would you like to do?";
          instructionsDiv.id = ELEMENT_IDS.instructions;
          instructionsDiv.innerText = CONTINUE_OR_CANCEL_INSTRUCTIONS;
          continueButton.id = ELEMENT_IDS.continueButton;
          continueButton.innerText = "Continue payment";
          cancelButton.id = ELEMENT_IDS.cancelButton;
          cancelButton.innerText = "Cancel payment";
          document.head.appendChild(backdropStylesElement);
          backDropContentContainer.appendChild(venmoLogoDiv);
          backDropContentContainer.appendChild(venmoMessageDiv);
          backDropContentContainer.appendChild(instructionsDiv);
          backDropContentContainer.appendChild(continueButton);
          backDropContentContainer.appendChild(cancelButton);
          backdropDiv.appendChild(backDropContentContainer);
          document.body.appendChild(backdropDiv);
          backdropDiv.addEventListener("click", function(event) {
            event.stopPropagation();
          });
        }
        function runWebLogin(options) {
          buildAndStyleElements();
          return openPopup(options);
        }
        function setupDesktopWebLogin(options) {
          var extendedPromise = new ExtendedPromise();
          var popupName = "venmoDesktopWebLogin";
          var assetsUrl = options.assetsUrl;
          var debug = options.debug || false;
          var popupLocation = centeredPopupDimensions();
          var assetsBaseUrl = assetsUrl + "/web/" + VERSION2 + "/html";
          frameService.create({
            name: popupName,
            dispatchFrameUrl: assetsBaseUrl + "/dispatch-frame" + useMin(debug) + ".html",
            openFrameUrl: assetsBaseUrl + "/venmo-landing-frame" + useMin(debug) + ".html",
            top: popupLocation.top,
            left: popupLocation.left,
            height: POPUP_HEIGHT,
            width: POPUP_WIDTH
          }, function(frameServiceInstance) {
            extendedPromise.resolve(frameServiceInstance);
          });
          return extendedPromise;
        }
        module2.exports = {
          runWebLogin,
          openPopup,
          setupDesktopWebLogin,
          POPUP_WIDTH,
          POPUP_HEIGHT
        };
      }, { "../../lib/braintree-error": 124, "../../lib/frame-service/external": 139, "../../lib/use-min": 160, "../shared/errors": 219, "@braintree/extended-promise": 34 }], 224: [function(_dereq_, module2, exports2) {
        var analytics = _dereq_("../lib/analytics");
        var isBrowserSupported = _dereq_("./shared/supports-venmo");
        var browserDetection = _dereq_("./shared/browser-detection");
        var constants = _dereq_("./shared/constants");
        var errors = _dereq_("./shared/errors");
        var querystring = _dereq_("../lib/querystring");
        var isVerifiedDomain = _dereq_("../lib/is-verified-domain");
        var methods = _dereq_("../lib/methods");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var inIframe = _dereq_("../lib/in-iframe");
        var ExtendedPromise = _dereq_("@braintree/extended-promise");
        var getVenmoUrl = _dereq_("./shared/get-venmo-url");
        var desktopWebLogin = _dereq_("./shared/web-login-backdrop");
        var snakeCaseToCamelCase = _dereq_("../lib/snake-case-to-camel-case");
        var createVenmoDesktop = _dereq_("./external/");
        var graphqlQueries = _dereq_("./external/queries");
        var VERSION2 = "3.100.0";
        var DEFAULT_MOBILE_POLLING_INTERVAL = 250;
        var DEFAULT_MOBILE_EXPIRING_THRESHOLD = 3e5;
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function Venmo(options) {
          var self2 = this;
          this._allowDesktopWebLogin = options.allowDesktopWebLogin || false;
          this._mobileWebFallBack = options.mobileWebFallBack || false;
          this._createPromise = options.createPromise;
          this._allowNewBrowserTab = options.allowNewBrowserTab !== false;
          this._allowWebviews = options.allowWebviews !== false;
          this._allowDesktop = options.allowDesktop === true;
          this._useRedirectForIOS = options.useRedirectForIOS === true;
          this._profileId = options.profileId;
          this._displayName = options.displayName;
          this._deepLinkReturnUrl = options.deepLinkReturnUrl;
          this._ignoreHistoryChanges = options.ignoreHistoryChanges;
          this._paymentMethodUsage = (options.paymentMethodUsage || "").toUpperCase();
          this._shouldUseLegacyFlow = !this._paymentMethodUsage;
          this._requireManualReturn = options.requireManualReturn === true;
          this._useDesktopQRFlow = this._allowDesktop && this._isDesktop() && !this._allowDesktopWebLogin;
          this._useAllowDesktopWebLogin = this._allowDesktopWebLogin && this._isDesktop();
          this._cannotHaveReturnUrls = inIframe() || this._requireManualReturn;
          this._allowAndroidRecreation = options.allowAndroidRecreation !== false;
          this._maxRetryCount = 3;
          this._collectCustomerBillingAddress = options.collectCustomerBillingAddress || false;
          this._collectCustomerShippingAddress = options.collectCustomerShippingAddress || false;
          this._lineItems = options.lineItems;
          this._subTotalAmount = options.subTotalAmount;
          this._discountAmount = options.discountAmount;
          this._taxAmount = options.taxAmount;
          this._shippingAmount = options.shippingAmount;
          this._totalAmount = options.totalAmount;
          this._shouldCreateVenmoPaymentContext = this._cannotHaveReturnUrls || !this._shouldUseLegacyFlow;
          analytics.sendEvent(this._createPromise, "venmo.desktop-flow.configured." + String(Boolean(this._allowDesktop)));
          if (this.hasTokenizationResult()) {
            analytics.sendEvent(this._createPromise, "venmo.appswitch.return-in-new-tab");
          } else if (this._useDesktopQRFlow) {
            this._createPromise = this._createPromise.then(function(client) {
              var config = client.getConfiguration().gatewayConfiguration;
              return createVenmoDesktop({
                url: config.assetsUrl + "/web/" + VERSION2 + "/html/venmo-desktop-frame.html",
                environment: config.environment === "production" ? "PRODUCTION" : "SANDBOX",
                profileId: self2._profileId || config.payWithVenmo.merchantId,
                paymentMethodUsage: self2._paymentMethodUsage,
                displayName: self2._displayName,
                Promise,
                apiRequest: function(query, data2) {
                  return client.request({
                    api: "graphQLApi",
                    data: {
                      query,
                      variables: data2
                    }
                  }).then(function(response) {
                    return response.data;
                  });
                },
                sendEvent: function(eventName) {
                  analytics.sendEvent(self2._createPromise, eventName);
                },
                verifyDomain: isVerifiedDomain
              }).then(function(venmoDesktopInstance) {
                self2._venmoDesktopInstance = venmoDesktopInstance;
                analytics.sendEvent(self2._createPromise, "venmo.desktop-flow.presented");
                return client;
              }).catch(function() {
                analytics.sendEvent(self2._createPromise, "venmo.desktop-flow.setup-failed");
                self2._useDesktopQRFlow = false;
                return client;
              });
            });
          } else if (this._shouldCreateVenmoPaymentContext) {
            this._mobilePollingInterval = DEFAULT_MOBILE_POLLING_INTERVAL;
            this._mobilePollingExpiresThreshold = DEFAULT_MOBILE_EXPIRING_THRESHOLD;
            this._createPromise = this._createPromise.then(function(client) {
              var paymentContextPromise, webLoginPromise;
              var analyticsCategory = self2._cannotHaveReturnUrls ? "manual-return" : "mobile-payment-context";
              var config = client.getConfiguration();
              webLoginPromise = desktopWebLogin.setupDesktopWebLogin({
                assetsUrl: config.gatewayConfiguration.assetsUrl,
                debug: config.isDebug
              }).then(function(frameServiceInstance) {
                self2._frameServiceInstance = frameServiceInstance;
              }).catch(function(desktopWebErr) {
                return desktopWebErr;
              });
              self2._mobilePollingContextEnvironment = config.gatewayConfiguration.environment.toUpperCase();
              paymentContextPromise = self2._createVenmoPaymentContext(client).then(function() {
                analytics.sendEvent(self2._createPromise, "venmo." + analyticsCategory + ".presented");
                return client;
              }).catch(function(err) {
                analytics.sendEvent(self2._createPromise, "venmo." + analyticsCategory + ".setup-failed");
                return Promise.reject(new BraintreeError({
                  type: errors.VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED.type,
                  code: errors.VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED.code,
                  message: isValidationError(err) ? err.details.originalError[0].message : errors.VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED.message,
                  details: {
                    originalError: err
                  }
                }));
              });
              return ExtendedPromise.all([webLoginPromise, paymentContextPromise]).then(function(results) {
                var paymentContextResult = results[1];
                return Promise.resolve(paymentContextResult);
              }).catch(function(promiseErr) {
                return Promise.reject(promiseErr);
              });
            });
          }
        }
        function isValidationError(err) {
          return err.details && err.details.originalError && err.details.originalError[0] && err.details.originalError[0].extensions && err.details.originalError[0].extensions.errorClass === "VALIDATION" && err.details.originalError[0].extensions.errorType === "user_error";
        }
        Venmo.prototype._createVenmoPaymentContext = function(client, cancelIfTokenizationInProgress) {
          var self2 = this;
          var promise, transactionDetails;
          var configuration = client.getConfiguration();
          var venmoConfiguration = configuration.gatewayConfiguration.payWithVenmo;
          var transactionDetailsPresent = false;
          if (!this._shouldCreateVenmoPaymentContext) {
            return Promise.resolve();
          }
          if (this._shouldUseLegacyFlow) {
            promise = client.request({
              api: "graphQLApi",
              data: {
                query: graphqlQueries.LEGACY_CREATE_PAYMENT_CONTEXT_QUERY,
                variables: {
                  input: {
                    environment: this._mobilePollingContextEnvironment,
                    intent: "PAY_FROM_APP"
                  }
                }
              }
            }).then(function(response) {
              return response.data.createVenmoQRCodePaymentContext.venmoQRCodePaymentContext;
            });
          } else {
            if ((this._collectCustomerBillingAddress || this._collectCustomerShippingAddress) && !venmoConfiguration.enrichedCustomerDataEnabled) {
              return Promise.reject(new BraintreeError(errors.VENMO_ECD_DISABLED));
            }
            if (this._lineItems) {
              this._lineItems.forEach(function(item) {
                item.unitTaxAmount = item.unitTaxAmount || "0";
              });
            }
            transactionDetails = {
              subTotalAmount: this._subTotalAmount,
              discountAmount: this._discountAmount,
              taxAmount: this._taxAmount,
              shippingAmount: this._shippingAmount,
              totalAmount: this._totalAmount,
              lineItems: this._lineItems
            };
            transactionDetailsPresent = Object.keys(transactionDetails).some(function(detail) {
              return transactionDetails[detail] !== void 0;
            });
            promise = client.request({
              api: "graphQLApi",
              data: {
                query: graphqlQueries.CREATE_PAYMENT_CONTEXT_QUERY,
                variables: {
                  input: {
                    paymentMethodUsage: this._paymentMethodUsage,
                    intent: "CONTINUE",
                    customerClient: "MOBILE_WEB",
                    displayName: this._displayName,
                    paysheetDetails: {
                      collectCustomerBillingAddress: this._collectCustomerBillingAddress,
                      collectCustomerShippingAddress: this._collectCustomerShippingAddress,
                      transactionDetails: transactionDetailsPresent ? transactionDetails : void 0
                    }
                  }
                }
              }
            }).then(function(response) {
              return response.data.createVenmoPaymentContext.venmoPaymentContext;
            });
          }
          return promise.then(function(context) {
            var expiredTime = new Date(context.expiresAt) - new Date(context.createdAt);
            var refreshIn = expiredTime * 0.6666;
            clearTimeout(self2._refreshPaymentContextTimeout);
            self2._refreshPaymentContextTimeout = setTimeout(function() {
              if (self2._tokenizationInProgress) {
                return;
              }
              self2._createVenmoPaymentContext(client, true);
            }, refreshIn);
            if (cancelIfTokenizationInProgress && self2._tokenizationInProgress) {
              return;
            }
            self2._venmoPaymentContextStatus = context.status;
            self2._venmoPaymentContextId = context.id;
          });
        };
        Venmo.prototype.appSwitch = function(url) {
          if (this._deepLinkReturnUrl) {
            if (isIosWebviewInDeepLinkReturnUrlFlow()) {
              analytics.sendEvent(this._createPromise, "venmo.appswitch.start.ios-webview");
              window.location.href = url;
            } else if (window.popupBridge && typeof window.popupBridge.open === "function") {
              analytics.sendEvent(this._createPromise, "venmo.appswitch.start.popup-bridge");
              window.popupBridge.open(url);
            } else {
              analytics.sendEvent(this._createPromise, "venmo.appswitch.start.webview");
              window.open(url);
            }
          } else {
            analytics.sendEvent(this._createPromise, "venmo.appswitch.start.browser");
            if (browserDetection.doesNotSupportWindowOpenInIos() || this._shouldUseRedirectStrategy()) {
              window.location.href = url;
            } else {
              window.open(url);
            }
          }
        };
        Venmo.prototype.getUrl = function() {
          return this._createPromise.then(function(client) {
            var configuration = client.getConfiguration();
            var params = {};
            var currentUrl = this._deepLinkReturnUrl || window.location.href.replace(window.location.hash, "");
            var venmoConfiguration = configuration.gatewayConfiguration.payWithVenmo;
            var analyticsMetadata = configuration.analyticsMetadata;
            var accessToken = venmoConfiguration.accessToken;
            var braintreeData = {
              _meta: {
                version: analyticsMetadata.sdkVersion,
                integration: analyticsMetadata.integration,
                platform: analyticsMetadata.platform,
                sessionId: analyticsMetadata.sessionId
              }
            };
            this._isDebug = configuration.isDebug;
            this._assetsUrl = configuration.gatewayConfiguration.assetsUrl;
            currentUrl = currentUrl.replace(/#*$/, "");
            if (this._venmoPaymentContextId) {
              if (this._shouldUseLegacyFlow) {
                accessToken += "|pcid:" + this._venmoPaymentContextId;
              } else {
                params.resource_id = this._venmoPaymentContextId;
              }
            }
            if (this._shouldIncludeReturnUrls() || this._useAllowDesktopWebLogin) {
              if (this._useAllowDesktopWebLogin) {
                currentUrl = this._assetsUrl + "/web/" + VERSION2 + "/html/redirect-frame.html";
              }
              params["x-success"] = currentUrl + "#venmoSuccess=1";
              params["x-cancel"] = currentUrl + "#venmoCancel=1";
              params["x-error"] = currentUrl + "#venmoError=1";
            } else {
              params["x-success"] = "NOOP";
              params["x-cancel"] = "NOOP";
              params["x-error"] = "NOOP";
            }
            if (!this._allowAndroidRecreation) {
              params.allowAndroidRecreation = 0;
            } else {
              params.allowAndroidRecreation = 1;
            }
            params.ua = window.navigator.userAgent;
            params.braintree_merchant_id = this._profileId || venmoConfiguration.merchantId;
            params.braintree_access_token = accessToken;
            params.braintree_environment = venmoConfiguration.environment;
            params.braintree_sdk_data = btoa(JSON.stringify(braintreeData));
            return getVenmoUrl({
              useAllowDesktopWebLogin: this._useAllowDesktopWebLogin,
              mobileWebFallBack: this._mobileWebFallBack
            }) + "?" + querystring.stringify(params);
          }.bind(this));
        };
        Venmo.prototype.isBrowserSupported = function() {
          return isBrowserSupported.isBrowserSupported({
            allowNewBrowserTab: this._allowNewBrowserTab,
            allowWebviews: this._allowWebviews,
            allowDesktop: this._allowDesktop,
            allowDesktopWebLogin: this._allowDesktopWebLogin
          });
        };
        Venmo.prototype.hasTokenizationResult = function() {
          return this._hasTokenizationResult();
        };
        Venmo.prototype._hasTokenizationResult = function(hash) {
          var params = getFragmentParameters(hash);
          return typeof (params.venmoSuccess || params.venmoError || params.venmoCancel) !== "undefined";
        };
        Venmo.prototype._shouldIncludeReturnUrls = function() {
          if (this._deepLinkReturnUrl) {
            return true;
          }
          return !this._cannotHaveReturnUrls;
        };
        Venmo.prototype._isDesktop = function() {
          return !(browserDetection.isIos() || browserDetection.isAndroid());
        };
        Venmo.prototype.tokenize = function(options) {
          var self2 = this;
          var tokenizationPromise;
          options = options || {};
          if (this._tokenizationInProgress === true) {
            return Promise.reject(new BraintreeError(errors.VENMO_TOKENIZATION_REQUEST_ACTIVE));
          }
          this._tokenizationInProgress = true;
          if (this._useDesktopQRFlow) {
            tokenizationPromise = this._tokenizeForDesktopQRFlow(options);
          } else if (this._useAllowDesktopWebLogin) {
            tokenizationPromise = this._tokenizeWebLoginWithRedirect();
          } else if (this._cannotHaveReturnUrls) {
            tokenizationPromise = this._tokenizeForMobileWithManualReturn();
          } else {
            tokenizationPromise = this._tokenizeForMobileWithHashChangeListeners(options);
          }
          return tokenizationPromise.then(function(payload) {
            return self2._createPromise.then(function(client) {
              return self2._createVenmoPaymentContext(client);
            }).then(function() {
              self2._tokenizationInProgress = false;
              return formatTokenizePayload(payload);
            });
          }).catch(function(err) {
            return self2._createPromise.then(function(client) {
              return self2._createVenmoPaymentContext(client);
            }).then(function() {
              self2._tokenizationInProgress = false;
              return Promise.reject(err);
            });
          });
        };
        Venmo.prototype.cancelTokenization = function() {
          if (!this._tokenizationInProgress) {
            return Promise.reject(new BraintreeError(errors.VENMO_TOKENIZATION_REQUEST_NOT_ACTIVE));
          }
          this._removeVisibilityEventListener();
          if (this._tokenizePromise) {
            this._tokenizePromise.reject(new BraintreeError(errors.VENMO_TOKENIZATION_CANCELED_BY_MERCHANT));
          }
          return Promise.all([
            this._cancelMobilePaymentContext(),
            this._cancelVenmoDesktopContext()
          ]);
        };
        Venmo.prototype._tokenizeWebLoginWithRedirect = function() {
          var self2 = this;
          analytics.sendEvent(self2._createPromise, "venmo.tokenize.web-login.start");
          this._tokenizePromise = new ExtendedPromise();
          return this.getUrl().then(function(url) {
            desktopWebLogin.runWebLogin({
              checkForStatusChange: self2._checkPaymentContextStatusAndProcessResult.bind(self2),
              cancelTokenization: self2.cancelTokenization.bind(self2),
              frameServiceInstance: self2._frameServiceInstance,
              venmoUrl: url,
              debug: self2._isDebug,
              checkPaymentContextStatus: self2._checkPaymentContextStatus.bind(self2)
            }).then(function(payload) {
              analytics.sendEvent(self2._createPromise, "venmo.tokenize.web-login.success");
              self2._tokenizePromise.resolve({
                paymentMethodNonce: payload.paymentMethodId,
                username: payload.userName,
                payerInfo: payload.payerInfo,
                id: self2._venmoPaymentContextId
              });
            }).catch(function(err) {
              analytics.sendEvent(self2._createPromise, "venmo.tokenize.web-login.failure");
              self2._tokenizePromise.reject(err);
            });
            return self2._tokenizePromise;
          });
        };
        Venmo.prototype._queryPaymentContextStatus = function(id) {
          var self2 = this;
          return this._createPromise.then(function(client) {
            var query = self2._shouldUseLegacyFlow ? graphqlQueries.LEGACY_VENMO_PAYMENT_CONTEXT_STATUS_QUERY : graphqlQueries.VENMO_PAYMENT_CONTEXT_STATUS_QUERY;
            return client.request({
              api: "graphQLApi",
              data: {
                query,
                variables: {
                  id
                }
              }
            });
          }).then(function(response) {
            return response.data.node;
          });
        };
        Venmo.prototype._checkPaymentContextStatusAndProcessResult = function(retryCount) {
          var self2 = this;
          return self2._checkPaymentContextStatus().then(function(node) {
            var resultStatus = node.status;
            if (resultStatus !== self2._venmoPaymentContextStatus) {
              self2._venmoPaymentContextStatus = resultStatus;
              analytics.sendEvent(self2._createPromise, "venmo.tokenize.web-login.status-change");
              switch (resultStatus) {
                case "APPROVED":
                  return Promise.resolve(node);
                case "CANCELED":
                  return Promise.reject(new BraintreeError(errors.VENMO_CUSTOMER_CANCELED));
                case "FAILED":
                  return Promise.reject(new BraintreeError(errors.VENMO_TOKENIZATION_FAILED));
              }
            }
            return new Promise(function(resolve2, reject) {
              if (retryCount < self2._maxRetryCount) {
                retryCount++;
                return self2._checkPaymentContextStatusAndProcessResult(retryCount).then(resolve2).catch(reject);
              }
              return reject(new BraintreeError(errors.VENMO_TOKENIZATION_FAILED));
            });
          });
        };
        Venmo.prototype._checkPaymentContextStatus = function() {
          var self2 = this;
          return self2._queryPaymentContextStatus(self2._venmoPaymentContextId).catch(function(networkError) {
            return Promise.reject(new BraintreeError({
              type: errors.VENMO_NETWORK_ERROR.type,
              code: errors.VENMO_NETWORK_ERROR.code,
              message: errors.VENMO_NETWORK_ERROR.message,
              details: networkError
            }));
          }).then(function(node) {
            return Promise.resolve(node);
          });
        };
        Venmo.prototype._pollForStatusChange = function() {
          var self2 = this;
          if (Date.now() > self2._mobilePollingContextExpiresIn) {
            return Promise.reject(new BraintreeError(errors.VENMO_MOBILE_POLLING_TOKENIZATION_TIMEOUT));
          }
          return this._queryPaymentContextStatus(this._venmoPaymentContextId).catch(function(networkError) {
            return Promise.reject(new BraintreeError({
              type: errors.VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR.type,
              code: errors.VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR.code,
              message: errors.VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR.message,
              details: {
                originalError: networkError
              }
            }));
          }).then(function(node) {
            var newStatus = node.status;
            if (newStatus !== self2._venmoPaymentContextStatus) {
              self2._venmoPaymentContextStatus = newStatus;
              analytics.sendEvent(self2._createPromise, "venmo.tokenize.manual-return.status-change." + newStatus.toLowerCase());
              switch (newStatus) {
                case "EXPIRED":
                case "FAILED":
                case "CANCELED":
                  return Promise.reject(new BraintreeError(errors["VENMO_MOBILE_POLLING_TOKENIZATION_" + newStatus]));
                case "APPROVED":
                  return Promise.resolve(node);
              }
            }
            return new Promise(function(resolve2, reject) {
              setTimeout(function() {
                self2._pollForStatusChange().then(resolve2).catch(reject);
              }, self2._mobilePollingInterval);
            });
          });
        };
        Venmo.prototype._tokenizeForMobileWithManualReturn = function() {
          var self2 = this;
          analytics.sendEvent(this._createPromise, "venmo.tokenize.manual-return.start");
          this._mobilePollingContextExpiresIn = Date.now() + this._mobilePollingExpiresThreshold;
          this._tokenizePromise = new ExtendedPromise();
          this._pollForStatusChange().then(function(payload) {
            analytics.sendEvent(self2._createPromise, "venmo.tokenize.manual-return.success");
            self2._tokenizePromise.resolve({
              paymentMethodNonce: payload.paymentMethodId,
              username: payload.userName,
              payerInfo: payload.payerInfo,
              id: self2._venmoPaymentContextId
            });
          }).catch(function(err) {
            analytics.sendEvent(self2._createPromise, "venmo.tokenize.manual-return.failure");
            self2._tokenizePromise.reject(err);
          });
          return this.getUrl().then(function(url) {
            self2.appSwitch(url);
            return self2._tokenizePromise;
          });
        };
        Venmo.prototype._shouldUseRedirectStrategy = function() {
          if (!browserDetection.isIos()) {
            return false;
          }
          if (this._mobileWebFallBack === true) {
            return true;
          }
          return this._useRedirectForIOS;
        };
        Venmo.prototype._tokenizeForMobileWithHashChangeListeners = function(options) {
          var self2 = this;
          var resultProcessingInProgress, visibilityChangeListenerTimeout;
          if (this.hasTokenizationResult()) {
            return this.processHashChangeFlowResults();
          }
          analytics.sendEvent(this._createPromise, "venmo.tokenize.mobile.start");
          this._tokenizePromise = new ExtendedPromise();
          this._previousHash = window.location.hash;
          function completeFlow(hash) {
            var error;
            self2.processHashChangeFlowResults(hash).catch(function(err) {
              error = err;
            }).then(function(res) {
              if (!self2._ignoreHistoryChanges && window.location.hash !== self2._previousHash) {
                window.location.hash = self2._previousHash;
              }
              self2._removeVisibilityEventListener();
              if (error) {
                self2._tokenizePromise.reject(error);
              } else {
                self2._tokenizePromise.resolve(res);
              }
              delete self2._tokenizePromise;
            });
          }
          this._onHashChangeListener = function(e) {
            var hash = e.newURL.split("#")[1];
            if (!self2._hasTokenizationResult(hash)) {
              return;
            }
            resultProcessingInProgress = true;
            clearTimeout(visibilityChangeListenerTimeout);
            completeFlow(hash);
          };
          window.addEventListener("hashchange", this._onHashChangeListener, false);
          this._visibilityChangeListener = function() {
            var delay = options.processResultsDelay || constants.DEFAULT_PROCESS_RESULTS_DELAY;
            if (!window.document.hidden) {
              if (!resultProcessingInProgress) {
                visibilityChangeListenerTimeout = setTimeout(completeFlow, delay);
              }
            }
          };
          return this.getUrl().then(function(url) {
            self2.appSwitch(url);
            setTimeout(function() {
              window.document.addEventListener(documentVisibilityChangeEventName(), self2._visibilityChangeListener);
            }, constants.DOCUMENT_VISIBILITY_CHANGE_EVENT_DELAY);
            return self2._tokenizePromise;
          });
        };
        Venmo.prototype._tokenizeForDesktopQRFlow = function() {
          var self2 = this;
          analytics.sendEvent(this._createPromise, "venmo.tokenize.desktop.start");
          this._tokenizePromise = new ExtendedPromise();
          this._createPromise.then(function() {
            return self2._venmoDesktopInstance.launchDesktopFlow();
          }).then(function(payload) {
            self2._venmoDesktopInstance.hideDesktopFlow();
            analytics.sendEvent(self2._createPromise, "venmo.tokenize.desktop.success");
            self2._tokenizePromise.resolve(payload);
          }).catch(function(err) {
            analytics.sendEvent(self2._createPromise, "venmo.tokenize.desktop.failure");
            if (self2._venmoDesktopInstance) {
              self2._venmoDesktopInstance.hideDesktopFlow();
            }
            if (err && err.reason === "CUSTOMER_CANCELED") {
              self2._tokenizePromise.reject(new BraintreeError(errors.VENMO_DESKTOP_CANCELED));
              return;
            }
            self2._tokenizePromise.reject(new BraintreeError({
              type: errors.VENMO_DESKTOP_UNKNOWN_ERROR.type,
              code: errors.VENMO_DESKTOP_UNKNOWN_ERROR.code,
              message: errors.VENMO_DESKTOP_UNKNOWN_ERROR.message,
              details: {
                originalError: err
              }
            }));
          });
          return this._tokenizePromise;
        };
        Venmo.prototype._cancelMobilePaymentContext = function() {
          var self2 = this;
          return this._createPromise.then(function(client) {
            var query;
            if (self2._venmoPaymentContextId) {
              query = self2._shouldUseLegacyFlow ? graphqlQueries.LEGACY_UPDATE_PAYMENT_CONTEXT_QUERY : graphqlQueries.UPDATE_PAYMENT_CONTEXT_QUERY;
              return client.request({
                api: "graphQLApi",
                data: {
                  query,
                  variables: {
                    input: {
                      id: self2._venmoPaymentContextId,
                      status: "CANCELED"
                    }
                  }
                }
              });
            }
            return Promise.resolve();
          });
        };
        Venmo.prototype._cancelVenmoDesktopContext = function() {
          var self2 = this;
          return this._createPromise.then(function() {
            if (self2._venmoDesktopInstance) {
              self2._venmoDesktopInstance.updateVenmoDesktopPaymentContext("CANCELED");
            }
            return Promise.resolve();
          });
        };
        Venmo.prototype.teardown = function() {
          var self2 = this;
          this._removeVisibilityEventListener();
          return this._createPromise.then(function() {
            if (self2._venmoDesktopInstance) {
              self2._venmoDesktopInstance.teardown();
            }
            clearTimeout(self2._refreshPaymentContextTimeout);
            self2._cancelMobilePaymentContext();
            convertMethodsToError(this, methods(Venmo.prototype));
          }.bind(this));
        };
        Venmo.prototype._removeVisibilityEventListener = function() {
          window.removeEventListener("hashchange", this._onHashChangeListener);
          window.document.removeEventListener(documentVisibilityChangeEventName(), this._visibilityChangeListener);
          delete this._visibilityChangeListener;
          delete this._onHashChangeListener;
        };
        Venmo.prototype.processHashChangeFlowResults = function(hash) {
          var self2 = this;
          var params = getFragmentParameters(hash);
          return new Promise(function(resolve2, reject) {
            if (!self2._shouldUseLegacyFlow) {
              self2._pollForStatusChange().then(function(payload) {
                analytics.sendEvent(self2._createPromise, "venmo.appswitch.handle.payment-context-status-query.success");
                return resolve2({
                  paymentMethodNonce: payload.paymentMethodId,
                  username: payload.userName,
                  payerInfo: payload.payerInfo,
                  id: self2._venmoPaymentContextId
                });
              }).catch(function(err) {
                if (err.type === errors.VENMO_MOBILE_POLLING_TOKENIZATION_CANCELED.type) {
                  reject(err);
                }
                analytics.sendEvent(self2._createPromise, "venmo.process-results.payment-context-status-query-failed");
                resolve2(params);
              });
            } else if (params.venmoSuccess) {
              analytics.sendEvent(self2._createPromise, "venmo.appswitch.handle.success");
              resolve2(params);
            } else if (params.venmoError) {
              analytics.sendEvent(self2._createPromise, "venmo.appswitch.handle.error");
              reject(new BraintreeError({
                type: errors.VENMO_APP_FAILED.type,
                code: errors.VENMO_APP_FAILED.code,
                message: errors.VENMO_APP_FAILED.message,
                details: {
                  originalError: {
                    message: decodeURIComponent(params.errorMessage),
                    code: params.errorCode
                  }
                }
              }));
            } else if (params.venmoCancel) {
              analytics.sendEvent(self2._createPromise, "venmo.appswitch.handle.cancel");
              reject(new BraintreeError(errors.VENMO_APP_CANCELED));
            } else {
              analytics.sendEvent(self2._createPromise, "venmo.appswitch.cancel-or-unavailable");
              reject(new BraintreeError(errors.VENMO_CANCELED));
            }
            self2._clearFragmentParameters();
          });
        };
        Venmo.prototype._clearFragmentParameters = function() {
          if (this._ignoreHistoryChanges) {
            return;
          }
          if (typeof window.history.replaceState === "function" && window.location.hash) {
            history.pushState({}, "", window.location.href.slice(0, window.location.href.indexOf("#")));
          }
        };
        function getFragmentParameters(hash) {
          var keyValuesArray = (hash || window.location.hash.substring(1)).split("&");
          var parsedParams = keyValuesArray.reduce(function(toReturn, keyValue) {
            var parts = keyValue.split("=");
            var decodedKey = decodeURIComponent(parts[0]).replace(/\W/g, "");
            var key = snakeCaseToCamelCase(decodedKey);
            var value = decodeURIComponent(parts[1]);
            toReturn[key] = value;
            return toReturn;
          }, {});
          if (parsedParams.resourceId) {
            parsedParams.id = parsedParams.resourceId;
          }
          return parsedParams;
        }
        function formatUserName(username) {
          username = username || "";
          return "@" + username.replace("@", "");
        }
        function formatTokenizePayload(payload) {
          var formattedPayload = {
            nonce: payload.paymentMethodNonce,
            type: "VenmoAccount",
            details: {
              username: formatUserName(payload.username),
              paymentContextId: payload.id
            }
          };
          if (payload.payerInfo) {
            formattedPayload.details.payerInfo = payload.payerInfo;
            formattedPayload.details.payerInfo.userName = formatUserName(payload.payerInfo.userName);
          }
          return formattedPayload;
        }
        function documentVisibilityChangeEventName() {
          var visibilityChange;
          if (typeof window.document.hidden !== "undefined") {
            visibilityChange = "visibilitychange";
          } else if (typeof window.document.msHidden !== "undefined") {
            visibilityChange = "msvisibilitychange";
          } else if (typeof window.document.webkitHidden !== "undefined") {
            visibilityChange = "webkitvisibilitychange";
          }
          return visibilityChange;
        }
        function isIosWebviewInDeepLinkReturnUrlFlow() {
          return window.navigator.platform && /iPhone|iPad|iPod/.test(window.navigator.platform);
        }
        module2.exports = wrapPromise.wrapPrototype(Venmo);
      }, { "../lib/analytics": 119, "../lib/braintree-error": 124, "../lib/convert-methods-to-error": 127, "../lib/in-iframe": 150, "../lib/is-verified-domain": 153, "../lib/methods": 155, "../lib/querystring": 157, "../lib/snake-case-to-camel-case": 159, "./external/": 213, "./external/queries": 214, "./shared/browser-detection": 217, "./shared/constants": 218, "./shared/errors": 219, "./shared/get-venmo-url": 221, "./shared/supports-venmo": 222, "./shared/web-login-backdrop": 223, "@braintree/extended-promise": 34, "@braintree/wrap-promise": 43 }], 225: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        module2.exports = {
          VISA_CHECKOUT_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "VISA_CHECKOUT_NOT_ENABLED",
            message: "Visa Checkout is not enabled for this merchant."
          },
          VISA_CHECKOUT_INIT_OPTIONS_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "VISA_CHECKOUT_INIT_OPTIONS_REQUIRED",
            message: "initOptions requires an object."
          },
          VISA_CHECKOUT_PAYMENT_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "VISA_CHECKOUT_PAYMENT_REQUIRED",
            message: "tokenize requires callid, encKey, and encPaymentData."
          },
          VISA_CHECKOUT_TOKENIZATION: {
            type: BraintreeError.types.NETWORK,
            code: "VISA_CHECKOUT_TOKENIZATION",
            message: "A network error occurred when processing the Visa Checkout payment."
          }
        };
      }, { "../lib/braintree-error": 124 }], 226: [function(_dereq_, module2, exports2) {
        var basicComponentVerification = _dereq_("../lib/basic-component-verification");
        var BraintreeError = _dereq_("../lib/braintree-error");
        var createDeferredClient = _dereq_("../lib/create-deferred-client");
        var createAssetsUrl = _dereq_("../lib/create-assets-url");
        var VisaCheckout = _dereq_("./visa-checkout");
        var analytics = _dereq_("../lib/analytics");
        var errors = _dereq_("./errors");
        var VERSION2 = "3.100.0";
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        function create2(options) {
          var name = "Visa Checkout";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            });
          }).then(function(client) {
            options.client = client;
            if (!options.client.getConfiguration().gatewayConfiguration.visaCheckout) {
              return Promise.reject(new BraintreeError(errors.VISA_CHECKOUT_NOT_ENABLED));
            }
            analytics.sendEvent(options.client, "visacheckout.initialized");
            return new VisaCheckout(options);
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 119, "../lib/basic-component-verification": 122, "../lib/braintree-error": 124, "../lib/create-assets-url": 129, "../lib/create-deferred-client": 131, "./errors": 225, "./visa-checkout": 227, "@braintree/wrap-promise": 43 }], 227: [function(_dereq_, module2, exports2) {
        var BraintreeError = _dereq_("../lib/braintree-error");
        var analytics = _dereq_("../lib/analytics");
        var errors = _dereq_("./errors");
        var jsonClone = _dereq_("../lib/json-clone");
        var methods = _dereq_("../lib/methods");
        var convertMethodsToError = _dereq_("../lib/convert-methods-to-error");
        var wrapPromise = _dereq_("@braintree/wrap-promise");
        var cardTypeTransformMap = {
          Visa: "VISA",
          MasterCard: "MASTERCARD",
          Discover: "DISCOVER",
          "American Express": "AMEX"
        };
        function VisaCheckout(options) {
          this._client = options.client;
        }
        function transformCardTypes(cardTypes) {
          return cardTypes.reduce(function(acc, type) {
            if (cardTypeTransformMap.hasOwnProperty(type)) {
              return acc.concat(cardTypeTransformMap[type]);
            }
            return acc;
          }, []);
        }
        VisaCheckout.prototype.createInitOptions = function(options) {
          var initOptions;
          var gatewayConfiguration = this._client.getConfiguration().gatewayConfiguration;
          var visaCheckoutConfiguration = gatewayConfiguration.visaCheckout;
          if (!options) {
            throw new BraintreeError(errors.VISA_CHECKOUT_INIT_OPTIONS_REQUIRED);
          }
          initOptions = jsonClone(options);
          initOptions.apikey = initOptions.apikey || visaCheckoutConfiguration.apikey;
          initOptions.encryptionKey = visaCheckoutConfiguration.encryptionKey;
          initOptions.externalClientId = initOptions.externalClientId || visaCheckoutConfiguration.externalClientId;
          initOptions.settings = initOptions.settings || {};
          initOptions.settings.dataLevel = "FULL";
          initOptions.settings.payment = initOptions.settings.payment || {};
          if (!initOptions.settings.payment.cardBrands) {
            initOptions.settings.payment.cardBrands = transformCardTypes(gatewayConfiguration.visaCheckout.supportedCardTypes);
          }
          return initOptions;
        };
        VisaCheckout.prototype.tokenize = function(payment) {
          var self2 = this;
          if (!payment.callid || !payment.encKey || !payment.encPaymentData) {
            return Promise.reject(new BraintreeError(errors.VISA_CHECKOUT_PAYMENT_REQUIRED));
          }
          return this._client.request({
            method: "post",
            endpoint: "payment_methods/visa_checkout_cards",
            data: {
              _meta: {
                source: "visa-checkout"
              },
              visaCheckoutCard: {
                callId: payment.callid,
                encryptedPaymentData: payment.encPaymentData,
                encryptedKey: payment.encKey
              }
            }
          }).then(function(response) {
            analytics.sendEvent(self2._client, "visacheckout.tokenize.succeeded");
            return response.visaCheckoutCards[0];
          }).catch(function(err) {
            analytics.sendEvent(self2._client, "visacheckout.tokenize.failed");
            return Promise.reject(new BraintreeError({
              type: errors.VISA_CHECKOUT_TOKENIZATION.type,
              code: errors.VISA_CHECKOUT_TOKENIZATION.code,
              message: errors.VISA_CHECKOUT_TOKENIZATION.message,
              details: {
                originalError: err
              }
            }));
          });
        };
        VisaCheckout.prototype.teardown = function() {
          convertMethodsToError(this, methods(VisaCheckout.prototype));
          return Promise.resolve();
        };
        module2.exports = wrapPromise.wrapPrototype(VisaCheckout);
      }, { "../lib/analytics": 119, "../lib/braintree-error": 124, "../lib/convert-methods-to-error": 127, "../lib/json-clone": 154, "../lib/methods": 155, "./errors": 225, "@braintree/wrap-promise": 43 }] }, {}, [117])(117);
    });
  })(browser);
  var braintree = /* @__PURE__ */ getDefaultExportFromCjs(browser.exports);
  var getPaymentExtensionAttributes = () => {
    const { agreementIds } = useAgreementStore();
    return {
      agreement_ids: agreementIds
    };
  };
  var buildCartUrl = (path, prefix = "") => {
    const { customer: { token, tokenType } } = useCustomerStore();
    const builtPath = tokenType === tokenTypes.guestUser ? `/guest-carts/${token}/${path}` : `/carts/mine/${path}`;
    return `${getBaseRestUrl()}${prefix}${builtPath}`;
  };
  var getNewsletterMutation = () => {
    const { newsletterEnabled, newsletterAllowGuests } = useConfigStore();
    const customerStore = useCustomerStore();
    const newSignUp = customerStore.isLoggedIn ? !customerStore.newsletter.isSubscribed : newsletterAllowGuests;
    if (newsletterEnabled && newSignUp && customerStore.newsletter.subscribeToNewsletter) {
      return `
      subscribeEmailToNewsletter(email: "${customerStore.customer.email}") {
        status
      }`;
    }
    return "";
  };
  var createPayment$1 = async (payment) => {
    const { tokens } = useRecaptchaStore();
    const headers = {
      "X-ReCaptcha": tokens.placeOrder,
      "X-Requested-With": "XMLHttpRequest"
    };
    const newsletterMutation = getNewsletterMutation();
    if (newsletterMutation) {
      const request3 = `
      mutation {
        ${newsletterMutation}
      }
    `;
      await graphQlRequest(request3);
    }
    return authenticatedRequest().post(buildCartUrl("payment-information"), {
      ...payment,
      "g-recaptcha-response": tokens.placeOrder
    }, { headers }).then((response) => response.data);
  };
  const _sfc_main$V = {
    name: "BraintreeGooglePay",
    data() {
      return {
        googlePayNoShippingMethods: "",
        instance: null,
        googleClient: null,
        googlePaymentInstance: null,
        googlePayLoaded: false,
        key: "braintreeGooglePay"
      };
    },
    computed: {
      ...mapState(useBraintreeStore, [
        "environment",
        "clientToken",
        "google",
        "threeDSEnabled",
        "threeDSThresholdAmount",
        "alwaysRequestThreeDS"
      ]),
      ...mapState(useCartStore, ["cart", "cartGrandTotal"]),
      ...mapState(useShippingMethodsStore, ["selectedMethod"]),
      ...mapState(useConfigStore, [
        "currencyCode",
        "locale",
        "countryCode",
        "countries",
        "getRegionId",
        "storeCode"
      ]),
      ...mapState(usePaymentStore, ["availableMethods"])
    },
    async created() {
      this.addExpressMethod(this.key);
      await this.getInitialConfig();
      await this.getCart();
      const googlePayConfig = this.availableMethods.find((method) => method.code === "braintree_googlepay");
      if (!googlePayConfig) {
        this.removeExpressMethod(this.key);
        this.googlePayLoaded = true;
        return;
      }
      await this.createClientToken();
      if (!this.clientToken) {
        this.removeExpressMethod(this.key);
        this.googlePayLoaded = true;
        return;
      }
      this.googleClient = markRaw(new window.google.payments.api.PaymentsClient({
        environment: this.environment === "sandbox" ? "TEST" : "LIVE",
        paymentDataCallbacks: {
          ...this.cart.is_virtual ? {} : { onPaymentDataChanged: this.onPaymentDataChanged },
          onPaymentAuthorized: this.onPaymentAuthorized
        }
      }));
      this.instance = await markRaw(braintree.client.create({
        authorization: this.clientToken
      }));
      braintree.googlePayment.create({
        client: this.instance,
        googlePayVersion: 2
      }, (error, googlePaymentInstance) => {
        this.googlePaymentInstance = markRaw(googlePaymentInstance);
        this.googleClient.isReadyToPay({
          apiVersion: 2,
          apiVersionMinor: 0,
          allowedPaymentMethods: googlePaymentInstance.createPaymentDataRequest().allowedPaymentMethods,
          existingPaymentMethodRequired: true
        }).then((isReadyToPay) => {
          if (isReadyToPay) {
            const button = this.googleClient.createButton({
              buttonColor: this.google.buttonColor,
              buttonType: "buy",
              buttonSizeMode: "fill",
              onClick: () => this.onClick()
            });
            this.$refs.braintreeGooglePay.append(button);
          }
        });
      });
    },
    mounted() {
      const googlePayScript = document.createElement("script");
      googlePayScript.setAttribute("src", "https://pay.google.com/gp/p/js/pay.js");
      document.head.appendChild(googlePayScript);
    },
    methods: {
      ...mapActions(useAgreementStore, ["validateAgreements"]),
      ...mapActions(useBraintreeStore, ["createClientToken"]),
      ...mapActions(useLoadingStore, ["setLoadingState"]),
      ...mapActions(useShippingMethodsStore, ["submitShippingInfo"]),
      ...mapActions(usePaymentStore, [
        "addExpressMethod",
        "removeExpressMethod",
        "setErrorMessage"
      ]),
      ...mapActions(useCartStore, ["getCart"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useCustomerStore, ["submitEmail"]),
      onClick() {
      },
      getGooglePayMethod(paymentMethodsResponse) {
        return paymentMethodsResponse.paymentMethods.find(({ type }) => type === "paywithgoogle" || "googlepay");
      },
      onPaymentDataChanged(data2) {
        return new Promise((resolve2) => {
          const address = {
            city: data2.shippingAddress.locality,
            country_code: data2.shippingAddress.countryCode,
            postcode: data2.shippingAddress.postalCode,
            region: data2.shippingAddress.administrativeArea,
            region_id: this.getRegionId(data2.shippingAddress.countryCode, data2.shippingAddress.administrativeArea),
            street: ["0"],
            telephone: "000000000",
            firstname: "UNKNOWN",
            lastname: "UNKNOWN"
          };
          getShippingMethods(address).then(async (response) => {
            const shippingMethods2 = response.map((shippingMethod) => {
              const description = shippingMethod.carrier_title ? `${formatPrice(shippingMethod.price_incl_tax.value)} ${shippingMethod.carrier_title}` : formatPrice(shippingMethod.price_incl_tax.value);
              return {
                id: shippingMethod.method_code,
                label: shippingMethod.method_title,
                description
              };
            });
            const fShippingMethods = shippingMethods2.filter((sid) => sid.id !== "nominated_delivery");
            if (!fShippingMethods.length) {
              resolve2({
                error: {
                  reason: "SHIPPING_ADDRESS_UNSERVICEABLE",
                  message: this.$t("errorMessages.googlePayNoShippingMethods"),
                  intent: "SHIPPING_ADDRESS"
                }
              });
              return;
            }
            const selectedShipping = data2.shippingOptionData.id === "shipping_option_unselected" ? shippingMethods2[0] : shippingMethods2.find(({ method_code: id }) => id === data2.shippingOptionData.id) || shippingMethods2[0];
            await this.submitShippingInfo(selectedShipping.carrier_code, selectedShipping.method_code);
            this.setLoadingState(true);
            const paymentDataRequestUpdate = {
              newShippingOptionParameters: {
                defaultSelectedOptionId: selectedShipping.method_code,
                shippingOptions: fShippingMethods
              },
              newTransactionInfo: {
                displayItems: [
                  {
                    label: "Shipping",
                    type: "LINE_ITEM",
                    price: this.cart.shipping_addresses[0].selected_shipping_method.amount.value.toString(),
                    status: "FINAL"
                  }
                ],
                currencyCode: this.cart.prices.grand_total.currency,
                totalPriceStatus: "FINAL",
                totalPrice: this.cart.prices.grand_total.value.toString(),
                totalPriceLabel: "Total",
                countryCode: this.countryCode
              }
            };
            resolve2(paymentDataRequestUpdate);
          });
        });
      },
      onPaymentAuthorized(data2) {
        return new Promise((resolve2) => {
          var _a, _b, _c;
          if (!this.cart.is_virtual && !this.cart.shipping_addresses[0].selected_shipping_method) {
            resolve2({
              error: {
                reason: "SHIPPING_OPTION_INVALID",
                message: "No shipping method selected",
                intent: "SHIPPING_OPTION"
              }
            });
            return;
          }
          const { androidPayCards } = JSON.parse(data2.paymentMethodData.tokenizationData.token);
          if (!((_a = androidPayCards == null ? void 0 : androidPayCards[0]) == null ? void 0 : _a.nonce) || !((_c = (_b = androidPayCards == null ? void 0 : androidPayCards[0]) == null ? void 0 : _b.details) == null ? void 0 : _c.bin)) {
            resolve2({
              error: {
                reason: "SHIPPING_OPTION_INVALID",
                message: "Unable to validate payment. Please try again with another payment method.",
                intent: "SHIPPING_OPTION"
              }
            });
            return;
          }
          const { email } = data2;
          const { billingAddress } = data2.paymentMethodData.info;
          const { phoneNumber } = billingAddress;
          const mapBillingAddress = this.mapAddress(billingAddress, email, phoneNumber);
          let mapShippingAddress = null;
          if (!this.cart.is_virtual) {
            const { shippingAddress } = data2;
            const { phoneNumber: shippingPhoneNumber } = shippingAddress;
            mapShippingAddress = this.mapAddress(shippingAddress, email, shippingPhoneNumber);
          }
          try {
            setAddressesOnCart(mapShippingAddress, mapBillingAddress, email).then(() => {
              resolve2({
                transactionState: "SUCCESS"
              });
            });
          } catch (error) {
            resolve2({
              error: {
                reason: "PAYMENT_DATA_INVALID",
                message: error.message,
                intent: "PAYMENT_AUTHORIZATION"
              }
            });
          }
        });
      },
      async handleThreeDs(response) {
        this.setLoadingState(true);
        const billingAddress = this.mapAddress(response.paymentMethodData.info.billingAddress, response.email, response.paymentMethodData.info.billingAddress.phoneNumber);
        billingAddress.region = billingAddress.region.region_code || billingAddress.region.region;
        const { email } = response;
        const { androidPayCards } = JSON.parse(response.paymentMethodData.tokenizationData.token);
        if (!this.threeDSEnabled) {
          return Promise.resolve({
            nonce: androidPayCards[0].nonce,
            billingAddress,
            email
          });
        }
        const threeDSecureInstance = await braintree.threeDSecure.create({
          version: 2,
          client: this.instance
        });
        return new Promise((resolve2, reject) => {
          billingAddress.countryCodeAlpha2 = billingAddress.country_code;
          const price = this.cartGrandTotal / 100;
          const threshold = this.threeDSThresholdAmount;
          const challengeRequested = this.alwaysRequestThreeDS || price >= threshold;
          const threeDSecureParameters = {
            amount: parseFloat(this.cartGrandTotal / 100).toFixed(2),
            nonce: androidPayCards[0].nonce,
            bin: androidPayCards[0].details.bin,
            challengeRequested,
            billingAddress,
            onLookupComplete: (lookupData, next) => {
              next();
            }
          };
          threeDSecureInstance.verifyCard(threeDSecureParameters, (err, threeDSResponse) => {
            if (err) {
              if (err.code === "THREEDS_LOOKUP_VALIDATION_ERROR") {
                const errorMessage = err.details.originalError.details.originalError.error.message;
                const message = "Please update the address and try again.";
                if (errorMessage === "Billing line1 format is invalid." && billingAddress.street[0].length > 50) {
                  return reject(new Error(`Billing line1 must be string and less than 50 characters. ${message}`));
                }
                if (errorMessage === "Billing line2 format is invalid." && billingAddress.street[1].length > 50) {
                  return reject(new Error(`Billing line2 must be string and less than 50 characters. ${message}`));
                }
              }
              return reject(err);
            }
            const liability = {
              shifted: threeDSResponse.liabilityShifted,
              shiftPossible: threeDSResponse.liabilityShiftPossible
            };
            if (liability.shifted || !liability.shifted && !liability.shiftPossible) {
              delete billingAddress.countryCodeAlpha2;
              resolve2({
                nonce: threeDSResponse.nonce,
                billingAddress,
                email
              });
            } else {
              reject(new Error("Please try again with another form of payment."));
            }
            return true;
          });
        });
      },
      makePayment(response) {
        const payment = {
          email: response.email,
          paymentMethod: {
            method: "braintree_googlepay",
            additional_data: {
              payment_method_nonce: response.nonce
            },
            extension_attributes: getPaymentExtensionAttributes()
          }
        };
        return createPayment$1(payment);
      },
      mapAddress(address, email, telephone) {
        const [firstname, ...lastname] = address.name.split(" ");
        const regionId = this.getRegionId(address.countryCode, address.administrativeArea);
        return {
          street: [
            address.address1,
            address.address2
          ],
          postcode: address.postalCode,
          country_code: address.countryCode,
          company: address.company || "",
          email,
          firstname,
          lastname: lastname.length ? lastname.join(" ") : "UNKNOWN",
          city: address.locality,
          telephone,
          region: {
            ...address.administrativeArea ? { region: address.administrativeArea } : {},
            ...regionId ? { region_id: regionId } : {}
          }
        };
      }
    }
  };
  function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", {
      id: "braintree-google-pay",
      ref: "braintreeGooglePay",
      class: normalizeClass(!$data.googlePayLoaded ? "text-loading" : "")
    }, null, 2);
  }
  var BraintreeGooglePay = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$V]]);
  var getSuccessPageUrl = () => {
    const { secureBaseLinkUrl } = useConfigStore();
    return `${secureBaseLinkUrl}checkout/onepage/success`;
  };
  const _sfc_main$U = {
    name: "BraintreeApplePay",
    data() {
      return {
        applePayTotal: "",
        applePayAvailable: false,
        instance: null,
        applePayInstance: null,
        dataCollectorInstance: null,
        applePayLoaded: true,
        shippingMethods: [],
        key: "braintreeApplePay"
      };
    },
    computed: {
      ...mapState(useBraintreeStore, ["clientToken"]),
      ...mapState(useCartStore, ["cart", "cartGrandTotal", "cartDiscountTotal"]),
      ...mapState(useShippingMethodsStore, ["selectedMethod"]),
      ...mapState(useConfigStore, [
        "currencyCode",
        "locale",
        "countryCode",
        "websiteName",
        "countries",
        "getRegionId",
        "storeCode"
      ]),
      ...mapState(usePaymentStore, ["availableMethods"])
    },
    async created() {
      if (window.ApplePaySession && window.ApplePaySession.canMakePayments) {
        this.applePayAvailable = true;
        this.applePayLoaded = false;
      } else {
        return;
      }
      this.addExpressMethod(this.key);
      await this.getInitialConfig();
      await this.getCart();
      const applePayConfig = this.availableMethods.find((method) => method.code === "braintree_applepay");
      if (!applePayConfig) {
        this.applePayLoaded = true;
        this.removeExpressMethod(this.key);
        return;
      }
      await this.createClientToken();
      this.instance = await markRaw(braintree.client.create({
        authorization: this.clientToken
      }));
      this.applePayTotal = this.websiteName;
      braintree.applePay.create({
        client: this.instance
      }, (error, applePayInstance) => {
        window.ApplePaySession.canMakePaymentsWithActiveCard(applePayInstance.merchantIdentifier).then(() => {
          this.applePayInstance = markRaw(applePayInstance);
          this.applePayLoaded = true;
        });
      });
      braintree.dataCollector.create({
        client: this.instance
      }, (error, dataCollectorInstance) => {
        this.dataCollectorInstance = markRaw(dataCollectorInstance);
      });
    },
    methods: {
      ...mapActions(useAgreementStore, ["validateAgreements"]),
      ...mapActions(useShippingMethodsStore, ["selectShippingMethod", "submitShippingInfo"]),
      ...mapActions(usePaymentStore, [
        "addExpressMethod",
        "removeExpressMethod",
        "setErrorMessage"
      ]),
      ...mapActions(useCartStore, ["getCart"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useCustomerStore, ["submitEmail", "setAddressToStore", "validatePostcode"]),
      ...mapActions(useBraintreeStore, ["createClientToken"]),
      ...mapActions(useRecaptchaStore, ["validateToken"]),
      click(event) {
        event.preventDefault();
      },
      onValidateMerchant(event, session) {
        return this.applePayInstance.performValidation({
          validationURL: event.validationURL,
          displayName: this.websiteName
        }, (validationErr, merchantSession) => {
          if (validationErr) {
            session.abort();
            console.error("Braintree ApplePay Error validating merchant:", validationErr);
            this.setApplePayError();
            return;
          }
          session.completeMerchantValidation(merchantSession);
        });
      },
      getApplePayMethod(paymentMethodsResponse) {
        return paymentMethodsResponse.paymentMethods.find(({ type }) => type === "applepay");
      },
      async onAuthorized(data2, session) {
        const { shippingContact, billingContact } = data2.payment;
        const email = shippingContact.emailAddress;
        const telephone = shippingContact.phoneNumber;
        const billingAddress = this.mapAddress(billingContact, email, telephone);
        let shippingAddress = null;
        if (!this.cart.is_virtual) {
          shippingAddress = this.mapAddress(shippingContact, email, telephone);
        }
        if (!this.countries.some(({ id }) => id === billingAddress.country_code)) {
          session.completePayment(window.ApplePaySession.STATUS_FAILURE);
          return;
        }
        this.applePayInstance.tokenize({
          token: data2.payment.token
        }, async (tokenizeErr, payload) => {
          if (tokenizeErr) {
            console.error("Error tokenizing Apple Pay:", tokenizeErr);
            session.completePayment(window.ApplePaySession.STATUS_FAILURE);
            return;
          }
          try {
            setAddressesOnCart(shippingAddress, billingAddress, email).then(() => {
              const payment = {
                email,
                paymentMethod: {
                  method: "braintree_applepay",
                  additional_data: {
                    payment_method_nonce: payload.nonce,
                    device_data: this.dataCollectorInstance.deviceData
                  },
                  extension_attributes: getPaymentExtensionAttributes()
                }
              };
              return createPayment$1(payment);
            }).then(async () => {
              session.completePayment(window.ApplePaySession.STATUS_SUCCESS);
              await refreshCustomerData(getCartSectionNames());
              window.location.href = getSuccessPageUrl();
            });
          } catch (error) {
            console.log(error);
            session.completePayment(window.ApplePaySession.STATUS_FAILURE);
          }
        });
      },
      async onShippingContactSelect(data2, session) {
        const address = {
          city: data2.shippingContact.locality,
          region: data2.shippingContact.administrativeArea,
          region_id: this.getRegionId(data2.shippingContact.countryCode, data2.shippingContact.administrativeArea),
          country_code: data2.shippingContact.countryCode.toUpperCase(),
          postcode: data2.shippingContact.postalCode,
          street: ["0"],
          telephone: "000000000",
          firstname: "UNKNOWN",
          lastname: "UNKNOWN"
        };
        this.address = address;
        const result = await getShippingMethods(address);
        const filteredMethods = result.filter(({ method_code: methodCode }) => methodCode !== "nominated_delivery");
        this.shippingMethods = filteredMethods;
        if (!filteredMethods.length) {
          const errors = {
            errors: [
              new window.ApplePayError("addressUnserviceable", "postalAddress", this.applePayNoShippingMethods)
            ],
            newTotal: {
              label: this.websiteName,
              amount: "0.00",
              type: "pending"
            }
          };
          session.completeShippingContactSelection(errors);
          return;
        }
        const selectedShipping = filteredMethods[0];
        await this.submitShippingInfo(selectedShipping.carrier_code, selectedShipping.method_code);
        const newShippingMethods = this.mapShippingMethods(filteredMethods);
        const applePayShippingContactUpdate = {
          newShippingMethods,
          newTotal: {
            label: this.applePayTotal,
            amount: parseFloat(this.cartGrandTotal / 100).toFixed(2)
          },
          newLineItems: [
            {
              type: "final",
              label: "Subtotal",
              amount: this.cart.prices.subtotal_including_tax.value.toString()
            },
            {
              type: "final",
              label: "Shipping",
              amount: selectedShipping.amount.value.toString()
            }
          ]
        };
        if (this.cartDiscountTotal) {
          applePayShippingContactUpdate.newLineItems.push({
            type: "final",
            label: "Discount",
            amount: this.cartDiscountTotal.toString()
          });
        }
        session.completeShippingContactSelection(applePayShippingContactUpdate);
      },
      async onShippingMethodSelect(data2, session) {
        const selectedShipping = this.shippingMethods.find(({ method_code: id }) => id === data2.shippingMethod.identifier);
        await this.submitShippingInfo(selectedShipping.carrier_code, selectedShipping.method_code);
        const applePayShippingContactUpdate = {
          newTotal: {
            label: this.applePayTotal,
            amount: parseFloat(this.cartGrandTotal / 100).toFixed(2)
          },
          newLineItems: [
            {
              type: "final",
              label: "Subtotal",
              amount: this.cart.prices.subtotal_including_tax.value.toString()
            },
            {
              type: "final",
              label: "Shipping",
              amount: selectedShipping.amount.value.toString()
            }
          ]
        };
        if (this.cartDiscountTotal) {
          applePayShippingContactUpdate.newLineItems.push({
            type: "final",
            label: "Discount",
            amount: this.cartDiscountTotal.toString()
          });
        }
        session.completeShippingMethodSelection(applePayShippingContactUpdate);
      },
      mapShippingMethods(shippingMethods2) {
        return shippingMethods2.map((shippingMethod) => ({
          label: shippingMethod.method_title,
          detail: shippingMethod.carrier_title || "",
          amount: shippingMethod.amount.value.toString(),
          identifier: shippingMethod.method_code,
          carrierCode: shippingMethod.carrier_code
        }));
      },
      mapAddress(address, email, telephone) {
        const regionId = this.getRegionId(address.countryCode.toUpperCase(), address.administrativeArea);
        return {
          email,
          telephone,
          firstname: address.givenName,
          lastname: address.familyName,
          company: address.company || "",
          street: address.addressLines,
          city: address.locality,
          country_code: address.countryCode.toUpperCase(),
          postcode: address.postalCode,
          region: {
            ...address.administrativeArea ? { region: address.administrativeArea } : {},
            ...regionId ? { region_id: regionId } : {}
          }
        };
      },
      setApplePayError() {
        this.setErrorMessage("We're unable to take payments through Apple Pay at the moment. Please try an alternative payment method.");
      }
    }
  };
  function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
    return $data.applePayAvailable ? (openBlock(), createElementBlock("div", {
      key: 0,
      id: "braintree-apple-pay",
      class: normalizeClass(!$data.applePayLoaded ? "text-loading" : "braintree-apple-pay"),
      onKeydown: _cache[0] || (_cache[0] = withKeys((...args) => $options.click && $options.click(...args), ["enter"])),
      onClick: _cache[1] || (_cache[1] = (...args) => $options.click && $options.click(...args))
    }, null, 34)) : createCommentVNode("", true);
  }
  var BraintreeApplePay = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$U]]);
  const _sfc_main$T = {
    name: "BraintreePayPal",
    props: {
      isCredit: {
        type: Boolean
      }
    },
    data() {
      return {
        googlePayNoShippingMethods: "",
        instance: null,
        googleClient: null,
        paypalInstance: null,
        paypalLoaded: false,
        key: "braintreePayPal",
        namespace: "paypal"
      };
    },
    computed: {
      ...mapState(useBraintreeStore, ["clientToken", "environment", "paypal"]),
      ...mapState(useCartStore, ["cart", "cartGrandTotal"]),
      ...mapState(useShippingMethodsStore, ["selectedMethod"]),
      ...mapState(useConfigStore, [
        "currencyCode",
        "locale",
        "countryCode",
        "countries",
        "getRegionId",
        "storeCode"
      ]),
      ...mapState(usePaymentStore, ["availableMethods"])
    },
    async created() {
      this.addExpressMethod(this.key);
      await this.getInitialConfig();
      await this.getCart();
      const paypalConfig = this.availableMethods.find((method) => method.code === "braintree_paypal");
      if (!paypalConfig) {
        this.paypalLoaded = true;
        this.removeExpressMethod(this.key);
        return;
      }
      await this.createClientToken();
      if (!this.clientToken) {
        this.$emit("expressPaymentsLoad", "false");
        this.paypalLoaded = true;
        return;
      }
      this.instance = await markRaw(braintree.client.create({
        authorization: this.clientToken
      }));
      braintree.paypalCheckout.create({
        client: this.instance
      }, (error, paypalInstance) => {
        if (!this.$refs.braintreePayPal) {
          paypalInstance.teardown();
          this.removeExpressMethod(this.key);
          return;
        }
        this.paypalInstance = markRaw(paypalInstance);
        this.namespace = `${this.namespace}${this.isCredit ? "_credit" : ""}`;
        const sdkConfig = {
          currency: this.currencyCode,
          intent: "capture",
          vault: "false",
          dataAttributes: {
            namespace: this.namespace
          }
        };
        if (this.isCredit) {
          sdkConfig["enable-funding"] = "credit";
        }
        if (this.environment === "sandbox") {
          sdkConfig["buyer-country"] = this.countryCode;
        }
        paypalInstance.loadPayPalSDK(sdkConfig, () => {
          const renderData = {
            env: this.environment,
            commit: true,
            style: {
              label: this.paypal.buttonLabel,
              size: "responsive",
              shape: this.paypal.buttonShape,
              color: this.paypal.buttonColor,
              tagline: false
            },
            fundingSource: window[this.namespace].FUNDING.PAYPAL,
            offerCredit: false,
            createOrder: () => paypalInstance.createPayment({
              amount: this.cartGrandTotal / 100,
              flow: "checkout",
              currency: this.currencyCode,
              enableShippingAddress: !this.cart.is_virtual,
              locale: this.locale,
              intent: "capture",
              lineItems: this.getPayPalLineItems(),
              shippingOptions: []
            }),
            onClick: () => {
              this.setErrorMessage("");
              const agreementsValid = this.validateAgreements();
              const recaptchaValid = this.validateToken("placeOrder");
              if (!agreementsValid || !recaptchaValid) {
                return false;
              }
              return true;
            },
            onShippingChange: async (data2) => {
              const address = {
                city: data2.shipping_address.city,
                country_code: data2.shipping_address.country_code,
                postcode: data2.shipping_address.postal_code,
                region: data2.shipping_address.state,
                region_id: this.getRegionId(data2.shipping_address.country_code, data2.shipping_address.state),
                street: ["0"],
                telephone: "000000000",
                firstname: "UNKNOWN",
                lastname: "UNKNOWN"
              };
              const result = await getShippingMethods(address);
              const methods = result.shipping_addresses[0].available_shipping_methods;
              const fShippingMethods = methods.filter((sid) => sid.id !== "nominated_delivery");
              const selectedShipping = !data2.selected_shipping_option ? fShippingMethods[0] : fShippingMethods.find(({ method_code: id }) => id === data2.selected_shipping_option.id) || fShippingMethods[0];
              await this.submitShippingInfo(selectedShipping.carrier_code, selectedShipping.method_code);
              const shippingOptions = fShippingMethods.map((method) => ({
                id: method.method_code,
                label: method.method_title,
                type: "SHIPPING",
                selected: selectedShipping.method_code === method.method_code,
                amount: {
                  value: method.amount.value.toString(),
                  currency: this.currencyCode
                }
              }));
              const amount = this.cartGrandTotal / 100;
              return paypalInstance.updatePayment({
                paymentId: data2.paymentId,
                amount,
                currency: this.currencyCode,
                shippingOptions,
                lineItems: this.getPayPalLineItems(false)
              });
            },
            onApprove: (data2) => paypalInstance.tokenizePayment(data2).then(this.setInformationToQuote).then(this.makePayment).then(() => refreshCustomerData(["cart"])).then(this.redirectToSuccess).catch((err) => {
              try {
                handleServiceError(err);
              } catch (formattedError) {
                this.setErrorMessage(formattedError);
              }
            }),
            onError: (err) => {
              this.setErrorMessage(err);
            }
          };
          this.paypalLoaded = true;
          if (this.paypal.creditActive && this.isCredit) {
            renderData.fundingSource = window[this.namespace].FUNDING.CREDIT;
            renderData.style.color = this.paypal.creditColor !== "gold" ? this.paypal.creditColor : "black";
            renderData.style.label = this.paypal.creditLabel;
            renderData.style.shape = this.paypal.creditShape;
          }
          return window[this.namespace].Buttons(renderData).render("#braintree-paypal");
        });
      });
    },
    methods: {
      ...mapActions(useAgreementStore, ["validateAgreements"]),
      ...mapActions(useBraintreeStore, ["createClientToken", "getPayPalLineItems"]),
      ...mapActions(useShippingMethodsStore, ["submitShippingInfo"]),
      ...mapActions(usePaymentStore, [
        "addExpressMethod",
        "removeExpressMethod",
        "setErrorMessage"
      ]),
      ...mapActions(useCartStore, ["getCart"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useCustomerStore, ["submitEmail"]),
      ...mapActions(useRecaptchaStore, ["validateToken"]),
      setInformationToQuote(payload) {
        const shippingAddress = !this.cart.is_virtual ? this.mapAddress(payload.details.shippingAddress, payload.details.email, payload.details.phone) : null;
        const billingAddress = this.mapAddress(payload.details.billingAddress, payload.details.email, payload.details.phone, payload.details.firstName, payload.details.lastName);
        return setAddressesOnCart(shippingAddress, billingAddress, payload.details.email).then(() => ({ payload, email: payload.details.email }));
      },
      makePayment({ payload, email }) {
        const payment = {
          email,
          paymentMethod: {
            method: "braintree_paypal",
            additional_data: {
              payment_method_nonce: payload.nonce
            },
            extension_attributes: getPaymentExtensionAttributes()
          }
        };
        return createPayment$1(payment);
      },
      mapAddress(address, email, telephone, billingFirstname, billingLastname) {
        const [firstname, ...lastname] = address.recipientName ? address.recipientName.split(" ") : [];
        const regionId = this.getRegionId(address.countryCode, address.state);
        return {
          street: [
            address.line1,
            address.line2 || ""
          ],
          postcode: address.postalCode,
          country_code: address.countryCode,
          company: address.company || "",
          email,
          firstname: billingFirstname || firstname,
          lastname: billingLastname || (lastname.length ? lastname.join(" ") : "UNKNOWN"),
          city: address.city,
          telephone: telephone !== void 0 ? telephone : "000000000",
          region: {
            ...address.state ? { region: address.state } : {},
            ...regionId ? { region_id: regionId } : {}
          }
        };
      },
      redirectToSuccess() {
        window.location.href = getSuccessPageUrl();
      }
    }
  };
  const _hoisted_1$P = /* @__PURE__ */ createBaseVNode("div", {
    class: /* @__PURE__ */ normalizeClass("fake-button")
  }, null, -1);
  function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", null, [
      _hoisted_1$P,
      createBaseVNode("div", {
        id: "braintree-paypal",
        ref: "braintreePayPal",
        class: normalizeClass(!$data.paypalLoaded ? "text-loading" : "ui-designer-disabled")
      }, null, 2)
    ]);
  }
  var BraintreePayPal = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$T]]);
  const _sfc_main$S = {
    name: "Checkbox",
    props: {
      id: {
        type: String,
        default: ""
      },
      dataCy: {
        type: String
      },
      text: {
        type: String
      },
      content: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      },
      checked: {
        type: Boolean,
        default: false
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      },
      fontStyle: {
        type: String
      },
      ariaChecked: {
        type: String
      },
      role: {
        type: String
      },
      changeHandler: {
        type: Function,
        default: () => {
        }
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          fontSize: reactiveProps.fontSize,
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontStyle: reactiveProps.fontStyle
        }))
      };
    }
  };
  const _hoisted_1$O = ["for"];
  const _hoisted_2$D = ["id", "disabled", "checked", "aria-checked", "role", "content", "data-cy"];
  function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("label", {
        for: "input-checkbox-" + $props.id
      }, [
        createBaseVNode("input", {
          id: "input-checkbox-" + $props.id,
          type: "checkbox",
          disabled: $props.disabled,
          checked: $props.checked,
          "aria-checked": $props.ariaChecked,
          role: $props.role,
          content: $props.content,
          "data-cy": $props.dataCy ? $props.dataCy : "checkbox",
          onChange: _cache[0] || (_cache[0] = (...args) => $props.changeHandler && $props.changeHandler(...args))
        }, null, 40, _hoisted_2$D),
        createBaseVNode("span", {
          style: normalizeStyle($setup.style)
        }, [
          createTextVNode(toDisplayString$1($props.text), 1),
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ], 4)
      ], 8, _hoisted_1$O)
    ]);
  }
  var CheckboxComponent = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$S], ["__scopeId", "data-v-4421e73e"]]);
  const _sfc_main$R = {
    name: "Modal",
    props: {
      visible: {
        type: Boolean,
        default: false
      },
      classes: {
        type: String,
        default: ""
      },
      dataCy: {
        type: String
      },
      header: {
        type: Boolean,
        default: true
      },
      footer: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      getModalClasses() {
        return `${this.classes} modal`;
      }
    },
    methods: {
      handleKeydown() {
        this.$emit("focus");
      },
      close() {
        this.$emit("close");
      },
      focus() {
        this.$emit("focus");
      }
    }
  };
  const _hoisted_1$N = ["data-cy"];
  const _hoisted_2$C = {
    key: 0,
    id: "modalTitle",
    class: "modal-header"
  };
  const _hoisted_3$x = {
    id: "modalDescription",
    class: "modal-body"
  };
  const _hoisted_4$n = {
    key: 1,
    class: "modal-footer"
  };
  function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(Transition, { name: "fade" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: "modal-backdrop",
            ref: "backdrop",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.close && $options.close(...args)),
            onKeydown: _cache[1] || (_cache[1] = (...args) => $options.focus && $options.focus(...args)),
            tabindex: "0"
          }, null, 544), [
            [vShow, $props.visible]
          ])
        ]),
        _: 1
      }),
      createVNode(Transition, {
        name: "slide",
        appear: ""
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: normalizeClass($options.getModalClasses),
            "data-cy": $props.dataCy ? $props.dataCy : "modal",
            role: "dialog",
            "aria-labelledby": "modalTitle",
            "aria-describedby": "modalDescription",
            onKeydown: _cache[2] || (_cache[2] = (...args) => $options.handleKeydown && $options.handleKeydown(...args)),
            onClick: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["stop"]))
          }, [
            $props.header ? (openBlock(), createElementBlock("header", _hoisted_2$C, [
              renderSlot(_ctx.$slots, "header", {}, void 0, true)
            ])) : createCommentVNode("", true),
            createBaseVNode("section", _hoisted_3$x, [
              renderSlot(_ctx.$slots, "body", {}, () => [
                createTextVNode(" This is the default body! ")
              ], true)
            ]),
            $props.footer ? (openBlock(), createElementBlock("footer", _hoisted_4$n, [
              renderSlot(_ctx.$slots, "footer", {}, void 0, true)
            ])) : createCommentVNode("", true)
          ], 42, _hoisted_1$N), [
            [vShow, $props.visible]
          ])
        ]),
        _: 3
      })
    ], 64);
  }
  var Modal = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$R], ["__scopeId", "data-v-55bffe12"]]);
  const _sfc_main$Q = {
    name: "Agreement",
    components: {
      TextField,
      ButtonComponent: MyButton,
      CheckboxComponent,
      ErrorMessage,
      Modal,
      CloseIcon
    },
    props: {
      agreement: {
        type: Object,
        required: true
      },
      id: {
        type: String,
        default: ""
      }
    },
    data() {
      return {
        isModalVisible: false
      };
    },
    mounted() {
      document.addEventListener("focusin", this.handleFocusIn);
    },
    methods: {
      ...mapActions(useAgreementStore, ["updateAgreementData"]),
      changeAgreement(event) {
        const { currentTarget } = event;
        if (typeof currentTarget.checked !== "undefined") {
          this.updateAgreementData(this.agreement, currentTarget.checked);
        }
      },
      handleFocusIn(event) {
        const modal = document.querySelector(".agreement-container .modal");
        if (modal && !modal.contains(event.target)) {
          this.closeModal();
        }
      },
      trapFocus(event) {
        const modal = document.querySelector(".agreement-container .modal");
        const focusableButtons = modal.querySelectorAll("button:not([disabled])");
        const firstButton = focusableButtons[0];
        if (this.isModalVisible) {
          event.preventDefault();
          firstButton.focus();
        }
      },
      changeAgreementFromModal() {
        const agreementCheckbox = document.querySelector('.agreement-checkbox input[type="checkbox"]');
        if (agreementCheckbox && !agreementCheckbox.checked) {
          this.updateAgreementData(this.agreement, true);
        }
        this.closeModal();
      },
      showModal(event) {
        event.preventDefault();
        document.body.classList.add("no-scrollable");
        this.isModalVisible = true;
        this.trapFocus(event);
      },
      closeModal() {
        document.body.classList.remove("no-scrollable");
        this.isModalVisible = false;
      }
    }
  };
  const _hoisted_1$M = { class: "agreement-container" };
  const _hoisted_2$B = { key: 0 };
  const _hoisted_3$w = ["innerHTML"];
  const _hoisted_4$m = {
    key: 1,
    class: "agreement-label"
  };
  const _hoisted_5$j = ["innerHTML"];
  const _hoisted_6$e = { class: "closer-container" };
  const _hoisted_7$b = ["innerHTML"];
  function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_CheckboxComponent = resolveComponent("CheckboxComponent");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_TextField = resolveComponent("TextField");
    const _component_CloseIcon = resolveComponent("CloseIcon");
    const _component_ButtonComponent = resolveComponent("ButtonComponent");
    const _component_modal = resolveComponent("modal");
    return openBlock(), createElementBlock("div", _hoisted_1$M, [
      $props.agreement.mode === "MANUAL" ? (openBlock(), createElementBlock("div", _hoisted_2$B, [
        createVNode(_component_CheckboxComponent, {
          class: "agreement-checkbox",
          id: `${$props.agreement.agreement_id}-${$props.id}`,
          checked: $props.agreement.approved,
          "change-handler": $options.changeAgreement
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString$1(_ctx.$t("agreements.label")) + " ", 1),
            createBaseVNode("a", {
              href: "#",
              class: "agreement-open-modal",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.showModal && $options.showModal(...args)),
              onKeydown: _cache[1] || (_cache[1] = (...args) => $options.showModal && $options.showModal(...args)),
              innerHTML: $props.agreement.checkbox_text
            }, null, 40, _hoisted_3$w)
          ]),
          _: 1
        }, 8, ["id", "checked", "change-handler"])
      ])) : (openBlock(), createElementBlock("span", _hoisted_4$m, [
        createBaseVNode("span", null, toDisplayString$1(_ctx.$t("agreements.label")), 1),
        createTextVNode("\xA0 "),
        createBaseVNode("a", {
          href: "#",
          class: "agreement-open-modal",
          onClick: _cache[2] || (_cache[2] = (...args) => $options.showModal && $options.showModal(...args)),
          onKeydown: _cache[3] || (_cache[3] = (...args) => $options.showModal && $options.showModal(...args)),
          innerHTML: $props.agreement.checkbox_text
        }, null, 40, _hoisted_5$j),
        typeof $props.agreement.valid !== "undefined" && !$props.agreement.valid ? (openBlock(), createBlock(_component_ErrorMessage, {
          key: 0,
          message: _ctx.$t("agreements.errorMessage")
        }, null, 8, ["message"])) : createCommentVNode("", true)
      ])),
      createVNode(_component_modal, {
        visible: $data.isModalVisible,
        onClose: $options.closeModal
      }, {
        header: withCtx(() => [
          createBaseVNode("div", _hoisted_6$e, [
            createVNode(_component_TextField, {
              class: "modal-header-title",
              text: _ctx.$t("agreements.title")
            }, null, 8, ["text"]),
            createBaseVNode("button", {
              type: "button",
              class: "button button--blank agreement-close",
              "aria-label": "Close",
              onClick: _cache[4] || (_cache[4] = (...args) => $options.closeModal && $options.closeModal(...args))
            }, [
              createVNode(_component_CloseIcon)
            ])
          ])
        ]),
        body: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("p", {
              innerHTML: $props.agreement.content
            }, null, 8, _hoisted_7$b)
          ])
        ]),
        footer: withCtx(() => [
          createVNode(_component_ButtonComponent, {
            class: "modal-footer-btn-close button--secondary",
            label: _ctx.$t("orderSummary.backBtn"),
            "aria-label": _ctx.$t("orderSummary.backBtn"),
            onClick: $options.closeModal
          }, null, 8, ["label", "aria-label", "onClick"]),
          createVNode(_component_ButtonComponent, {
            class: "modal-footer-btn-close button--primary",
            label: _ctx.$t("agreements.acceptBtn"),
            "aria-label": _ctx.$t("agreements.acceptBtn"),
            onClick: $options.changeAgreementFromModal
          }, null, 8, ["label", "aria-label", "onClick"])
        ]),
        _: 1
      }, 8, ["visible", "onClose"])
    ]);
  }
  var Agreement = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$Q]]);
  const _sfc_main$P = {
    name: "Agreements",
    components: {
      Agreement,
      ErrorMessage
    },
    props: {
      id: {
        type: String,
        default: ""
      }
    },
    computed: {
      ...mapState(useAgreementStore, ["agreements", "showError"])
    },
    created() {
      this.getInitialConfig();
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"])
    }
  };
  const _hoisted_1$L = {
    key: 0,
    class: "agreements-container"
  };
  function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Agreement = resolveComponent("Agreement");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    return Object.keys(_ctx.agreements).length ? (openBlock(), createElementBlock("div", _hoisted_1$L, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.agreements, (agreement) => {
        return openBlock(), createBlock(_component_Agreement, {
          id: $props.id,
          key: agreement.agreement_id,
          agreement
        }, null, 8, ["id", "agreement"]);
      }), 128)),
      _ctx.showError ? (openBlock(), createBlock(_component_ErrorMessage, {
        key: 0,
        message: _ctx.$t("agreements.paymentErrorMessage"),
        attached: false,
        margin: false
      }, null, 8, ["message"])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true);
  }
  var Agreements = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$P]]);
  var continueToDeliveryDataLayer = () => {
    const gtmStore = useGtmStore();
    gtmStore.trackGtmEvent({
      event: "continueToDelivery"
    });
  };
  const _sfc_main$O = {
    name: "SignInComponent",
    components: {
      TextField,
      PayWith,
      DividerComponent,
      EmailAddress,
      BraintreeGooglePay,
      BraintreeApplePay,
      BraintreePayPal,
      ErrorMessage,
      Loader,
      Recaptcha,
      Agreements
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    data() {
      return {
        isAddressBlockVisible: true,
        isSavedAddressSelected: false,
        savedAddressID: null,
        customerInfoValidation: false,
        billingInfoValidation: false,
        addressFormErrorMessage: false,
        storedKey: 0,
        instantCheckoutText: "",
        instantCheckoutTextId: "bluefinch-checkout-instantcheckout-text",
        proceedToPayText: "",
        proceedToPayTextId: "bluefinch-checkout-proceedtopay-text",
        buttonEnabled: false,
        addressInfoWrong: false
      };
    },
    computed: {
      ...mapState(useCartStore, ["cart", "cartEmitter", "subtotalInclTax"]),
      ...mapState(useConfigStore, ["addressFinder", "custom", "storeCode"]),
      ...mapState(useCustomerStore, [
        "inputsSanitiseError",
        "customer",
        "isLoggedIn",
        "emailEntered",
        "selected",
        "isUsingSavedShippingAddress"
      ]),
      ...mapState(useShippingMethodsStore, ["isClickAndCollect", "loadingShippingMethods"]),
      ...mapState(usePaymentStore, ["errorMessage", "isExpressPaymentsVisible"])
    },
    created() {
      this.cartEmitter.on("cartUpdated", async () => {
        this.storedKey += 1;
      });
      const customerStore = useCustomerStore();
      customerStore.$subscribe((mutation) => {
        if (mutation.type === "direct" || mutation.type === "patch object" && mutation.payload.selected && mutation.payload.selected[this.address_type]) {
          this.updateButtonState();
        }
      }, { flush: "sync" });
      this.updateButtonState();
    },
    async mounted() {
      var _a, _b;
      await this.getInitialConfig();
      await this.getCart();
      const types = {
        shipping: "customerInfoValidation",
        billing: "billingInfoValidation"
      };
      this.instantCheckoutText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.instantCheckoutTextId]) || this.$t("instantCheckout");
      this.proceedToPayText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.proceedToPayTextId]) || this.$t("shippingStep.proceedToPay");
      Object.keys(types).forEach((type) => {
        const first = this.validateNameField(type, "First name", this.selected[type].firstname);
        const last = this.validateNameField(type, "Last name", this.selected[type].lastname);
        const phone = this.validatePhone(type, this.selected[type].telephone);
        this[types[type]] = first && last && phone;
      });
      document.addEventListener(this.instantCheckoutTextId, this.setInstantCheckoutTextId);
      document.addEventListener(this.proceedToPayTextId, this.setProceedToPayTextId);
    },
    unmounted() {
      document.removeEventListener(this.instantCheckoutTextId, this.setInstantCheckoutTextId);
      document.removeEventListener(this.proceedToPayTextId, this.setProceedToPayTextId);
    },
    methods: {
      ...mapActions(useCartStore, ["getCart"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useCustomerStore, [
        "setAddressAsCustom",
        "setAddressAsEditing",
        "validateAddress",
        "addAddressError",
        "validateNameField",
        "validatePhone",
        "validatePostcode",
        "setAddressToStore"
      ]),
      ...mapActions(useShippingMethodsStore, [
        "clearShippingMethodCache",
        "setClickAndCollect",
        "setNotClickAndCollect",
        "setAddressesOnCart"
      ]),
      ...mapActions(useStepsStore, ["goToShipping", "goToPayment"]),
      updateButtonState() {
        const addressType = this.address_type;
        const areNamesValid = this.validateNameField(addressType, "First name", this.selected[addressType].firstname) && this.validateNameField(addressType, "Last name", this.selected[addressType].lastname) && this.validatePhone(addressType, this.selected[addressType].telephone);
        const validAddress = this.validateAddress(addressType);
        const validPostcode = this.validatePostcode(this.address_type);
        this.buttonEnabled = !this.inputsSanitiseError && validAddress && validPostcode && areNamesValid;
      },
      async submitShippingOption() {
        this.requiredErrorMessage = "";
        const isValid = this.validateAddress(this.address_type, true) && this.validatePostcode(this.address_type, true);
        if (isValid) {
          if (this.savedAddressID === null || this.selected[this.address_type].id === null) {
            this.setAddressAsCustom(this.address_type);
          }
          this.setAddressAsEditing(this.address_type, false);
          if (this.selected.billing.same_as_shipping) {
            const clonedAddress = deepClone(this.selected.shipping);
            this.setAddressToStore(clonedAddress, "billing");
          }
          await this.setAddressesOnCart();
          this.goToShipping();
          continueToDeliveryDataLayer();
        } else {
          const fieldErrors = this.selected.formErrors[this.address_type];
          Object.entries(fieldErrors).forEach(([value]) => {
            this.addAddressError(this.address_type, value);
          });
          this.requiredErrorMessage = this.selected.formErrors.message[this.address_type];
          this.addressInfoWrong = true;
        }
      },
      async submitBillingInfo() {
        await this.setAddressesOnCart();
        this.goToPayment();
      },
      editAddress() {
        this.setAddressAsEditing(this.address_type, true);
        this.setAddressAsCustom(this.address_type);
      },
      showAddressBlock(value) {
        this.isAddressBlockVisible = value;
      },
      passSelectedItemId(value) {
        this.savedAddressID = value;
        if (value !== null) {
          this.buttonEnabled = true;
        }
      },
      selectedSavedAddress(value) {
        this.isSavedAddressSelected = value;
      },
      isCustomerInfoFull(value) {
        this.customerInfoValidation = value;
      },
      billingInfoFull(value) {
        this.billingInfoValidation = value;
      },
      formatPrice(price) {
        return formatPrice(price);
      },
      setInstantCheckoutTextId(event) {
        var _a;
        this.instantCheckoutText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("instantCheckout");
      },
      setProceedToPayTextId(event) {
        var _a;
        this.proceedToPayText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("shippingStep.proceedToPay");
      }
    }
  };
  const _hoisted_1$K = { class: "details-form" };
  const _hoisted_2$A = { class: "details-form-header" };
  const _hoisted_3$v = { class: "instantCheckout-block" };
  const _hoisted_4$l = { class: "instant-payment-buttons" };
  const _hoisted_5$i = { class: "details-form-body" };
  function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loader = resolveComponent("Loader");
    const _component_TextField = resolveComponent("TextField");
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_Agreements = resolveComponent("Agreements");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_BraintreeGooglePay = resolveComponent("BraintreeGooglePay");
    const _component_BraintreeApplePay = resolveComponent("BraintreeApplePay");
    const _component_BraintreePayPal = resolveComponent("BraintreePayPal");
    const _component_DividerComponent = resolveComponent("DividerComponent");
    const _component_PayWith = resolveComponent("PayWith");
    const _component_EmailAddress = resolveComponent("EmailAddress");
    return openBlock(), createElementBlock(Fragment, null, [
      _ctx.loadingShippingMethods ? (openBlock(), createBlock(_component_Loader, { key: 0 })) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_1$K, [
        withDirectives(createBaseVNode("div", _hoisted_2$A, [
          createBaseVNode("div", _hoisted_3$v, [
            createVNode(_component_TextField, { text: $data.instantCheckoutText }, null, 8, ["text"])
          ]),
          createVNode(_component_Recaptcha, {
            id: "placeOrder",
            location: "expressPayments"
          }),
          createVNode(_component_Agreements, { id: "SignInPage" }),
          createBaseVNode("div", _hoisted_4$l, [
            _ctx.errorMessage !== "" ? (openBlock(), createBlock(_component_ErrorMessage, {
              key: 0,
              message: _ctx.errorMessage,
              attached: false
            }, null, 8, ["message"])) : createCommentVNode("", true),
            (openBlock(), createBlock(_component_BraintreeGooglePay, {
              key: `braintreeGooglePay-${$data.storedKey}`
            })),
            (openBlock(), createBlock(_component_BraintreeApplePay, {
              key: `braintreeApplePay-${$data.storedKey}`
            })),
            (openBlock(), createBlock(_component_BraintreePayPal, {
              key: `braintreePayPal-${$data.storedKey}`
            }))
          ])
        ], 512), [
          [vShow, _ctx.isExpressPaymentsVisible]
        ]),
        createBaseVNode("div", _hoisted_5$i, [
          createVNode(_component_DividerComponent),
          createVNode(_component_PayWith),
          createVNode(_component_EmailAddress)
        ])
      ])
    ], 64);
  }
  var SignInPage = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$O], ["__scopeId", "data-v-0c182da9"]]);
  var deliverySvg = "/delivery.svg";
  const _sfc_main$N = {
    name: "Locate",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      deliverySvgIcon() {
        return `${getStaticUrl(deliverySvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$J = ["src", "alt"];
  function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.deliverySvgIcon,
      alt: $options.deliverySvgIcon
    }, null, 8, _hoisted_1$J);
  }
  var Locate = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$N]]);
  var detailsIconSvg = "/detailsIcon.svg";
  const _sfc_main$M = {
    name: "YourDetails",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      detailsIconSvg() {
        return `${getStaticUrl(detailsIconSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$I = ["src", "alt"];
  function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.detailsIconSvg,
      alt: $options.detailsIconSvg
    }, null, 8, _hoisted_1$I);
  }
  var YourDetails = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$M]]);
  const _sfc_main$L = {
    name: "DeliveryTabIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$H = ["role", "aria-label"];
  const _hoisted_2$z = ["fill"];
  function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      createBaseVNode("path", {
        d: "M5.5021 21C4.83546 21 4.42048 20.582 4.42048 19.9106V12.0798L3.76187 12.7377C3.53966 12.9561 3.2639 13.0775 2.98279 13.0775C2.72577 13.0775 2.48214 12.975 2.29741 12.7863C1.88244 12.3683 1.90385 11.7616 2.34828 11.3112C5.30666 8.32884 8.26771 5.34644 11.2341 2.36673C11.3439 2.25617 11.4751 2.18606 11.5902 2.12135C11.6464 2.09168 11.6866 2.06741 11.7241 2.04315L11.791 2H12.2542L12.3264 2.05663C12.3853 2.10247 12.4442 2.14561 12.5031 2.19146C12.6611 2.30741 12.811 2.42066 12.9502 2.55819C15.3625 4.9797 17.7693 7.40392 20.1789 9.82813L21.5844 11.2411C21.6406 11.2978 21.6969 11.3544 21.7477 11.4137C22.0958 11.8263 22.0824 12.4007 21.7156 12.7782C21.5228 12.9777 21.2712 13.0856 21.0008 13.0856C20.7545 13.0856 20.5135 12.9885 20.3288 12.8159C20.2297 12.7215 20.1307 12.6272 20.0316 12.5301L19.5765 12.0798V19.8378C19.5765 20.6063 19.1615 20.8733 18.8135 20.9622C18.6983 20.9919 18.5859 20.9946 18.4841 20.9946H11.194H5.5021V21ZM13.9997 12.6191C14.7199 12.6191 15.1161 13.0236 15.1161 13.7516V18.9695H17.5766V17.7102C17.5766 14.8195 17.5766 13.1422 17.5685 10.1841V10.1274L17.5471 10.0762C17.5391 10.06 17.5203 10.0196 17.4909 9.98453C15.9515 8.42322 14.4174 6.88078 12.886 5.33565L11.9971 4.44309L11.3948 5.04712C9.76162 6.69202 8.12849 8.33693 6.50072 9.98453L6.43646 10.0492L6.42308 10.1571V10.1868C6.41772 13.1314 6.41772 14.7305 6.41772 17.6751V18.9695H8.87009V13.7705C8.87009 13.029 9.27168 12.6218 9.99722 12.6191C10.6639 12.6191 11.3305 12.6191 11.9971 12.6191C12.6638 12.6191 13.3304 12.6191 13.9971 12.6191H13.9997ZM10.8888 18.9668H13.1055V14.6469H10.8888V18.9668Z",
        fill: $props.fill
      }, null, 8, _hoisted_2$z)
    ], 12, _hoisted_1$H);
  }
  var DeliveryTabIcon = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$L]]);
  const _sfc_main$K = {
    name: "ClickCollectTabIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$G = ["role", "aria-label"];
  const _hoisted_2$y = ["fill"];
  function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 25 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      createBaseVNode("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M8.57113 5.56531C8.13832 5.56531 7.77417 5.30861 7.66223 4.92505C7.28464 3.62513 6.9384 2.32969 6.63394 1.07902C6.57872 0.849184 6.63692 0.607408 6.7996 0.399957C6.99511 0.149226 7.29807 -1.81738e-05 7.61 -0.00151062C8.08609 -0.00151062 8.45323 0.274592 8.57561 0.717849C8.90992 1.93419 9.23527 3.15651 9.54271 4.34748C9.67106 4.84595 9.37407 5.3713 8.88007 5.51905C8.77858 5.5489 8.67411 5.56382 8.56964 5.56382L8.57113 5.56531ZM14.808 23.997C14.3528 23.9851 14.026 23.7135 13.835 23.1896L12.0261 18.2123C11.6538 17.1888 11.2818 16.1652 10.9097 15.1415L10.9091 15.1399L10.9086 15.1384L10.908 15.1369C10.2633 13.3631 9.61854 11.5891 8.97256 9.81579C8.79795 9.33523 8.86063 8.96808 9.17255 8.65915C9.36806 8.46662 9.58447 8.3726 9.8352 8.3726C9.97847 8.3726 10.1382 8.40394 10.3083 8.46513L10.7292 8.61885L11.8912 9.0417C15.7642 10.4511 19.7397 11.8977 23.6597 13.3111C24.0985 13.4693 24.3716 13.7409 24.5179 14.1633V14.4469C24.4 14.8961 24.0955 15.1826 23.503 15.399C22.8463 15.6393 22.1897 15.9065 21.5554 16.1647C21.3061 16.2661 21.0554 16.3676 20.8062 16.4676C20.5654 16.5635 20.3255 16.6612 20.0793 16.7614L20.0789 16.7616L19.8734 16.8452L19.1018 17.1586L19.4212 17.5004L19.4412 17.5219L19.4412 17.5219C19.4942 17.5789 19.542 17.6302 19.5898 17.678L20.5525 18.6421L20.5525 18.6422L20.5525 18.6422L20.5526 18.6422L20.5526 18.6423C21.654 19.7451 22.7539 20.8465 23.8597 21.9449L23.8639 21.9491C24.1342 22.2179 24.414 22.4961 24.5179 22.8732V23.1448L24.5089 23.1642C24.4851 23.2165 24.4612 23.2702 24.4418 23.3239C24.294 23.7299 23.9254 23.9925 23.506 23.9925C23.2657 23.9925 23.0389 23.906 22.8478 23.7433C22.7852 23.6896 22.7255 23.6299 22.6628 23.5657L22.0822 22.9836C20.7868 21.6882 18.1974 19.0928 18.1974 19.0928L17.6914 18.6108L17.5676 18.8645L17.4989 19.0137L17.4824 19.0498C17.4578 19.1035 17.4331 19.1574 17.4123 19.2122L15.8065 23.2224C15.6647 23.5761 15.3811 23.9985 14.8364 23.9985H14.811L14.808 23.997ZM14.8513 20.1659L15.0752 19.6525L15.1498 19.4854L15.1687 19.4428L15.1687 19.4428L15.1688 19.4426L15.1688 19.4425C15.2002 19.3719 15.2258 19.3142 15.2483 19.2555L15.5229 18.572L15.6349 18.2932L15.6349 18.2932L15.6351 18.2926L15.6352 18.2925C15.9105 17.6073 16.1924 16.9056 16.4617 16.2109C16.5139 16.0751 16.5781 16.0139 16.7243 15.9572C17.5661 15.6274 18.4168 15.2856 19.2406 14.9528L20.1823 14.5752L20.6763 14.3797L20.2316 14.1916L11.5261 11.0262L14.8513 20.1674V20.1659ZM4.81468 9.03222C4.90273 9.05461 4.99228 9.06655 5.08033 9.06655L5.08183 9.06506C5.52508 9.06506 5.91312 8.77701 6.02804 8.36211C6.18176 7.80394 5.89819 7.28755 5.35494 7.13383C4.05353 6.76669 2.84913 6.44581 1.67308 6.1518C1.59696 6.1324 1.51936 6.12345 1.44324 6.12345C1.19848 6.12345 0.967152 6.22195 0.791043 6.39955C0.601502 6.59058 0.498524 6.84877 0.500016 7.12786C0.503001 7.59798 0.780596 7.95468 1.24027 8.08004C2.44915 8.40987 3.65206 8.72926 4.81468 9.03222ZM3.7222 16.4989C3.27745 16.4571 2.98493 16.2631 2.82673 15.9049C2.64614 15.499 2.71181 15.1304 3.01776 14.811C3.36638 14.4455 3.7322 14.0827 4.08656 13.7312L4.0866 13.7312L4.15202 13.6663C4.31171 13.5081 4.4729 13.3484 4.6311 13.1887L4.91018 12.9081L4.91108 12.9072C5.14509 12.6717 5.37762 12.4377 5.61462 12.2067C5.83699 11.9903 6.10713 11.8709 6.37577 11.8709C6.64441 11.8709 6.86827 11.9738 7.0608 12.1693C7.46824 12.5798 7.44734 13.1753 7.01155 13.617C6.64382 13.9883 6.27418 14.3577 5.90493 14.7267L5.62805 15.0035L5.24145 15.3898C4.98377 15.6471 4.72609 15.9045 4.46842 16.1631C4.26843 16.3646 4.02367 16.4736 3.7207 16.4974L3.7222 16.4989ZM12.6739 6.56227C12.8649 6.75032 13.1112 6.8533 13.3694 6.8533L13.3679 6.85479C13.6231 6.85479 13.8678 6.75181 14.0574 6.56675C14.8618 5.78023 15.7961 4.86238 16.6945 3.91915C16.8139 3.79379 16.893 3.60425 16.9557 3.45202C16.9721 3.41097 16.9886 3.37368 17.0038 3.33901L17.008 3.32964C16.9512 2.77892 16.7736 2.4864 16.4035 2.32373C16.2528 2.25806 16.105 2.22373 15.9647 2.22373C15.7334 2.22373 15.5215 2.31626 15.3334 2.49834C14.4081 3.39978 13.5052 4.30271 12.6485 5.18176C12.2709 5.5683 12.2814 6.17573 12.6739 6.56227Z",
        fill: $props.fill
      }, null, 8, _hoisted_2$y)
    ], 12, _hoisted_1$G);
  }
  var ClickCollectTabIcon = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$K]]);
  const findUrl = "https://services.postcodeanywhere.co.uk/Capture/Interactive/Find/v1.00/json3.ws";
  const retrieveUrl = "https://services.postcodeanywhere.co.uk/Capture/Interactive/Retrieve/v1.00/json3.ws";
  let request2 = null;
  var loqate = {
    cancel() {
      request2.cancel();
      this.clearOldRequest();
    },
    clearOldRequest() {
      request2 = null;
    },
    getSuggestions(containerQuery, query, addressType) {
      var _a;
      const { countryCode, addressFinder: { loqate: loqate2 } } = useConfigStore();
      const { selected } = useCustomerStore();
      if (request2)
        this.cancel();
      const axiosSource = axios.CancelToken.source();
      request2 = { cancel: axiosSource.cancel, msg: "Loading..." };
      const container = typeof containerQuery === "string" ? `&Container=${containerQuery}` : "";
      const loqateCountry = ((_a = selected[addressType]) == null ? void 0 : _a.country_code) || countryCode;
      const requestUrl = `${findUrl}?key=${loqate2.apiKey}&Countries=${loqateCountry}&Limit=10&Text=${query}${container}`;
      return axios.get(requestUrl, { cancelToken: axiosSource.token }).then((response) => {
        this.clearOldRequest();
        return response.data.Items;
      }).catch(this.logResponseErrors);
    },
    logResponseErrors(error) {
      if (axios.isCancel(error))
        console.log("Loqate request cancelled");
    },
    getAndUseAddress(id) {
      const { addressFinder: { loqate: loqate2 } } = useConfigStore();
      return axios.get(`${retrieveUrl}?key=${loqate2.apiKey}&Id=${id}`).then((response) => {
        if (typeof response.data.Items[0].Error !== "string") {
          return response.data.Items[0];
        }
        return handleError({ error: { message: response.data.Items[0].Error } });
      });
    }
  };
  const _sfc_main$J = {
    name: "AddressBlock",
    props: {
      address_type: {
        type: String,
        default: "shipping"
      },
      address: {
        default: {
          street: ["", ""],
          city: "",
          region: "",
          country_code: "",
          postcode: "",
          company: "",
          telephone: "",
          firstname: "",
          lastname: ""
        }
      },
      showNameFields: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      showRegion() {
        const { region } = this.address;
        return region && typeof region === "string";
      },
      sanitizedAddress() {
        return {
          ...this.address,
          firstname: this.address.firstname === "UNKNOWN" ? "" : this.address.firstname,
          lastname: this.address.lastname === "UNKNOWN" ? "" : this.address.lastname
        };
      }
    }
  };
  const _hoisted_1$F = { class: "address-block__address" };
  const _hoisted_2$x = { key: 0 };
  const _hoisted_3$u = { key: 1 };
  function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$F, [
      createBaseVNode("div", null, [
        $props.showNameFields ? (openBlock(), createElementBlock("p", _hoisted_2$x, toDisplayString$1($options.sanitizedAddress.firstname) + " " + toDisplayString$1($options.sanitizedAddress.lastname), 1)) : createCommentVNode("", true),
        createBaseVNode("p", null, toDisplayString$1($options.sanitizedAddress.street[0]), 1),
        createBaseVNode("p", null, [
          $options.sanitizedAddress.street[1] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString$1($options.sanitizedAddress.street[1]), 1)
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("p", null, toDisplayString$1($options.sanitizedAddress.city), 1),
        createBaseVNode("p", null, [
          $options.showRegion ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString$1($options.sanitizedAddress.region), 1)
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("p", null, toDisplayString$1($options.sanitizedAddress.postcode), 1),
        $props.showNameFields ? (openBlock(), createElementBlock("p", _hoisted_3$u, toDisplayString$1($options.sanitizedAddress.telephone), 1)) : createCommentVNode("", true)
      ])
    ]);
  }
  var AddressBlock = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$J], ["__scopeId", "data-v-477bb351"]]);
  const _sfc_main$I = {
    name: "Remove",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$E = ["role", "aria-label"];
  const _hoisted_2$w = /* @__PURE__ */ createBaseVNode("circle", {
    cx: "9",
    cy: "9",
    r: "8",
    stroke: "#343434",
    "stroke-width": "2"
  }, null, -1);
  const _hoisted_3$t = /* @__PURE__ */ createBaseVNode("path", {
    d: "M15 15L21.5 21.5",
    stroke: "#343434",
    "stroke-width": "2",
    "stroke-linecap": "round"
  }, null, -1);
  const _hoisted_4$k = [
    _hoisted_2$w,
    _hoisted_3$t
  ];
  function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "23",
      height: "23",
      viewBox: "0 0 23 23",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_4$k, 12, _hoisted_1$E);
  }
  var Search = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$I]]);
  var selectAddressDataLayer = (addressType) => {
    const gtmStore = useGtmStore();
    gtmStore.trackGtmEvent({
      event: "selectAddress",
      addressType
    });
  };
  const _sfc_main$H = {
    name: "LoqateAddress",
    components: {
      AddressBlock,
      TextInput,
      Search,
      Edit,
      MyButton
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    data() {
      return {
        query: "",
        addressList: [],
        arrowCounter: -1,
        address: false,
        request: null,
        displayResults: false
      };
    },
    computed: {
      ...mapWritableState(useCustomerStore, ["selected", "customer"]),
      ...mapState(useConfigStore, ["countryCode", "stateRequired", "countries"]),
      selectedAddressType() {
        return this.selected[this.address_type];
      }
    },
    methods: {
      ...mapActions(useConfigStore, ["getRegionsByCountry"]),
      ...mapActions(useCustomerStore, [
        "setAddressToStore",
        "validateNameField",
        "validatePhone",
        "validateAddress",
        "validatePostcode",
        "updateRegionRequired",
        "setAddressAsEditing"
      ]),
      editAddress() {
        this.address = false;
      },
      resetAddressData() {
        this.addressList = [];
        this.arrowCounter = -1;
        this.address = false;
      },
      getSuggestions(containerQuery) {
        this.resetAddressData();
        if (this.query !== "") {
          loqate.getSuggestions(containerQuery, this.query, this.address_type).then((addresses) => {
            this.addressList = addresses;
          });
        } else {
          this.displayResults = false;
        }
      },
      selectSuggestion(item) {
        this.arrowCounter = -1;
        this.addressList = [];
        if (item.Type === "Address") {
          loqate.getAndUseAddress(item.Id).then(this.updateAddress);
          this.displayResults = false;
          selectAddressDataLayer(this.address_type);
        } else {
          this.query = item.Text;
          loqate.getSuggestions(item.Id, this.query).then((addresses) => {
            this.addressList = addresses;
          });
        }
      },
      onBlur(event) {
        if (!event.relatedTarget || !event.relatedTarget.classList.contains("afd-postcode__action")) {
          this.displayResults = false;
        }
      },
      onFocus() {
        this.displayResults = true;
      },
      onArrowDown() {
        if (this.arrowCounter < this.addressList.length) {
          this.arrowCounter += 1;
        }
      },
      onArrowUp() {
        if (this.arrowCounter > 0) {
          this.arrowCounter -= 1;
        }
      },
      onEnter() {
        this.selectSuggestion(this.addressList[this.arrowCounter]);
      },
      getResultsCount() {
        return this.addressList && this.addressList.length;
      },
      updateAddress(address) {
        let countryCode = "";
        if (address.CountryIso2 === "GG" || address.CountryIso2 === "IM" || address.CountryIso2 === "JE") {
          countryCode = this.countryCode;
        } else {
          countryCode = address.CountryIso2;
        }
        const availableRegions = this.getRegionsByCountry(countryCode);
        const region = availableRegions.length && availableRegions.find((rgin) => rgin.option.name === address.PostalCounty || rgin.option.name === address.ProvinceName);
        const newAddress = {
          id: "custom",
          company: address.Company,
          street: [address.Line1, address.Line2],
          city: address.City,
          country_code: countryCode,
          region: {
            region: region ? region.option.code : address.ProvinceName,
            ...region ? { region_id: region.option.value } : {}
          },
          postcode: address.PostalCode
        };
        this.setAddressToStore(newAddress, this.address_type);
        this.updateRegionRequired(this.address_type);
        this.setAddressToStore(newAddress, this.address_type);
        const firstNameValid = this.validateNameField(this.address_type, "First name", this.selectedAddressType.firstname, true);
        const lastNameValid = this.validateNameField(this.address_type, "Last name", this.selectedAddressType.lastname, true);
        const phoneNumberValid = this.validatePhone(this.address_type, this.selectedAddressType.telephone, true);
        const addressValid = this.validateAddress(this.address_type, true);
        const postcodeValid = this.validatePostcode(this.address_type, true);
        const isValid = firstNameValid && lastNameValid && phoneNumberValid && addressValid && postcodeValid;
        if (!isValid) {
          this.setAddressAsEditing(this.address_type, true);
        }
      }
    }
  };
  const _hoisted_1$D = { class: "loqate__container" };
  const _hoisted_2$v = { class: "loqate__field" };
  const _hoisted_3$s = {
    key: 0,
    class: "loqate__results"
  };
  const _hoisted_4$j = ["onClick"];
  const _hoisted_5$h = { class: "address-block__item" };
  function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextInput = resolveComponent("TextInput");
    const _component_Search = resolveComponent("Search");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_Edit = resolveComponent("Edit");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$D, [
        createBaseVNode("div", _hoisted_2$v, [
          createVNode(_component_TextInput, {
            id: "loqate",
            modelValue: $data.query,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.query = $event),
            type: "text",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.title"),
            class: "loqate__input",
            autocomplete: "postal-code",
            onBlur: $options.onBlur,
            onFocus: $options.onFocus,
            onInput: $options.getSuggestions,
            onKeydown: [
              withKeys($options.onArrowDown, ["down"]),
              withKeys($options.onArrowUp, ["up"]),
              withKeys($options.onEnter, ["enter"])
            ]
          }, null, 8, ["modelValue", "placeholder", "label", "onBlur", "onFocus", "onInput", "onKeydown"]),
          createVNode(_component_Search, { stroke: "black" })
        ]),
        $options.getResultsCount() > 0 ? (openBlock(), createElementBlock("ul", _hoisted_3$s, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.addressList, (item, i) => {
            return openBlock(), createElementBlock("li", {
              key: i,
              class: normalizeClass([{ "locate__suggestion--active": i === $data.arrowCounter }, "loqate__result"])
            }, [
              createBaseVNode("button", {
                tabindex: "-1",
                type: "button",
                class: "loqate__action",
                onClick: ($event) => {
                  $options.selectSuggestion(item);
                }
              }, toDisplayString$1(item.Text) + " - " + toDisplayString$1(item.Description), 9, _hoisted_4$j)
            ], 2);
          }), 128))
        ])) : createCommentVNode("", true)
      ]),
      $data.address ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["address-block", _ctx.customer.addresses.length > 0 ? "saved-address-active" : ""])
      }, [
        createBaseVNode("div", _hoisted_5$h, [
          createBaseVNode("article", null, [
            createVNode(_component_AddressBlock, {
              address_type: $props.address_type,
              address: $data.address
            }, null, 8, ["address_type", "address"])
          ])
        ]),
        createBaseVNode("div", {
          class: "address-block__edit",
          tabindex: "0",
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"])),
          onKeydown: _cache[2] || (_cache[2] = withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"]))
        }, [
          createVNode(_component_Edit),
          createVNode(_component_MyButton, {
            label: _ctx.$t("yourDetailsSection.editButton"),
            secondary: ""
          }, null, 8, ["label"])
        ], 32)
      ], 2)) : createCommentVNode("", true)
    ], 64);
  }
  var Loqate = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$H], ["__scopeId", "data-v-21db6280"]]);
  const _sfc_main$G = {
    name: "AfdPostCode",
    components: {
      AddressBlock,
      TextInput,
      Search,
      Edit,
      MyButton
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    data() {
      return {
        query: "",
        addressList: [],
        arrowCounter: -1,
        address: false,
        request: null,
        displayResults: true
      };
    },
    computed: {
      ...mapWritableState(useCustomerStore, ["selected", "customer"]),
      ...mapState(useConfigStore, [
        "countryCode",
        "stateRequired",
        "countries",
        "addressFinder"
      ]),
      selectedAddressType() {
        return this.selected[this.address_type];
      }
    },
    async mounted() {
      await this.getAfdConfiguration();
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "setAddressToStore",
        "validateNameField",
        "validatePhone",
        "validateAddress",
        "validatePostcode",
        "setAddressAsEditing",
        "getRegionOptions",
        "updateRegionRequired",
        "getAfdConfiguration"
      ]),
      editAddress() {
        this.address = false;
      },
      resetAddressData() {
        this.addressList = [];
        this.arrowCounter = -1;
        this.address = false;
      },
      onBlur({ relatedTarget }) {
        if (!relatedTarget) {
          this.displayResults = false;
        } else if (!Array.from(relatedTarget.classList).some((c) => c.startsWith("afd-postcode__"))) {
          this.displayResults = false;
        }
      },
      onFocus() {
        this.displayResults = true;
      },
      onArrowDown() {
        if (this.arrowCounter < this.addressList.length) {
          this.arrowCounter += 1;
        }
      },
      onArrowUp() {
        if (this.arrowCounter > 0) {
          this.arrowCounter -= 1;
        }
      },
      onEnter() {
        this.selectSuggestion(this.addressList[this.arrowCounter]);
      },
      getResultsCount() {
        return this.addressList && this.addressList.length;
      },
      getSuggestions() {
        this.resetAddressData();
        afdPostcode.getSuggestions(this.query, this.address_type).then((addresses) => {
          this.addressList = addresses;
        });
      },
      selectSuggestion(item) {
        this.arrowCounter = -1;
        this.addressList = [];
        afdPostcode.getAndUseAddress(item.Key, this.address_type).then(this.updateAddress);
        this.displayResults = false;
      },
      updateAddress(address) {
        const {
          two_letter_abbreviation: countryCode = ""
        } = this.countries.find(({ three_letter_abbreviation }) => address.CountryISO === three_letter_abbreviation);
        const availableRegions = this.getRegionOptions(this.address_type);
        const region = availableRegions.length && availableRegions.find((rgin) => {
          const regionName = rgin.option.name;
          const regionCode = rgin.option.code;
          return regionName === address.PostalCounty || regionCode === address.AbbreviatedPostalCounty;
        });
        const line1 = address.Property || address.Street || address.Organisation;
        const line2 = address.Property ? address.Street : address.Locality;
        const newAddress = {
          id: "custom",
          company: address.Organisation,
          street: [line1, line2],
          city: address.Town,
          country_code: countryCode,
          region: {
            region: region ? region.option.code : address.PostalCounty,
            ...region ? { region_id: region.option.value } : {}
          },
          postcode: address.Postcode
        };
        this.setAddressToStore(newAddress, this.address_type);
        this.updateRegionRequired(this.address_type);
        this.setAddressToStore(newAddress, this.address_type);
        const firstNameValid = this.validateNameField(this.address_type, "First name", this.selectedAddressType.firstname, true);
        const lastNameValid = this.validateNameField(this.address_type, "Last name", this.selectedAddressType.lastname, true);
        const phoneNumberValid = this.validatePhone(this.address_type, this.selectedAddressType.telephone, true);
        const addressValid = this.validateAddress(this.address_type, true);
        const postcodeValid = this.validatePostcode(this.address_type, true);
        const isValid = firstNameValid && lastNameValid && phoneNumberValid && addressValid && postcodeValid;
        if (!isValid) {
          this.setAddressAsEditing(this.address_type, true);
        }
      }
    }
  };
  const _hoisted_1$C = { key: 0 };
  const _hoisted_2$u = { class: "afd-postcode__container" };
  const _hoisted_3$r = { class: "afd-postcode__field" };
  const _hoisted_4$i = {
    key: 0,
    class: "afd-postcode__results"
  };
  const _hoisted_5$g = ["onClick"];
  const _hoisted_6$d = { class: "address-block__item" };
  function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextInput = resolveComponent("TextInput");
    const _component_Search = resolveComponent("Search");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_Edit = resolveComponent("Edit");
    const _component_MyButton = resolveComponent("MyButton");
    return _ctx.addressFinder.afd.serial && _ctx.addressFinder.afd.id ? (openBlock(), createElementBlock("div", _hoisted_1$C, [
      createBaseVNode("div", _hoisted_2$u, [
        createBaseVNode("div", _hoisted_3$r, [
          createVNode(_component_TextInput, {
            type: "text",
            id: "afd-postcode",
            modelValue: $data.query,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.query = $event),
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.label"),
            class: "afd-postcode__input",
            autocomplete: "postal-code",
            onBlur: $options.onBlur,
            onFocus: $options.onFocus,
            onInput: $options.getSuggestions,
            onKeydown: [
              withKeys($options.onArrowDown, ["down"]),
              withKeys($options.onArrowUp, ["up"]),
              withKeys($options.onEnter, ["enter"])
            ]
          }, null, 8, ["modelValue", "placeholder", "label", "onBlur", "onFocus", "onInput", "onKeydown"]),
          createVNode(_component_Search, { stroke: "black" })
        ]),
        $options.getResultsCount() > 0 && $data.displayResults ? (openBlock(), createElementBlock("ul", _hoisted_4$i, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.addressList, (item, i) => {
            return openBlock(), createElementBlock("li", {
              key: i,
              class: normalizeClass([{ "afdPostcode__suggestion--active": i === $data.arrowCounter }, "afd-postcode__result"]),
              tabindex: "-1"
            }, [
              createBaseVNode("button", {
                tabindex: "-1",
                type: "button",
                class: "afd-postcode__action",
                onClick: ($event) => {
                  $options.selectSuggestion(item);
                }
              }, toDisplayString$1(item.List), 9, _hoisted_5$g)
            ], 2);
          }), 128))
        ])) : createCommentVNode("", true)
      ]),
      $data.address ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["address-block", _ctx.customer.addresses.length > 0 ? "saved-address-active" : ""])
      }, [
        createBaseVNode("div", _hoisted_6$d, [
          createBaseVNode("article", null, [
            createVNode(_component_AddressBlock, {
              address_type: $props.address_type,
              address: $data.address
            }, null, 8, ["address_type", "address"])
          ])
        ]),
        createBaseVNode("div", {
          class: "address-block__edit",
          tabindex: "0",
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"])),
          onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"]), ["enter"]))
        }, [
          createVNode(_component_Edit),
          createVNode(_component_MyButton, {
            secondary: "",
            label: _ctx.$t("yourDetailsSection.editButton")
          }, null, 8, ["label"])
        ], 32)
      ], 2)) : createCommentVNode("", true)
    ])) : createCommentVNode("", true);
  }
  var AfdPostCode = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$G], ["__scopeId", "data-v-fc3dd1ec"]]);
  const _sfc_main$F = {
    name: "AddressFinder",
    components: {
      AfdPostCode,
      Loqate
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    computed: {
      ...mapState(useConfigStore, ["addressFinder"])
    },
    methods: {
      ...mapActions(useConfigStore, ["getLoqateConfiguration", "getAfdStatus"])
    }
  };
  function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Loqate = resolveComponent("Loqate");
    const _component_AfdPostCode = resolveComponent("AfdPostCode");
    return openBlock(), createElementBlock(Fragment, null, [
      _ctx.addressFinder.loqate.enabled && _ctx.addressFinder.loqate.apiKey && !_ctx.addressFinder.afd.enabled ? (openBlock(), createBlock(_component_Loqate, {
        key: 0,
        address_type: $props.address_type
      }, null, 8, ["address_type"])) : createCommentVNode("", true),
      _ctx.addressFinder.afd.enabled && !_ctx.addressFinder.loqate.enabled ? (openBlock(), createBlock(_component_AfdPostCode, {
        key: 1,
        address_type: $props.address_type
      }, null, 8, ["address_type"])) : createCommentVNode("", true)
    ], 64);
  }
  var AddressFinder = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$F]]);
  const _sfc_main$E = {
    name: "ErrorIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$B = ["role", "aria-label"];
  const _hoisted_2$t = /* @__PURE__ */ createBaseVNode("path", {
    d: "M0 12.7482C0 12.2491 0 11.7473 0 11.2482C0.0131297 11.172 0.0341373 11.0984 0.0420151 11.0223C0.249465 8.51866 1.11603 6.26463 2.75461 4.36788C5.88736 0.734638 9.86041 -0.655083 14.5661 0.285409C19.9204 1.35463 23.9197 6.26463 23.9985 11.7263C24.0353 14.2247 23.4024 16.5365 22.0054 18.6119C20.099 21.4439 17.4546 23.1882 14.0908 23.8135C13.647 23.8949 13.198 23.9396 12.749 24H11.2495C11.0894 23.979 10.9265 23.958 10.7664 23.9396C8.61834 23.7031 6.65676 22.9728 4.92364 21.6829C2.3581 19.773 0.766775 17.2432 0.189068 14.0881C0.107664 13.6441 0.0630226 13.1948 0.00262594 12.7456L0 12.7482ZM11.9927 5.19804C11.0211 5.19804 10.1178 6.02294 10.2884 7.0869C10.5327 8.60535 10.685 10.1369 10.8819 11.6606C10.9686 12.3332 11.0447 13.0083 11.1603 13.6782C11.2364 14.1327 11.5988 14.4164 12.0058 14.4138C12.405 14.4112 12.7384 14.1275 12.8409 13.6887C12.8855 13.4917 12.9091 13.2894 12.9328 13.0871C13.1638 11.2902 13.3949 9.49593 13.6208 7.69638C13.668 7.31808 13.7468 6.92928 13.7074 6.55623C13.6234 5.77599 12.8461 5.19278 11.9927 5.19541V5.19804ZM13.5184 17.2668C13.5131 16.4261 12.8356 15.751 11.9979 15.7536C11.1603 15.7536 10.4854 16.434 10.4854 17.2747C10.4854 18.1259 11.1655 18.8036 12.0189 18.7958C12.8592 18.7879 13.5262 18.1101 13.521 17.2668H13.5184Z",
    fill: "#BD0005"
  }, null, -1);
  const _hoisted_3$q = [
    _hoisted_2$t
  ];
  function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$q, 12, _hoisted_1$B);
  }
  var ErrorIcon = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$E]]);
  const _sfc_main$D = {
    name: "AddressFormName",
    components: {
      TextInput,
      ValidIcon,
      ErrorIcon
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    emits: ["isCustomerInfoFull"],
    setup() {
      const customerStore = useCustomerStore();
      return {
        getAddressFieldHasError: customerStore.getAddressFieldHasError
      };
    },
    computed: {
      ...mapWritableState(useCustomerStore, ["selected"]),
      selectedAddressType() {
        return this.selected[this.address_type];
      }
    },
    watch: {
      selectedAddressType: {
        handler(newValue) {
          if (newValue.firstname === "UNKNOWN") {
            this.selectedAddressType.firstname = "";
          }
          if (newValue.lastname === "UNKNOWN") {
            this.selectedAddressType.lastname = "";
          }
          if (String(newValue.telephone) === "000000000") {
            this.selectedAddressType.telephone = "";
          }
        },
        deep: true
      }
    },
    mounted() {
      this.validateFields();
    },
    updated() {
      this.sanitizeAddressFields();
      this.validateFields();
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "validateNameField",
        "validatePhone"
      ]),
      sanitizeAddressFields() {
        if (this.selectedAddressType.firstname === "UNKNOWN") {
          this.selectedAddressType.firstname = "";
        }
        if (this.selectedAddressType.lastname === "UNKNOWN") {
          this.selectedAddressType.lastname = "";
        }
        if (String(this.selectedAddressType.telephone) === "000000000") {
          this.selectedAddressType.telephone = "";
        }
      },
      validateFields() {
        const first = this.validateField("firstname", "First name");
        const last = this.validateField("lastname", "Last name");
        const phone = this.validatePhone(this.address_type, this.selectedAddressType.telephone);
        const fullDetails = first && last && phone;
        this.$emit("isCustomerInfoFull", fullDetails);
      },
      validateField(field, label, addError) {
        return this.validateNameField(this.address_type, label, this.selectedAddressType[field], addError);
      },
      isFieldValid(field, label) {
        return !this.getAddressFieldHasError(this.address_type, label) && this.selectedAddressType[field];
      },
      phoneChange(event) {
        if (event.key === "Enter") {
          this.validateField("telephone", "Telephone");
        }
      },
      textChange(event, type) {
        if (event.key === "Enter") {
          this.validateField(type, type === "firstname" ? "First name" : "Last name");
        }
      }
    }
  };
  const _hoisted_1$A = { class: "phone-field" };
  function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextInput = resolveComponent("TextInput");
    const _component_ValidIcon = resolveComponent("ValidIcon");
    const _component_ErrorIcon = resolveComponent("ErrorIcon");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", null, [
        createVNode(_component_TextInput, {
          modelValue: $options.selectedAddressType.firstname,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.selectedAddressType.firstname = $event),
          class: normalizeClass({ "field-valid": $options.isFieldValid("firstname", "First name") }),
          identifier: `${$props.address_type}-first-name`,
          label: _ctx.$t("yourDetailsSection.firstName.label"),
          placeholder: _ctx.$t("yourDetailsSection.firstName.placeholder"),
          error: $setup.getAddressFieldHasError($props.address_type, "First name"),
          "error-message": $setup.getAddressFieldHasError($props.address_type, "First name") ? _ctx.$t("errorMessages.firstNameErrorMessage") : "",
          type: "text",
          required: "",
          autocomplete: "given-name",
          onKeyup: _cache[1] || (_cache[1] = ($event) => $options.textChange($event, "firstname")),
          onFocusout: _cache[2] || (_cache[2] = ($event) => $options.validateField("firstname", "First name", true))
        }, null, 8, ["modelValue", "class", "identifier", "label", "placeholder", "error", "error-message"]),
        $options.isFieldValid("firstname", "First name") ? (openBlock(), createBlock(_component_ValidIcon, { key: 0 })) : createCommentVNode("", true),
        $setup.getAddressFieldHasError($props.address_type, "First name") ? (openBlock(), createBlock(_component_ErrorIcon, { key: 1 })) : createCommentVNode("", true)
      ]),
      createBaseVNode("div", null, [
        createVNode(_component_TextInput, {
          modelValue: $options.selectedAddressType.lastname,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $options.selectedAddressType.lastname = $event),
          class: normalizeClass({ "field-valid": $options.isFieldValid("lastname", "Last name") }),
          identifier: `${$props.address_type}-last-name`,
          label: _ctx.$t("yourDetailsSection.lastName.label"),
          placeholder: _ctx.$t("yourDetailsSection.lastName.placeholder"),
          error: $setup.getAddressFieldHasError($props.address_type, "Last name"),
          "error-message": $setup.getAddressFieldHasError($props.address_type, "Last name") ? _ctx.$t("errorMessages.lastNameErrorMessage") : "",
          type: "text",
          required: "",
          autocomplete: "family-name",
          onKeyup: _cache[4] || (_cache[4] = ($event) => $options.textChange($event, "lastname")),
          onFocusout: _cache[5] || (_cache[5] = ($event) => $options.validateField("lastname", "Last name", true))
        }, null, 8, ["modelValue", "class", "identifier", "label", "placeholder", "error", "error-message"]),
        $options.isFieldValid("lastname", "Last name") ? (openBlock(), createBlock(_component_ValidIcon, { key: 0 })) : createCommentVNode("", true),
        $setup.getAddressFieldHasError($props.address_type, "Last name") ? (openBlock(), createBlock(_component_ErrorIcon, { key: 1 })) : createCommentVNode("", true)
      ]),
      createBaseVNode("div", null, [
        createBaseVNode("div", _hoisted_1$A, [
          createVNode(_component_TextInput, {
            modelValue: $options.selectedAddressType.telephone,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $options.selectedAddressType.telephone = $event),
            class: normalizeClass({
              "field-valid": $options.isFieldValid("telephone", "Telephone"),
              "field-error": $setup.getAddressFieldHasError($props.address_type, "Telephone")
            }),
            error: $setup.getAddressFieldHasError($props.address_type, "Telephone"),
            "error-message": $setup.getAddressFieldHasError($props.address_type, "Telephone") ? _ctx.$t("errorMessages.phoneErrorMessage") : "",
            identifier: `${$props.address_type}-phone`,
            type: "tel",
            label: _ctx.$t("yourDetailsSection.phoneField.label"),
            placeholder: _ctx.$t("yourDetailsSection.phoneField.placeholder"),
            required: "",
            autocomplete: "tel",
            onKeyup: _cache[7] || (_cache[7] = ($event) => $options.phoneChange($event)),
            onFocusout: _cache[8] || (_cache[8] = ($event) => _ctx.validatePhone($props.address_type, $event.value, true)),
            onTelephoneError: _cache[9] || (_cache[9] = ($event) => _ctx.validatePhone($props.address_type, $options.selectedAddressType.telephone, true))
          }, null, 8, ["modelValue", "class", "error", "error-message", "identifier", "label", "placeholder"]),
          _ctx.validatePhone($props.address_type, $options.selectedAddressType.telephone) ? (openBlock(), createBlock(_component_ValidIcon, { key: 0 })) : createCommentVNode("", true),
          $setup.getAddressFieldHasError($props.address_type, "Telephone") ? (openBlock(), createBlock(_component_ErrorIcon, { key: 1 })) : createCommentVNode("", true)
        ])
      ])
    ], 64);
  }
  var NameFields = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$D], ["__scopeId", "data-v-4a3cfcba"]]);
  const _sfc_main$C = {
    name: "SelectInput",
    components: {
      ArrowDown
    },
    props: {
      error: {
        type: Boolean
      },
      dataCy: {
        type: String
      },
      label: {
        type: String
      },
      modelValue: {
        type: String || Number,
        default: ""
      },
      name: {
        type: String
      },
      selectedOption: {
        type: String || Number
      },
      identifier: {
        type: String
      },
      required: {
        type: Boolean,
        default: false
      },
      options: {
        type: Array,
        default() {
          return [
            {
              option: {
                name: "First",
                value: "1"
              }
            },
            {
              option: {
                name: "Second",
                value: "2"
              }
            }
          ];
        }
      },
      dataRole: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    methods: {
      onSelectChange(event) {
        this.$emit("update:modelValue", event.target.value);
        const selectElement = event.target;
        const selectedOption = selectElement.options[selectElement.selectedIndex];
        if (selectedOption.value !== "") {
          selectElement.classList.add("selected");
        } else {
          selectElement.classList.remove("selected");
        }
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        classes: computed(() => ({
          error: reactiveProps.error
        }))
      };
    }
  };
  const _hoisted_1$z = { class: "select-input" };
  const _hoisted_2$s = ["for"];
  const _hoisted_3$p = ["id", "name", "data-role", "disabled", "required", "value", "data-cy"];
  const _hoisted_4$h = {
    value: "",
    disabled: "",
    selected: ""
  };
  const _hoisted_5$f = ["value"];
  function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ArrowDown = resolveComponent("ArrowDown");
    return openBlock(), createElementBlock("div", _hoisted_1$z, [
      createBaseVNode("label", {
        for: $props.identifier,
        class: normalizeClass($setup.classes)
      }, [
        createBaseVNode("span", null, toDisplayString$1($props.required ? $props.label + " *" : $props.label), 1),
        createBaseVNode("select", {
          id: $props.identifier,
          name: $props.name,
          "data-role": $props.dataRole,
          disabled: $props.disabled,
          required: $props.required,
          value: $props.modelValue,
          "data-cy": $props.dataCy ? $props.dataCy : "select",
          onChange: _cache[0] || (_cache[0] = (...args) => $options.onSelectChange && $options.onSelectChange(...args))
        }, [
          createBaseVNode("option", _hoisted_4$h, toDisplayString$1($props.selectedOption), 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options, (option, index) => {
            return openBlock(), createElementBlock("option", {
              value: option.option.value,
              key: index
            }, toDisplayString$1(option.option.name), 9, _hoisted_5$f);
          }), 128))
        ], 40, _hoisted_3$p),
        createVNode(_component_ArrowDown)
      ], 10, _hoisted_2$s)
    ]);
  }
  var SelectInput = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$C], ["__scopeId", "data-v-d1f67e38"]]);
  const _sfc_main$B = {
    name: "AddressForm",
    components: {
      TextInput,
      SelectInput,
      MyButton,
      ErrorMessage,
      ValidIcon,
      ErrorIcon,
      CheckboxComponent
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    setup() {
      const customerStore = useCustomerStore();
      return {
        getAddressFieldHasError: customerStore.getAddressFieldHasError,
        getRegionOptions: customerStore.getRegionOptions,
        getRegionRequired: customerStore.getRegionRequired
      };
    },
    data() {
      return {
        buttonEnabled: false,
        requiredErrorMessage: "",
        streetAddress1Valid: false,
        streetAddress2Valid: false,
        cityValid: false,
        regionValid: false
      };
    },
    computed: {
      ...mapWritableState(useCustomerStore, ["selected", "isLoggedIn", "postCodeValid", "inputsSanitiseError"]),
      ...mapState(useConfigStore, [
        "countries",
        "stateRequired",
        "displayState",
        "countryCode",
        "optionalZipCountries",
        "postcodeRequired"
      ]),
      selectedAddressType() {
        return this.selected[this.address_type];
      },
      selectOptions() {
        return this.countries.map((country) => ({
          option: {
            name: country.full_name_locale,
            value: country.id
          }
        }));
      }
    },
    created() {
      this.setupCountry();
      if (!this.selected[this.address_type].region.region) {
        this.updateRegionRequired(this.address_type);
      }
      const customerStore = useCustomerStore();
      customerStore.$subscribe((mutation) => {
        if (mutation.type === "direct" || mutation.type === "patch object" && mutation.payload.selected && mutation.payload.selected[this.address_type]) {
          this.updateButtonState();
        }
      }, { flush: "sync" });
      this.updateButtonState();
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "validateAddress",
        "setAddressAsCustom",
        "setAddressToStore",
        "setAddressAsEditing",
        "addAddressError",
        "removeAddressError",
        "updateRegionRequired",
        "validateNameField",
        "validatePhone",
        "validatePostcode"
      ]),
      validateAndSave() {
        this.requiredErrorMessage = "";
        const isValid = this.validateAddress(this.address_type, true) && this.validatePostcode(this.address_type, true);
        if (isValid) {
          this.setAddressAsCustom(this.address_type);
          this.setAddressAsEditing(this.address_type, false);
          if (this.address_type === "shipping" && this.selected.billing.same_as_shipping) {
            const clonedShipping = deepClone(this.selected.shipping);
            this.setAddressToStore(clonedShipping, "billing");
          }
        } else {
          const fieldErrors = this.selected.formErrors[this.address_type];
          Object.entries(fieldErrors).forEach(([value]) => {
            this.addAddressError(this.address_type, value);
          });
          this.requiredErrorMessage = this.selected.formErrors.message[this.address_type];
        }
      },
      setupCountry() {
        if (!this.selectedAddressType.country_code) {
          this.selectedAddressType.country_code = this.countryCode;
        }
      },
      countryUpdated() {
        this.updateRegionRequired(this.address_type);
        this.validatePostcode(this.address_type, true);
      },
      setRegion(event) {
        const availableRegions = this.getRegionOptions(this.address_type);
        if (availableRegions.length) {
          const regionId = parseInt(event.target.value, 10);
          const region = availableRegions.find((rgion) => rgion.option.value === regionId);
          if (region) {
            this.selectedAddressType.region = {
              region: region.option.name,
              region_code: region.option.code,
              region_id: region.option.value
            };
          } else {
            this.selectedAddressType.region = {
              region: "",
              region_code: "",
              region_id: 0
            };
          }
        }
      },
      validateStreet(text2) {
        let hasError = !text2 || typeof text2 === "string" && !text2.trim();
        if (!hasError) {
          const streetAddress1 = this.selectedAddressType.street[0];
          const streetAddress2 = this.selectedAddressType.street[1];
          hasError = [streetAddress1, streetAddress2].join(" ").length > 75;
          this.streetAddress1Valid = !hasError;
        }
        hasError ? this.addAddressError(this.address_type, "Address Line 1") : this.removeAddressError(this.address_type, "Address Line 1");
      },
      validateStreet2(text2) {
        const streetAddress1 = this.selectedAddressType.street[0];
        const streetAddress2 = this.selectedAddressType.street[1];
        const hasError = text2 && [streetAddress1, streetAddress2].join(" ").length > 75;
        this.streetAddress2Valid = !hasError;
        hasError ? this.addAddressError(this.address_type, "Address Line 2") : this.removeAddressError(this.address_type, "Address Line 2");
      },
      validateCity(text2) {
        const hasError = !text2 || typeof text2 === "string" && !text2.trim();
        this.cityValid = !hasError;
        hasError ? this.addAddressError(this.address_type, "City") : this.removeAddressError(this.address_type, "City");
      },
      validateRegion(text2) {
        const hasError = !text2 || typeof text2 === "string" && !text2.trim();
        this.regionValid = !hasError;
        if (this.getRegionRequired(this.address_type)) {
          hasError ? this.addAddressError(this.address_type, "State/Region") : this.removeAddressError(this.address_type, "State/Region");
        }
      },
      updateButtonState() {
        const addressType = this.address_type;
        const areNamesValid = addressType !== "billing" || this.validateNameField(addressType, "First name", this.selected[addressType].firstname) && this.validateNameField(addressType, "Last name", this.selected[addressType].lastname) && this.validatePhone(addressType, this.selected[addressType].telephone);
        const validAddress = this.validateAddress(addressType);
        const validPostcode = this.validatePostcode(this.address_type);
        this.buttonEnabled = !this.inputsSanitiseError && validAddress && validPostcode && areNamesValid;
      },
      handleSaveInAddressBookChange(checked) {
        this.selectedAddressType.save_in_address_book = checked ? 1 : 0;
      }
    }
  };
  const _hoisted_1$y = { class: "address-form" };
  const _hoisted_2$r = { class: "address-form-fields" };
  const _hoisted_3$o = { class: "error-icon-block" };
  const _hoisted_4$g = { class: "error-icon-block" };
  const _hoisted_5$e = { class: "error-icon-block" };
  const _hoisted_6$c = { class: "error-icon-block" };
  const _hoisted_7$a = { class: "error-icon-block" };
  const _hoisted_8$9 = {
    key: 3,
    class: "save-address-field"
  };
  function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextInput = resolveComponent("TextInput");
    const _component_ValidIcon = resolveComponent("ValidIcon");
    const _component_ErrorIcon = resolveComponent("ErrorIcon");
    const _component_SelectInput = resolveComponent("SelectInput");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_CheckboxComponent = resolveComponent("CheckboxComponent");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock("div", _hoisted_1$y, [
      createBaseVNode("div", _hoisted_2$r, [
        createBaseVNode("form", {
          autocomplete: "on",
          onSubmit: _cache[19] || (_cache[19] = withModifiers(($event) => $options.validateAndSave(), ["prevent"]))
        }, [
          createBaseVNode("div", null, [
            createVNode(_component_TextInput, {
              modelValue: $options.selectedAddressType.street[0],
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.selectedAddressType.street[0] = $event),
              type: "text",
              class: normalizeClass({ "field-valid": $data.streetAddress1Valid && !$setup.getAddressFieldHasError($props.address_type, "Address Line 1") }),
              error: $setup.getAddressFieldHasError($props.address_type, "Address Line 1"),
              "error-message": $setup.getAddressFieldHasError($props.address_type, "Address Line 1") ? _ctx.$t("errorMessages.streetErrorMessage") : "",
              placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.addressField.placeholder"),
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.addressField.label"),
              autocomplete: "address-line1",
              required: "",
              onInput: _cache[1] || (_cache[1] = ($event) => $options.validateStreet($options.selectedAddressType.street[0])),
              onFocusout: _cache[2] || (_cache[2] = ($event) => $options.validateStreet($options.selectedAddressType.street[0]))
            }, null, 8, ["modelValue", "class", "error", "error-message", "placeholder", "label"]),
            $data.streetAddress1Valid && !$setup.getAddressFieldHasError($props.address_type, "Address Line 1") ? (openBlock(), createBlock(_component_ValidIcon, { key: 0 })) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_3$o, [
              createVNode(_component_ErrorIcon)
            ])
          ]),
          createBaseVNode("div", null, [
            createVNode(_component_TextInput, {
              modelValue: $options.selectedAddressType.street[1],
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $options.selectedAddressType.street[1] = $event),
              type: "text",
              class: normalizeClass({ "field-valid": $data.streetAddress2Valid && !$setup.getAddressFieldHasError($props.address_type, "Address Line 2") }),
              error: $setup.getAddressFieldHasError($props.address_type, "Address Line 2"),
              "error-message": $setup.getAddressFieldHasError($props.address_type, "Address Line 2") ? _ctx.$t("errorMessages.streetErrorMessage") : "",
              placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.addressField.unrequired"),
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.addressField.unrequiredLabel"),
              autocomplete: "address-line2",
              onInput: _cache[4] || (_cache[4] = ($event) => $options.validateStreet2($options.selectedAddressType.street[1])),
              onFocusout: _cache[5] || (_cache[5] = ($event) => $options.validateStreet2($options.selectedAddressType.street[1]))
            }, null, 8, ["modelValue", "class", "error", "error-message", "placeholder", "label"]),
            $data.streetAddress2Valid && !$setup.getAddressFieldHasError($props.address_type, "Address Line 2") ? (openBlock(), createBlock(_component_ValidIcon, { key: 0 })) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_4$g, [
              createVNode(_component_ErrorIcon)
            ])
          ]),
          createBaseVNode("div", null, [
            createVNode(_component_TextInput, {
              modelValue: $options.selectedAddressType.city,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $options.selectedAddressType.city = $event),
              type: "text",
              class: normalizeClass({ "field-valid": $data.cityValid && !$setup.getAddressFieldHasError($props.address_type, "City") }),
              error: $setup.getAddressFieldHasError($props.address_type, "City"),
              "error-message": $setup.getAddressFieldHasError($props.address_type, "City") ? _ctx.$t("errorMessages.cityErrorMessage") : "",
              placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.cityField.placeholder"),
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.cityField.label"),
              required: "",
              autocomplete: "address-level2",
              onInput: _cache[7] || (_cache[7] = ($event) => $options.validateCity($options.selectedAddressType.city)),
              onFocusout: _cache[8] || (_cache[8] = ($event) => $options.validateCity($options.selectedAddressType.city))
            }, null, 8, ["modelValue", "class", "error", "error-message", "placeholder", "label"]),
            $data.cityValid && !$setup.getAddressFieldHasError($props.address_type, "City") ? (openBlock(), createBlock(_component_ValidIcon, { key: 0 })) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_5$e, [
              createVNode(_component_ErrorIcon)
            ])
          ]),
          createBaseVNode("div", null, [
            _ctx.displayState && !$setup.getRegionOptions($props.address_type).length ? (openBlock(), createBlock(_component_TextInput, {
              key: 0,
              modelValue: $options.selectedAddressType.region.region,
              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $options.selectedAddressType.region.region = $event),
              class: normalizeClass({ "field-valid": $data.regionValid && !$setup.getAddressFieldHasError($props.address_type, "State/Region") }),
              type: "text",
              error: $setup.getAddressFieldHasError($props.address_type, "State/Region"),
              "error-message": $setup.getAddressFieldHasError($props.address_type, "State/Region") ? _ctx.$t("errorMessages.regionErrorMessage") : "",
              placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.regionField.placeholder"),
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.regionField.label"),
              autocomplete: "address-level1",
              required: $setup.getRegionRequired($props.address_type),
              onInput: _cache[10] || (_cache[10] = ($event) => $options.validateRegion($options.selectedAddressType.region)),
              onFocusout: _cache[11] || (_cache[11] = ($event) => $options.validateRegion($options.selectedAddressType.region))
            }, null, 8, ["modelValue", "class", "error", "error-message", "placeholder", "label", "required"])) : createCommentVNode("", true),
            $data.regionValid && !$setup.getAddressFieldHasError($props.address_type, "State/Region") ? (openBlock(), createBlock(_component_ValidIcon, { key: 1 })) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_6$c, [
              createVNode(_component_ErrorIcon)
            ])
          ]),
          _ctx.displayState && $setup.getRegionOptions($props.address_type).length ? (openBlock(), createBlock(_component_SelectInput, {
            key: 0,
            modelValue: $options.selectedAddressType.region.region_id,
            "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $options.selectedAddressType.region.region_id = $event),
            options: $setup.getRegionOptions($props.address_type),
            error: $setup.getAddressFieldHasError($props.address_type, "State/Region"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.regionField.label"),
            required: $setup.getRegionRequired($props.address_type),
            onChange: _cache[13] || (_cache[13] = ($event) => $options.setRegion($event))
          }, null, 8, ["modelValue", "options", "error", "label", "required"])) : createCommentVNode("", true),
          createBaseVNode("div", null, [
            createVNode(_component_TextInput, {
              modelValue: $options.selectedAddressType.postcode,
              "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => $options.selectedAddressType.postcode = $event),
              error: $setup.getAddressFieldHasError($props.address_type, "Postcode"),
              class: normalizeClass({ "field-valid": _ctx.postCodeValid && $options.selectedAddressType.postcode !== "" }),
              type: "text",
              placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressForm.postCodeField.placeholder"),
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.postCodeField.label"),
              autocomplete: "postal-code",
              required: _ctx.postcodeRequired($options.selectedAddressType.country_code),
              onInput: _cache[15] || (_cache[15] = ($event) => _ctx.validatePostcode($props.address_type, true)),
              onFocusout: _cache[16] || (_cache[16] = ($event) => _ctx.validatePostcode($props.address_type, true))
            }, null, 8, ["modelValue", "error", "class", "placeholder", "label", "required"]),
            _ctx.postCodeValid && $options.selectedAddressType.postcode !== "" ? (openBlock(), createBlock(_component_ValidIcon, { key: 0 })) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_7$a, [
              createVNode(_component_ErrorIcon)
            ]),
            $setup.getAddressFieldHasError($props.address_type, "Postcode") ? (openBlock(), createBlock(_component_ErrorMessage, {
              key: 1,
              message: `${_ctx.$t("errorMessages.postCodeErrorMessage")} ${$options.selectedAddressType.country_code}`
            }, null, 8, ["message"])) : createCommentVNode("", true)
          ]),
          createVNode(_component_SelectInput, {
            modelValue: $options.selectedAddressType.country_code,
            "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => $options.selectedAddressType.country_code = $event),
            options: $options.selectOptions,
            error: $setup.getAddressFieldHasError($props.address_type, "Country"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.countryField.label"),
            "selected-option": _ctx.$t("yourDetailsSection.selectPlaceholder"),
            required: "",
            onChange: _cache[18] || (_cache[18] = ($event) => $options.countryUpdated($event))
          }, null, 8, ["modelValue", "options", "error", "label", "selected-option"]),
          $setup.getAddressFieldHasError($props.address_type, "Country") ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 1,
            message: _ctx.$t("errorMessages.countryErrorMessage")
          }, null, 8, ["message"])) : createCommentVNode("", true),
          $data.requiredErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 2,
            message: $data.requiredErrorMessage
          }, null, 8, ["message"])) : createCommentVNode("", true),
          _ctx.isLoggedIn ? (openBlock(), createElementBlock("div", _hoisted_8$9, [
            createVNode(_component_CheckboxComponent, {
              id: `${$props.address_type}-save-in-address-book`,
              text: _ctx.$t("saveNewAddress"),
              checked: $options.selectedAddressType.save_in_address_book === 1,
              onChange: $options.handleSaveInAddressBookChange
            }, null, 8, ["id", "text", "checked", "onChange"])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", null, [
            $props.address_type !== "shipping" ? (openBlock(), createBlock(_component_MyButton, {
              key: 0,
              class: "select-address-btn",
              type: "submit",
              primary: "",
              disabled: !$data.buttonEnabled,
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.saveAddressButton")
            }, null, 8, ["disabled", "label"])) : createCommentVNode("", true)
          ])
        ], 32)
      ])
    ]);
  }
  var AddressForm = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$B], ["__scopeId", "data-v-ab106308"]]);
  const _sfc_main$A = {
    name: "ShippingForm",
    components: {
      AddressForm
    },
    data() {
      return {
        address_type: "shipping"
      };
    },
    computed: {
      ...mapState(useCustomerStore, ["selected"]),
      formErrors() {
        return this.selected.formErrors;
      }
    }
  };
  function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_AddressForm = resolveComponent("AddressForm");
    return openBlock(), createElementBlock("div", null, [
      createVNode(_component_AddressForm, { address_type: $data.address_type }, null, 8, ["address_type"])
    ]);
  }
  var ShippingForm = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$A]]);
  const _sfc_main$z = {
    name: "LinkComponent",
    props: {
      label: {
        type: String,
        required: true
      },
      dataCy: {
        type: String
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontSize: reactiveProps.fontSize
        }))
      };
    }
  };
  const _hoisted_1$x = ["data-cy"];
  function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("button", {
      type: "button",
      class: "button--link",
      style: normalizeStyle($setup.style),
      "data-cy": $props.dataCy ? $props.dataCy : "button"
    }, toDisplayString$1($props.label), 13, _hoisted_1$x);
  }
  var LinkComponent = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$z]]);
  const _sfc_main$y = {
    name: "Tick",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$w = ["role", "aria-label"];
  const _hoisted_2$q = /* @__PURE__ */ createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M0 7.5C0 5.51088 0.790176 3.60322 2.1967 2.1967C3.60322 0.790176 5.51088 0 7.5 0C9.48912 0 11.3968 0.790176 12.8033 2.1967C14.2098 3.60322 15 5.51088 15 7.5C15 9.48912 14.2098 11.3968 12.8033 12.8033C11.3968 14.2098 9.48912 15 7.5 15C5.51088 15 3.60322 14.2098 2.1967 12.8033C0.790176 11.3968 0 9.48912 0 7.5H0ZM7.072 10.71L11.39 5.312L10.61 4.688L6.928 9.289L4.32 7.116L3.68 7.884L7.072 10.711V10.71Z"
  }, null, -1);
  const _hoisted_3$n = [
    _hoisted_2$q
  ];
  function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 15 15",
      width: "25",
      height: "25"
    }, _hoisted_3$n, 12, _hoisted_1$w);
  }
  var Tick = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$y]]);
  const _sfc_main$x = {
    name: "BillingAddressIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$v = ["role", "aria-label"];
  const _hoisted_2$p = /* @__PURE__ */ createBaseVNode("path", {
    d: "M20 20H4C3.46957 20 2.96086 19.7893 2.58579 19.4142C2.21071 19.0391 2 18.5304 2 18V6C2 5.46957 2.21071 4.96086 2.58579 4.58579C2.96086 4.21071 3.46957 4 4 4H20C20.5304 4 21.0391 4.21071 21.4142 4.58579C21.7893 4.96086 22 5.46957 22 6V18C22 18.5304 21.7893 19.0391 21.4142 19.4142C21.0391 19.7893 20.5304 20 20 20ZM4 12V18H20V12H4ZM4 6V8H20V6H4ZM13 16H6V14H13V16Z",
    fill: "#3F5D7C"
  }, null, -1);
  const _hoisted_3$m = [
    _hoisted_2$p
  ];
  function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$m, 12, _hoisted_1$v);
  }
  var BillingAddressIcon = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$x]]);
  var shippingSvg = "/shippingIcon.svg";
  const _sfc_main$w = {
    name: "Shipping",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      shippingSvgIcon() {
        return `${getStaticUrl(shippingSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$u = ["src", "alt"];
  function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.shippingSvgIcon,
      alt: $options.shippingSvgIcon
    }, null, 8, _hoisted_1$u);
  }
  var Shipping = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$w]]);
  const _sfc_main$v = {
    name: "AddressList",
    components: {
      TextField,
      Tick,
      MyButton,
      BillingAddressIcon,
      Shipping
    },
    props: {
      addressType: {
        type: String,
        default: "shipping"
      },
      displayTitle: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        isShippingNewCTA: true,
        uniqueAddressList: [],
        addNewAddressButtonText: "",
        addNewAddressButtonTextId: "bluefinch-checkout-addnewaddress-button-text"
      };
    },
    computed: {
      ...mapState(useCustomerStore, ["customer", "selected"])
    },
    watch: {
      addressType: {
        immediate: true,
        handler(newVal) {
          if (newVal === "billing") {
            this.selectFirstAddress();
          }
        }
      }
    },
    mounted() {
      var _a;
      this.$emit("showAddressBlock", false);
      let selectedId = null;
      const selectedItem = this.customer.addresses.find((item) => item.id === this.selected[this.addressType].id);
      if (selectedItem) {
        selectedId = selectedItem.id;
      }
      this.$emit("passSelectedItemId", selectedId);
      const uniqueAddresses = {};
      this.customer.addresses.forEach((address) => {
        const identifier = `${address.city}-${address.postcode}-${address.street.join("-")}`;
        if (!uniqueAddresses[identifier]) {
          uniqueAddresses[identifier] = true;
          this.uniqueAddressList.push(address);
        }
      });
      this.addNewAddressButtonText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.addNewAddressButtonTextId]) || this.$t("addNewAddressBtn");
      document.addEventListener(this.addNewAddressButtonTextId, this.setAddNewAddressButtonText);
    },
    unmounted() {
      document.removeEventListener(this.addNewAddressButtonTextId, this.setAddNewAddressButtonText);
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "setAddressToStore",
        "createNewAddress",
        "removeAddressError",
        "setAddressAsEditing",
        "setAddressAsCustom",
        "createNewBillingAddress"
      ]),
      selectFirstAddress() {
        if (this.customer.addresses.length > 0) {
          const firstItem = this.customer.addresses[0];
          this.selectAddress(firstItem);
        }
      },
      selectAddress(address) {
        const clonedAddress = deepClone(address);
        this.setAddressToStore(clonedAddress, this.addressType);
        this.setAddressAsEditing(this.addressType, false);
        if (this.selected.billing.same_as_shipping) {
          this.setAddressToStore(clonedAddress, "billing");
        }
        this.$emit("selectedSavedAddress", true);
        this.$emit("passSelectedItemId", address.id);
        this.isShippingNewCTA = true;
      },
      newAddress() {
        this.isShippingNewCTA = false;
        this.removeAddressError(this.addressType, "Postcode");
        if (this.selected[this.addressType].region_id !== null) {
          this.selected[this.addressType].region_id = null;
        }
        if (this.addressType === "billing") {
          this.createNewBillingAddress("billing");
          this.setAddressAsCustom("billing");
          this.setAddressAsEditing("billing", true);
        } else {
          this.createNewAddress(this.addressType);
        }
      },
      setAddNewAddressButtonText(event) {
        var _a;
        this.addNewAddressButtonText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("addNewAddressBtn");
      }
    }
  };
  const _withScopeId$6 = (n) => (pushScopeId("data-v-c2bd3fb4"), n = n(), popScopeId(), n);
  const _hoisted_1$t = { class: "address-list" };
  const _hoisted_2$o = {
    key: 0,
    class: "delivery-section-title"
  };
  const _hoisted_3$l = { class: "delivery-section-title-text" };
  const _hoisted_4$f = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_5$d = { class: "address-list__list" };
  const _hoisted_6$b = ["onClick", "onKeydown"];
  const _hoisted_7$9 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
  const _hoisted_8$8 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
  const _hoisted_9$6 = { key: 2 };
  const _hoisted_10$6 = { key: 3 };
  const _hoisted_11$5 = { key: 4 };
  const _hoisted_12$4 = { key: 5 };
  const _hoisted_13$3 = {
    key: 0,
    class: "address-list__item-new"
  };
  function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Shipping = resolveComponent("Shipping");
    const _component_BillingAddressIcon = resolveComponent("BillingAddressIcon");
    const _component_TextField = resolveComponent("TextField");
    const _component_Tick = resolveComponent("Tick");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock("div", _hoisted_1$t, [
      $props.displayTitle ? (openBlock(), createElementBlock("div", _hoisted_2$o, [
        $props.addressType === "shipping" ? (openBlock(), createBlock(_component_Shipping, { key: 0 })) : createCommentVNode("", true),
        $props.addressType === "billing" ? (openBlock(), createBlock(_component_BillingAddressIcon, { key: 1 })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$l, [
          createVNode(_component_TextField, {
            text: _ctx.$t("yourDetailsSection.deliverySection.savedAddressesTitle", { addressType: $props.addressType })
          }, null, 8, ["text"])
        ]),
        _hoisted_4$f
      ])) : createCommentVNode("", true),
      createBaseVNode("ul", _hoisted_5$d, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.uniqueAddressList, (item) => {
          return openBlock(), createElementBlock("li", {
            tabindex: "0",
            key: item.id,
            class: normalizeClass(["address-list__item", { active: item.id === _ctx.selected[$props.addressType].id }]),
            onClick: ($event) => $options.selectAddress(item),
            "data-cy": "ship-here",
            onKeydown: ($event) => $options.selectAddress(item)
          }, [
            item.id === _ctx.selected[$props.addressType].id ? (openBlock(), createBlock(_component_Tick, { key: 0 })) : $props.addressType === "shipping" ? (openBlock(), createBlock(_component_TextField, {
              key: 1,
              class: "ship-here",
              text: _ctx.$t("yourDetailsSection.deliverySection.shipHere")
            }, null, 8, ["text"])) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.firstname) + " " + toDisplayString$1(item.lastname), 1),
            _hoisted_7$9,
            _hoisted_8$8,
            createTextVNode(" " + toDisplayString$1(item.street[0]), 1),
            item.street[0] ? (openBlock(), createElementBlock("br", _hoisted_9$6)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.street[1]), 1),
            item.street[1] ? (openBlock(), createElementBlock("br", _hoisted_10$6)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.city), 1),
            item.city ? (openBlock(), createElementBlock("br", _hoisted_11$5)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.postcode), 1),
            item.postcode ? (openBlock(), createElementBlock("br", _hoisted_12$4)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString$1(item.telephone), 1)
          ], 42, _hoisted_6$b);
        }), 128)),
        _ctx.selected[$props.addressType].id !== "custom" && $data.isShippingNewCTA ? (openBlock(), createElementBlock("li", _hoisted_13$3, [
          createVNode(_component_MyButton, {
            type: "button",
            secondary: "",
            label: $data.addNewAddressButtonText,
            onClick: $options.newAddress
          }, null, 8, ["label", "onClick"])
        ])) : createCommentVNode("", true)
      ])
    ]);
  }
  var AddressList = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v], ["__scopeId", "data-v-c2bd3fb4"]]);
  const _sfc_main$u = {
    name: "BillingForm",
    components: {
      TextField,
      AddressForm,
      AddressBlock,
      Edit,
      NameFields,
      CheckboxComponent,
      AddressFinder,
      AddressList,
      Locate
    },
    props: {
      showCheckbox: {
        type: Boolean,
        default: true
      }
    },
    emits: [
      "billingInfoFull"
    ],
    data() {
      return {
        address_type: "billing",
        customerInfoValidation: false,
        savedAddressActive: false,
        newAddressText: "",
        newAddressTextId: "bluefinch-checkout-new-address-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["cart", "isLoggedIn"]),
      ...mapState(useConfigStore, ["addressFinder"]),
      ...mapState(useCustomerStore, ["customer", "emailEntered", "selected", "isUsingSavedBillingAddress"]),
      ...mapState(useShippingMethodsStore, ["isClickAndCollect"])
    },
    mounted() {
      var _a;
      this.newAddressText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.newAddressTextId]) || this.$t("yourDetailsSection.deliverySection.newAddressTitle");
      document.addEventListener(this.newAddressTextId, this.setNewAddressText);
    },
    unmounted() {
      document.removeEventListener(this.newAddressTextId, this.setNewAddressText);
    },
    methods: {
      ...mapActions(useCustomerStore, [
        "setAddressAsEditing",
        "createNewAddress",
        "submitCustom",
        "setAddressAsCustom"
      ]),
      toggleBillingAddress(event) {
        if (!event.target.checked) {
          if (this.customer.addresses.length > 0) {
            this.savedAddressActive = true;
          }
          this.createNewAddress(this.address_type);
          this.selected[this.address_type].same_as_shipping = false;
          this.setAddressAsEditing(this.address_type, true);
        } else {
          this.savedAddressActive = false;
          this.selected[this.address_type] = deepClone(this.selected.shipping);
          this.selected[this.address_type].same_as_shipping = true;
          this.setAddressAsEditing(this.address_type, false);
        }
      },
      editBillingAddress() {
        this.setAddressAsEditing(this.address_type, true);
      },
      isCustomerInfoFull(value) {
        this.customerInfoValidation = value;
        this.$emit("billingInfoFull", value);
      },
      setNewAddressText(event) {
        var _a;
        this.newAddressText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("yourDetailsSection.deliverySection.newAddressTitle");
      }
    }
  };
  const _withScopeId$5 = (n) => (pushScopeId("data-v-f7977ea2"), n = n(), popScopeId(), n);
  const _hoisted_1$s = { class: "billing-address-not-same" };
  const _hoisted_2$n = { class: "address-block__checkbox" };
  const _hoisted_3$k = { class: "address-block__item" };
  const _hoisted_4$e = { class: "address-block__title-with-icon billing" };
  const _hoisted_5$c = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_6$a = { class: "billing-form-address" };
  function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_CheckboxComponent = resolveComponent("CheckboxComponent");
    const _component_AddressList = resolveComponent("AddressList");
    const _component_TextField = resolveComponent("TextField");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_Edit = resolveComponent("Edit");
    const _component_Locate = resolveComponent("Locate");
    const _component_NameFields = resolveComponent("NameFields");
    const _component_AddressFinder = resolveComponent("AddressFinder");
    const _component_AddressForm = resolveComponent("AddressForm");
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1$s, [
        createBaseVNode("div", _hoisted_2$n, [
          $props.showCheckbox && !_ctx.cart.is_virtual ? (openBlock(), createBlock(_component_CheckboxComponent, {
            key: 0,
            checked: _ctx.selected[$data.address_type].same_as_shipping,
            text: _ctx.$t("billingForm.notSameAddress"),
            onChange: $options.toggleBillingAddress
          }, null, 8, ["checked", "text", "onChange"])) : createCommentVNode("", true)
        ]),
        _ctx.emailEntered && _ctx.customer.addresses.length && (!_ctx.selected[$data.address_type].same_as_shipping || _ctx.cart.is_virtual) ? (openBlock(), createBlock(_component_AddressList, {
          key: 0,
          "display-title": true,
          "address-type": "billing"
        })) : createCommentVNode("", true),
        !_ctx.selected[$data.address_type].editing && (!_ctx.selected[$data.address_type].same_as_shipping || _ctx.isClickAndCollect || _ctx.cart.is_virtual) && _ctx.selected[$data.address_type].id && !_ctx.isUsingSavedBillingAddress ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["address-block", _ctx.customer.addresses.length > 0 ? "saved-address-active" : ""])
        }, [
          createVNode(_component_TextField, {
            class: "address-block__title selected",
            text: _ctx.$t("yourDetailsSection.deliverySection.selectedBillingAddressTitle")
          }, null, 8, ["text"]),
          createBaseVNode("div", _hoisted_3$k, [
            createBaseVNode("article", null, [
              createVNode(_component_AddressBlock, {
                address_type: $data.address_type,
                address: _ctx.selected[$data.address_type]
              }, null, 8, ["address_type", "address"])
            ])
          ]),
          _ctx.selected[$data.address_type].id ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "address-block__edit",
            tabindex: "0",
            onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.editBillingAddress && $options.editBillingAddress(...args), ["prevent"])),
            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.editBillingAddress && $options.editBillingAddress(...args), ["prevent"]), ["enter"]))
          }, [
            createVNode(_component_Edit)
          ], 32)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true)
      ]),
      ((_ctx.customer.addresses.length > 0 ? !_ctx.selected[$data.address_type].id && !$data.savedAddressActive : !_ctx.selected[$data.address_type].id) || _ctx.selected[$data.address_type].id === "custom" && _ctx.selected[$data.address_type].editing) && (!_ctx.selected[$data.address_type].same_as_shipping || _ctx.isClickAndCollect || _ctx.cart.is_virtual) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("div", _hoisted_4$e, [
          createVNode(_component_Locate),
          createVNode(_component_TextField, {
            class: "address-block__title",
            text: $data.newAddressText
          }, null, 8, ["text"]),
          _hoisted_5$c
        ]),
        createVNode(_component_NameFields, {
          address_type: $data.address_type,
          onIsCustomerInfoFull: $options.isCustomerInfoFull
        }, null, 8, ["address_type", "onIsCustomerInfoFull"]),
        createBaseVNode("div", _hoisted_6$a, [
          createBaseVNode("div", null, [
            !_ctx.selected[$data.address_type].id || _ctx.selected[$data.address_type].id === "custom" && _ctx.selected[$data.address_type].editing ? (openBlock(), createBlock(_component_AddressFinder, {
              key: 0,
              address_type: $data.address_type
            }, null, 8, ["address_type"])) : createCommentVNode("", true)
          ]),
          _ctx.selected[$data.address_type].editing || !_ctx.addressFinder.enabled ? (openBlock(), createBlock(_component_AddressForm, {
            key: 0,
            address_type: $data.address_type
          }, null, 8, ["address_type"])) : createCommentVNode("", true)
        ])
      ], 64)) : createCommentVNode("", true)
    ]);
  }
  var BillingForm = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u], ["__scopeId", "data-v-f7977ea2"]]);
  const _sfc_main$t = {
    name: "Newsletter",
    components: {
      Checkbox: CheckboxComponent
    },
    computed: {
      ...mapState(useConfigStore, ["newsletterEnabled", "newsletterAllowGuests"]),
      ...mapState(useCustomerStore, ["isLoggedIn", "newsletter"])
    },
    methods: {
      ...mapActions(useCustomerStore, ["updateNewsletterSubscription"]),
      changeNewsletterSubscription(event) {
        const { target } = event;
        if (typeof target.checked !== "undefined") {
          this.updateNewsletterSubscription(target.checked);
        }
      }
    }
  };
  const _hoisted_1$r = {
    key: 0,
    class: "newsletter-container"
  };
  function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Checkbox = resolveComponent("Checkbox");
    return _ctx.newsletterEnabled && (!_ctx.isLoggedIn && _ctx.newsletterAllowGuests || _ctx.isLoggedIn && !_ctx.newsletter.isSubscribed) ? (openBlock(), createElementBlock("div", _hoisted_1$r, [
      createVNode(_component_Checkbox, {
        id: "newsletter-signup",
        checked: _ctx.newsletter.subscribeToNewsletter,
        text: _ctx.$t("newsletter.label"),
        "change-handler": $options.changeNewsletterSubscription
      }, null, 8, ["checked", "text", "change-handler"])
    ])) : createCommentVNode("", true);
  }
  var Newsletter = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t], ["__scopeId", "data-v-d14efae6"]]);
  const _sfc_main$s = {
    name: "Present",
    props: {
      width: {
        type: String,
        default: "20"
      },
      height: {
        type: String,
        default: "20"
      },
      fill: {
        type: String
      },
      stroke: {
        type: String,
        default: "currentColor"
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$q = ["role", "aria-label", "width", "height"];
  const _hoisted_2$m = ["stroke"];
  function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: $props.width,
      height: $props.height,
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      createBaseVNode("path", {
        d: "M9.99874 6.00052V18.9987M2.99972 9.99996H16.9978M2.99972 9.99996C2.46936 9.99996 1.96072 9.78928 1.5857 9.41426C1.21068 9.03924 1 8.5306 1 8.00024C1 7.46989 1.21068 6.96125 1.5857 6.58623C1.96072 6.21121 2.46936 6.00052 2.99972 6.00052H16.9978C17.5281 6.00052 18.0368 6.21121 18.4118 6.58623C18.7868 6.96125 18.9975 7.46989 18.9975 8.00024C18.9975 8.5306 18.7868 9.03924 18.4118 9.41426C18.0368 9.78928 17.5281 9.99996 16.9978 9.99996M2.99972 9.99996V16.999C2.99972 17.5293 3.2104 18.038 3.58543 18.413C3.96045 18.788 4.46908 18.9987 4.99944 18.9987H14.998C15.5284 18.9987 16.037 18.788 16.4121 18.413C16.7871 18.038 16.9978 17.5293 16.9978 16.999V9.99996M9.99874 6.00052V4.0008C9.99874 3.6053 10.116 3.21867 10.3358 2.88982C10.5555 2.56097 10.8678 2.30466 11.2332 2.1533C11.5986 2.00195 12.0007 1.96235 12.3886 2.03951C12.7765 2.11667 13.1328 2.30712 13.4125 2.58679C13.6921 2.86645 13.8826 3.22277 13.9598 3.61068C14.0369 3.99858 13.9973 4.40066 13.846 4.76606C13.6946 5.13146 13.4383 5.44378 13.1094 5.66351C12.7806 5.88324 12.394 6.00052 11.9985 6.00052H9.99874ZM9.99874 6.00052V3.50087C9.99874 3.00649 9.85214 2.52321 9.57748 2.11214C9.30281 1.70108 8.91242 1.38069 8.45567 1.1915C7.99892 1.0023 7.49632 0.952802 7.01143 1.04925C6.52655 1.1457 6.08115 1.38377 5.73157 1.73335C5.38199 2.08294 5.14392 2.52833 5.04747 3.01322C4.95102 3.4981 5.00052 4.0007 5.18972 4.45745C5.37891 4.9142 5.6993 5.30459 6.11036 5.57926C6.52143 5.85392 7.00471 6.00052 7.49909 6.00052H9.99874Z",
        stroke: $props.stroke,
        "stroke-width": "1.5",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      }, null, 8, _hoisted_2$m)
    ], 12, _hoisted_1$q);
  }
  var Present = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s]]);
  const _sfc_main$r = {
    name: "GoogleMap",
    props: {
      lat: {
        type: Number,
        required: true,
        default: 0
      },
      lng: {
        type: Number,
        required: true,
        default: 0
      },
      zoom: {
        type: Number,
        default: 14
      }
    },
    computed: {
      ...mapState(useConfigStore, ["custom"])
    }
  };
  const _hoisted_1$p = {
    ref: "googleMap",
    class: "google-map-container"
  };
  function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$p, null, 512);
  }
  var GoogleMap = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r], ["__scopeId", "data-v-98e8d4ae"]]);
  var formatClickAndCollectAddress = (location2) => {
    const fullAddress = [
      location2.address,
      location2.city,
      location2.county,
      location2.postcode
    ];
    const removedEmpty = fullAddress.filter((addressLine) => addressLine);
    return removedEmpty.join(", ");
  };
  const _sfc_main$q = {
    name: "ClickAndCollectLocation",
    components: {
      ArrowDown,
      ArrowUp,
      Present,
      GoogleMap,
      LinkComponent,
      TextField
    },
    props: {
      location: {
        type: Object,
        default: () => {
        }
      }
    },
    data() {
      return {
        infoOpen: false
      };
    },
    computed: {
      ...mapState(useConfigStore, ["countryCode"]),
      formattedMiles() {
        return this.location.miles.toFixed(2);
      },
      formattedLat() {
        return parseFloat(this.location.lat);
      },
      formattedLng() {
        return parseFloat(this.location.long);
      },
      formattedAddress() {
        return formatClickAndCollectAddress(this.location);
      }
    },
    methods: {
      ...mapActions(useCustomerStore, ["setAddressToStore"]),
      ...mapActions(useShippingMethodsStore, ["setAsClickAndCollect", "setClickAndCollectLocation"]),
      async selectAddress(location2) {
        await this.setAsClickAndCollect(location2.site_number);
        const newAddress = {
          id: "clickAndCollect",
          company: location2.siteName,
          street: [location2.address],
          city: location2.city,
          country_code: this.countryCode,
          region: location2.county,
          region_id: 0,
          postcode: location2.postcode
        };
        this.setAddressToStore(newAddress, "shipping");
        this.setClickAndCollectLocation(location2);
      }
    }
  };
  const _hoisted_1$o = { class: "click-and-collect-location" };
  const _hoisted_2$l = { class: "click-and-collect-title click-and-collect-semibold" };
  const _hoisted_3$j = { class: "click-and-collect-title" };
  const _hoisted_4$d = { key: 0 };
  const _hoisted_5$b = { class: "click-and-collect-opening-times" };
  function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Present = resolveComponent("Present");
    const _component_ArrowUp = resolveComponent("ArrowUp");
    const _component_ArrowDown = resolveComponent("ArrowDown");
    const _component_LinkComponent = resolveComponent("LinkComponent");
    const _component_TextField = resolveComponent("TextField");
    const _component_GoogleMap = resolveComponent("GoogleMap");
    return openBlock(), createElementBlock("div", _hoisted_1$o, [
      createBaseVNode("div", null, [
        createBaseVNode("span", _hoisted_2$l, toDisplayString$1($props.location.site_name) + " - ", 1),
        createBaseVNode("span", _hoisted_3$j, toDisplayString$1(_ctx.$t("yourDetailsSection.deliverySection.addressForm.collectionDistance", { distance: $options.formattedMiles })), 1)
      ]),
      createBaseVNode("p", null, toDisplayString$1($options.formattedAddress), 1),
      createBaseVNode("div", {
        class: "click-and-collect-map-title",
        onClick: _cache[0] || (_cache[0] = ($event) => $data.infoOpen = !$data.infoOpen),
        onKeydown: _cache[1] || (_cache[1] = ($event) => $data.infoOpen = !$data.infoOpen)
      }, [
        createVNode(_component_Present),
        createTextVNode(" " + toDisplayString$1(_ctx.$t("yourDetailsSection.deliverySection.addressForm.viewMapAndHours")) + " ", 1),
        $data.infoOpen ? (openBlock(), createBlock(_component_ArrowUp, {
          key: 0,
          height: "9",
          stroke: "black",
          width: "12"
        })) : (openBlock(), createBlock(_component_ArrowDown, {
          key: 1,
          height: "9",
          width: "12"
        }))
      ], 32),
      createBaseVNode("div", null, [
        createVNode(_component_LinkComponent, {
          class: "click-and-collect-select",
          label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.selectLocation"),
          onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $options.selectAddress($props.location), ["prevent"]))
        }, null, 8, ["label"])
      ]),
      $data.infoOpen ? (openBlock(), createElementBlock("div", _hoisted_4$d, [
        createVNode(_component_TextField, {
          class: "click-and-collect-title click-and-collect-semibold",
          text: _ctx.$t("yourDetailsSection.deliverySection.clickandCollectOpeningTimes")
        }, null, 8, ["text"]),
        createBaseVNode("div", _hoisted_5$b, [
          createVNode(_component_TextField, {
            text: _ctx.$t("days.monday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.monday_open} - ${$props.location.monday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.tuesday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.tuesday_open} - ${$props.location.tuesday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.wednesday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.wednesday_open} - ${$props.location.wednesday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.thursday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.thursday_open} - ${$props.location.thursday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.friday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.friday_open} - ${$props.location.friday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.saturday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.saturday_open} - ${$props.location.saturday_close}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.$t("days.sunday")
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: `${$props.location.sunday_open} - ${$props.location.sunday_close}`
          }, null, 8, ["text"])
        ])
      ])) : createCommentVNode("", true),
      $data.infoOpen ? (openBlock(), createBlock(_component_GoogleMap, {
        key: 1,
        lat: $options.formattedLat,
        lng: $options.formattedLng
      }, null, 8, ["lat", "lng"])) : createCommentVNode("", true)
    ]);
  }
  var ClickAndCollectLocation = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q], ["__scopeId", "data-v-192be9ac"]]);
  var getClickAndCollectLocations = (search) => {
    const url = "https://api.collectplus.yodel.co.uk/api/v1/agentlocator/skatehut/AgentLocator.json";
    const query = `?searchCriteria=${search}&maxRecords=20`;
    return axios.get(`${url}${query}`).then((response) => response.data);
  };
  var getUsersPostcode = () => new Promise((resolve2) => {
    if (navigator.geolocation) {
      const options = {
        enableHighAccuracy: false,
        timeout: 5e3,
        maximumAge: 0
      };
      const success = async (position) => {
        const { custom: { googleMapKey } } = useConfigStore();
        const { coords = {} } = position;
        const { latitude, longitude } = coords;
        const latLng = `${latitude},${longitude}`;
        const url = "https://maps.googleapis.com/maps/api/geocode/json";
        const addressData = await axios.get(`${url}?key=${googleMapKey}&latlng=${encodeURIComponent(latLng)}`, {
          method: "GET",
          cache: "no-cache"
        }).then((response) => response.data);
        const { results = [] } = addressData;
        const postcode = results.reduce((prev, curr) => {
          if (prev) {
            return prev;
          }
          const { address_components: addressComponents = [] } = curr;
          return addressComponents.find((component) => component.types.includes("postal_code") && component.short_name).short_name;
        }, null);
        resolve2(postcode);
      };
      const error = (err) => {
        console.warn(`ERROR(${err.code}): ${err.message}`);
        resolve2(null);
      };
      navigator.geolocation.getCurrentPosition(success, error, options);
    } else {
      resolve2(null);
    }
  });
  const _sfc_main$p = {
    name: "ClickAndCollect",
    components: {
      ClickAndCollectLocation,
      LinkComponent,
      Search,
      TextField,
      TextInput,
      NameFields,
      MyButton,
      AddressBlock,
      AddressList,
      BillingForm,
      GoogleMap
    },
    data() {
      return {
        query: "",
        foundLocations: [],
        customerInfoValidation: false,
        customInfoSubmitted: false,
        isAddressBlockVisible: true,
        queryTimeout: null,
        postcodeError: false,
        postcodeErrorMessage: ""
      };
    },
    computed: {
      ...mapState(useCustomerStore, [
        "customer",
        "selected"
      ]),
      ...mapState(useShippingMethodsStore, ["clickAndCollectLocation", "setClickAndCollectLocation"])
    },
    async mounted() {
      this.customInfoSubmitted = this.selected.shipping.firstname && this.selected.shipping.lastname;
      if (this.selected.shipping.id && !Object.keys(this.clickAndCollectLocation).length) {
        const locations = await getClickAndCollectLocations(this.selected.shipping.postcode);
        if (locations.agents.length) {
          const [location2] = locations.agents;
          this.setClickAndCollectLocation(location2);
        }
      }
    },
    methods: {
      ...mapActions(useCustomerStore, ["setAddressToStore", "setAddressAsEditing"]),
      ...mapActions(useLoadingStore, ["setLoadingState"]),
      ...mapActions(useShippingMethodsStore, ["clearShippingMethodCache", "submitShippingInfo"]),
      ...mapActions(useStepsStore, ["goToShipping"]),
      async useMyLocation() {
        this.postcodeError = false;
        this.postcodeErrorMessage = "";
        this.setLoadingState(true);
        const postcode = await getUsersPostcode();
        if (postcode) {
          this.query = postcode;
          this.getLocations();
        } else {
          this.postcodeError = true;
          this.postcodeErrorMessage = this.$t("errorMessages.postcodeLookup");
          this.setLoadingState(false);
        }
      },
      editShippingAdress() {
        const emptyAddress = getEmptyAddress();
        const newAddress = Object.assign(emptyAddress, {
          firstname: this.selected.shipping.firstname,
          lastname: this.selected.shipping.lastname,
          telephone: this.selected.shipping.telephone
        });
        this.setAddressToStore(newAddress, "shipping");
      },
      getLocations() {
        if (this.queryTimeout) {
          clearTimeout(this.queryTimeout);
        }
        this.postcodeError = false;
        this.postcodeErrorMessage = "";
        this.queryTimeout = setTimeout(async () => {
          if (this.query) {
            const locations = await getClickAndCollectLocations(this.query);
            this.foundLocations = locations.agents;
            this.setLoadingState(false);
          }
          this.queryTimeout = null;
        }, 1e3);
      },
      showAddressBlock(value) {
        this.isAddressBlockVisible = value;
      },
      isCustomerInfoFull(value) {
        this.customerInfoValidation = value;
      },
      submitCollectionDetails() {
        this.customInfoSubmitted = true;
      },
      async submitClickAndCollect() {
        this.clearShippingMethodCache();
        this.goToShipping();
      }
    }
  };
  const _hoisted_1$n = { class: "click-and-collect-container" };
  const _hoisted_2$k = { class: "click-and-collect-title-container" };
  const _hoisted_3$i = { key: 0 };
  const _hoisted_4$c = { class: "click-and-collect-input" };
  const _hoisted_5$a = {
    key: 0,
    class: "click-and-collect-container"
  };
  const _hoisted_6$9 = { class: "click-and-collect-locations" };
  const _hoisted_7$8 = {
    key: 4,
    class: "click-and-collect-container"
  };
  const _hoisted_8$7 = { class: "click-and-collect-title-container" };
  const _hoisted_9$5 = { key: 0 };
  const _hoisted_10$5 = { key: 1 };
  const _hoisted_11$4 = {
    key: 5,
    class: "click-and-collect-container"
  };
  const _hoisted_12$3 = { class: "click-and-collect-billing" };
  function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_LinkComponent = resolveComponent("LinkComponent");
    const _component_TextInput = resolveComponent("TextInput");
    const _component_Search = resolveComponent("Search");
    const _component_ClickAndCollectLocation = resolveComponent("ClickAndCollectLocation");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_GoogleMap = resolveComponent("GoogleMap");
    const _component_NameFields = resolveComponent("NameFields");
    const _component_MyButton = resolveComponent("MyButton");
    const _component_AddressList = resolveComponent("AddressList");
    const _component_BillingForm = resolveComponent("BillingForm");
    return openBlock(), createElementBlock("div", _hoisted_1$n, [
      createBaseVNode("div", _hoisted_2$k, [
        createVNode(_component_TextField, {
          class: "click-and-collect-title click-and-collect-semibold",
          text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.collectLocations")
        }, null, 8, ["text"]),
        _ctx.selected.shipping.id ? (openBlock(), createBlock(_component_LinkComponent, {
          key: 0,
          label: _ctx.$t("yourDetailsSection.editButton"),
          onClick: withModifiers($options.editShippingAdress, ["prevent"])
        }, null, 8, ["label", "onClick"])) : createCommentVNode("", true)
      ]),
      !_ctx.selected.shipping.id ? (openBlock(), createElementBlock("div", _hoisted_3$i, [
        createBaseVNode("div", _hoisted_4$c, [
          createVNode(_component_TextInput, {
            modelValue: $data.query,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.query = $event),
            type: "text",
            placeholder: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.placeholder"),
            label: _ctx.$t("yourDetailsSection.deliverySection.addressFinder.label"),
            required: "",
            error: $data.postcodeError,
            "error-message": $data.postcodeErrorMessage,
            onInput: $options.getLocations
          }, null, 8, ["modelValue", "placeholder", "label", "error", "error-message", "onInput"]),
          createVNode(_component_Search, { stroke: "black" })
        ]),
        createVNode(_component_LinkComponent, {
          label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.useMyLocation"),
          class: "click-and-collect-use-location",
          onClick: withModifiers($options.useMyLocation, ["prevent"])
        }, null, 8, ["label", "onClick"]),
        $data.query && !$data.queryTimeout ? (openBlock(), createElementBlock("div", _hoisted_5$a, [
          createVNode(_component_TextField, {
            class: "click-and-collect-title click-and-collect-semibold",
            text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.closestLocations")
          }, null, 8, ["text"]),
          createBaseVNode("div", _hoisted_6$9, [
            !$data.foundLocations.length ? (openBlock(), createBlock(_component_TextField, {
              key: 0,
              text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.noLocations")
            }, null, 8, ["text"])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.foundLocations, (location2) => {
              return openBlock(), createBlock(_component_ClickAndCollectLocation, {
                key: location2.site_number,
                location: location2
              }, null, 8, ["location"]);
            }), 128))
          ])
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true),
      _ctx.selected.shipping.id ? (openBlock(), createBlock(_component_TextField, {
        key: 1,
        text: `${_ctx.clickAndCollectLocation.site_name} -
        ${_ctx.$t("yourDetailsSection.deliverySection.addressForm.collectionDistance", { distance: _ctx.clickAndCollectLocation.miles.toFixed(2) })}`
      }, null, 8, ["text"])) : createCommentVNode("", true),
      _ctx.selected.shipping.id ? (openBlock(), createBlock(_component_AddressBlock, {
        key: 2,
        class: "click-and-collect-address",
        "show-name-fields": false,
        address_type: `shipping`,
        address: _ctx.selected.shipping
      }, null, 8, ["address"])) : createCommentVNode("", true),
      _ctx.selected.shipping.id && _ctx.clickAndCollectLocation.lat && _ctx.clickAndCollectLocation.long ? (openBlock(), createBlock(_component_GoogleMap, {
        key: 3,
        lat: _ctx.clickAndCollectLocation.lat,
        lng: _ctx.clickAndCollectLocation.long
      }, null, 8, ["lat", "lng"])) : createCommentVNode("", true),
      _ctx.selected.shipping.id ? (openBlock(), createElementBlock("div", _hoisted_7$8, [
        createBaseVNode("div", _hoisted_8$7, [
          createVNode(_component_TextField, {
            class: "click-and-collect-title click-and-collect-semibold",
            text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.collectionName")
          }, null, 8, ["text"]),
          _ctx.selected.shipping.id && $data.customInfoSubmitted ? (openBlock(), createBlock(_component_LinkComponent, {
            key: 0,
            label: _ctx.$t("yourDetailsSection.editButton"),
            onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $data.customInfoSubmitted = false, ["prevent"]))
          }, null, 8, ["label"])) : createCommentVNode("", true)
        ]),
        !$data.customInfoSubmitted ? (openBlock(), createElementBlock("div", _hoisted_9$5, [
          createVNode(_component_NameFields, {
            address_type: "shipping",
            onIsCustomerInfoFull: $options.isCustomerInfoFull
          }, null, 8, ["onIsCustomerInfoFull"]),
          createVNode(_component_MyButton, {
            class: "click-and-collect-container",
            type: "submit",
            primary: "",
            label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.submitCollectionDetails"),
            disabled: !$data.customerInfoValidation,
            onClick: $options.submitCollectionDetails
          }, null, 8, ["label", "disabled", "onClick"])
        ])) : (openBlock(), createElementBlock("div", _hoisted_10$5, [
          createVNode(_component_TextField, {
            text: `${_ctx.selected.shipping.firstname} ${_ctx.selected.shipping.lastname}`
          }, null, 8, ["text"]),
          createVNode(_component_TextField, {
            text: _ctx.selected.shipping.telephone
          }, null, 8, ["text"])
        ]))
      ])) : createCommentVNode("", true),
      _ctx.selected.shipping.id && $data.customInfoSubmitted ? (openBlock(), createElementBlock("div", _hoisted_11$4, [
        createVNode(_component_TextField, {
          class: "click-and-collect-title click-and-collect-semibold",
          text: _ctx.$t("yourDetailsSection.deliverySection.addressForm.collectionBillingTitle")
        }, null, 8, ["text"]),
        createBaseVNode("div", _hoisted_12$3, [
          _ctx.customer.addresses.length ? (openBlock(), createBlock(_component_AddressList, {
            key: 0,
            "display-title": false,
            "address-type": "billing",
            onShowAddressBlock: $options.showAddressBlock
          }, null, 8, ["onShowAddressBlock"])) : createCommentVNode("", true),
          createVNode(_component_BillingForm, {
            "show-checkbox": false,
            class: "click-and-collect-address"
          })
        ]),
        !_ctx.selected.billing.editing ? (openBlock(), createBlock(_component_MyButton, {
          key: 0,
          disabled: !_ctx.selected.billing.id,
          class: "click-and-collect-container",
          type: "submit",
          primary: "",
          label: _ctx.$t("yourDetailsSection.deliverySection.toShippingButton"),
          onClick: _cache[2] || (_cache[2] = ($event) => {
            $options.submitClickAndCollect();
          })
        }, null, 8, ["disabled", "label"])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ]);
  }
  var ClickAndCollect = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p], ["__scopeId", "data-v-55da53a6"]]);
  const _sfc_main$o = {
    name: "ProgressBarArrow",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$m = ["role", "aria-label"];
  const _hoisted_2$j = /* @__PURE__ */ createBaseVNode("path", {
    d: "M90.8536 4.35355C91.0488 4.15829 91.0488 3.84171 90.8536 3.64645L87.6716 0.464466C87.4763 0.269204 87.1597 0.269204 86.9645 0.464466C86.7692 0.659728 86.7692 0.976311 86.9645 1.17157L89.7929 4L86.9645 6.82843C86.7692 7.02369 86.7692 7.34027 86.9645 7.53553C87.1597 7.7308 87.4763 7.7308 87.6716 7.53553L90.8536 4.35355ZM0 4.5H90.5V3.5H0V4.5Z",
    fill: "#3F5D7C"
  }, null, -1);
  const _hoisted_3$h = [
    _hoisted_2$j
  ];
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      xmlns: "http://www.w3.org/2000/svg",
      width: "91",
      height: "8",
      viewBox: "0 0 91 8",
      fill: "none"
    }, _hoisted_3$h, 12, _hoisted_1$m);
  }
  var ProgressBarArrow = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
  const _sfc_main$n = {
    name: "StepCompletedIcon",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$l = ["role", "aria-label"];
  const _hoisted_2$i = /* @__PURE__ */ createBaseVNode("path", {
    d: "M11.2999 0C11.7692 0 12.2385 0 12.7051 0C13.1214 0.0530388 13.5403 0.0928179 13.9539 0.16442C16.8147 0.662985 19.2168 1.99956 21.0966 4.21393C23.4748 7.01438 24.4028 10.2657 23.8407 13.8988C23.39 16.8212 21.9874 19.2504 19.7285 21.1545C17.1567 23.3238 14.166 24.252 10.8148 23.9417C8.64597 23.7402 6.67338 22.9764 4.92616 21.6716C2.36233 19.7569 0.768884 17.227 0.188244 14.0712C0.106053 13.6204 0.0609805 13.1642 0 12.7081C0 12.2387 0 11.7693 0 11.3026C0.0212106 11.1408 0.0424212 10.979 0.0609805 10.8173C0.315508 8.45703 1.16658 6.34079 2.66723 4.50034C4.56823 2.16398 7.0048 0.708068 9.98224 0.182984C10.4171 0.106078 10.8598 0.0609946 11.2999 0ZM11.2522 13.7211C11.1356 13.5965 11.0401 13.4931 10.9447 13.3896C10.189 12.5675 9.43341 11.7454 8.67248 10.926C8.36758 10.5945 7.99109 10.4566 7.55097 10.5812C7.09759 10.7112 6.82451 11.0241 6.73436 11.4855C6.64422 11.9443 6.798 12.3315 7.10555 12.6657C8.15547 13.8139 9.216 14.949 10.2527 16.1079C10.7273 16.6383 11.6101 16.8133 12.2359 16.1344C13.9804 14.2462 15.7701 12.4031 17.5253 10.5255C17.7241 10.3134 17.8726 10.0137 17.9389 9.72996C18.1377 8.89725 17.6021 8.23692 16.8147 8.29261C16.4912 8.31648 16.25 8.48886 16.0326 8.71692C14.927 9.87582 13.8214 11.0347 12.7158 12.191C12.2359 12.6922 11.756 13.1934 11.2549 13.7185L11.2522 13.7211Z",
    fill: "#00B2AD"
  }, null, -1);
  const _hoisted_3$g = [
    _hoisted_2$i
  ];
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$g, 12, _hoisted_1$l);
  }
  var StepCompletedIcon = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
  const _sfc_main$m = {
    name: "ProgressBar",
    components: {
      ProgressBarArrow,
      TextField,
      StepCompletedIcon
    },
    computed: {
      ...mapState(useStepsStore, ["yourDetailsActive", "shippingActive", "paymentActive"]),
      ...mapState(useConfigStore, ["progressBarVisible"])
    },
    methods: {
      ...mapActions(useStepsStore, ["goToYouDetails", "goToShipping", "goToPayment"])
    }
  };
  const _withScopeId$4 = (n) => (pushScopeId("data-v-66c8b928"), n = n(), popScopeId(), n);
  const _hoisted_1$k = {
    key: 0,
    class: "progress-bar-container",
    id: "progress-bar"
  };
  const _hoisted_2$h = {
    key: 1,
    class: "number active"
  };
  const _hoisted_3$f = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("p", null, "1", -1));
  const _hoisted_4$b = [
    _hoisted_3$f
  ];
  const _hoisted_5$9 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("p", null, "2", -1));
  const _hoisted_6$8 = [
    _hoisted_5$9
  ];
  const _hoisted_7$7 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("p", null, "3", -1));
  const _hoisted_8$6 = [
    _hoisted_7$7
  ];
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_StepCompletedIcon = resolveComponent("StepCompletedIcon");
    const _component_TextField = resolveComponent("TextField");
    const _component_router_link = resolveComponent("router-link");
    const _component_ProgressBarArrow = resolveComponent("ProgressBarArrow");
    return _ctx.progressBarVisible ? (openBlock(), createElementBlock("div", _hoisted_1$k, [
      createVNode(_component_router_link, {
        "aria-label": "progress-bar-link to-details-page",
        to: "/checkout",
        class: "details active",
        onClick: _ctx.goToYouDetails
      }, {
        default: withCtx(() => [
          _ctx.shippingActive ? (openBlock(), createBlock(_component_StepCompletedIcon, { key: 0 })) : createCommentVNode("", true),
          !_ctx.shippingActive ? (openBlock(), createElementBlock("div", _hoisted_2$h, _hoisted_4$b)) : createCommentVNode("", true),
          createVNode(_component_TextField, {
            class: "details-text",
            text: _ctx.$t("progressBar.detailStepTitle")
          }, null, 8, ["text"])
        ]),
        _: 1
      }, 8, ["onClick"]),
      createBaseVNode("div", {
        class: normalizeClass(["progress-bar-arrow", { active: _ctx.shippingActive }])
      }, [
        createVNode(_component_ProgressBarArrow)
      ], 2),
      createVNode(_component_router_link, {
        "aria-label": "progress-bar-link to-shipping-page",
        to: _ctx.shippingActive ? "/shipping" : "",
        class: normalizeClass([{ active: _ctx.shippingActive }, "shipping"]),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.shippingActive ? _ctx.goToShipping() : null)
      }, {
        default: withCtx(() => [
          _ctx.paymentActive ? (openBlock(), createBlock(_component_StepCompletedIcon, { key: 0 })) : createCommentVNode("", true),
          !_ctx.paymentActive ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(["number", { active: _ctx.shippingActive }])
          }, _hoisted_6$8, 2)) : createCommentVNode("", true),
          createVNode(_component_TextField, {
            text: _ctx.$t("progressBar.shippingStepTitle")
          }, null, 8, ["text"])
        ]),
        _: 1
      }, 8, ["to", "class"]),
      createBaseVNode("div", {
        class: normalizeClass(["progress-bar-arrow", { active: _ctx.paymentActive }])
      }, [
        createVNode(_component_ProgressBarArrow)
      ], 2),
      createVNode(_component_router_link, {
        "aria-label": "progress-bar-link to-payment-page",
        to: _ctx.paymentActive ? "/payments" : "",
        class: normalizeClass([{ active: _ctx.paymentActive }, "payment"]),
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.paymentActive ? _ctx.goToPayment() : null)
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(["number", { active: _ctx.paymentActive }])
          }, _hoisted_8$6, 2),
          createVNode(_component_TextField, {
            text: _ctx.$t("progressBar.paymentStepTitle")
          }, null, 8, ["text"])
        ]),
        _: 1
      }, 8, ["to", "class"])
    ])) : createCommentVNode("", true);
  }
  var ProgressBar = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m], ["__scopeId", "data-v-66c8b928"]]);
  const _sfc_main$l = {
    name: "YourDetailComponent",
    components: {
      TextField,
      PayWith,
      YourDetails,
      DividerComponent,
      Locate,
      AddressFinder,
      NameFields,
      ShippingForm,
      AddressBlock,
      Edit,
      EmailAddress,
      LinkComponent,
      AddressList,
      BraintreeGooglePay,
      BraintreeApplePay,
      BraintreePayPal,
      ErrorMessage,
      BillingForm,
      Newsletter,
      MyButton,
      ClickAndCollect,
      ProgressBar,
      Recaptcha,
      Agreements,
      DeliveryTabIcon,
      ClickCollectTabIcon
    },
    props: {
      address_type: {
        type: String,
        default: "shipping"
      }
    },
    data() {
      return {
        isAddressBlockVisible: true,
        savedAddressID: null,
        customerInfoValidation: false,
        billingInfoValidation: false,
        addressFormErrorMessage: false,
        storedKey: 0,
        instantCheckoutText: "",
        instantCheckoutTextId: "bluefinch-checkout-instantcheckout-text",
        yourDetailsText: "",
        yourDetailsTextId: "bluefinch-checkout-your-details-text",
        deliverWhereText: "",
        deliverWhereTextId: "bluefinch-checkout-deliver-where-text",
        newAddressText: "",
        newAddressTextId: "bluefinch-checkout-new-address-text",
        proceedToShippingText: "",
        proceedToShippingTextId: "bluefinch-checkout-proceedtoshipping-text",
        proceedToPayText: "",
        proceedToPayTextId: "bluefinch-checkout-proceedtopay-text",
        homeDeliveryText: "",
        homeDeliveryTextId: "bluefinch-checkout-homedelivery-text",
        clickAndCollectText: "",
        clickAndCollectTextId: "bluefinch-checkout-clickandcollect-text",
        buttonEnabled: false,
        addressInfoWrong: false
      };
    },
    computed: {
      ...mapState(useCartStore, ["cart", "cartEmitter", "subtotalInclTax"]),
      ...mapState(useConfigStore, ["addressFinder", "custom", "storeCode", "clickCollectTabsEnabled"]),
      ...mapState(useCustomerStore, [
        "inputsSanitiseError",
        "customer",
        "isLoggedIn",
        "emailEntered",
        "selected",
        "isUsingSavedShippingAddress"
      ]),
      ...mapState(useShippingMethodsStore, ["isClickAndCollect"]),
      ...mapState(usePaymentStore, ["errorMessage", "isExpressPaymentsVisible"]),
      ...mapState(useBraintreeStore, ["paypal"])
    },
    created() {
      this.cartEmitter.on("cartUpdated", async () => {
        this.storedKey += 1;
      });
      const customerStore = useCustomerStore();
      customerStore.$subscribe((mutation) => {
        if (mutation.type === "direct" || mutation.type === "patch object" && mutation.payload.selected && mutation.payload.selected[this.address_type]) {
          this.updateButtonState();
        }
      }, { flush: "sync" });
      this.updateButtonState();
    },
    async mounted() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      await this.getInitialConfig();
      await this.getCart();
      const types = {
        shipping: "customerInfoValidation",
        billing: "billingInfoValidation"
      };
      Object.keys(types).forEach((type) => {
        const first = this.validateNameField(type, "First name", this.selected[type].firstname);
        const last = this.validateNameField(type, "Last name", this.selected[type].lastname);
        const phone = this.validatePhone(type, this.selected[type].telephone);
        this[types[type]] = first && last && phone;
      });
      this.instantCheckoutText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.instantCheckoutTextId]) || this.$t("instantCheckout");
      this.yourDetailsText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.yourDetailsTextId]) || this.$t("yourDetailsSection.title");
      this.deliverWhereText = ((_c = window.bluefinchCheckout) == null ? void 0 : _c[this.deliverWhereTextId]) || this.$t("yourDetailsSection.deliverySection.title");
      this.newAddressText = ((_d = window.bluefinchCheckout) == null ? void 0 : _d[this.newAddressTextId]) || this.$t("yourDetailsSection.deliverySection.newAddressTitle");
      this.proceedToPayText = ((_e = window.bluefinchCheckout) == null ? void 0 : _e[this.proceedToPayTextId]) || this.$t("shippingStep.proceedToPay");
      this.proceedToShippingText = ((_f = window.bluefinchCheckout) == null ? void 0 : _f[this.proceedToShippingTextId]) || this.$t("yourDetailsSection.deliverySection.toShippingButton");
      this.homeDeliveryText = ((_g = window.bluefinchCheckout) == null ? void 0 : _g[this.homeDeliveryTextId]) || this.$t("yourDetailsSection.deliverySection.shippingButton");
      this.clickAndCollectText = ((_h = window.bluefinchCheckout) == null ? void 0 : _h[this.clickAndCollectTextId]) || this.$t("yourDetailsSection.deliverySection.clickandCollectButton");
      document.addEventListener(this.instantCheckoutTextId, this.setInstantCheckoutText);
      document.addEventListener(this.yourDetailsTextId, this.setYourDetailsText);
      document.addEventListener(this.deliverWhereTextId, this.setDeliverWhereText);
      document.addEventListener(this.newAddressTextId, this.setNewAddressText);
      document.addEventListener(this.proceedToShippingTextId, this.setProceedToShippingText);
      document.addEventListener(this.proceedToPayTextId, this.setProceedToPayText);
      document.addEventListener(this.homeDeliveryTextId, this.setHomeDeliveryText);
      document.addEventListener(this.clickAndCollectTextId, this.setClickAndCollectText);
    },
    unmounted() {
      document.removeEventListener(this.instantCheckoutTextId, this.setInstantCheckoutText);
      document.removeEventListener(this.yourDetailsTextId, this.setYourDetailsText);
      document.removeEventListener(this.deliverWhereTextId, this.setDeliverWhereText);
      document.removeEventListener(this.newAddressTextId, this.setNewAddressText);
      document.removeEventListener(this.proceedToShippingTextId, this.setProceedToShippingText);
      document.removeEventListener(this.proceedToPayTextId, this.setProceedToPayText);
      document.removeEventListener(this.homeDeliveryTextId, this.setHomeDeliveryText);
      document.removeEventListener(this.clickAndCollectTextId, this.setClickAndCollectText);
    },
    methods: {
      ...mapActions(useCartStore, ["getCart"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useCustomerStore, [
        "setAddressAsCustom",
        "setAddressAsEditing",
        "validateAddress",
        "addAddressError",
        "validateNameField",
        "validatePhone",
        "validatePostcode",
        "setAddressToStore"
      ]),
      ...mapActions(useShippingMethodsStore, [
        "clearShippingMethodCache",
        "setClickAndCollect",
        "setNotClickAndCollect",
        "setAddressesOnCart"
      ]),
      ...mapActions(useStepsStore, ["goToShipping", "goToPayment"]),
      updateButtonState() {
        const addressType = this.address_type;
        const areNamesValid = this.validateNameField(addressType, "First name", this.selected[addressType].firstname) && this.validateNameField(addressType, "Last name", this.selected[addressType].lastname) && this.validatePhone(addressType, this.selected[addressType].telephone);
        const validAddress = this.validateAddress(addressType);
        const validPostcode = this.validatePostcode(this.address_type);
        this.buttonEnabled = !this.inputsSanitiseError && validAddress && validPostcode && areNamesValid;
      },
      async submitShippingOption() {
        this.requiredErrorMessage = "";
        const isValid = this.validateAddress(this.address_type, true) && this.validatePostcode(this.address_type, true);
        if (isValid) {
          if (this.savedAddressID === null || this.selected[this.address_type].id === null) {
            this.setAddressAsCustom(this.address_type);
          }
          this.setAddressAsEditing(this.address_type, false);
          if (this.selected.billing.same_as_shipping) {
            const clonedAddress = deepClone(this.selected.shipping);
            this.setAddressToStore(clonedAddress, "billing");
          }
          await this.setAddressesOnCart();
          this.goToShipping();
          continueToDeliveryDataLayer();
        } else {
          const fieldErrors = this.selected.formErrors[this.address_type];
          Object.entries(fieldErrors).forEach(([value]) => {
            this.addAddressError(this.address_type, value);
          });
          this.requiredErrorMessage = this.selected.formErrors.message[this.address_type];
          this.addressInfoWrong = true;
        }
      },
      async submitBillingInfo() {
        await this.setAddressesOnCart();
        this.goToPayment();
      },
      editAddress() {
        this.setAddressAsEditing(this.address_type, true);
        this.setAddressAsCustom(this.address_type);
      },
      showAddressBlock(value) {
        this.isAddressBlockVisible = value;
      },
      passSelectedItemId(value) {
        this.savedAddressID = value;
        if (value !== null) {
          this.buttonEnabled = true;
        }
      },
      isCustomerInfoFull(value) {
        this.customerInfoValidation = value;
      },
      billingInfoFull(value) {
        this.billingInfoValidation = value;
      },
      formatPrice(price) {
        return formatPrice(price);
      },
      setInstantCheckoutText(event) {
        var _a;
        this.instantCheckoutText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("instantCheckout");
      },
      setYourDetailsText(event) {
        var _a;
        this.yourDetailsText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("yourDetailsSection.title");
      },
      setDeliverWhereText(event) {
        var _a;
        this.deliverWhereText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("yourDetailsSection.deliverySection.title");
      },
      setNewAddressText(event) {
        var _a;
        this.newAddressText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("yourDetailsSection.deliverySection.newAddressTitle");
      },
      setProceedToShippingText(event) {
        var _a;
        this.proceedToShippingText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("yourDetailsSection.deliverySection.toShippingButton");
      },
      setProceedToPayText(event) {
        var _a;
        this.proceedToPayText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("shippingStep.proceedToPay");
      },
      setHomeDeliveryText(event) {
        var _a;
        this.homeDeliveryText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("yourDetailsSection.deliverySection.shippingButton");
      },
      setClickAndCollectText(event) {
        var _a;
        this.clickAndCollectText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("yourDetailsSection.deliverySection.clickandCollectButton");
      }
    }
  };
  const _withScopeId$3 = (n) => (pushScopeId("data-v-5afd22ba"), n = n(), popScopeId(), n);
  const _hoisted_1$j = { class: "details-form" };
  const _hoisted_2$g = { class: "details-form-header" };
  const _hoisted_3$e = { class: "instantCheckout-block" };
  const _hoisted_4$a = { class: "instant-payment-buttons" };
  const _hoisted_5$8 = { class: "details-form-body" };
  const _hoisted_6$7 = {
    key: 2,
    class: "shipping-type-toggle"
  };
  const _hoisted_7$6 = { key: 3 };
  const _hoisted_8$5 = { class: "details-form-title" };
  const _hoisted_9$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_10$4 = { class: "delivery-section-title" };
  const _hoisted_11$3 = { class: "delivery-section-title-text" };
  const _hoisted_12$2 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_13$2 = { class: "address-form-error-message" };
  const _hoisted_14 = { class: "additional-detail-form" };
  const _hoisted_15 = { class: "delivery-section" };
  const _hoisted_16 = { class: "details-form-title saved-address" };
  const _hoisted_17 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1));
  const _hoisted_18 = { class: "address-block__item" };
  const _hoisted_19 = ["aria-label"];
  const _hoisted_20 = { class: "address-form-error-message" };
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_Agreements = resolveComponent("Agreements");
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_BraintreeGooglePay = resolveComponent("BraintreeGooglePay");
    const _component_BraintreeApplePay = resolveComponent("BraintreeApplePay");
    const _component_BraintreePayPal = resolveComponent("BraintreePayPal");
    const _component_DividerComponent = resolveComponent("DividerComponent");
    const _component_PayWith = resolveComponent("PayWith");
    const _component_ProgressBar = resolveComponent("ProgressBar");
    const _component_EmailAddress = resolveComponent("EmailAddress");
    const _component_Newsletter = resolveComponent("Newsletter");
    const _component_DeliveryTabIcon = resolveComponent("DeliveryTabIcon");
    const _component_ClickCollectTabIcon = resolveComponent("ClickCollectTabIcon");
    const _component_ClickAndCollect = resolveComponent("ClickAndCollect");
    const _component_YourDetails = resolveComponent("YourDetails");
    const _component_NameFields = resolveComponent("NameFields");
    const _component_Locate = resolveComponent("Locate");
    const _component_AddressList = resolveComponent("AddressList");
    const _component_AddressFinder = resolveComponent("AddressFinder");
    const _component_ShippingForm = resolveComponent("ShippingForm");
    const _component_LinkComponent = resolveComponent("LinkComponent");
    const _component_AddressBlock = resolveComponent("AddressBlock");
    const _component_Edit = resolveComponent("Edit");
    const _component_BillingForm = resolveComponent("BillingForm");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock("div", _hoisted_1$j, [
      withDirectives(createBaseVNode("div", _hoisted_2$g, [
        createBaseVNode("div", _hoisted_3$e, [
          createVNode(_component_TextField, { text: $data.instantCheckoutText }, null, 8, ["text"])
        ]),
        createVNode(_component_Agreements, { id: "detailsPage" }),
        createVNode(_component_Recaptcha, {
          id: "placeOrder",
          location: "expressPayments"
        }),
        createBaseVNode("div", _hoisted_4$a, [
          _ctx.errorMessage !== "" ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 0,
            message: _ctx.errorMessage,
            attached: false,
            margin: false
          }, null, 8, ["message"])) : createCommentVNode("", true),
          (openBlock(), createBlock(_component_BraintreeGooglePay, {
            key: `braintreeGooglePay-${$data.storedKey}`
          })),
          (openBlock(), createBlock(_component_BraintreeApplePay, {
            key: `braintreeApplePay-${$data.storedKey}`
          })),
          (openBlock(), createBlock(_component_BraintreePayPal, {
            key: `braintreePayPal-${$data.storedKey}`
          })),
          (openBlock(), createBlock(_component_BraintreePayPal, {
            key: `braintreePayPal-${$data.storedKey}-credit`,
            isCredit: _ctx.paypal.creditActive
          }, null, 8, ["isCredit"]))
        ])
      ], 512), [
        [vShow, _ctx.isExpressPaymentsVisible]
      ]),
      createBaseVNode("div", _hoisted_5$8, [
        createVNode(_component_DividerComponent),
        createVNode(_component_PayWith),
        _ctx.emailEntered ? (openBlock(), createBlock(_component_ProgressBar, { key: 0 })) : createCommentVNode("", true),
        createVNode(_component_EmailAddress),
        _ctx.emailEntered ? (openBlock(), createBlock(_component_Newsletter, { key: 1 })) : createCommentVNode("", true),
        _ctx.clickCollectTabsEnabled && _ctx.emailEntered && !_ctx.cart.is_virtual ? (openBlock(), createElementBlock("div", _hoisted_6$7, [
          createBaseVNode("button", {
            class: normalizeClass(["button details-button button--medium", { "button--tab": !_ctx.isClickAndCollect, "button--tab__unselected": _ctx.isClickAndCollect }]),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.setNotClickAndCollect())
          }, [
            createVNode(_component_DeliveryTabIcon, {
              fill: !_ctx.isClickAndCollect ? "white" : "#0F273C"
            }, null, 8, ["fill"]),
            createVNode(_component_TextField, {
              text: $data.homeDeliveryText,
              "data-cy": "home-delivery-title"
            }, null, 8, ["text"])
          ], 2),
          createBaseVNode("button", {
            class: normalizeClass(["button click-collect-button button--medium", { "button--tab": _ctx.isClickAndCollect, "button--tab__unselected": !_ctx.isClickAndCollect }]),
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.setClickAndCollect())
          }, [
            createVNode(_component_ClickCollectTabIcon, {
              fill: _ctx.isClickAndCollect ? "white" : "#0F273C"
            }, null, 8, ["fill"]),
            createVNode(_component_TextField, {
              text: $data.clickAndCollectText,
              "data-cy": "click-collect-title"
            }, null, 8, ["text"])
          ], 2)
        ])) : createCommentVNode("", true),
        _ctx.emailEntered && _ctx.isClickAndCollect ? (openBlock(), createElementBlock("div", _hoisted_7$6, [
          _ctx.subtotalInclTax >= _ctx.custom.clickandcollectMin && _ctx.subtotalInclTax <= _ctx.custom.clickandcollectMax ? (openBlock(), createBlock(_component_ClickAndCollect, { key: 0 })) : _ctx.subtotalInclTax < _ctx.custom.clickandcollectMin ? (openBlock(), createBlock(_component_TextField, {
            key: 1,
            class: "click-and-collect-unavilable",
            text: _ctx.$t("yourDetailsSection.deliverySection.clickandCollectThresholdLow", { price: $options.formatPrice(_ctx.custom.clickandcollectMin) })
          }, null, 8, ["text"])) : (openBlock(), createBlock(_component_TextField, {
            key: 2,
            class: "click-and-collect-unavilable",
            text: _ctx.$t("yourDetailsSection.deliverySection.clickandCollectThresholdHigh", { price: $options.formatPrice(_ctx.custom.clickandcollectMax) })
          }, null, 8, ["text"]))
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_8$5, [
          createVNode(_component_YourDetails, { fill: "black" }),
          createVNode(_component_TextField, { text: $data.yourDetailsText }, null, 8, ["text"]),
          _hoisted_9$4
        ]),
        createVNode(_component_NameFields, {
          address_type: $props.address_type,
          onIsCustomerInfoFull: $options.isCustomerInfoFull
        }, null, 8, ["address_type", "onIsCustomerInfoFull"]),
        createBaseVNode("div", _hoisted_10$4, [
          createVNode(_component_Locate),
          createBaseVNode("div", _hoisted_11$3, [
            createVNode(_component_TextField, { text: $data.deliverWhereText }, null, 8, ["text"])
          ]),
          _hoisted_12$2
        ]),
        _ctx.emailEntered && _ctx.customer.addresses.length && !_ctx.isClickAndCollect && !_ctx.cart.is_virtual ? (openBlock(), createBlock(_component_AddressList, {
          key: 4,
          "address-type": "shipping",
          onShowAddressBlock: $options.showAddressBlock,
          onPassSelectedItemId: $options.passSelectedItemId,
          onSelectedSavedAddress: _ctx.selectedSavedAddress
        }, null, 8, ["onShowAddressBlock", "onPassSelectedItemId", "onSelectedSavedAddress"])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_13$2, [
          $data.addressInfoWrong ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 0,
            message: _ctx.$t("errorMessages.addressWrongError")
          }, null, 8, ["message"])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_14, [
          createBaseVNode("div", _hoisted_15, [
            createBaseVNode("div", null, [
              createBaseVNode("div", null, [
                !_ctx.selected[$props.address_type].id || _ctx.selected[$props.address_type].id === "custom" && _ctx.selected[$props.address_type].editing ? (openBlock(), createBlock(_component_AddressFinder, { key: 0 })) : createCommentVNode("", true)
              ])
            ]),
            createBaseVNode("div", _hoisted_16, [
              createVNode(_component_Locate),
              createVNode(_component_TextField, {
                class: "address-block__title",
                text: $data.newAddressText
              }, null, 8, ["text"]),
              _hoisted_17
            ]),
            createVNode(_component_ShippingForm),
            !_ctx.selected[$props.address_type].id && !_ctx.selected[$props.address_type].editing && $props.address_type === "shipping" && _ctx.addressFinder.enabled ? (openBlock(), createBlock(_component_LinkComponent, {
              key: 0,
              class: "manually-button",
              label: _ctx.$t("yourDetailsSection.deliverySection.addressForm.linkText"),
              onClick: withModifiers($options.editAddress, ["prevent"])
            }, null, 8, ["label", "onClick"])) : createCommentVNode("", true)
          ])
        ]),
        _ctx.emailEntered && !_ctx.selected[$props.address_type].editing && !_ctx.isSavedAddressSelected && _ctx.selected[$props.address_type].id && !_ctx.isUsingSavedShippingAddress && !_ctx.isClickAndCollect && !_ctx.cart.is_virtual ? (openBlock(), createElementBlock("div", {
          key: 5,
          class: normalizeClass(["address-block", _ctx.customer.addresses.length > 0 ? "saved-address-active" : ""])
        }, [
          createVNode(_component_TextField, {
            class: "address-block__title selected",
            text: _ctx.$t("yourDetailsSection.deliverySection.deliveryAddressTitle")
          }, null, 8, ["text"]),
          createBaseVNode("div", _hoisted_18, [
            createBaseVNode("article", null, [
              createVNode(_component_AddressBlock, {
                address_type: `shipping`,
                address: _ctx.selected[$props.address_type]
              }, null, 8, ["address"])
            ])
          ]),
          _ctx.selected[$props.address_type].id ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "address-block__edit",
            "aria-label": _ctx.$t("yourDetailsSection.deliverySection.editButton"),
            tabindex: "0",
            onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"])),
            onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.editAddress && $options.editAddress(...args), ["prevent"]), ["enter"]))
          }, [
            createVNode(_component_Edit)
          ], 40, _hoisted_19)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_20, [
          !$data.customerInfoValidation && $data.addressFormErrorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
            key: 0,
            message: _ctx.$t("errorMessages.addressFormErrorMessage")
          }, null, 8, ["message"])) : createCommentVNode("", true)
        ]),
        _ctx.emailEntered && !_ctx.isClickAndCollect ? (openBlock(), createBlock(_component_BillingForm, {
          key: 6,
          onBillingInfoFull: $options.billingInfoFull
        }, null, 8, ["onBillingInfoFull"])) : createCommentVNode("", true),
        _ctx.emailEntered && !_ctx.selected.billing.editing && !_ctx.isClickAndCollect && !_ctx.cart.is_virtual ? (openBlock(), createBlock(_component_MyButton, {
          key: 7,
          type: "submit",
          primary: "",
          label: $data.proceedToShippingText,
          onClick: _cache[4] || (_cache[4] = ($event) => {
            $options.submitShippingOption();
          })
        }, null, 8, ["label"])) : createCommentVNode("", true),
        _ctx.emailEntered && !_ctx.selected.billing.editing && !_ctx.isClickAndCollect && _ctx.cart.is_virtual ? (openBlock(), createBlock(_component_MyButton, {
          key: 8,
          type: "submit",
          primary: "",
          label: $data.proceedToPayText,
          disabled: !_ctx.selected.billing.id || !_ctx.customer.id && !$data.billingInfoValidation,
          onClick: _cache[5] || (_cache[5] = ($event) => {
            $options.submitBillingInfo();
          })
        }, null, 8, ["label", "disabled"])) : createCommentVNode("", true)
      ])
    ]);
  }
  var DetailsPage = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l], ["__scopeId", "data-v-5afd22ba"]]);
  const _sfc_main$k = {
    name: "AddressBlock",
    props: {
      address_type: {
        type: String,
        default: "shipping"
      },
      address: {
        default: {
          street: ["", ""],
          city: "",
          region: "",
          country_code: "",
          postcode: "",
          company: "",
          telephone: "",
          firstname: "",
          lastname: ""
        }
      }
    },
    computed: {
      showRegion() {
        const { region } = this.address;
        return region && typeof region === "string";
      }
    }
  };
  const _hoisted_1$i = { class: "address-block__address" };
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", _hoisted_1$i, [
      createBaseVNode("div", null, [
        createBaseVNode("p", null, [
          createTextVNode(toDisplayString$1($props.address.firstname) + " " + toDisplayString$1($props.address.lastname) + ", " + toDisplayString$1($props.address.street[0]) + " ", 1),
          $props.address.street[1] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString$1($props.address.street[1]), 1)
          ], 64)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString$1($props.address.city) + " ", 1),
          $options.showRegion ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString$1($props.address.region), 1)
          ], 64)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString$1($props.address.postcode) + " " + toDisplayString$1($props.address.telephone), 1)
        ])
      ])
    ]);
  }
  var AddressBlockShort = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k], ["__scopeId", "data-v-79dd704d"]]);
  const _sfc_main$j = {
    name: "SavedDeliveryAddress",
    components: {
      TextField,
      AddressBlockShort,
      YourDetails,
      Edit
    },
    data() {
      return {
        detailStepText: "",
        detailStepTextId: "bluefinch-checkout-detailstep-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["cart"])
    },
    async created() {
      var _a;
      this.detailStepText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.detailStepTextId]) || this.$t("yourDetailsSection.title");
      document.addEventListener(this.detailStepTextId, this.setDetailStepText);
    },
    unmounted() {
      document.removeEventListener(this.detailStepTextId, this.setDetailStepText);
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useStepsStore, ["goToYouDetails"]),
      setDetailStepText(event) {
        var _a;
        this.detailStepText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("yourDetailsSection.title");
      },
      setDetailsStepActive() {
      }
    }
  };
  const _hoisted_1$h = { class: "delivery-address" };
  const _hoisted_2$f = {
    class: "delivery-address-link",
    "aria-label": "proceed-to-details-link"
  };
  const _hoisted_3$d = { class: "details-title-section" };
  const _hoisted_4$9 = { class: "details-title-section-image" };
  const _hoisted_5$7 = { class: "details-title-section-title" };
  const _hoisted_6$6 = { class: "address-block__edit proceed-to-details" };
  const _hoisted_7$5 = ["aria-label"];
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_YourDetails = resolveComponent("YourDetails");
    const _component_TextField = resolveComponent("TextField");
    const _component_AddressBlockShort = resolveComponent("AddressBlockShort");
    const _component_Edit = resolveComponent("Edit");
    return openBlock(), createElementBlock("div", _hoisted_1$h, [
      createBaseVNode("div", _hoisted_2$f, [
        createBaseVNode("div", _hoisted_3$d, [
          createBaseVNode("div", _hoisted_4$9, [
            createVNode(_component_YourDetails, { fill: "black" })
          ]),
          createBaseVNode("div", _hoisted_5$7, [
            createVNode(_component_TextField, { text: $data.detailStepText }, null, 8, ["text"])
          ])
        ]),
        createVNode(_component_AddressBlockShort, {
          class: "shipping-billing-steps",
          address_type: !_ctx.cart.is_virtual ? `shipping` : `billing`,
          address: !_ctx.cart.is_virtual ? (_a = _ctx.cart.shipping_addresses) == null ? void 0 : _a[0] : _ctx.cart.billing_address
        }, null, 8, ["address_type", "address"]),
        createBaseVNode("div", _hoisted_6$6, [
          createBaseVNode("button", {
            class: "button--blank edit-details-button",
            "aria-label": _ctx.$t("yourDetailsSection.editDetailsButtonLabel")
          }, [
            createVNode(_component_TextField, {
              class: "edit-button-title",
              text: _ctx.$t("yourDetailsSection.editButton")
            }, null, 8, ["text"]),
            createVNode(_component_Edit)
          ], 8, _hoisted_7$5)
        ])
      ])
    ]);
  }
  var SavedDeliveryAddress = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j], ["__scopeId", "data-v-7322d39d"]]);
  const _sfc_main$i = {
    name: "Calendar",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$g = ["role", "aria-label"];
  const _hoisted_2$e = /* @__PURE__ */ createBaseVNode("path", {
    d: "M1.755 10.346h21.388m-5.37 4.688h.011m-5.334 0h.01m-5.347 0h.01m10.65 4.662h.011m-5.334 0h.01m-5.347 0h.01M17.296 1.46v3.95M7.602 1.46v3.95",
    stroke: "#252F3B",
    "stroke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_3$c = /* @__PURE__ */ createBaseVNode("path", {
    "clip-rule": "evenodd",
    d: "M17.529 3.355H7.369c-3.525 0-5.726 1.964-5.726 5.572v10.86c0 3.665 2.201 5.673 5.725 5.673h10.15c3.535 0 5.725-1.974 5.725-5.582V8.928c.011-3.61-2.179-5.573-5.714-5.573Z",
    stroke: "#252F3B",
    "stroke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_4$8 = [
    _hoisted_2$e,
    _hoisted_3$c
  ];
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "24",
      height: "27",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_4$8, 12, _hoisted_1$g);
  }
  var Calendar = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
  const _sfc_main$h = {
    name: "ArrowLeft",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$f = ["role", "aria-label"];
  const _hoisted_2$d = /* @__PURE__ */ createBaseVNode("path", {
    d: "M13.5 1L1.5 13L13.5 25",
    stroke: "",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_3$b = [
    _hoisted_2$d
  ];
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "15",
      height: "26",
      viewBox: "0 0 15 26",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$b, 12, _hoisted_1$f);
  }
  var ArrowLeft = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
  const _sfc_main$g = {
    name: "ArrowRight",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      stroke: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill,
          stroke: reactiveProps.stroke
        }))
      };
    }
  };
  const _hoisted_1$e = ["role", "aria-label"];
  const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("path", {
    d: "M1.5 25L13.5 13L1.5 1",
    stroke: "",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null, -1);
  const _hoisted_3$a = [
    _hoisted_2$c
  ];
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("svg", {
      style: normalizeStyle($setup.style),
      role: $props.role,
      "aria-label": $props.ariaLabel,
      width: "15",
      height: "26",
      viewBox: "0 0 15 26",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_3$a, 12, _hoisted_1$e);
  }
  var ArrowRight = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
  const _sfc_main$f = {
    name: "NominatedDay",
    components: {
      TextField,
      Calendar,
      ArrowLeft,
      ArrowRight
    },
    props: {
      item: {
        type: Object,
        default() {
          return {
            method_code: "",
            carrier_code: ""
          };
        }
      }
    },
    data() {
      return {
        showCalender: false,
        isKeyboard: false,
        today: new Date(),
        day: null,
        month: null,
        year: null,
        emptyDays: 0,
        weekdays: [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ]
      };
    },
    computed: {
      ...mapWritableState(useShippingMethodsStore, ["nominatedSelectedMethod", "nominatedSelectedDate", "nominatedSelectedDateFormatted"]),
      ...mapState(useShippingMethodsStore, ["nominatedDates"]),
      disablePrevArrow() {
        return this.month <= this.today.getMonth();
      },
      disableNextArrow() {
        return this.month >= this.today.getMonth() + 1;
      },
      firstAvailableDay() {
        const availableDates = this.nominatedDates.filter((method) => new Date(method.extension_attributes.date_required));
        return new Date(availableDates[0].extension_attributes.date_required);
      }
    },
    mounted() {
      const { firstAvailableDay } = this.firstAvailableDay;
      this.day = firstAvailableDay.getDate();
      this.month = firstAvailableDay.getMonth();
      this.year = firstAvailableDay.getFullYear();
    },
    methods: {
      ...mapActions(useLoadingStore, ["setLoadingState"]),
      ...mapActions(useShippingMethodsStore, ["selectShippingMethod", "submitShippingInfo"]),
      openCalendar() {
        this.showCalender = true;
      },
      closeCalendar() {
        this.showCalender = false;
      },
      getMonth(month = false) {
        const months = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ];
        return month ? months[month] : months[this.month];
      },
      formatedSelectedDate(date) {
        const day = date.getDate() + (date.getDate() % 10 === 1 && date.getDate() !== 11 ? "st" : date.getDate() % 10 === 2 && date.getDate() !== 12 ? "nd" : date.getDate() % 10 === 3 && date.getDate() !== 13 ? "rd" : "th");
        const weekday = this.weekdays[date.getDay()];
        return `${weekday}, ${this.getMonth()} ${day} ${this.year}`;
      },
      async selectDate(date) {
        this.setLoadingState(true);
        this.nominatedSelectedDate = date;
        this.nominatedSelectedDateFormatted = this.formatedSelectedDate(date);
        this.selectShippingMethod({
          nominatedSelectedDate: this.nominatedSelectedDate,
          nominatedSelectedDateFormatted: this.nominatedSelectedDateFormatted,
          ...this.item
        });
        await this.submitShippingInfo();
        this.setLoadingState(false);
        this.closeCalendar();
      },
      numberOfDaysInMonth() {
        const date = new Date(this.year, this.month, 1);
        const dates = [];
        this.emptyDays = date.getDay();
        while (date.getMonth() === this.month) {
          dates.push(new Date(date));
          date.setDate(date.getDate() + 1);
        }
        return dates;
      },
      getDateLabel(date) {
        return date.getDate();
      },
      increaseMonth() {
        if (this.month + 1 === 12) {
          this.month = 0;
          this.year++;
        } else {
          this.month++;
        }
      },
      decreaseMonth() {
        if (this.month === 0) {
          this.month = 11;
          this.year--;
        } else {
          this.month--;
        }
      },
      isDateInPast(date) {
        return date.getTime() < this.today.getTime() - 1;
      },
      isAvailableDate(currentDate) {
        if (this.isDateInPast(currentDate)) {
          return false;
        }
        return this.nominatedDates.filter((method) => {
          if (method) {
            const date = new Date(method);
            return date.getTime() === currentDate.getTime();
          }
        }).length > 0;
      },
      compareDates(firstDate, secondDate) {
        firstDate = new Date(firstDate);
        return firstDate.getTime() === secondDate.getTime();
      }
    }
  };
  const _withScopeId$2 = (n) => (pushScopeId("data-v-cd86a3e2"), n = n(), popScopeId(), n);
  const _hoisted_1$d = { class: "nominated-container" };
  const _hoisted_2$b = ["aria-modal"];
  const _hoisted_3$9 = { class: "calendar-header" };
  const _hoisted_4$7 = ["disabled"];
  const _hoisted_5$6 = { class: "calendar-header-date" };
  const _hoisted_6$5 = ["disabled"];
  const _hoisted_7$4 = { class: "calendar-week" };
  const _hoisted_8$4 = ["textContent"];
  const _hoisted_9$3 = { class: "calendar" };
  const _hoisted_10$3 = ["onClick"];
  const _hoisted_11$2 = { class: "calendar-radio-label" };
  const _hoisted_12$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "calendar-button-symbol" }, null, -1));
  const _hoisted_13$1 = {
    key: 1,
    class: "calendar-span"
  };
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextField = resolveComponent("TextField");
    const _component_Calendar = resolveComponent("Calendar");
    const _component_ArrowLeft = resolveComponent("ArrowLeft");
    const _component_ArrowRight = resolveComponent("ArrowRight");
    return openBlock(), createElementBlock("section", _hoisted_1$d, [
      withDirectives(createBaseVNode("button", {
        ref: "nominated",
        class: "nominated-select",
        type: "button",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.openCalendar && $options.openCalendar(...args), ["prevent"]))
      }, [
        _ctx.nominatedSelectedDate ? (openBlock(), createBlock(_component_TextField, {
          key: 0,
          text: $options.formatedSelectedDate(_ctx.nominatedSelectedDate),
          class: "nominated-select-textfield"
        }, null, 8, ["text"])) : (openBlock(), createBlock(_component_TextField, {
          key: 1,
          text: _ctx.$t("shippingStep.nominatedDelivery"),
          class: "nominated-select-textfield"
        }, null, 8, ["text"])),
        createVNode(_component_Calendar, { stroke: "black" })
      ], 512), [
        [vShow, !$data.showCalender]
      ]),
      withDirectives((openBlock(), createElementBlock("div", {
        id: "nominated-calendar",
        key: _ctx.selectedView,
        class: "calendar-container",
        role: "dialog",
        "aria-labelledby": "calendar-tile",
        "aria-describedby": "calendar-description",
        "aria-modal": $data.showCalender,
        onKeyup: _cache[3] || (_cache[3] = withKeys(($event) => $options.closeCalendar(), ["esc"]))
      }, [
        createBaseVNode("header", _hoisted_3$9, [
          createBaseVNode("button", {
            type: "button",
            class: "calendar-header-button",
            disabled: $options.disablePrevArrow,
            onClick: _cache[1] || (_cache[1] = ($event) => $options.decreaseMonth())
          }, [
            createVNode(_component_ArrowLeft, {
              width: "8px",
              stroke: "black"
            })
          ], 8, _hoisted_4$7),
          createBaseVNode("p", _hoisted_5$6, toDisplayString$1($options.getMonth()) + " " + toDisplayString$1($data.year), 1),
          createBaseVNode("button", {
            type: "button",
            class: "calendar-header-button",
            disabled: $options.disableNextArrow,
            onClick: _cache[2] || (_cache[2] = ($event) => $options.increaseMonth())
          }, [
            createVNode(_component_ArrowRight, {
              width: "8px",
              stroke: "black"
            })
          ], 8, _hoisted_6$5)
        ]),
        createBaseVNode("ol", _hoisted_7$4, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.weekdays, (date) => {
            return openBlock(), createElementBlock("li", {
              key: date,
              class: "calendar-week-day"
            }, [
              createBaseVNode("span", {
                textContent: toDisplayString$1(date.substring(0, 2))
              }, null, 8, _hoisted_8$4)
            ]);
          }), 128))
        ]),
        createBaseVNode("ol", _hoisted_9$3, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.emptyDays, (date) => {
            return openBlock(), createElementBlock("li", {
              key: date,
              class: "calendar-day"
            });
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.numberOfDaysInMonth(), (date) => {
            return openBlock(), createElementBlock("li", {
              key: date,
              class: normalizeClass(["calendar-day", {
                "calendar-day--in-past": $options.isDateInPast(date),
                "calendar-day--available": $options.isAvailableDate(date)
              }])
            }, [
              $options.isAvailableDate(date) ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                class: normalizeClass(["calendar-button", {
                  "active": $options.compareDates(_ctx.nominatedSelectedDate, date)
                }]),
                onClick: ($event) => $options.selectDate(date)
              }, [
                createBaseVNode("span", _hoisted_11$2, [
                  createBaseVNode("span", null, toDisplayString$1($options.getDateLabel(date)), 1),
                  _hoisted_12$1
                ])
              ], 10, _hoisted_10$3)) : (openBlock(), createElementBlock("span", _hoisted_13$1, toDisplayString$1($options.getDateLabel(date)), 1))
            ], 2);
          }), 128))
        ])
      ], 40, _hoisted_2$b)), [
        [vShow, $data.showCalender]
      ]),
      withDirectives(createVNode(_component_TextField, {
        text: _ctx.$t("shippingStep.nominatedDeliveryCalendar"),
        class: "nominated-select-calendar-text"
      }, null, 8, ["text"]), [
        [vShow, $data.showCalender]
      ])
    ]);
  }
  var NominatedDay = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-cd86a3e2"]]);
  const _sfc_main$e = {
    name: "RadioButton",
    props: {
      text: {
        type: String
      },
      dataCy: {
        type: String
      },
      subtext: {
        type: String
      },
      disabled: {
        type: Boolean,
        default: false
      },
      checked: {
        type: Boolean,
        default: false
      },
      subtextShow: {
        type: Boolean,
        default: false
      },
      color: {
        type: String
      },
      fontSize: {
        type: String
      },
      fontWeight: {
        type: String
      },
      fontStyle: {
        type: String
      },
      ariaChecked: {
        type: String
      },
      role: {
        type: String
      },
      changeHandler: {
        type: Function,
        default: () => {
        }
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          fontSize: reactiveProps.fontSize,
          color: reactiveProps.color,
          fontWeight: reactiveProps.fontWeight,
          fontStyle: reactiveProps.fontStyle
        }))
      };
    }
  };
  const _hoisted_1$c = {
    class: "radio-button",
    for: "radio-input"
  };
  const _hoisted_2$a = ["disabled", "checked", "aria-checked", "role", "data-cy"];
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", null, [
      createBaseVNode("label", _hoisted_1$c, [
        createBaseVNode("input", {
          id: "radio-input",
          type: "radio",
          disabled: $props.disabled,
          checked: $props.checked,
          "aria-checked": $props.ariaChecked,
          role: $props.role,
          "data-cy": $props.dataCy ? $props.dataCy : "radio-button",
          onChange: _cache[0] || (_cache[0] = (...args) => $props.changeHandler && $props.changeHandler(...args))
        }, null, 40, _hoisted_2$a),
        renderSlot(_ctx.$slots, "icon", {}, void 0, true),
        createBaseVNode("span", {
          style: normalizeStyle($setup.style)
        }, toDisplayString$1($props.text), 5)
      ]),
      withDirectives(createBaseVNode("p", null, toDisplayString$1($props.subtext), 513), [
        [vShow, $props.subtextShow]
      ])
    ]);
  }
  var RadioButton = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__scopeId", "data-v-b90c1728"]]);
  const scriptRel = "modulepreload";
  const seen = {};
  const base = "/";
  const __vitePreload = function preload(baseModule, deps) {
    if (!deps || deps.length === 0) {
      return baseModule();
    }
    return Promise.all(deps.map((dep) => {
      dep = `${base}${dep}`;
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    })).then(() => baseModule());
  };
  var shippingMethods = () => {
    var _a;
    const shippingMethods2 = {};
    if ((_a = window.bluefinchCheckout) == null ? void 0 : _a.shippingMethods) {
      Object.keys(window.bluefinchCheckout.shippingMethods).forEach((shippingMethod) => {
        shippingMethods2[shippingMethod] = defineAsyncComponent(() => __vitePreload(() => import(
          /* @vite-ignore */
          window.bluefinchCheckout.shippingMethods[shippingMethod]
        ), true ? [] : void 0));
      });
    }
    return shippingMethods2;
  };
  const _sfc_main$d = {
    name: "ShippingMethod",
    components: {
      TextField,
      Loader,
      Shipping,
      NominatedDay,
      MyButton,
      ProgressBar,
      RadioButton,
      ...shippingMethods()
    },
    props: {
      buttonText: {
        type: String,
        default: "Continue to Payment"
      }
    },
    data() {
      return {
        additionalShippingMethods: [],
        nominatedId: "nominated_delivery",
        hasSubmitted: false,
        shippingStepText: "",
        shippingStepTextId: "bluefinch-checkout-shippingstep-text",
        proceedToPayText: "",
        proceedToPayTextId: "bluefinch-checkout-proceedtopay-text"
      };
    },
    computed: {
      ...mapState(useCartStore, ["cart"]),
      ...mapState(useConfigStore, ["taxCartDisplayShipping"]),
      ...mapState(useCustomerStore, ["selected"]),
      ...mapState(useShippingMethodsStore, [
        "getError",
        "nominatedDayEnabled",
        "nominatedPrice",
        "selectedMethod"
      ])
    },
    async created() {
      var _a, _b;
      this.additionalShippingMethods = Object.keys(shippingMethods());
      this.shippingStepText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.shippingStepTextId]) || this.$t("shippingStep.stepTitle");
      this.proceedToPayText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b[this.proceedToPayTextId]) || this.$t("shippingStep.proceedToPay");
      document.addEventListener(this.shippingStepTextId, this.setShippingStepText);
      document.addEventListener(this.proceedToPayTextId, this.setProceedToPayText);
    },
    unmounted() {
      document.removeEventListener(this.shippingStepTextId, this.setShippingStepText);
      document.addEventListener(this.proceedToPayTextId, this.setProceedToPayText);
    },
    methods: {
      ...mapActions(useShippingMethodsStore, [
        "submitShippingInfo",
        "selectShippingMethod"
      ]),
      ...mapActions(usePaymentStore, ["setPaymentMethods"]),
      ...mapActions(useStepsStore, ["goToPayment"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      setShippingStepText(event) {
        var _a;
        this.shippingStepText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("shippingStep.stepTitle");
      },
      setProceedToPayText(event) {
        var _a;
        this.proceedToPayText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("shippingStep.proceedToPay");
      },
      formatPrice(price) {
        if (price === 0) {
          return "FREE";
        }
        return formatPrice(price);
      },
      async handleChange(item) {
        this.selectShippingMethod(item);
        await this.submitShippingInfo(item.carrier_code, item.method_code);
      }
    }
  };
  const _hoisted_1$b = { class: "checkout-section checkout-shipping" };
  const _hoisted_2$9 = { class: "checkout-shipping-methods" };
  const _hoisted_3$8 = { class: "checkout-shipping-methods__title" };
  const _hoisted_4$6 = { class: "checkout-shipping-methods__title-icon" };
  const _hoisted_5$5 = { class: "title" };
  const _hoisted_6$4 = /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1);
  const _hoisted_7$3 = {
    key: 0,
    class: "shipping-method__container"
  };
  const _hoisted_8$3 = ["onClick", "onKeydown"];
  const _hoisted_9$2 = { class: "shipping-method__input" };
  const _hoisted_10$2 = { class: "shipping-method__content" };
  const _hoisted_11$1 = { class: "shipping-method__input" };
  const _hoisted_12 = { class: "shipping-method__content" };
  const _hoisted_13 = ["innerHTML"];
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const _component_ProgressBar = resolveComponent("ProgressBar");
    const _component_Shipping = resolveComponent("Shipping");
    const _component_TextField = resolveComponent("TextField");
    const _component_RadioButton = resolveComponent("RadioButton");
    const _component_NominatedDay = resolveComponent("NominatedDay");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock("section", null, [
      createBaseVNode("div", _hoisted_1$b, [
        createVNode(_component_ProgressBar),
        createBaseVNode("div", _hoisted_2$9, [
          createBaseVNode("div", _hoisted_3$8, [
            createBaseVNode("div", _hoisted_4$6, [
              createVNode(_component_Shipping, { fill: "black" })
            ]),
            createBaseVNode("div", _hoisted_5$5, [
              createVNode(_component_TextField, {
                class: "main-text",
                text: $data.shippingStepText
              }, null, 8, ["text"])
            ]),
            _hoisted_6$4
          ]),
          ((_b = (_a = _ctx.cart.shipping_addresses) == null ? void 0 : _a[0]) == null ? void 0 : _b.available_shipping_methods) ? (openBlock(), createElementBlock("div", _hoisted_7$3, [
            (openBlock(true), createElementBlock(Fragment, null, renderList((_d = (_c = _ctx.cart.shipping_addresses) == null ? void 0 : _c[0]) == null ? void 0 : _d.available_shipping_methods, (item) => {
              var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2;
              return openBlock(), createElementBlock("span", {
                key: item.carrier_code,
                class: normalizeClass(["shipping-method__label", {
                  "selected": item.method_code === ((_c2 = (_b2 = (_a2 = _ctx.cart.shipping_addresses) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.selected_shipping_method) == null ? void 0 : _c2.method_code)
                }]),
                onClick: ($event) => $options.handleChange(item),
                onKeydown: withKeys(($event) => $options.handleChange(item), ["enter"])
              }, [
                item.method_code !== $data.nominatedId ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createBaseVNode("span", _hoisted_9$2, [
                    createVNode(_component_RadioButton, {
                      id: item.method_code,
                      checked: item.method_code === ((_f2 = (_e2 = (_d2 = _ctx.cart.shipping_addresses) == null ? void 0 : _d2[0]) == null ? void 0 : _e2.selected_shipping_method) == null ? void 0 : _f2.method_code),
                      name: "shipping-option"
                    }, null, 8, ["id", "checked"])
                  ]),
                  createBaseVNode("span", _hoisted_10$2, [
                    createVNode(_component_TextField, {
                      text: item.method_title
                    }, null, 8, ["text"]),
                    createVNode(_component_TextField, {
                      text: item.carrier_title
                    }, null, 8, ["text"])
                  ])
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createBaseVNode("span", _hoisted_11$1, [
                    createVNode(_component_RadioButton, {
                      id: $data.nominatedId,
                      checked: item.method_code === ((_i2 = (_h2 = (_g2 = _ctx.cart.shipping_addresses) == null ? void 0 : _g2[0]) == null ? void 0 : _h2.selected_shipping_method) == null ? void 0 : _i2.method_code),
                      name: "shipping-option"
                    }, null, 8, ["id", "checked"])
                  ]),
                  createBaseVNode("span", _hoisted_12, [
                    createVNode(_component_TextField, {
                      text: item.method_title
                    }, null, 8, ["text"]),
                    createVNode(_component_TextField, {
                      text: item.carrier_title
                    }, null, 8, ["text"])
                  ])
                ], 64)),
                createVNode(_component_TextField, {
                  class: "shipping-method__price",
                  text: _ctx.taxCartDisplayShipping ? $options.formatPrice(item.price_incl_tax.value) : $options.formatPrice(item.price_excl_tax.value)
                }, null, 8, ["text"]),
                item.carrier_code === $data.nominatedId && _ctx.nominatedDayEnabled && _ctx.selectedMethod.carrier_code === $data.nominatedId ? (openBlock(), createBlock(_component_NominatedDay, {
                  key: 2,
                  item
                }, null, 8, ["item"])) : createCommentVNode("", true)
              ], 42, _hoisted_8$3);
            }), 128)),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.additionalShippingMethods, (additionalShippingMethod) => {
              return openBlock(), createBlock(resolveDynamicComponent(additionalShippingMethod), { key: additionalShippingMethod });
            }), 128))
          ])) : !((_f = (_e = _ctx.cart.shipping_addresses) == null ? void 0 : _e[0]) == null ? void 0 : _f.available_shipping_methods.length) ? (openBlock(), createBlock(_component_TextField, {
            key: 1,
            class: "checkout-shipping-methods__error",
            text: _ctx.$t("errorMessages.noShippingMethods")
          }, null, 8, ["text"])) : _ctx.getError ? (openBlock(), createElementBlock("span", {
            key: 2,
            innerHTML: _ctx.getError
          }, null, 8, _hoisted_13)) : createCommentVNode("", true)
        ]),
        createVNode(_component_MyButton, {
          type: "submit",
          primary: "",
          label: $data.proceedToPayText,
          disabled: !((_i = (_h = (_g = _ctx.cart.shipping_addresses) == null ? void 0 : _g[0]) == null ? void 0 : _h.available_shipping_methods) == null ? void 0 : _i.length) || !((_l = (_k = (_j = _ctx.cart.shipping_addresses) == null ? void 0 : _j[0]) == null ? void 0 : _k.selected_shipping_method) == null ? void 0 : _l.method_code),
          onClick: _ctx.goToPayment
        }, null, 8, ["label", "disabled", "onClick"])
      ])
    ]);
  }
  var ShippingMethod = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
  const _sfc_main$c = {
    name: "ShippingPage",
    components: {
      SavedDeliveryAddress,
      ShippingMethod
    },
    computed: {
      ...mapState(useConfigStore, ["storeCode"])
    },
    methods: {
      ...mapActions(useCartStore, ["getCart"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useShippingMethodsStore, ["setDefaultShippingMethod"]),
      ...mapActions(useGtmStore, ["trackStep"])
    }
  };
  const _hoisted_1$a = { class: "shipping-step" };
  const _hoisted_2$8 = { class: "shipping-form" };
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_SavedDeliveryAddress = resolveComponent("SavedDeliveryAddress");
    const _component_ShippingMethod = resolveComponent("ShippingMethod");
    return openBlock(), createElementBlock("div", _hoisted_1$a, [
      createVNode(_component_SavedDeliveryAddress),
      createBaseVNode("div", _hoisted_2$8, [
        createVNode(_component_ShippingMethod)
      ])
    ]);
  }
  var ShippingPage = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-e8c0b8e4"]]);
  const _sfc_main$b = {
    name: "PrivacyPolicy",
    components: {
      Modal
    },
    data() {
      return {
        isModalVisible: false
      };
    },
    computed: {
      ...mapState(useConfigStore, ["privacyPolicy"])
    },
    async created() {
      await this.getPrivacyPolicyBlock();
    },
    methods: {
      ...mapActions(useConfigStore, ["getPrivacyPolicyBlock"]),
      showModal() {
        document.body.classList.add("no-scrollable");
        this.isModalVisible = true;
      },
      closeModal() {
        document.body.classList.remove("no-scrollable");
        this.isModalVisible = false;
      }
    }
  };
  const _hoisted_1$9 = { class: "privacy-policy-container" };
  const _hoisted_2$7 = { class: "privacy-policy-content" };
  const _hoisted_3$7 = { class: "closer-container" };
  const _hoisted_4$5 = ["innerHTML"];
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ButtonComponent = resolveComponent("ButtonComponent");
    const _component_modal = resolveComponent("modal");
    return _ctx.privacyPolicy.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createBaseVNode("div", _hoisted_1$9, [
        createBaseVNode("span", _hoisted_2$7, toDisplayString$1(_ctx.$t("privacyPolicy.content")), 1),
        createBaseVNode("button", {
          type: "button",
          class: "privacy-policy-content_button button--blank",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.showModal && $options.showModal(...args)),
          onKeydown: _cache[1] || (_cache[1] = (...args) => $options.showModal && $options.showModal(...args))
        }, toDisplayString$1(_ctx.$t("privacyPolicy.link")), 33)
      ]),
      createVNode(_component_modal, {
        visible: $data.isModalVisible,
        onClose: $options.closeModal
      }, {
        header: withCtx(() => [
          createBaseVNode("div", _hoisted_3$7, [
            createBaseVNode("button", {
              type: "button",
              class: "button button--blank privacy-close",
              "aria-label": "Close",
              onClick: _cache[2] || (_cache[2] = (...args) => $options.closeModal && $options.closeModal(...args))
            }, " \u2715 ")
          ])
        ]),
        body: withCtx(() => [
          createBaseVNode("div", {
            innerHTML: _ctx.privacyPolicy.content
          }, null, 8, _hoisted_4$5)
        ]),
        footer: withCtx(() => [
          createVNode(_component_ButtonComponent, {
            class: "modal-footer-btn-close",
            label: "Close",
            "aria-label": "close",
            onClick: $options.closeModal
          }, null, 8, ["onClick"])
        ]),
        _: 1
      }, 8, ["visible", "onClose"])
    ], 64)) : createCommentVNode("", true);
  }
  var PrivacyPolicy = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-310c7762"]]);
  var getAdditionalPaymentData = () => ({});
  const _sfc_main$a = {
    name: "BraintreeAch",
    components: {
      Agreements,
      CheckboxComponent,
      ErrorMessage,
      MyButton,
      PrivacyPolicy,
      Recaptcha,
      SelectInput,
      TextField,
      TextInput
    },
    data() {
      return {
        loading: false,
        selectedMethod: null,
        routingNumber: "",
        accountNumber: "",
        accountType: "checking",
        ownershipType: "personal",
        firstname: "",
        lastname: "",
        businessName: "",
        achMandate: false,
        usBankAccount: null,
        achLocation: null
      };
    },
    computed: {
      ...mapState(useBraintreeStore, [
        "ach",
        "clientInstance",
        "errorMessage",
        "merchantAccountId"
      ]),
      ...mapState(useConfigStore, ["currencyCode", "websiteName"]),
      ...mapState(useCartStore, ["cart", "cartGrandTotal"]),
      ...mapState(useCustomerStore, ["customer", "selected"]),
      ...mapState(usePaymentStore, ["paymentEmitter", "getPaymentPriority"]),
      ...mapState(useRecaptchaStore, ["isRecaptchaVisible"])
    },
    async created() {
      await this.getInitialConfig();
      await this.createClientToken();
      if (this.clientInstance) {
        this.createInstance();
      } else {
        const braintreeStore = useBraintreeStore();
        braintreeStore.$subscribe((mutation) => {
          if (mutation.payload && "clientInstance" in mutation.payload) {
            this.createInstance();
          }
        });
      }
      this.paymentEmitter.on("braintreePaymentStart", () => {
        this.loading = true;
      });
      this.paymentEmitter.on("braintreePaymentError", () => {
        this.loading = false;
      });
      this.paymentEmitter.on("braintreeInitComplete", () => {
        this.achLocation = ".braintree-sheet__container";
      });
      this.paymentEmitter.on("paymentMethodSelected", ({ id }) => {
        this.selectedMethod = id;
      });
    },
    methods: {
      ...mapActions(useAgreementStore, ["validateAgreements"]),
      ...mapActions(useBraintreeStore, [
        "createClientToken",
        "setErrorMessage",
        "clearErrorMessage"
      ]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useRecaptchaStore, ["validateToken"]),
      selectMethod() {
        this.paymentEmitter.emit("paymentMethodSelected", { id: "braintree-ach" });
      },
      async createInstance() {
        const options = {
          client: this.clientInstance
        };
        this.usBankAccount = await braintree.usBankAccount.create(options);
      },
      getAccountTypeOptions() {
        return [
          {
            option: {
              name: "Checking",
              value: "checking"
            }
          },
          {
            option: {
              name: "Savings",
              value: "savings"
            }
          }
        ];
      },
      getOwnershipTypeOptions() {
        return [
          {
            option: {
              name: "Personal",
              value: "personal"
            }
          },
          {
            option: {
              name: "Business",
              value: "business"
            }
          }
        ];
      },
      async startPayment() {
        this.clearErrorMessage();
      },
      getPaymentData(payload) {
        const additionalPaymentData = getAdditionalPaymentData();
        return {
          email: this.customer.email,
          paymentMethod: {
            method: "braintree_ach_direct_debit",
            additional_data: {
              payment_method_nonce: payload.nonce,
              ...additionalPaymentData
            },
            extension_attributes: getPaymentExtensionAttributes()
          }
        };
      },
      redirectToSuccess() {
        window.location.href = getSuccessPageUrl();
      }
    }
  };
  const _withScopeId$1 = (n) => (pushScopeId("data-v-01c349ac"), n = n(), popScopeId(), n);
  const _hoisted_1$8 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "braintree-option__logo" }, [
    /* @__PURE__ */ createBaseVNode("svg", {
      width: "48",
      height: "29",
      class: ""
    }, [
      /* @__PURE__ */ createBaseVNode("use", { "xlink:href": "#logoAch" })
    ])
  ], -1));
  const _hoisted_2$6 = ["aria-label"];
  const _hoisted_3$6 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "braintree-option__disabled-message" }, null, -1));
  const _hoisted_4$4 = { class: "braintree-ach-container" };
  const _hoisted_5$4 = { class: "braintree-ach-mandate" };
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_TextInput = resolveComponent("TextInput");
    const _component_SelectInput = resolveComponent("SelectInput");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_CheckboxComponent = resolveComponent("CheckboxComponent");
    const _component_TextField = resolveComponent("TextField");
    const _component_Agreements = resolveComponent("Agreements");
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_PrivacyPolicy = resolveComponent("PrivacyPolicy");
    const _component_MyButton = resolveComponent("MyButton");
    return $data.achLocation ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: $data.achLocation
    }, [
      !$data.loading && _ctx.clientInstance ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "braintree-form braintree-sheet",
        style: normalizeStyle({
          "--braintree-method-position": _ctx.getPaymentPriority("braintree_ach_direct_debit") + 1
        })
      }, [
        createBaseVNode("div", {
          "data-braintree-id": "ach",
          class: "braintree-ach braintree-sheet",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.selectMethod && $options.selectMethod(...args)),
          onKeydown: _cache[1] || (_cache[1] = (...args) => $options.selectMethod && $options.selectMethod(...args))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["braintree-option braintree-option__ach", { "braintree-option__selected": $data.selectedMethod === "braintree-ach" }]),
            tabindex: "0",
            role: "button"
          }, [
            _hoisted_1$8,
            createBaseVNode("div", {
              class: "braintree-option__label",
              "aria-label": _ctx.$t("braintree.ach.payment")
            }, [
              createTextVNode(toDisplayString$1(_ctx.$t("braintree.ach.payment")) + " ", 1),
              _hoisted_3$6
            ], 8, _hoisted_2$6)
          ], 2)
        ], 32),
        withDirectives(createBaseVNode("div", _hoisted_4$4, [
          createVNode(_component_TextInput, {
            modelValue: $data.routingNumber,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.routingNumber = $event),
            name: "routing-number",
            placeholder: _ctx.$t("braintree.ach.routingNumber"),
            autocomplete: "off"
          }, null, 8, ["modelValue", "placeholder"]),
          createVNode(_component_TextInput, {
            modelValue: $data.accountNumber,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.accountNumber = $event),
            name: "account-number",
            placeholder: _ctx.$t("braintree.ach.accountNumber"),
            autocomplete: "off"
          }, null, 8, ["modelValue", "placeholder"]),
          createVNode(_component_SelectInput, {
            modelValue: $data.accountType,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.accountType = $event),
            options: $options.getAccountTypeOptions(),
            label: _ctx.$t("braintree.ach.accountType")
          }, null, 8, ["modelValue", "options", "label"]),
          createVNode(_component_SelectInput, {
            modelValue: $data.ownershipType,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.ownershipType = $event),
            options: $options.getOwnershipTypeOptions(),
            label: _ctx.$t("braintree.ach.ownershipType")
          }, null, 8, ["modelValue", "options", "label"]),
          $data.ownershipType === "personal" ? (openBlock(), createBlock(_component_TextInput, {
            key: 0,
            modelValue: $data.firstname,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.firstname = $event),
            name: "firstname",
            placeholder: _ctx.$t("braintree.ach.firstname"),
            autocomplete: "off"
          }, null, 8, ["modelValue", "placeholder"])) : createCommentVNode("", true),
          $data.ownershipType === "personal" ? (openBlock(), createBlock(_component_TextInput, {
            key: 1,
            modelValue: $data.lastname,
            "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.lastname = $event),
            name: "lastname",
            placeholder: _ctx.$t("braintree.ach.lastname"),
            autocomplete: "off"
          }, null, 8, ["modelValue", "placeholder"])) : createCommentVNode("", true),
          $data.ownershipType === "business" ? (openBlock(), createBlock(_component_TextInput, {
            key: 2,
            modelValue: $data.businessName,
            "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.businessName = $event),
            class: "braintree-ach-business-name",
            name: "business-name",
            placeholder: _ctx.$t("braintree.ach.businessName"),
            autocomplete: "off"
          }, null, 8, ["modelValue", "placeholder"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_5$4, [
            _ctx.errorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
              key: 0,
              message: _ctx.errorMessage,
              attached: false
            }, null, 8, ["message"])) : createCommentVNode("", true),
            createVNode(_component_CheckboxComponent, {
              checked: $data.achMandate,
              "change-handler": ({ currentTarget }) => $data.achMandate = currentTarget.checked,
              text: _ctx.$t("braintree.ach.proof")
            }, null, 8, ["checked", "change-handler", "text"]),
            createVNode(_component_TextField, {
              text: _ctx.$t("braintree.ach.terms", { websiteName: _ctx.websiteName })
            }, null, 8, ["text"]),
            createVNode(_component_Agreements, { id: "braintreeAch" }),
            _ctx.isRecaptchaVisible("placeOrder") ? (openBlock(), createBlock(_component_Recaptcha, {
              key: 1,
              id: "placeOrder",
              location: "braintreeAch"
            })) : createCommentVNode("", true),
            createVNode(_component_PrivacyPolicy),
            createVNode(_component_MyButton, {
              label: "Pay",
              primary: "",
              onClick: _cache[9] || (_cache[9] = ($event) => $options.startPayment())
            })
          ])
        ], 512), [
          [vShow, $data.selectedMethod === "braintree-ach"]
        ])
      ], 4)) : createCommentVNode("", true)
    ], 8, ["to"])) : createCommentVNode("", true);
  }
  var BraintreeAch = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-01c349ac"]]);
  var bancontact = "/bancontact.svg";
  var eps = "/eps.svg";
  var giropay = "/giropay.svg";
  var ideal = "/ideal.svg";
  var mybank = "/mybank.svg";
  var p24 = "/p24.svg";
  var sepa = "/sepa.svg";
  var sofort = "/sofort.svg";
  var images = {
    bancontact,
    eps,
    giropay,
    ideal,
    mybank,
    p24,
    sepa,
    sofort
  };
  const _sfc_main$9 = {
    name: "BraintreeLpm",
    components: {
      Agreements,
      ErrorMessage,
      PrivacyPolicy,
      Recaptcha,
      TextField
    },
    data() {
      return {
        loading: false,
        selectedMethod: null,
        lpmLocation: null
      };
    },
    computed: {
      ...mapState(useBraintreeStore, [
        "merchantAccountId",
        "clientInstance",
        "lpm",
        "getFilteredLpmMethods",
        "errorMessage"
      ]),
      ...mapState(useConfigStore, ["currencyCode"]),
      ...mapState(useCartStore, ["cart", "cartGrandTotal"]),
      ...mapState(useCustomerStore, ["customer", "selected", "getSelectedBillingAddress"]),
      ...mapState(usePaymentStore, ["paymentEmitter", "getPaymentPriority"]),
      ...mapState(useRecaptchaStore, ["isRecaptchaVisible"])
    },
    async created() {
      await this.getInitialConfig();
      await this.createClientToken();
      this.paymentEmitter.on("braintreePaymentStart", () => {
        this.loading = true;
      });
      this.paymentEmitter.on("braintreePaymentError", () => {
        this.loading = false;
      });
      this.paymentEmitter.on("braintreeInitComplete", () => {
        this.lpmLocation = ".braintree-sheet__container";
      });
      this.paymentEmitter.on("paymentMethodSelected", ({ id }) => {
        this.selectedMethod = id;
      });
    },
    methods: {
      ...mapActions(useAgreementStore, ["validateAgreements"]),
      ...mapActions(useBraintreeStore, [
        "createClientToken",
        "setErrorMessage",
        "clearErrorMessage"
      ]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(usePaymentStore, ["getPaymentMethodTitle"]),
      ...mapActions(useRecaptchaStore, ["validateToken"]),
      getIcon(method) {
        return getStaticUrl(images[method]);
      },
      selectMethod() {
        this.paymentEmitter.emit("paymentMethodSelected", { id: "braintree-lpm" });
      },
      async initialiseLpm() {
        this.clearErrorMessage();
      },
      getPaymentData(payload) {
        const additionalPaymentData = getAdditionalPaymentData();
        return {
          email: this.customer.email,
          paymentMethod: {
            method: "braintree_local_payment",
            additional_data: {
              payment_method_nonce: payload.nonce,
              ...additionalPaymentData
            },
            extension_attributes: getPaymentExtensionAttributes()
          }
        };
      },
      redirectToSuccess() {
        window.location.href = getSuccessPageUrl();
      }
    }
  };
  const _withScopeId = (n) => (pushScopeId("data-v-6d64a483"), n = n(), popScopeId(), n);
  const _hoisted_1$7 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "braintree-option__logo" }, [
    /* @__PURE__ */ createBaseVNode("svg", {
      width: "48",
      height: "29",
      class: ""
    }, [
      /* @__PURE__ */ createBaseVNode("use", { "xlink:href": "#logoLpm" })
    ])
  ], -1));
  const _hoisted_2$5 = ["aria-label"];
  const _hoisted_3$5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "braintree-option__disabled-message" }, null, -1));
  const _hoisted_4$3 = { class: "braintree-lpm-container" };
  const _hoisted_5$3 = ["onClick"];
  const _hoisted_6$3 = ["src", "alt"];
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    var _a;
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_Agreements = resolveComponent("Agreements");
    const _component_PrivacyPolicy = resolveComponent("PrivacyPolicy");
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_TextField = resolveComponent("TextField");
    return $data.lpmLocation ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: $data.lpmLocation
    }, [
      !$data.loading && _ctx.clientInstance ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "braintree-form braintree-sheet",
        style: normalizeStyle({
          "--braintree-method-position": _ctx.getPaymentPriority("braintree_local_payment") + 1
        })
      }, [
        createBaseVNode("div", {
          "data-braintree-id": "lpm",
          class: "braintree-lpm braintree-sheet",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.selectMethod && $options.selectMethod(...args)),
          onKeydown: _cache[1] || (_cache[1] = (...args) => $options.selectMethod && $options.selectMethod(...args))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["braintree-option braintree-option__lpm", { "braintree-option__selected": $data.selectedMethod === "braintree-lpm" }]),
            tabindex: "0",
            role: "button"
          }, [
            _hoisted_1$7,
            createBaseVNode("div", {
              class: "braintree-option__label",
              "aria-label": _ctx.$t("braintree.payingWith", { paymentTitle: _ctx.getPaymentMethodTitle("braintree_local_payment") })
            }, [
              createTextVNode(toDisplayString$1(_ctx.getPaymentMethodTitle("braintree_local_payment")) + " ", 1),
              _hoisted_3$5
            ], 8, _hoisted_2$5)
          ], 2)
        ], 32),
        withDirectives(createBaseVNode("div", _hoisted_4$3, [
          ((_a = _ctx.getFilteredLpmMethods) == null ? void 0 : _a.length) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _ctx.errorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
              key: 0,
              message: _ctx.errorMessage,
              attached: false
            }, null, 8, ["message"])) : createCommentVNode("", true),
            createVNode(_component_Agreements, { id: "braintreeLpm" }),
            createVNode(_component_PrivacyPolicy),
            _ctx.isRecaptchaVisible("placeOrder") ? (openBlock(), createBlock(_component_Recaptcha, {
              key: 1,
              id: "placeOrder",
              location: "braintreeLpm"
            })) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getFilteredLpmMethods, (allowedMethod) => {
              return withDirectives((openBlock(), createElementBlock("button", {
                key: allowedMethod,
                class: "button button--secondary braintree-lpm-method",
                onClick: ($event) => $options.initialiseLpm(allowedMethod)
              }, [
                createBaseVNode("img", {
                  src: $options.getIcon(allowedMethod),
                  alt: allowedMethod
                }, null, 8, _hoisted_6$3)
              ], 8, _hoisted_5$3)), [
                [vShow, !$data.loading]
              ]);
            }), 128))
          ], 64)) : (openBlock(), createBlock(_component_TextField, {
            key: 1,
            text: _ctx.$t("braintree.lpm.noMethods")
          }, null, 8, ["text"]))
        ], 512), [
          [vShow, $data.selectedMethod === "braintree-lpm"]
        ])
      ], 4)) : createCommentVNode("", true)
    ], 8, ["to"])) : createCommentVNode("", true);
  }
  var BraintreeLpm = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-6d64a483"]]);
  var dropin = { exports: {} };
  (function(module, exports) {
    (function(f) {
      {
        module.exports = f();
      }
    })(function() {
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = typeof commonjsRequire == "function" && commonjsRequire;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p2 = n[i2] = { exports: {} };
              e[i2][0].call(p2.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p2, p2.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = typeof commonjsRequire == "function" && commonjsRequire, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.loadStylesheet = exports2.loadScript = void 0;
        var loadScript = require2("./load-script");
        exports2.loadScript = loadScript;
        var loadStylesheet = require2("./load-stylesheet");
        exports2.loadStylesheet = loadStylesheet;
      }, { "./load-script": 3, "./load-stylesheet": 4 }], 2: [function(require2, module2, exports2) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.PromiseGlobal = void 0;
        var promise_polyfill_1 = __importDefault(require2("promise-polyfill"));
        var PromiseGlobal = typeof Promise !== "undefined" ? Promise : promise_polyfill_1.default;
        exports2.PromiseGlobal = PromiseGlobal;
      }, { "promise-polyfill": 184 }], 3: [function(require2, module2, exports2) {
        var promise_1 = require2("./lib/promise");
        var scriptPromiseCache = {};
        function loadScript(options) {
          var scriptLoadPromise;
          var stringifiedOptions = JSON.stringify(options);
          if (!options.forceScriptReload) {
            scriptLoadPromise = scriptPromiseCache[stringifiedOptions];
            if (scriptLoadPromise) {
              return scriptLoadPromise;
            }
          }
          var script = document.createElement("script");
          var attrs = options.dataAttributes || {};
          var container = options.container || document.head;
          script.src = options.src;
          script.id = options.id || "";
          script.async = true;
          if (options.crossorigin) {
            script.setAttribute("crossorigin", "" + options.crossorigin);
          }
          Object.keys(attrs).forEach(function(key) {
            script.setAttribute("data-" + key, "" + attrs[key]);
          });
          scriptLoadPromise = new promise_1.PromiseGlobal(function(resolve2, reject) {
            script.addEventListener("load", function() {
              resolve2(script);
            });
            script.addEventListener("error", function() {
              reject(new Error(options.src + " failed to load."));
            });
            script.addEventListener("abort", function() {
              reject(new Error(options.src + " has aborted."));
            });
            container.appendChild(script);
          });
          scriptPromiseCache[stringifiedOptions] = scriptLoadPromise;
          return scriptLoadPromise;
        }
        loadScript.clearCache = function() {
          scriptPromiseCache = {};
        };
        module2.exports = loadScript;
      }, { "./lib/promise": 2 }], 4: [function(require2, module2, exports2) {
        var promise_1 = require2("./lib/promise");
        module2.exports = function loadStylesheet(options) {
          var stylesheet = document.querySelector('link[href="' + options.href + '"]');
          if (stylesheet) {
            return promise_1.PromiseGlobal.resolve(stylesheet);
          }
          stylesheet = document.createElement("link");
          var container = options.container || document.head;
          stylesheet.setAttribute("rel", "stylesheet");
          stylesheet.setAttribute("type", "text/css");
          stylesheet.setAttribute("href", options.href);
          stylesheet.setAttribute("id", options.id);
          if (container.firstChild) {
            container.insertBefore(stylesheet, container.firstChild);
          } else {
            container.appendChild(stylesheet);
          }
          return promise_1.PromiseGlobal.resolve(stylesheet);
        };
      }, { "./lib/promise": 2 }], 5: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/load-script");
      }, { "./dist/load-script": 3 }], 6: [function(require2, module2, exports2) {
        module2.exports = function isAndroid(ua) {
          ua = ua || window.navigator.userAgent;
          return /Android/i.test(ua);
        };
      }, {}], 7: [function(require2, module2, exports2) {
        module2.exports = function isChromeOS(ua) {
          ua = ua || window.navigator.userAgent;
          return /CrOS/i.test(ua);
        };
      }, {}], 8: [function(require2, module2, exports2) {
        var isEdge = require2("./is-edge");
        var isSamsung = require2("./is-samsung");
        var isDuckDuckGo = require2("./is-duckduckgo");
        var isOpera = require2("./is-opera");
        var isSilk = require2("./is-silk");
        module2.exports = function isChrome(ua) {
          ua = ua || window.navigator.userAgent;
          return (ua.indexOf("Chrome") !== -1 || ua.indexOf("CriOS") !== -1) && !isEdge(ua) && !isSamsung(ua) && !isDuckDuckGo(ua) && !isOpera(ua) && !isSilk(ua);
        };
      }, { "./is-duckduckgo": 9, "./is-edge": 10, "./is-opera": 21, "./is-samsung": 22, "./is-silk": 23 }], 9: [function(require2, module2, exports2) {
        module2.exports = function isDuckDuckGo(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("DuckDuckGo/") !== -1;
        };
      }, {}], 10: [function(require2, module2, exports2) {
        module2.exports = function isEdge(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("Edge/") !== -1;
        };
      }, {}], 11: [function(require2, module2, exports2) {
        module2.exports = function isFirefox(ua) {
          ua = ua || window.navigator.userAgent;
          return /Firefox/i.test(ua);
        };
      }, {}], 12: [function(require2, module2, exports2) {
        module2.exports = function isIe10(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("MSIE 10") !== -1;
        };
      }, {}], 13: [function(require2, module2, exports2) {
        module2.exports = function isIe9(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("MSIE 9") !== -1;
        };
      }, {}], 14: [function(require2, module2, exports2) {
        module2.exports = function isIosFirefox(ua) {
          ua = ua || window.navigator.userAgent;
          return /FxiOS/i.test(ua);
        };
      }, {}], 15: [function(require2, module2, exports2) {
        var isIos = require2("./is-ios");
        function isGoogleSearchApp(ua) {
          return /\bGSA\b/.test(ua);
        }
        module2.exports = function isIosGoogleSearchApp(ua) {
          ua = ua || window.navigator.userAgent;
          return isIos(ua) && isGoogleSearchApp(ua);
        };
      }, { "./is-ios": 19 }], 16: [function(require2, module2, exports2) {
        var isIos = require2("./is-ios");
        var isIosFirefox = require2("./is-ios-firefox");
        var webkitRegexp = /webkit/i;
        function isWebkit(ua) {
          return webkitRegexp.test(ua);
        }
        function isIosChrome(ua) {
          return ua.indexOf("CriOS") > -1;
        }
        function isFacebook(ua) {
          return ua.indexOf("FBAN") > -1;
        }
        module2.exports = function isIosSafari(ua) {
          ua = ua || window.navigator.userAgent;
          return isIos(ua) && isWebkit(ua) && !isIosChrome(ua) && !isIosFirefox(ua) && !isFacebook(ua);
        };
      }, { "./is-ios": 19, "./is-ios-firefox": 14 }], 17: [function(require2, module2, exports2) {
        var isIos = require2("./is-ios");
        var isIosGoogleSearchApp = require2("./is-ios-google-search-app");
        module2.exports = function isIosWebview(ua) {
          ua = ua || window.navigator.userAgent;
          if (isIos(ua)) {
            if (isIosGoogleSearchApp(ua)) {
              return true;
            }
            return /.+AppleWebKit(?!.*Safari)/i.test(ua);
          }
          return false;
        };
      }, { "./is-ios": 19, "./is-ios-google-search-app": 15 }], 18: [function(require2, module2, exports2) {
        var isIosWebview = require2("./is-ios-webview");
        module2.exports = function isIosWKWebview(ua, statusBarVisible) {
          statusBarVisible = typeof statusBarVisible !== "undefined" ? statusBarVisible : window.statusbar.visible;
          return isIosWebview(ua) && statusBarVisible;
        };
      }, { "./is-ios-webview": 17 }], 19: [function(require2, module2, exports2) {
        var isIpadOS = require2("./is-ipados");
        module2.exports = function isIos(ua, checkIpadOS, document2) {
          if (checkIpadOS === void 0) {
            checkIpadOS = true;
          }
          ua = ua || window.navigator.userAgent;
          var iOsTest = /iPhone|iPod|iPad/i.test(ua);
          return checkIpadOS ? iOsTest || isIpadOS(ua, document2) : iOsTest;
        };
      }, { "./is-ipados": 20 }], 20: [function(require2, module2, exports2) {
        module2.exports = function isIpadOS(ua, document2) {
          ua = ua || window.navigator.userAgent;
          document2 = document2 || window.document;
          return /Mac|iPad/i.test(ua) && "ontouchend" in document2;
        };
      }, {}], 21: [function(require2, module2, exports2) {
        module2.exports = function isOpera(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("OPR/") !== -1 || ua.indexOf("Opera/") !== -1 || ua.indexOf("OPT/") !== -1;
        };
      }, {}], 22: [function(require2, module2, exports2) {
        module2.exports = function isSamsungBrowser(ua) {
          ua = ua || window.navigator.userAgent;
          return /SamsungBrowser/i.test(ua);
        };
      }, {}], 23: [function(require2, module2, exports2) {
        module2.exports = function isSilk(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("Silk/") !== -1;
        };
      }, {}], 24: [function(require2, module2, exports2) {
        var MINIMUM_SUPPORTED_CHROME_IOS_VERSION = 48;
        var isAndroid = require2("./is-android");
        var isIosFirefox = require2("./is-ios-firefox");
        var isIosWebview = require2("./is-ios-webview");
        var isChrome = require2("./is-chrome");
        var isSamsungBrowser = require2("./is-samsung");
        var isDuckDuckGo = require2("./is-duckduckgo");
        function isUnsupportedIosChrome(ua) {
          ua = ua || window.navigator.userAgent;
          var match = ua.match(/CriOS\/(\d+)\./);
          if (!match) {
            return false;
          }
          var version2 = parseInt(match[1], 10);
          return version2 < MINIMUM_SUPPORTED_CHROME_IOS_VERSION;
        }
        function isOperaMini(ua) {
          ua = ua || window.navigator.userAgent;
          return ua.indexOf("Opera Mini") > -1;
        }
        function isAndroidWebview(ua) {
          var androidWebviewRegExp = /Version\/[\d.]+/i;
          ua = ua || window.navigator.userAgent;
          if (isAndroid(ua)) {
            return androidWebviewRegExp.test(ua) && !isOperaMini(ua) && !isDuckDuckGo(ua);
          }
          return false;
        }
        function isOldSamsungBrowserOrSamsungWebview(ua) {
          return !isChrome(ua) && !isSamsungBrowser(ua) && /samsung/i.test(ua);
        }
        module2.exports = function supportsPopups(ua) {
          ua = ua || window.navigator.userAgent;
          return !(isIosWebview(ua) || isIosFirefox(ua) || isAndroidWebview(ua) || isOperaMini(ua) || isUnsupportedIosChrome(ua) || isOldSamsungBrowserOrSamsungWebview(ua));
        };
      }, { "./is-android": 6, "./is-chrome": 8, "./is-duckduckgo": 9, "./is-ios-firefox": 14, "./is-ios-webview": 17, "./is-samsung": 22 }], 25: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-android");
      }, { "./dist/is-android": 6 }], 26: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-chrome-os");
      }, { "./dist/is-chrome-os": 7 }], 27: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-chrome");
      }, { "./dist/is-chrome": 8 }], 28: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-firefox");
      }, { "./dist/is-firefox": 11 }], 29: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-ie10");
      }, { "./dist/is-ie10": 12 }], 30: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-ie9");
      }, { "./dist/is-ie9": 13 }], 31: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-ios-safari");
      }, { "./dist/is-ios-safari": 16 }], 32: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-ios-webview");
      }, { "./dist/is-ios-webview": 17 }], 33: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-ios-wkwebview");
      }, { "./dist/is-ios-wkwebview": 18 }], 34: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-ios");
      }, { "./dist/is-ios": 19 }], 35: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/is-samsung");
      }, { "./dist/is-samsung": 22 }], 36: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/supports-popups");
      }, { "./dist/supports-popups": 24 }], 37: [function(require2, module2, exports2) {
        var EventEmitter = function() {
          function EventEmitter2() {
            this._events = {};
          }
          EventEmitter2.prototype.on = function(event, callback) {
            if (this._events[event]) {
              this._events[event].push(callback);
            } else {
              this._events[event] = [callback];
            }
          };
          EventEmitter2.prototype.off = function(event, callback) {
            var eventCallbacks = this._events[event];
            if (!eventCallbacks) {
              return;
            }
            var indexOfCallback = eventCallbacks.indexOf(callback);
            eventCallbacks.splice(indexOfCallback, 1);
          };
          EventEmitter2.prototype._emit = function(event) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
            }
            var eventCallbacks = this._events[event];
            if (!eventCallbacks) {
              return;
            }
            eventCallbacks.forEach(function(callback) {
              callback.apply(void 0, args);
            });
          };
          EventEmitter2.prototype.hasListener = function(event) {
            var eventCallbacks = this._events[event];
            if (!eventCallbacks) {
              return false;
            }
            return eventCallbacks.length > 0;
          };
          EventEmitter2.createChild = function(ChildObject) {
            ChildObject.prototype = Object.create(EventEmitter2.prototype, {
              constructor: ChildObject
            });
          };
          return EventEmitter2;
        }();
        module2.exports = EventEmitter;
      }, {}], 38: [function(require2, module2, exports2) {
        var GlobalPromise = typeof Promise !== "undefined" ? Promise : null;
        var ExtendedPromise = function() {
          function ExtendedPromise2(options) {
            var _this = this;
            if (typeof options === "function") {
              this._promise = new ExtendedPromise2.Promise(options);
              return;
            }
            this._promise = new ExtendedPromise2.Promise(function(resolve2, reject) {
              _this._resolveFunction = resolve2;
              _this._rejectFunction = reject;
            });
            options = options || {};
            this._onResolve = options.onResolve || ExtendedPromise2.defaultOnResolve;
            this._onReject = options.onReject || ExtendedPromise2.defaultOnReject;
            if (ExtendedPromise2.shouldCatchExceptions(options)) {
              this._promise.catch(function() {
              });
            }
            this._resetState();
          }
          ExtendedPromise2.defaultOnResolve = function(result) {
            return ExtendedPromise2.Promise.resolve(result);
          };
          ExtendedPromise2.defaultOnReject = function(err) {
            return ExtendedPromise2.Promise.reject(err);
          };
          ExtendedPromise2.setPromise = function(PromiseClass) {
            ExtendedPromise2.Promise = PromiseClass;
          };
          ExtendedPromise2.shouldCatchExceptions = function(options) {
            if (options.hasOwnProperty("suppressUnhandledPromiseMessage")) {
              return Boolean(options.suppressUnhandledPromiseMessage);
            }
            return Boolean(ExtendedPromise2.suppressUnhandledPromiseMessage);
          };
          ExtendedPromise2.all = function(args) {
            return ExtendedPromise2.Promise.all(args);
          };
          ExtendedPromise2.allSettled = function(args) {
            return ExtendedPromise2.Promise.allSettled(args);
          };
          ExtendedPromise2.race = function(args) {
            return ExtendedPromise2.Promise.race(args);
          };
          ExtendedPromise2.reject = function(arg) {
            return ExtendedPromise2.Promise.reject(arg);
          };
          ExtendedPromise2.resolve = function(arg) {
            return ExtendedPromise2.Promise.resolve(arg);
          };
          ExtendedPromise2.prototype.then = function() {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = this._promise).then.apply(_a, args);
          };
          ExtendedPromise2.prototype.catch = function() {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = this._promise).catch.apply(_a, args);
          };
          ExtendedPromise2.prototype.resolve = function(arg) {
            var _this = this;
            if (this.isFulfilled) {
              return this;
            }
            this._setResolved();
            ExtendedPromise2.Promise.resolve().then(function() {
              return _this._onResolve(arg);
            }).then(function(argForResolveFunction) {
              _this._resolveFunction(argForResolveFunction);
            }).catch(function(err) {
              _this._resetState();
              _this.reject(err);
            });
            return this;
          };
          ExtendedPromise2.prototype.reject = function(arg) {
            var _this = this;
            if (this.isFulfilled) {
              return this;
            }
            this._setRejected();
            ExtendedPromise2.Promise.resolve().then(function() {
              return _this._onReject(arg);
            }).then(function(result) {
              _this._setResolved();
              _this._resolveFunction(result);
            }).catch(function(err) {
              return _this._rejectFunction(err);
            });
            return this;
          };
          ExtendedPromise2.prototype._resetState = function() {
            this.isFulfilled = false;
            this.isResolved = false;
            this.isRejected = false;
          };
          ExtendedPromise2.prototype._setResolved = function() {
            this.isFulfilled = true;
            this.isResolved = true;
            this.isRejected = false;
          };
          ExtendedPromise2.prototype._setRejected = function() {
            this.isFulfilled = true;
            this.isResolved = false;
            this.isRejected = true;
          };
          ExtendedPromise2.Promise = GlobalPromise;
          return ExtendedPromise2;
        }();
        module2.exports = ExtendedPromise;
      }, {}], 39: [function(require2, module2, exports2) {
        var set_attributes_1 = require2("./lib/set-attributes");
        var default_attributes_1 = require2("./lib/default-attributes");
        var assign_1 = require2("./lib/assign");
        module2.exports = function createFrame(options) {
          if (options === void 0) {
            options = {};
          }
          var iframe = document.createElement("iframe");
          var config = assign_1.assign({}, default_attributes_1.defaultAttributes, options);
          if (config.style && typeof config.style !== "string") {
            assign_1.assign(iframe.style, config.style);
            delete config.style;
          }
          set_attributes_1.setAttributes(iframe, config);
          if (!iframe.getAttribute("id")) {
            iframe.id = iframe.name;
          }
          return iframe;
        };
      }, { "./lib/assign": 40, "./lib/default-attributes": 41, "./lib/set-attributes": 42 }], 40: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.assign = void 0;
        function assign2(target) {
          var objs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            objs[_i - 1] = arguments[_i];
          }
          objs.forEach(function(obj) {
            if (typeof obj !== "object") {
              return;
            }
            Object.keys(obj).forEach(function(key) {
              target[key] = obj[key];
            });
          });
          return target;
        }
        exports2.assign = assign2;
      }, {}], 41: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.defaultAttributes = void 0;
        exports2.defaultAttributes = {
          src: "about:blank",
          frameBorder: 0,
          allowtransparency: true,
          scrolling: "no"
        };
      }, {}], 42: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.setAttributes = void 0;
        function setAttributes(element, attributes) {
          for (var key in attributes) {
            if (attributes.hasOwnProperty(key)) {
              var value = attributes[key];
              if (value == null) {
                element.removeAttribute(key);
              } else {
                element.setAttribute(key, value);
              }
            }
          }
        }
        exports2.setAttributes = setAttributes;
      }, {}], 43: [function(require2, module2, exports2) {
        function uuid() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0;
            var v = c === "x" ? r : r & 3 | 8;
            return v.toString(16);
          });
        }
        module2.exports = uuid;
      }, {}], 44: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function deferred(fn) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            setTimeout(function() {
              try {
                fn.apply(void 0, args);
              } catch (err) {
                console.log("Error in callback function");
                console.log(err);
              }
            }, 1);
          };
        }
        exports2.deferred = deferred;
      }, {}], 45: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function once(fn) {
          var called = false;
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (!called) {
              called = true;
              fn.apply(void 0, args);
            }
          };
        }
        exports2.once = once;
      }, {}], 46: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function promiseOrCallback(promise, callback) {
          if (!callback) {
            return promise;
          }
          promise.then(function(data2) {
            return callback(null, data2);
          }).catch(function(err) {
            return callback(err);
          });
        }
        exports2.promiseOrCallback = promiseOrCallback;
      }, {}], 47: [function(require2, module2, exports2) {
        var deferred_1 = require2("./lib/deferred");
        var once_1 = require2("./lib/once");
        var promise_or_callback_1 = require2("./lib/promise-or-callback");
        function wrapPromise(fn) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var callback;
            var lastArg = args[args.length - 1];
            if (typeof lastArg === "function") {
              callback = args.pop();
              callback = once_1.once(deferred_1.deferred(callback));
            }
            return promise_or_callback_1.promiseOrCallback(fn.apply(this, args), callback);
          };
        }
        wrapPromise.wrapPrototype = function(target, options) {
          if (options === void 0) {
            options = {};
          }
          var ignoreMethods = options.ignoreMethods || [];
          var includePrivateMethods = options.transformPrivateMethods === true;
          var methods = Object.getOwnPropertyNames(target.prototype).filter(function(method) {
            var isNotPrivateMethod;
            var isNonConstructorFunction = method !== "constructor" && typeof target.prototype[method] === "function";
            var isNotAnIgnoredMethod = ignoreMethods.indexOf(method) === -1;
            if (includePrivateMethods) {
              isNotPrivateMethod = true;
            } else {
              isNotPrivateMethod = method.charAt(0) !== "_";
            }
            return isNonConstructorFunction && isNotPrivateMethod && isNotAnIgnoredMethod;
          });
          methods.forEach(function(method) {
            var original = target.prototype[method];
            target.prototype[method] = wrapPromise(original);
          });
          return target;
        };
        module2.exports = wrapPromise;
      }, { "./lib/deferred": 44, "./lib/once": 45, "./lib/promise-or-callback": 46 }], 48: [function(require2, module2, exports2) {
        var BraintreeError = require2("../lib/braintree-error");
        var analytics = require2("../lib/analytics");
        var errors = require2("./errors");
        var methods = require2("../lib/methods");
        var convertMethodsToError = require2("../lib/convert-methods-to-error");
        var wrapPromise = require2("@braintree/wrap-promise");
        function ApplePay(options) {
          this._instantiatedWithClient = Boolean(!options.useDeferredClient);
          this._client = options.client;
          this._createPromise = options.createPromise;
          if (this._client) {
            this._setMerchantIdentifier();
          }
        }
        ApplePay.prototype._waitForClient = function() {
          if (this._client) {
            return Promise.resolve();
          }
          return this._createPromise.then(function(client) {
            this._client = client;
            this._setMerchantIdentifier();
          }.bind(this));
        };
        ApplePay.prototype._setMerchantIdentifier = function() {
          var applePayConfig = this._client.getConfiguration().gatewayConfiguration.applePayWeb;
          if (!applePayConfig) {
            return;
          }
          Object.defineProperty(this, "merchantIdentifier", {
            value: applePayConfig.merchantIdentifier,
            configurable: false,
            writable: false
          });
        };
        ApplePay.prototype.createPaymentRequest = function(paymentRequest) {
          if (this._instantiatedWithClient) {
            return this._createPaymentRequestSynchronously(paymentRequest);
          }
          return this._waitForClient().then(function() {
            return this._createPaymentRequestSynchronously(paymentRequest);
          }.bind(this));
        };
        ApplePay.prototype._createPaymentRequestSynchronously = function(paymentRequest) {
          var applePay = this._client.getConfiguration().gatewayConfiguration.applePayWeb;
          var defaults2 = {
            countryCode: applePay.countryCode,
            currencyCode: applePay.currencyCode,
            merchantCapabilities: applePay.merchantCapabilities || ["supports3DS"],
            supportedNetworks: applePay.supportedNetworks.map(function(network) {
              return network === "mastercard" ? "masterCard" : network;
            })
          };
          return Object.assign({}, defaults2, paymentRequest);
        };
        ApplePay.prototype.performValidation = function(options) {
          var self2 = this;
          if (!options || !options.validationURL) {
            return Promise.reject(new BraintreeError(errors.APPLE_PAY_VALIDATION_URL_REQUIRED));
          }
          return this._waitForClient().then(function() {
            var applePayWebSession = {
              validationUrl: options.validationURL,
              domainName: options.domainName || window.location.hostname,
              merchantIdentifier: options.merchantIdentifier || self2.merchantIdentifier
            };
            if (options.displayName != null) {
              applePayWebSession.displayName = options.displayName;
            }
            return self2._client.request({
              method: "post",
              endpoint: "apple_pay_web/sessions",
              data: {
                _meta: { source: "apple-pay" },
                applePayWebSession
              }
            });
          }).then(function(response) {
            analytics.sendEvent(self2._client, "applepay.performValidation.succeeded");
            return Promise.resolve(response);
          }).catch(function(err) {
            analytics.sendEvent(self2._client, "applepay.performValidation.failed");
            if (err.code === "CLIENT_REQUEST_ERROR") {
              return Promise.reject(new BraintreeError({
                type: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.type,
                code: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.code,
                message: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.message,
                details: {
                  originalError: err.details.originalError
                }
              }));
            }
            return Promise.reject(new BraintreeError({
              type: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.type,
              code: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.code,
              message: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.message,
              details: {
                originalError: err
              }
            }));
          });
        };
        ApplePay.prototype.tokenize = function(options) {
          var self2 = this;
          if (!options.token) {
            return Promise.reject(new BraintreeError(errors.APPLE_PAY_PAYMENT_TOKEN_REQUIRED));
          }
          return this._waitForClient().then(function() {
            return self2._client.request({
              method: "post",
              endpoint: "payment_methods/apple_payment_tokens",
              data: {
                _meta: {
                  source: "apple-pay"
                },
                applePaymentToken: Object.assign({}, options.token, {
                  paymentData: btoa(JSON.stringify(options.token.paymentData))
                })
              }
            });
          }).then(function(response) {
            analytics.sendEvent(self2._client, "applepay.tokenize.succeeded");
            return Promise.resolve(response.applePayCards[0]);
          }).catch(function(err) {
            analytics.sendEvent(self2._client, "applepay.tokenize.failed");
            return Promise.reject(new BraintreeError({
              type: errors.APPLE_PAY_TOKENIZATION.type,
              code: errors.APPLE_PAY_TOKENIZATION.code,
              message: errors.APPLE_PAY_TOKENIZATION.message,
              details: {
                originalError: err
              }
            }));
          });
        };
        ApplePay.prototype.teardown = function() {
          convertMethodsToError(this, methods(ApplePay.prototype));
          return Promise.resolve();
        };
        module2.exports = wrapPromise.wrapPrototype(ApplePay);
      }, { "../lib/analytics": 86, "../lib/braintree-error": 91, "../lib/convert-methods-to-error": 93, "../lib/methods": 121, "./errors": 49, "@braintree/wrap-promise": 47 }], 49: [function(require2, module2, exports2) {
        var BraintreeError = require2("../lib/braintree-error");
        module2.exports = {
          APPLE_PAY_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "APPLE_PAY_NOT_ENABLED",
            message: "Apple Pay is not enabled for this merchant."
          },
          APPLE_PAY_VALIDATION_URL_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "APPLE_PAY_VALIDATION_URL_REQUIRED",
            message: "performValidation must be called with a validationURL."
          },
          APPLE_PAY_MERCHANT_VALIDATION_NETWORK: {
            type: BraintreeError.types.NETWORK,
            code: "APPLE_PAY_MERCHANT_VALIDATION_NETWORK",
            message: "A network error occurred when validating the Apple Pay merchant."
          },
          APPLE_PAY_MERCHANT_VALIDATION_FAILED: {
            type: BraintreeError.types.MERCHANT,
            code: "APPLE_PAY_MERCHANT_VALIDATION_FAILED",
            message: "Make sure you have registered your domain name in the Braintree Control Panel."
          },
          APPLE_PAY_PAYMENT_TOKEN_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "APPLE_PAY_PAYMENT_TOKEN_REQUIRED",
            message: "tokenize must be called with a payment token."
          },
          APPLE_PAY_TOKENIZATION: {
            type: BraintreeError.types.NETWORK,
            code: "APPLE_PAY_TOKENIZATION",
            message: "A network error occurred when processing the Apple Pay payment."
          }
        };
      }, { "../lib/braintree-error": 91 }], 50: [function(require2, module2, exports2) {
        var ApplePay = require2("./apple-pay");
        var analytics = require2("../lib/analytics");
        var BraintreeError = require2("../lib/braintree-error");
        var basicComponentVerification = require2("../lib/basic-component-verification");
        var createAssetsUrl = require2("../lib/create-assets-url");
        var createDeferredClient = require2("../lib/create-deferred-client");
        var errors = require2("./errors");
        var VERSION2 = "3.99.0";
        var wrapPromise = require2("@braintree/wrap-promise");
        function create2(options) {
          var name = "Apple Pay";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var applePayInstance;
            var createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            }).then(function(client) {
              if (!client.getConfiguration().gatewayConfiguration.applePayWeb) {
                return Promise.reject(new BraintreeError(errors.APPLE_PAY_NOT_ENABLED));
              }
              analytics.sendEvent(client, "applepay.initialized");
              return client;
            });
            options.createPromise = createPromise;
            applePayInstance = new ApplePay(options);
            if (!options.useDeferredClient) {
              return createPromise.then(function(client) {
                applePayInstance._client = client;
                return applePayInstance;
              });
            }
            return applePayInstance;
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 86, "../lib/basic-component-verification": 89, "../lib/braintree-error": 91, "../lib/create-assets-url": 95, "../lib/create-deferred-client": 97, "./apple-pay": 48, "./errors": 49, "@braintree/wrap-promise": 47 }], 51: [function(require2, module2, exports2) {
        var BRAINTREE_VERSION = require2("./constants").BRAINTREE_VERSION;
        var GraphQL = require2("./request/graphql");
        var request3 = require2("./request");
        var isVerifiedDomain = require2("../lib/is-verified-domain");
        var BraintreeError = require2("../lib/braintree-error");
        var convertToBraintreeError = require2("../lib/convert-to-braintree-error");
        var getGatewayConfiguration = require2("./get-configuration").getConfiguration;
        var createAuthorizationData = require2("../lib/create-authorization-data");
        var addMetadata = require2("../lib/add-metadata");
        var wrapPromise = require2("@braintree/wrap-promise");
        var once = require2("../lib/once");
        var deferred = require2("../lib/deferred");
        var assign2 = require2("../lib/assign").assign;
        var analytics = require2("../lib/analytics");
        var errors = require2("./errors");
        var VERSION2 = require2("../lib/constants").VERSION;
        var GRAPHQL_URLS = require2("../lib/constants").GRAPHQL_URLS;
        var methods = require2("../lib/methods");
        var convertMethodsToError = require2("../lib/convert-methods-to-error");
        var assets = require2("../lib/assets");
        var FRAUDNET_FNCLS = require2("../lib/constants").FRAUDNET_FNCLS;
        var FRAUDNET_SOURCE = require2("../lib/constants").FRAUDNET_SOURCE;
        var FRAUDNET_URL = require2("../lib/constants").FRAUDNET_URL;
        var cachedClients = {};
        function Client(configuration) {
          var configurationJSON, gatewayConfiguration;
          configuration = configuration || {};
          configurationJSON = JSON.stringify(configuration);
          gatewayConfiguration = configuration.gatewayConfiguration;
          if (!gatewayConfiguration) {
            throw new BraintreeError(errors.CLIENT_MISSING_GATEWAY_CONFIGURATION);
          }
          ["assetsUrl", "clientApiUrl", "configUrl"].forEach(function(property) {
            if (property in gatewayConfiguration && !isVerifiedDomain(gatewayConfiguration[property])) {
              throw new BraintreeError({
                type: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.type,
                code: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.code,
                message: property + " property is on an invalid domain."
              });
            }
          });
          this.getConfiguration = function() {
            return JSON.parse(configurationJSON);
          };
          this._request = request3;
          this._configuration = this.getConfiguration();
          this._clientApiBaseUrl = gatewayConfiguration.clientApiUrl + "/v1/";
          if (gatewayConfiguration.graphQL) {
            if (!isVerifiedDomain(gatewayConfiguration.graphQL.url)) {
              throw new BraintreeError({
                type: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.type,
                code: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.code,
                message: "graphQL.url property is on an invalid domain."
              });
            }
            this._graphQL = new GraphQL({
              graphQL: gatewayConfiguration.graphQL
            });
          }
        }
        Client.initialize = function(options) {
          var clientInstance, authData;
          var promise = cachedClients[options.authorization];
          if (promise) {
            analytics.sendEvent(promise, "custom.client.load.cached");
            return promise;
          }
          try {
            authData = createAuthorizationData(options.authorization);
          } catch (err) {
            return Promise.reject(new BraintreeError(errors.CLIENT_INVALID_AUTHORIZATION));
          }
          promise = getGatewayConfiguration(authData).then(function(configuration) {
            if (options.debug) {
              configuration.isDebug = true;
            }
            configuration.authorization = options.authorization;
            clientInstance = new Client(configuration);
            return clientInstance;
          });
          cachedClients[options.authorization] = promise;
          analytics.sendEvent(promise, "custom.client.load.initialized");
          return promise.then(function(client) {
            analytics.sendEvent(clientInstance, "custom.client.load.succeeded");
            return client;
          }).catch(function(err) {
            delete cachedClients[options.authorization];
            return Promise.reject(err);
          });
        };
        Client.clearCache = function() {
          cachedClients = {};
        };
        Client.prototype._findOrCreateFraudnetJSON = function(clientMetadataId) {
          var el = document.querySelector('script[fncls="' + FRAUDNET_FNCLS + '"]');
          var config, additionalData, authorizationFingerprint, parameters;
          if (!el) {
            el = document.body.appendChild(document.createElement("script"));
            el.type = "application/json";
            el.setAttribute("fncls", FRAUDNET_FNCLS);
          }
          config = this.getConfiguration();
          additionalData = {
            rda_tenant: "bt_card",
            mid: config.gatewayConfiguration.merchantId
          };
          authorizationFingerprint = config.authorizationFingerprint;
          if (authorizationFingerprint) {
            authorizationFingerprint.split("&").forEach(function(pieces) {
              var component = pieces.split("=");
              if (component[0] === "customer_id" && component.length > 1) {
                additionalData.cid = component[1];
              }
            });
          }
          parameters = {
            f: clientMetadataId.substr(0, 32),
            fp: additionalData,
            bu: false,
            s: FRAUDNET_SOURCE
          };
          el.text = JSON.stringify(parameters);
        };
        Client.prototype.request = function(options, callback) {
          var self2 = this;
          var requestPromise = new Promise(function(resolve2, reject) {
            var optionName, api, baseUrl, requestOptions;
            var shouldCollectData = Boolean(options.endpoint === "payment_methods/credit_cards" && self2.getConfiguration().gatewayConfiguration.creditCards.collectDeviceData);
            if (options.api !== "graphQLApi") {
              if (!options.method) {
                optionName = "options.method";
              } else if (!options.endpoint) {
                optionName = "options.endpoint";
              }
            }
            if (optionName) {
              throw new BraintreeError({
                type: errors.CLIENT_OPTION_REQUIRED.type,
                code: errors.CLIENT_OPTION_REQUIRED.code,
                message: optionName + " is required when making a request."
              });
            }
            if ("api" in options) {
              api = options.api;
            } else {
              api = "clientApi";
            }
            requestOptions = {
              method: options.method,
              graphQL: self2._graphQL,
              timeout: options.timeout,
              metadata: self2._configuration.analyticsMetadata
            };
            if (api === "clientApi") {
              baseUrl = self2._clientApiBaseUrl;
              requestOptions.data = addMetadata(self2._configuration, options.data);
            } else if (api === "graphQLApi") {
              baseUrl = GRAPHQL_URLS[self2._configuration.gatewayConfiguration.environment];
              options.endpoint = "";
              requestOptions.method = "post";
              requestOptions.data = assign2({
                clientSdkMetadata: {
                  platform: self2._configuration.analyticsMetadata.platform,
                  source: self2._configuration.analyticsMetadata.source,
                  integration: self2._configuration.analyticsMetadata.integration,
                  sessionId: self2._configuration.analyticsMetadata.sessionId,
                  version: VERSION2
                }
              }, options.data);
              requestOptions.headers = getAuthorizationHeadersForGraphQL(self2._configuration);
            } else {
              throw new BraintreeError({
                type: errors.CLIENT_OPTION_INVALID.type,
                code: errors.CLIENT_OPTION_INVALID.code,
                message: "options.api is invalid."
              });
            }
            requestOptions.url = baseUrl + options.endpoint;
            requestOptions.sendAnalyticsEvent = function(kind) {
              analytics.sendEvent(self2, kind);
            };
            self2._request(requestOptions, function(err, data2, status) {
              var resolvedData, requestError;
              requestError = formatRequestError(status, err);
              if (requestError) {
                reject(requestError);
                return;
              }
              if (api === "graphQLApi" && data2.errors) {
                reject(convertToBraintreeError(data2.errors, {
                  type: errors.CLIENT_GRAPHQL_REQUEST_ERROR.type,
                  code: errors.CLIENT_GRAPHQL_REQUEST_ERROR.code,
                  message: errors.CLIENT_GRAPHQL_REQUEST_ERROR.message
                }));
                return;
              }
              resolvedData = assign2({ _httpStatus: status }, data2);
              if (shouldCollectData && resolvedData.creditCards && resolvedData.creditCards.length > 0) {
                self2._findOrCreateFraudnetJSON(resolvedData.creditCards[0].nonce);
                assets.loadScript({
                  src: FRAUDNET_URL,
                  forceScriptReload: true
                });
              }
              resolve2(resolvedData);
            });
          });
          if (typeof callback === "function") {
            callback = once(deferred(callback));
            requestPromise.then(function(response) {
              callback(null, response, response._httpStatus);
            }).catch(function(err) {
              var status = err && err.details && err.details.httpStatus;
              callback(err, null, status);
            });
            return;
          }
          return requestPromise;
        };
        function formatRequestError(status, err) {
          var requestError;
          if (status === -1) {
            requestError = new BraintreeError(errors.CLIENT_REQUEST_TIMEOUT);
          } else if (status === 401) {
            requestError = new BraintreeError(errors.CLIENT_AUTHORIZATION_INVALID);
          } else if (status === 403) {
            requestError = new BraintreeError(errors.CLIENT_AUTHORIZATION_INSUFFICIENT);
          } else if (status === 429) {
            requestError = new BraintreeError(errors.CLIENT_RATE_LIMITED);
          } else if (status >= 500) {
            requestError = new BraintreeError(errors.CLIENT_GATEWAY_NETWORK);
          } else if (status < 200 || status >= 400) {
            requestError = convertToBraintreeError(err, {
              type: errors.CLIENT_REQUEST_ERROR.type,
              code: errors.CLIENT_REQUEST_ERROR.code,
              message: errors.CLIENT_REQUEST_ERROR.message
            });
          }
          if (requestError) {
            requestError.details = requestError.details || {};
            requestError.details.httpStatus = status;
            return requestError;
          }
        }
        Client.prototype.toJSON = function() {
          return this.getConfiguration();
        };
        Client.prototype.getVersion = function() {
          return VERSION2;
        };
        Client.prototype.teardown = wrapPromise(function() {
          var self2 = this;
          delete cachedClients[self2.getConfiguration().authorization];
          convertMethodsToError(self2, methods(Client.prototype));
          return Promise.resolve();
        });
        function getAuthorizationHeadersForGraphQL(configuration) {
          var token = configuration.authorizationFingerprint || configuration.authorization;
          return {
            Authorization: "Bearer " + token,
            "Braintree-Version": BRAINTREE_VERSION
          };
        }
        module2.exports = Client;
      }, { "../lib/add-metadata": 85, "../lib/analytics": 86, "../lib/assets": 87, "../lib/assign": 88, "../lib/braintree-error": 91, "../lib/constants": 92, "../lib/convert-methods-to-error": 93, "../lib/convert-to-braintree-error": 94, "../lib/create-authorization-data": 96, "../lib/deferred": 98, "../lib/is-verified-domain": 119, "../lib/methods": 121, "../lib/once": 122, "./constants": 52, "./errors": 53, "./get-configuration": 54, "./request": 65, "./request/graphql": 63, "@braintree/wrap-promise": 47 }], 52: [function(require2, module2, exports2) {
        module2.exports = {
          BRAINTREE_VERSION: "2018-05-10"
        };
      }, {}], 53: [function(require2, module2, exports2) {
        var BraintreeError = require2("../lib/braintree-error");
        module2.exports = {
          CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN"
          },
          CLIENT_OPTION_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_OPTION_REQUIRED"
          },
          CLIENT_OPTION_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_OPTION_INVALID"
          },
          CLIENT_MISSING_GATEWAY_CONFIGURATION: {
            type: BraintreeError.types.INTERNAL,
            code: "CLIENT_MISSING_GATEWAY_CONFIGURATION",
            message: "Missing gatewayConfiguration."
          },
          CLIENT_INVALID_AUTHORIZATION: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_INVALID_AUTHORIZATION",
            message: "Authorization is invalid. Make sure your client token or tokenization key is valid."
          },
          CLIENT_GATEWAY_NETWORK: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_GATEWAY_NETWORK",
            message: "Cannot contact the gateway at this time."
          },
          CLIENT_REQUEST_TIMEOUT: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_REQUEST_TIMEOUT",
            message: "Request timed out waiting for a reply."
          },
          CLIENT_REQUEST_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_REQUEST_ERROR",
            message: "There was a problem with your request."
          },
          CLIENT_GRAPHQL_REQUEST_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_GRAPHQL_REQUEST_ERROR",
            message: "There was a problem with your request."
          },
          CLIENT_RATE_LIMITED: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_RATE_LIMITED",
            message: "You are being rate-limited; please try again in a few minutes."
          },
          CLIENT_AUTHORIZATION_INSUFFICIENT: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_AUTHORIZATION_INSUFFICIENT",
            message: "The authorization used has insufficient privileges."
          },
          CLIENT_AUTHORIZATION_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "CLIENT_AUTHORIZATION_INVALID",
            message: "Either the client token has expired and a new one should be generated or the tokenization key has been deactivated or deleted."
          }
        };
      }, { "../lib/braintree-error": 91 }], 54: [function(require2, module2, exports2) {
        var BraintreeError = require2("../lib/braintree-error");
        var wrapPromise = require2("@braintree/wrap-promise");
        var request3 = require2("./request");
        var uuid = require2("@braintree/uuid");
        var constants = require2("../lib/constants");
        var errors = require2("./errors");
        var GraphQL = require2("./request/graphql");
        var GRAPHQL_URLS = require2("../lib/constants").GRAPHQL_URLS;
        var isDateStringBeforeOrOn = require2("../lib/is-date-string-before-or-on");
        var BRAINTREE_VERSION = require2("./constants").BRAINTREE_VERSION;
        function getConfiguration(authData) {
          return new Promise(function(resolve2, reject) {
            var configuration, attrs, configUrl, reqOptions;
            var sessionId = uuid();
            var analyticsMetadata = {
              merchantAppId: window.location.host,
              platform: constants.PLATFORM,
              sdkVersion: constants.VERSION,
              source: constants.SOURCE,
              integration: constants.INTEGRATION,
              integrationType: constants.INTEGRATION,
              sessionId
            };
            attrs = authData.attrs;
            configUrl = authData.configUrl;
            attrs._meta = analyticsMetadata;
            attrs.braintreeLibraryVersion = constants.BRAINTREE_LIBRARY_VERSION;
            attrs.configVersion = "3";
            reqOptions = {
              url: configUrl,
              method: "GET",
              data: attrs
            };
            if (attrs.authorizationFingerprint && authData.graphQL) {
              if (isDateStringBeforeOrOn(authData.graphQL.date, BRAINTREE_VERSION)) {
                reqOptions.graphQL = new GraphQL({
                  graphQL: {
                    url: authData.graphQL.url,
                    features: ["configuration"]
                  }
                });
              }
              reqOptions.metadata = analyticsMetadata;
            } else if (attrs.tokenizationKey) {
              reqOptions.graphQL = new GraphQL({
                graphQL: {
                  url: GRAPHQL_URLS[authData.environment],
                  features: ["configuration"]
                }
              });
              reqOptions.metadata = analyticsMetadata;
            }
            request3(reqOptions, function(err, response, status) {
              var errorTemplate;
              if (err) {
                if (status === 403) {
                  errorTemplate = errors.CLIENT_AUTHORIZATION_INSUFFICIENT;
                } else if (status === 401) {
                  errorTemplate = errors.CLIENT_AUTHORIZATION_INVALID;
                } else {
                  errorTemplate = errors.CLIENT_GATEWAY_NETWORK;
                }
                reject(new BraintreeError({
                  type: errorTemplate.type,
                  code: errorTemplate.code,
                  message: errorTemplate.message,
                  details: {
                    originalError: err
                  }
                }));
                return;
              }
              configuration = {
                authorizationType: attrs.tokenizationKey ? "TOKENIZATION_KEY" : "CLIENT_TOKEN",
                authorizationFingerprint: attrs.authorizationFingerprint,
                analyticsMetadata,
                gatewayConfiguration: response
              };
              resolve2(configuration);
            });
          });
        }
        module2.exports = {
          getConfiguration: wrapPromise(getConfiguration)
        };
      }, { "../lib/braintree-error": 91, "../lib/constants": 92, "../lib/is-date-string-before-or-on": 117, "./constants": 52, "./errors": 53, "./request": 65, "./request/graphql": 63, "@braintree/uuid": 43, "@braintree/wrap-promise": 47 }], 55: [function(require2, module2, exports2) {
        var BraintreeError = require2("../lib/braintree-error");
        var Client = require2("./client");
        var VERSION2 = "3.99.0";
        var wrapPromise = require2("@braintree/wrap-promise");
        var sharedErrors = require2("../lib/errors");
        function create2(options) {
          if (!options.authorization) {
            return Promise.reject(new BraintreeError({
              type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
              code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
              message: "options.authorization is required when instantiating a client."
            }));
          }
          return Client.initialize(options);
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/braintree-error": 91, "../lib/errors": 101, "./client": 51, "@braintree/wrap-promise": 47 }], 56: [function(require2, module2, exports2) {
        var querystring = require2("../../lib/querystring");
        var assign2 = require2("../../lib/assign").assign;
        var prepBody = require2("./prep-body");
        var parseBody = require2("./parse-body");
        var xhr2 = require2("./xhr");
        var isXHRAvailable = xhr2.isAvailable;
        var GraphQLRequest = require2("./graphql/request");
        var DefaultRequest = require2("./default-request");
        var MAX_TCP_RETRYCOUNT = 1;
        var TCP_PRECONNECT_BUG_STATUS_CODE = 408;
        function requestShouldRetry(status) {
          return !status || status === TCP_PRECONNECT_BUG_STATUS_CODE;
        }
        function graphQLRequestShouldRetryWithClientApi(body) {
          var errorClass = !body.data && body.errors && body.errors[0] && body.errors[0].extensions && body.errors[0].extensions.errorClass;
          return errorClass === "UNKNOWN" || errorClass === "INTERNAL";
        }
        function _requestWithRetry(options, tcpRetryCount, cb) {
          var status, resBody, ajaxRequest, body, method, headers, parsedBody;
          var url = options.url;
          var graphQL = options.graphQL;
          var timeout = options.timeout;
          var req = xhr2.getRequestObject();
          var callback = cb;
          var isGraphQLRequest = Boolean(graphQL && graphQL.isGraphQLRequest(url, options.data));
          options.headers = assign2({ "Content-Type": "application/json" }, options.headers);
          if (isGraphQLRequest) {
            ajaxRequest = new GraphQLRequest(options);
          } else {
            ajaxRequest = new DefaultRequest(options);
          }
          url = ajaxRequest.getUrl();
          body = ajaxRequest.getBody();
          method = ajaxRequest.getMethod();
          headers = ajaxRequest.getHeaders();
          if (method === "GET") {
            url = querystring.queryify(url, body);
            body = null;
          }
          if (isXHRAvailable) {
            req.onreadystatechange = function() {
              if (req.readyState !== 4) {
                return;
              }
              if (req.status === 0 && isGraphQLRequest) {
                delete options.graphQL;
                _requestWithRetry(options, tcpRetryCount, cb);
                return;
              }
              parsedBody = parseBody(req.responseText);
              resBody = ajaxRequest.adaptResponseBody(parsedBody);
              status = ajaxRequest.determineStatus(req.status, parsedBody);
              if (status >= 400 || status < 200) {
                if (isGraphQLRequest && graphQLRequestShouldRetryWithClientApi(parsedBody)) {
                  delete options.graphQL;
                  _requestWithRetry(options, tcpRetryCount, cb);
                  return;
                }
                if (tcpRetryCount < MAX_TCP_RETRYCOUNT && requestShouldRetry(status)) {
                  tcpRetryCount++;
                  _requestWithRetry(options, tcpRetryCount, cb);
                  return;
                }
                callback(resBody || "error", null, status || 500);
              } else {
                callback(null, resBody, status);
              }
            };
          } else {
            if (options.headers) {
              url = querystring.queryify(url, headers);
            }
            req.onload = function() {
              callback(null, parseBody(req.responseText), req.status);
            };
            req.onerror = function() {
              callback("error", null, 500);
            };
            req.onprogress = function() {
            };
            req.ontimeout = function() {
              callback("timeout", null, -1);
            };
          }
          try {
            req.open(method, url, true);
          } catch (requestOpenError) {
            if (!isGraphQLRequest) {
              throw requestOpenError;
            }
            delete options.graphQL;
            _requestWithRetry(options, tcpRetryCount, cb);
            return;
          }
          req.timeout = timeout;
          if (isXHRAvailable) {
            Object.keys(headers).forEach(function(headerKey) {
              req.setRequestHeader(headerKey, headers[headerKey]);
            });
          }
          try {
            req.send(prepBody(method, body));
          } catch (e) {
          }
        }
        function request3(options, cb) {
          _requestWithRetry(options, 0, cb);
        }
        module2.exports = {
          request: request3
        };
      }, { "../../lib/assign": 88, "../../lib/querystring": 123, "./default-request": 57, "./graphql/request": 64, "./parse-body": 66, "./prep-body": 67, "./xhr": 68 }], 57: [function(require2, module2, exports2) {
        function DefaultRequest(options) {
          this._url = options.url;
          this._data = options.data;
          this._method = options.method;
          this._headers = options.headers;
        }
        DefaultRequest.prototype.getUrl = function() {
          return this._url;
        };
        DefaultRequest.prototype.getBody = function() {
          return this._data;
        };
        DefaultRequest.prototype.getMethod = function() {
          return this._method;
        };
        DefaultRequest.prototype.getHeaders = function() {
          return this._headers;
        };
        DefaultRequest.prototype.adaptResponseBody = function(parsedBody) {
          return parsedBody;
        };
        DefaultRequest.prototype.determineStatus = function(status) {
          return status;
        };
        module2.exports = DefaultRequest;
      }, {}], 58: [function(require2, module2, exports2) {
        var errorResponseAdapter = require2("./error");
        var assign2 = require2("../../../../lib/assign").assign;
        var cardTypeTransforms = {
          creditCard: {
            AMERICAN_EXPRESS: "American Express",
            DISCOVER: "Discover",
            INTERNATIONAL_MAESTRO: "Maestro",
            JCB: "JCB",
            MASTERCARD: "MasterCard",
            SOLO: "Solo",
            UK_MAESTRO: "UK Maestro",
            UNION_PAY: "UnionPay",
            VISA: "Visa",
            ELO: "Elo",
            HIPER: "Hiper",
            HIPERCARD: "Hipercard"
          },
          applePayWeb: {
            VISA: "visa",
            MASTERCARD: "mastercard",
            DISCOVER: "discover",
            AMERICAN_EXPRESS: "amex",
            INTERNATIONAL_MAESTRO: "maestro",
            ELO: "elo"
          },
          visaCheckout: {
            VISA: "Visa",
            MASTERCARD: "MasterCard",
            DISCOVER: "Discover",
            AMERICAN_EXPRESS: "American Express"
          },
          googlePay: {
            VISA: "visa",
            MASTERCARD: "mastercard",
            DISCOVER: "discover",
            AMERICAN_EXPRESS: "amex",
            INTERNATIONAL_MAESTRO: "maestro",
            ELO: "elo"
          },
          masterpass: {
            VISA: "visa",
            MASTERCARD: "master",
            DISCOVER: "discover",
            AMERICAN_EXPRESS: "amex",
            DINERS: "diners",
            INTERNATIONAL_MAESTRO: "maestro",
            JCB: "jcb"
          }
        };
        function configurationResponseAdapter(responseBody, ctx) {
          var adaptedResponse;
          if (responseBody.data && !responseBody.errors) {
            adaptedResponse = adaptConfigurationResponseBody(responseBody, ctx);
          } else {
            adaptedResponse = errorResponseAdapter(responseBody);
          }
          return adaptedResponse;
        }
        function adaptConfigurationResponseBody(body, ctx) {
          var configuration = body.data.clientConfiguration;
          var response;
          response = {
            environment: configuration.environment.toLowerCase(),
            clientApiUrl: configuration.clientApiUrl,
            assetsUrl: configuration.assetsUrl,
            analytics: {
              url: configuration.analyticsUrl
            },
            merchantId: configuration.merchantId,
            venmo: "off"
          };
          if (configuration.supportedFeatures) {
            response.graphQL = {
              url: ctx._graphQL._config.url,
              features: configuration.supportedFeatures.map(function(feature) {
                return feature.toLowerCase();
              })
            };
          }
          if (configuration.braintreeApi) {
            response.braintreeApi = configuration.braintreeApi;
          }
          if (configuration.applePayWeb) {
            response.applePayWeb = configuration.applePayWeb;
            response.applePayWeb.supportedNetworks = mapCardTypes(configuration.applePayWeb.supportedCardBrands, cardTypeTransforms.applePayWeb);
            delete response.applePayWeb.supportedCardBrands;
          }
          if (configuration.ideal) {
            response.ideal = configuration.ideal;
          }
          if (configuration.kount) {
            response.kount = {
              kountMerchantId: configuration.kount.merchantId
            };
          }
          if (configuration.creditCard) {
            response.challenges = configuration.creditCard.challenges.map(function(challenge) {
              return challenge.toLowerCase();
            });
            response.creditCards = {
              supportedCardTypes: mapCardTypes(configuration.creditCard.supportedCardBrands, cardTypeTransforms.creditCard)
            };
            response.threeDSecureEnabled = configuration.creditCard.threeDSecureEnabled;
            response.threeDSecure = configuration.creditCard.threeDSecure;
          } else {
            response.challenges = [];
            response.creditCards = {
              supportedCardTypes: []
            };
            response.threeDSecureEnabled = false;
          }
          if (configuration.googlePay) {
            response.androidPay = {
              displayName: configuration.googlePay.displayName,
              enabled: true,
              environment: configuration.googlePay.environment.toLowerCase(),
              googleAuthorizationFingerprint: configuration.googlePay.googleAuthorization,
              paypalClientId: configuration.googlePay.paypalClientId,
              supportedNetworks: mapCardTypes(configuration.googlePay.supportedCardBrands, cardTypeTransforms.googlePay)
            };
          }
          if (configuration.venmo) {
            response.payWithVenmo = {
              merchantId: configuration.venmo.merchantId,
              accessToken: configuration.venmo.accessToken,
              environment: configuration.venmo.environment.toLowerCase(),
              enrichedCustomerDataEnabled: configuration.venmo.enrichedCustomerDataEnabled
            };
          }
          if (configuration.paypal) {
            response.paypalEnabled = true;
            response.paypal = assign2({}, configuration.paypal);
            response.paypal.currencyIsoCode = response.paypal.currencyCode;
            response.paypal.environment = response.paypal.environment.toLowerCase();
            delete response.paypal.currencyCode;
          } else {
            response.paypalEnabled = false;
          }
          if (configuration.unionPay) {
            response.unionPay = {
              enabled: true,
              merchantAccountId: configuration.unionPay.merchantAccountId
            };
          }
          if (configuration.visaCheckout) {
            response.visaCheckout = {
              apikey: configuration.visaCheckout.apiKey,
              encryptionKey: configuration.visaCheckout.encryptionKey,
              externalClientId: configuration.visaCheckout.externalClientId,
              supportedCardTypes: mapCardTypes(configuration.visaCheckout.supportedCardBrands, cardTypeTransforms.visaCheckout)
            };
          }
          if (configuration.masterpass) {
            response.masterpass = {
              merchantCheckoutId: configuration.masterpass.merchantCheckoutId,
              supportedNetworks: mapCardTypes(configuration.masterpass.supportedCardBrands, cardTypeTransforms.masterpass)
            };
          }
          if (configuration.usBankAccount) {
            response.usBankAccount = {
              routeId: configuration.usBankAccount.routeId,
              plaid: {
                publicKey: configuration.usBankAccount.plaidPublicKey
              }
            };
          }
          return response;
        }
        function mapCardTypes(cardTypes, cardTypeTransformMap) {
          return cardTypes.reduce(function(acc, type) {
            if (cardTypeTransformMap.hasOwnProperty(type)) {
              return acc.concat(cardTypeTransformMap[type]);
            }
            return acc;
          }, []);
        }
        module2.exports = configurationResponseAdapter;
      }, { "../../../../lib/assign": 88, "./error": 60 }], 59: [function(require2, module2, exports2) {
        var errorResponseAdapter = require2("./error");
        var CARD_BRAND_MAP = {
          AMERICAN_EXPRESS: "American Express",
          DINERS: "Discover",
          DISCOVER: "Discover",
          ELO: "Elo",
          HIPER: "Hiper",
          HIPERCARD: "Hipercard",
          INTERNATIONAL_MAESTRO: "Maestro",
          JCB: "JCB",
          MASTERCARD: "MasterCard",
          UK_MAESTRO: "Maestro",
          UNION_PAY: "UnionPay",
          VISA: "Visa"
        };
        var BIN_DATA_MAP = {
          YES: "Yes",
          NO: "No",
          UNKNOWN: "Unknown"
        };
        var AUTHENTICATION_INSIGHT_MAP = {
          PSDTWO: "psd2"
        };
        function creditCardTokenizationResponseAdapter(responseBody) {
          var adaptedResponse;
          if (responseBody.data && !responseBody.errors) {
            adaptedResponse = adaptTokenizeCreditCardResponseBody(responseBody);
          } else {
            adaptedResponse = errorResponseAdapter(responseBody);
          }
          return adaptedResponse;
        }
        function adaptTokenizeCreditCardResponseBody(body) {
          var data2 = body.data.tokenizeCreditCard;
          var creditCard = data2.creditCard;
          var lastTwo = creditCard.last4 ? creditCard.last4.substr(2, 4) : "";
          var binData = creditCard.binData;
          var response, regulationEnvironment;
          if (binData) {
            [
              "commercial",
              "debit",
              "durbinRegulated",
              "healthcare",
              "payroll",
              "prepaid"
            ].forEach(function(key) {
              if (binData[key]) {
                binData[key] = BIN_DATA_MAP[binData[key]];
              } else {
                binData[key] = "Unknown";
              }
            });
            ["issuingBank", "countryOfIssuance", "productId"].forEach(function(key) {
              if (!binData[key]) {
                binData[key] = "Unknown";
              }
            });
          }
          response = {
            creditCards: [
              {
                binData,
                consumed: false,
                description: lastTwo ? "ending in " + lastTwo : "",
                nonce: data2.token,
                details: {
                  cardholderName: creditCard.cardholderName,
                  expirationMonth: creditCard.expirationMonth,
                  expirationYear: creditCard.expirationYear,
                  bin: creditCard.bin || "",
                  cardType: CARD_BRAND_MAP[creditCard.brandCode] || "Unknown",
                  lastFour: creditCard.last4 || "",
                  lastTwo
                },
                type: "CreditCard",
                threeDSecureInfo: null
              }
            ]
          };
          if (data2.authenticationInsight) {
            regulationEnvironment = data2.authenticationInsight.customerAuthenticationRegulationEnvironment;
            response.creditCards[0].authenticationInsight = {
              regulationEnvironment: AUTHENTICATION_INSIGHT_MAP[regulationEnvironment] || regulationEnvironment.toLowerCase()
            };
          }
          return response;
        }
        module2.exports = creditCardTokenizationResponseAdapter;
      }, { "./error": 60 }], 60: [function(require2, module2, exports2) {
        function errorResponseAdapter(responseBody) {
          var response;
          var errorClass = responseBody.errors && responseBody.errors[0] && responseBody.errors[0].extensions && responseBody.errors[0].extensions.errorClass;
          if (errorClass === "VALIDATION") {
            response = userErrorResponseAdapter(responseBody);
          } else if (errorClass) {
            response = errorWithClassResponseAdapter(responseBody);
          } else {
            response = {
              error: { message: "There was a problem serving your request" },
              fieldErrors: []
            };
          }
          return response;
        }
        function errorWithClassResponseAdapter(responseBody) {
          return {
            error: { message: responseBody.errors[0].message },
            fieldErrors: []
          };
        }
        function userErrorResponseAdapter(responseBody) {
          var fieldErrors = buildFieldErrors(responseBody.errors);
          if (fieldErrors.length === 0) {
            return { error: { message: responseBody.errors[0].message } };
          }
          return {
            error: { message: getLegacyMessage(fieldErrors) },
            fieldErrors
          };
        }
        function buildFieldErrors(errors) {
          var fieldErrors = [];
          errors.forEach(function(error) {
            if (!(error.extensions && error.extensions.inputPath)) {
              return;
            }
            addFieldError(error.extensions.inputPath.slice(1), error, fieldErrors);
          });
          return fieldErrors;
        }
        function addFieldError(inputPath, errorDetail, fieldErrors) {
          var fieldError;
          var legacyCode = errorDetail.extensions.legacyCode;
          var inputField = inputPath[0];
          if (inputPath.length === 1) {
            fieldErrors.push({
              code: legacyCode,
              field: inputField,
              message: errorDetail.message
            });
            return;
          }
          fieldErrors.forEach(function(candidate) {
            if (candidate.field === inputField) {
              fieldError = candidate;
            }
          });
          if (!fieldError) {
            fieldError = { field: inputField, fieldErrors: [] };
            fieldErrors.push(fieldError);
          }
          addFieldError(inputPath.slice(1), errorDetail, fieldError.fieldErrors);
        }
        function getLegacyMessage(errors) {
          var legacyMessages = {
            creditCard: "Credit card is invalid"
          };
          var field = errors[0].field;
          return legacyMessages[field];
        }
        module2.exports = errorResponseAdapter;
      }, {}], 61: [function(require2, module2, exports2) {
        var CONFIGURATION_QUERY = "query ClientConfiguration {   clientConfiguration {     analyticsUrl     environment     merchantId     assetsUrl     clientApiUrl     creditCard {       supportedCardBrands       challenges       threeDSecureEnabled       threeDSecure {         cardinalAuthenticationJWT       }     }     applePayWeb {       countryCode       currencyCode       merchantIdentifier       supportedCardBrands     }     googlePay {       displayName       supportedCardBrands       environment       googleAuthorization       paypalClientId     }     ideal {       routeId       assetsUrl     }     kount {       merchantId     }     masterpass {       merchantCheckoutId       supportedCardBrands     }     paypal {       displayName       clientId       assetsUrl       environment       environmentNoNetwork       unvettedMerchant       braintreeClientId       billingAgreementsEnabled       merchantAccountId       currencyCode       payeeEmail     }     unionPay {       merchantAccountId     }     usBankAccount {       routeId       plaidPublicKey     }     venmo {       merchantId       accessToken       environment       enrichedCustomerDataEnabled    }     visaCheckout {       apiKey       externalClientId       supportedCardBrands     }     braintreeApi {       accessToken       url     }     supportedFeatures   } }";
        function configuration() {
          return {
            query: CONFIGURATION_QUERY,
            operationName: "ClientConfiguration"
          };
        }
        module2.exports = configuration;
      }, {}], 62: [function(require2, module2, exports2) {
        var assign2 = require2("../../../../lib/assign").assign;
        function createMutation(config) {
          var hasAuthenticationInsight = config.hasAuthenticationInsight;
          var mutation = "mutation TokenizeCreditCard($input: TokenizeCreditCardInput!";
          if (hasAuthenticationInsight) {
            mutation += ", $authenticationInsightInput: AuthenticationInsightInput!";
          }
          mutation += ") {   tokenizeCreditCard(input: $input) {     token     creditCard {       bin       brandCode       last4       cardholderName       expirationMonth      expirationYear      binData {         prepaid         healthcare         debit         durbinRegulated         commercial         payroll         issuingBank         countryOfIssuance         productId       }     } ";
          if (hasAuthenticationInsight) {
            mutation += "    authenticationInsight(input: $authenticationInsightInput) {      customerAuthenticationRegulationEnvironment    }";
          }
          mutation += "  } }";
          return mutation;
        }
        function createCreditCardTokenizationBody(body, options) {
          var cc = body.creditCard;
          var billingAddress = cc && cc.billingAddress;
          var expDate = cc && cc.expirationDate;
          var expirationMonth = cc && (cc.expirationMonth || expDate && expDate.split("/")[0].trim());
          var expirationYear = cc && (cc.expirationYear || expDate && expDate.split("/")[1].trim());
          var variables = {
            input: {
              creditCard: {
                number: cc && cc.number,
                expirationMonth,
                expirationYear,
                cvv: cc && cc.cvv,
                cardholderName: cc && cc.cardholderName
              },
              options: {}
            }
          };
          if (options.hasAuthenticationInsight) {
            variables.authenticationInsightInput = {
              merchantAccountId: body.merchantAccountId
            };
          }
          if (billingAddress) {
            variables.input.creditCard.billingAddress = billingAddress;
          }
          variables.input = addValidationRule(body, variables.input);
          return variables;
        }
        function addValidationRule(body, input) {
          var validate;
          if (body.creditCard && body.creditCard.options && typeof body.creditCard.options.validate === "boolean") {
            validate = body.creditCard.options.validate;
          } else if (body.authorizationFingerprint && body.tokenizationKey || body.authorizationFingerprint) {
            validate = true;
          } else if (body.tokenizationKey) {
            validate = false;
          }
          if (typeof validate === "boolean") {
            input.options = assign2({
              validate
            }, input.options);
          }
          return input;
        }
        function creditCardTokenization(body) {
          var options = {
            hasAuthenticationInsight: Boolean(body.authenticationInsight && body.merchantAccountId)
          };
          return {
            query: createMutation(options),
            variables: createCreditCardTokenizationBody(body, options),
            operationName: "TokenizeCreditCard"
          };
        }
        module2.exports = creditCardTokenization;
      }, { "../../../../lib/assign": 88 }], 63: [function(require2, module2, exports2) {
        var features = {
          tokenize_credit_cards: "payment_methods/credit_cards",
          configuration: "configuration"
        };
        var disallowedInputPaths = ["creditCard.options.unionPayEnrollment"];
        function GraphQL(config) {
          this._config = config.graphQL;
        }
        GraphQL.prototype.getGraphQLEndpoint = function() {
          return this._config.url;
        };
        GraphQL.prototype.isGraphQLRequest = function(url, body) {
          var featureEnabled;
          var path = this.getClientApiPath(url);
          if (!this._isGraphQLEnabled() || !path) {
            return false;
          }
          featureEnabled = this._config.features.some(function(feature) {
            return features[feature] === path;
          });
          if (containsDisallowedlistedKeys(body)) {
            return false;
          }
          return featureEnabled;
        };
        GraphQL.prototype.getClientApiPath = function(url) {
          var path;
          var clientApiPrefix = "/client_api/v1/";
          var pathParts = url.split(clientApiPrefix);
          if (pathParts.length > 1) {
            path = pathParts[1].split("?")[0];
          }
          return path;
        };
        GraphQL.prototype._isGraphQLEnabled = function() {
          return Boolean(this._config);
        };
        function containsDisallowedlistedKeys(body) {
          return disallowedInputPaths.some(function(keys) {
            var value = keys.split(".").reduce(function(accumulator, key) {
              return accumulator && accumulator[key];
            }, body);
            return value !== void 0;
          });
        }
        module2.exports = GraphQL;
      }, {}], 64: [function(require2, module2, exports2) {
        var BRAINTREE_VERSION = require2("../../constants").BRAINTREE_VERSION;
        var assign2 = require2("../../../lib/assign").assign;
        var snakeCaseToCamelCase = require2("../../../lib/snake-case-to-camel-case");
        var creditCardTokenizationBodyGenerator = require2("./generators/credit-card-tokenization");
        var creditCardTokenizationResponseAdapter = require2("./adapters/credit-card-tokenization");
        var configurationBodyGenerator = require2("./generators/configuration");
        var configurationResponseAdapter = require2("./adapters/configuration");
        var generators = {
          "payment_methods/credit_cards": creditCardTokenizationBodyGenerator,
          configuration: configurationBodyGenerator
        };
        var adapters = {
          "payment_methods/credit_cards": creditCardTokenizationResponseAdapter,
          configuration: configurationResponseAdapter
        };
        function GraphQLRequest(options) {
          var clientApiPath = options.graphQL.getClientApiPath(options.url);
          this._graphQL = options.graphQL;
          this._data = options.data;
          this._method = options.method;
          this._headers = options.headers;
          this._clientSdkMetadata = {
            source: options.metadata.source,
            integration: options.metadata.integration,
            sessionId: options.metadata.sessionId
          };
          this._sendAnalyticsEvent = options.sendAnalyticsEvent || Function.prototype;
          this._generator = generators[clientApiPath];
          this._adapter = adapters[clientApiPath];
          this._sendAnalyticsEvent("graphql.init");
        }
        GraphQLRequest.prototype.getUrl = function() {
          return this._graphQL.getGraphQLEndpoint();
        };
        GraphQLRequest.prototype.getBody = function() {
          var formattedBody = formatBodyKeys(this._data);
          var generatedBody = this._generator(formattedBody);
          var body = assign2({ clientSdkMetadata: this._clientSdkMetadata }, generatedBody);
          return JSON.stringify(body);
        };
        GraphQLRequest.prototype.getMethod = function() {
          return "POST";
        };
        GraphQLRequest.prototype.getHeaders = function() {
          var authorization, headers;
          if (this._data.authorizationFingerprint) {
            this._sendAnalyticsEvent("graphql.authorization-fingerprint");
            authorization = this._data.authorizationFingerprint;
          } else {
            this._sendAnalyticsEvent("graphql.tokenization-key");
            authorization = this._data.tokenizationKey;
          }
          headers = {
            Authorization: "Bearer " + authorization,
            "Braintree-Version": BRAINTREE_VERSION
          };
          return assign2({}, this._headers, headers);
        };
        GraphQLRequest.prototype.adaptResponseBody = function(parsedBody) {
          return this._adapter(parsedBody, this);
        };
        GraphQLRequest.prototype.determineStatus = function(httpStatus, parsedResponse) {
          var status, errorClass;
          if (httpStatus === 200) {
            errorClass = parsedResponse.errors && parsedResponse.errors[0] && parsedResponse.errors[0].extensions && parsedResponse.errors[0].extensions.errorClass;
            if (parsedResponse.data && !parsedResponse.errors) {
              status = 200;
            } else if (errorClass === "VALIDATION") {
              status = 422;
            } else if (errorClass === "AUTHORIZATION") {
              status = 403;
            } else if (errorClass === "AUTHENTICATION") {
              status = 401;
            } else if (isGraphQLError(errorClass, parsedResponse)) {
              status = 403;
            } else {
              status = 500;
            }
          } else if (!httpStatus) {
            status = 500;
          } else {
            status = httpStatus;
          }
          this._sendAnalyticsEvent("graphql.status." + httpStatus);
          this._sendAnalyticsEvent("graphql.determinedStatus." + status);
          return status;
        };
        function isGraphQLError(errorClass, parsedResponse) {
          return !errorClass && parsedResponse.errors[0].message;
        }
        function formatBodyKeys(originalBody) {
          var body = {};
          Object.keys(originalBody).forEach(function(key) {
            var camelCaseKey = snakeCaseToCamelCase(key);
            if (typeof originalBody[key] === "object") {
              body[camelCaseKey] = formatBodyKeys(originalBody[key]);
            } else if (typeof originalBody[key] === "number") {
              body[camelCaseKey] = String(originalBody[key]);
            } else {
              body[camelCaseKey] = originalBody[key];
            }
          });
          return body;
        }
        module2.exports = GraphQLRequest;
      }, { "../../../lib/assign": 88, "../../../lib/snake-case-to-camel-case": 125, "../../constants": 52, "./adapters/configuration": 58, "./adapters/credit-card-tokenization": 59, "./generators/configuration": 61, "./generators/credit-card-tokenization": 62 }], 65: [function(require2, module2, exports2) {
        var once = require2("../../lib/once");
        var AJAXDriver = require2("./ajax-driver");
        module2.exports = function(options, cb) {
          cb = once(cb || Function.prototype);
          options.method = (options.method || "GET").toUpperCase();
          options.timeout = options.timeout == null ? 6e4 : options.timeout;
          options.data = options.data || {};
          AJAXDriver.request(options, cb);
        };
      }, { "../../lib/once": 122, "./ajax-driver": 56 }], 66: [function(require2, module2, exports2) {
        module2.exports = function(body) {
          try {
            body = JSON.parse(body);
          } catch (e) {
          }
          return body;
        };
      }, {}], 67: [function(require2, module2, exports2) {
        module2.exports = function(method, body) {
          if (typeof method !== "string") {
            throw new Error("Method must be a string");
          }
          if (method.toLowerCase() !== "get" && body != null) {
            body = typeof body === "string" ? body : JSON.stringify(body);
          }
          return body;
        };
      }, {}], 68: [function(require2, module2, exports2) {
        var isXHRAvailable = typeof window !== "undefined" && window.XMLHttpRequest && "withCredentials" in new window.XMLHttpRequest();
        function getRequestObject() {
          return isXHRAvailable ? new window.XMLHttpRequest() : new window.XDomainRequest();
        }
        module2.exports = {
          isAvailable: isXHRAvailable,
          getRequestObject
        };
      }, {}], 69: [function(require2, module2, exports2) {
        var BraintreeError = require2("../lib/braintree-error");
        module2.exports = {
          GOOGLE_PAYMENT_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "GOOGLE_PAYMENT_NOT_ENABLED",
            message: "Google Pay is not enabled for this merchant."
          },
          GOOGLE_PAYMENT_GATEWAY_ERROR: {
            code: "GOOGLE_PAYMENT_GATEWAY_ERROR",
            message: "There was an error when tokenizing the Google Pay payment method.",
            type: BraintreeError.types.UNKNOWN
          },
          GOOGLE_PAYMENT_UNSUPPORTED_VERSION: {
            code: "GOOGLE_PAYMENT_UNSUPPORTED_VERSION",
            type: BraintreeError.types.MERCHANT
          }
        };
      }, { "../lib/braintree-error": 91 }], 70: [function(require2, module2, exports2) {
        var analytics = require2("../lib/analytics");
        var assign2 = require2("../lib/assign").assign;
        var convertMethodsToError = require2("../lib/convert-methods-to-error");
        var find = require2("../lib/find");
        var generateGooglePayConfiguration = require2("../lib/generate-google-pay-configuration");
        var BraintreeError = require2("../lib/braintree-error");
        var errors = require2("./errors");
        var methods = require2("../lib/methods");
        var wrapPromise = require2("@braintree/wrap-promise");
        var CREATE_PAYMENT_DATA_REQUEST_METHODS = {
          1: "_createV1PaymentDataRequest",
          2: "_createV2PaymentDataRequest"
        };
        function GooglePayment(options) {
          this._createPromise = options.createPromise;
          this._client = options.client;
          this._useDeferredClient = options.useDeferredClient;
          this._googlePayVersion = options.googlePayVersion || 1;
          this._googleMerchantId = options.googleMerchantId;
          if (this._isUnsupportedGooglePayAPIVersion()) {
            throw new BraintreeError({
              code: errors.GOOGLE_PAYMENT_UNSUPPORTED_VERSION.code,
              message: "The Braintree SDK does not support Google Pay version " + this._googlePayVersion + ". Please upgrade the version of your Braintree SDK and contact support if this error persists.",
              type: errors.GOOGLE_PAYMENT_UNSUPPORTED_VERSION.type
            });
          }
        }
        GooglePayment.prototype._waitForClient = function() {
          if (this._client) {
            return Promise.resolve();
          }
          return this._createPromise.then(function(client) {
            this._client = client;
          }.bind(this));
        };
        GooglePayment.prototype._isUnsupportedGooglePayAPIVersion = function() {
          return !(this._googlePayVersion in CREATE_PAYMENT_DATA_REQUEST_METHODS);
        };
        GooglePayment.prototype._getDefaultConfig = function() {
          if (!this._defaultConfig) {
            this._defaultConfig = generateGooglePayConfiguration(this._client.getConfiguration(), this._googlePayVersion, this._googleMerchantId);
          }
          return this._defaultConfig;
        };
        GooglePayment.prototype._createV1PaymentDataRequest = function(paymentDataRequest) {
          var defaultConfig = this._getDefaultConfig();
          var overrideCardNetworks = paymentDataRequest.cardRequirements && paymentDataRequest.cardRequirements.allowedCardNetworks;
          var defaultConfigCardNetworks = defaultConfig.cardRequirements.allowedCardNetworks;
          var allowedCardNetworks = overrideCardNetworks || defaultConfigCardNetworks;
          paymentDataRequest = assign2({}, defaultConfig, paymentDataRequest);
          paymentDataRequest.cardRequirements.allowedCardNetworks = allowedCardNetworks;
          return paymentDataRequest;
        };
        GooglePayment.prototype._createV2PaymentDataRequest = function(paymentDataRequest) {
          var defaultConfig = this._getDefaultConfig();
          if (paymentDataRequest.allowedPaymentMethods) {
            paymentDataRequest.allowedPaymentMethods.forEach(function(paymentMethod) {
              var defaultPaymentMethod = find(defaultConfig.allowedPaymentMethods, "type", paymentMethod.type);
              if (defaultPaymentMethod) {
                applyDefaultsToPaymentMethodConfiguration(paymentMethod, defaultPaymentMethod);
              }
            });
          }
          paymentDataRequest = assign2({}, defaultConfig, paymentDataRequest);
          return paymentDataRequest;
        };
        GooglePayment.prototype.createPaymentDataRequest = function(overrides) {
          if (!this._useDeferredClient) {
            return this._createPaymentDataRequestSyncronously(overrides);
          }
          return this._waitForClient().then(function() {
            return this._createPaymentDataRequestSyncronously(overrides);
          }.bind(this));
        };
        GooglePayment.prototype._createPaymentDataRequestSyncronously = function(overrides) {
          var paymentDataRequest = assign2({}, overrides);
          var version2 = this._googlePayVersion;
          var createPaymentDataRequestMethod = CREATE_PAYMENT_DATA_REQUEST_METHODS[version2];
          analytics.sendEvent(this._createPromise, "google-payment.v" + version2 + ".createPaymentDataRequest");
          return this[createPaymentDataRequestMethod](paymentDataRequest);
        };
        GooglePayment.prototype.parseResponse = function(response) {
          var self2 = this;
          return Promise.resolve().then(function() {
            var payload;
            var rawResponse = response.apiVersion === 2 ? response.paymentMethodData.tokenizationData.token : response.paymentMethodToken.token;
            var parsedResponse = JSON.parse(rawResponse);
            var error = parsedResponse.error;
            if (error) {
              return Promise.reject(error);
            }
            analytics.sendEvent(self2._createPromise, "google-payment.parseResponse.succeeded");
            if (parsedResponse.paypalAccounts) {
              payload = parsedResponse.paypalAccounts[0];
              analytics.sendEvent(self2._createPromise, "google-payment.parseResponse.succeeded.paypal");
              return Promise.resolve({
                nonce: payload.nonce,
                type: payload.type,
                description: payload.description
              });
            }
            payload = parsedResponse.androidPayCards[0];
            analytics.sendEvent(self2._createPromise, "google-payment.parseResponse.succeeded.google-payment");
            return Promise.resolve({
              nonce: payload.nonce,
              type: payload.type,
              description: payload.description,
              details: {
                cardType: payload.details.cardType,
                lastFour: payload.details.lastFour,
                lastTwo: payload.details.lastTwo,
                isNetworkTokenized: payload.details.isNetworkTokenized,
                bin: payload.details.bin
              },
              binData: payload.binData
            });
          }).catch(function(error) {
            analytics.sendEvent(self2._createPromise, "google-payment.parseResponse.failed");
            return Promise.reject(new BraintreeError({
              code: errors.GOOGLE_PAYMENT_GATEWAY_ERROR.code,
              message: errors.GOOGLE_PAYMENT_GATEWAY_ERROR.message,
              type: errors.GOOGLE_PAYMENT_GATEWAY_ERROR.type,
              details: {
                originalError: error
              }
            }));
          });
        };
        GooglePayment.prototype.teardown = function() {
          convertMethodsToError(this, methods(GooglePayment.prototype));
          return Promise.resolve();
        };
        function applyDefaultsToPaymentMethodConfiguration(merchantSubmittedPaymentMethod, defaultPaymentMethod) {
          Object.keys(defaultPaymentMethod).forEach(function(parameter) {
            if (typeof defaultPaymentMethod[parameter] === "object") {
              merchantSubmittedPaymentMethod[parameter] = assign2({}, defaultPaymentMethod[parameter], merchantSubmittedPaymentMethod[parameter]);
            } else {
              merchantSubmittedPaymentMethod[parameter] = merchantSubmittedPaymentMethod[parameter] || defaultPaymentMethod[parameter];
            }
          });
        }
        module2.exports = wrapPromise.wrapPrototype(GooglePayment);
      }, { "../lib/analytics": 86, "../lib/assign": 88, "../lib/braintree-error": 91, "../lib/convert-methods-to-error": 93, "../lib/find": 103, "../lib/generate-google-pay-configuration": 115, "../lib/methods": 121, "./errors": 69, "@braintree/wrap-promise": 47 }], 71: [function(require2, module2, exports2) {
        var GooglePayment = require2("./google-payment");
        var BraintreeError = require2("../lib/braintree-error");
        var createAssetsUrl = require2("../lib/create-assets-url");
        var createDeferredClient = require2("../lib/create-deferred-client");
        var basicComponentVerification = require2("../lib/basic-component-verification");
        var wrapPromise = require2("@braintree/wrap-promise");
        var VERSION2 = "3.99.0";
        var errors = require2("./errors");
        function create2(options) {
          var name = "Google Pay";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var createPromise, instance;
            createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            }).then(function(client) {
              var configuration = client.getConfiguration();
              options.client = client;
              if (!configuration.gatewayConfiguration.androidPay) {
                return Promise.reject(new BraintreeError(errors.GOOGLE_PAYMENT_NOT_ENABLED));
              }
              return client;
            });
            options.createPromise = createPromise;
            instance = new GooglePayment(options);
            if (!options.useDeferredClient) {
              return createPromise.then(function(client) {
                instance._client = client;
                return instance;
              });
            }
            return instance;
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 89, "../lib/braintree-error": 91, "../lib/create-assets-url": 95, "../lib/create-deferred-client": 97, "./errors": 69, "./google-payment": 70, "@braintree/wrap-promise": 47 }], 72: [function(require2, module2, exports2) {
        var BraintreeError = require2("../../lib/braintree-error");
        var errors = require2("../shared/errors");
        var allowedAttributes = require2("../shared/constants").allowedAttributes;
        function attributeValidationError(attribute, value) {
          var err;
          if (!allowedAttributes.hasOwnProperty(attribute)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED.type,
              code: errors.HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED.code,
              message: 'The "' + attribute + '" attribute is not supported in Hosted Fields.'
            });
          } else if (value != null && !_isValid(attribute, value)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED.type,
              code: errors.HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED.code,
              message: 'Value "' + value + '" is not allowed for "' + attribute + '" attribute.'
            });
          }
          return err;
        }
        function _isValid(attribute, value) {
          if (allowedAttributes[attribute] === "string") {
            return typeof value === "string" || typeof value === "number";
          } else if (allowedAttributes[attribute] === "boolean") {
            return String(value) === "true" || String(value) === "false";
          }
          return false;
        }
        module2.exports = attributeValidationError;
      }, { "../../lib/braintree-error": 91, "../shared/constants": 80, "../shared/errors": 81 }], 73: [function(require2, module2, exports2) {
        var constants = require2("../shared/constants");
        var useMin = require2("../../lib/use-min");
        module2.exports = function composeUrl(assetsUrl, componentId, isDebug) {
          return assetsUrl + "/web/" + constants.VERSION + "/html/hosted-fields-frame" + useMin(isDebug) + ".html#" + componentId;
        };
      }, { "../../lib/use-min": 126, "../shared/constants": 80 }], 74: [function(require2, module2, exports2) {
        var directions = require2("../shared/constants").navigationDirections;
        var browserDetection = require2("../shared/browser-detection");
        var focusIntercept = require2("../shared/focus-intercept");
        var findParentTags = require2("../shared/find-parent-tags");
        var userFocusableTagNames = ["INPUT", "SELECT", "TEXTAREA"];
        var unfocusedInputTypes = [
          "hidden",
          "button",
          "reset",
          "submit",
          "checkbox",
          "radio",
          "file"
        ];
        function _isUserFocusableElement(element) {
          if (!browserDetection.hasSoftwareKeyboard()) {
            return element.type !== "hidden";
          }
          return userFocusableTagNames.indexOf(element.tagName) > -1 && unfocusedInputTypes.indexOf(element.type) < 0;
        }
        function _createNavigationHelper(direction, numberOfElementsInForm) {
          switch (direction) {
            case directions.BACK:
              return {
                checkIndexBounds: function(index) {
                  return index < 0;
                },
                indexChange: -1
              };
            case directions.FORWARD:
              return {
                checkIndexBounds: function(index) {
                  return index > numberOfElementsInForm - 1;
                },
                indexChange: 1
              };
          }
          return {};
        }
        function _findFirstFocusableElement(elementsInForm) {
          var elementsIndex, element;
          for (elementsIndex = 0; elementsIndex < elementsInForm.length; elementsIndex++) {
            element = elementsInForm[elementsIndex];
            if (_isUserFocusableElement(element)) {
              return element;
            }
          }
          return null;
        }
        module2.exports = {
          removeExtraFocusElements: function(checkoutForm, onRemoveFocusIntercepts) {
            var elements = Array.prototype.slice.call(checkoutForm.elements);
            var firstFocusableInput = _findFirstFocusableElement(elements);
            var lastFocusableInput = _findFirstFocusableElement(elements.reverse());
            [firstFocusableInput, lastFocusableInput].forEach(function(input) {
              if (!input) {
                return;
              }
              if (focusIntercept.matchFocusElement(input.getAttribute("id"))) {
                onRemoveFocusIntercepts(input.getAttribute("id"));
              }
            });
          },
          createFocusChangeHandler: function(hostedFieldsId, callbacks) {
            return function(data2) {
              var currentIndex, targetElement, checkoutForm, navHelper;
              var sourceElement = document.getElementById("bt-" + data2.field + "-" + data2.direction + "-" + hostedFieldsId);
              if (!sourceElement) {
                return;
              }
              checkoutForm = findParentTags(sourceElement, "form")[0];
              if (document.forms.length < 1 || !checkoutForm) {
                callbacks.onRemoveFocusIntercepts();
                return;
              }
              checkoutForm = [].slice.call(checkoutForm.elements);
              currentIndex = checkoutForm.indexOf(sourceElement);
              navHelper = _createNavigationHelper(data2.direction, checkoutForm.length);
              do {
                currentIndex += navHelper.indexChange;
                if (navHelper.checkIndexBounds(currentIndex)) {
                  return;
                }
                targetElement = checkoutForm[currentIndex];
              } while (!_isUserFocusableElement(targetElement));
              if (focusIntercept.matchFocusElement(targetElement.getAttribute("id"))) {
                callbacks.onTriggerInputFocus(targetElement.getAttribute("data-braintree-type"));
              } else {
                targetElement.focus();
              }
            };
          }
        };
      }, { "../shared/browser-detection": 79, "../shared/constants": 80, "../shared/find-parent-tags": 82, "../shared/focus-intercept": 83 }], 75: [function(require2, module2, exports2) {
        var allowedStyles = require2("../shared/constants").allowedStyles;
        module2.exports = function getStylesFromClass(cssClass) {
          var element = document.createElement("input");
          var styles = {};
          var computedStyles;
          if (cssClass[0] === ".") {
            cssClass = cssClass.substring(1);
          }
          element.className = cssClass;
          element.style.display = "none !important";
          element.style.position = "fixed !important";
          element.style.left = "-99999px !important";
          element.style.top = "-99999px !important";
          document.body.appendChild(element);
          computedStyles = window.getComputedStyle(element);
          allowedStyles.forEach(function(style) {
            var value = computedStyles[style];
            if (value) {
              styles[style] = value;
            }
          });
          document.body.removeChild(element);
          return styles;
        };
      }, { "../shared/constants": 80 }], 76: [function(require2, module2, exports2) {
        var assign2 = require2("../../lib/assign").assign;
        var createAssetsUrl = require2("../../lib/create-assets-url");
        var isVerifiedDomain = require2("../../lib/is-verified-domain");
        var Destructor = require2("../../lib/destructor");
        var iFramer = require2("@braintree/iframer");
        var Bus = require2("framebus");
        var createDeferredClient = require2("../../lib/create-deferred-client");
        var BraintreeError = require2("../../lib/braintree-error");
        var composeUrl = require2("./compose-url");
        var getStylesFromClass = require2("./get-styles-from-class");
        var constants = require2("../shared/constants");
        var errors = require2("../shared/errors");
        var INTEGRATION_TIMEOUT_MS = require2("../../lib/constants").INTEGRATION_TIMEOUT_MS;
        var uuid = require2("@braintree/uuid");
        var findParentTags = require2("../shared/find-parent-tags");
        var browserDetection = require2("../shared/browser-detection");
        var events = constants.events;
        var EventEmitter = require2("@braintree/event-emitter");
        var injectFrame = require2("./inject-frame");
        var analytics = require2("../../lib/analytics");
        var allowedFields = constants.allowedFields;
        var methods = require2("../../lib/methods");
        var shadow = require2("../../lib/shadow");
        var findRootNode = require2("../../lib/find-root-node");
        var convertMethodsToError = require2("../../lib/convert-methods-to-error");
        var sharedErrors = require2("../../lib/errors");
        var getCardTypes = require2("../shared/get-card-types");
        var attributeValidationError = require2("./attribute-validation-error");
        var wrapPromise = require2("@braintree/wrap-promise");
        var focusChange = require2("./focus-change");
        var destroyFocusIntercept = require2("../shared/focus-intercept").destroy;
        var SAFARI_FOCUS_TIMEOUT = 5;
        function createInputEventHandler(fields) {
          return function(eventData) {
            var field;
            var merchantPayload = eventData.merchantPayload;
            var emittedBy = merchantPayload.emittedBy;
            var container = fields[emittedBy].containerElement;
            Object.keys(merchantPayload.fields).forEach(function(key) {
              merchantPayload.fields[key].container = fields[key].containerElement;
            });
            field = merchantPayload.fields[emittedBy];
            container.classList.toggle(constants.externalClasses.FOCUSED, field.isFocused);
            container.classList.toggle(constants.externalClasses.VALID, field.isValid);
            container.classList.toggle(constants.externalClasses.INVALID, !field.isPotentiallyValid);
            this._state = {
              cards: merchantPayload.cards,
              fields: merchantPayload.fields
            };
            this._emit(eventData.type, merchantPayload);
          };
        }
        function isVisibleEnough(node) {
          var boundingBox = node.getBoundingClientRect();
          var verticalMidpoint = Math.floor(boundingBox.height / 2);
          var horizontalMidpoint = Math.floor(boundingBox.width / 2);
          return boundingBox.top < (window.innerHeight - verticalMidpoint || document.documentElement.clientHeight - verticalMidpoint) && boundingBox.right > horizontalMidpoint && boundingBox.bottom > verticalMidpoint && boundingBox.left < (window.innerWidth - horizontalMidpoint || document.documentElement.clientWidth - horizontalMidpoint);
        }
        function HostedFields(options) {
          var failureTimeout, clientConfig, assetsUrl, isDebug, hostedFieldsUrl;
          var self2 = this;
          var fields = {};
          var frameReadyPromiseResolveFunctions = {};
          var frameReadyPromises = [];
          var componentId = uuid();
          this._merchantConfigurationOptions = assign2({}, options);
          if (options.client) {
            clientConfig = options.client.getConfiguration();
            assetsUrl = clientConfig.gatewayConfiguration.assetsUrl;
            isDebug = clientConfig.isDebug;
          } else {
            assetsUrl = createAssetsUrl.create(options.authorization);
            isDebug = Boolean(options.isDebug);
          }
          this._clientPromise = createDeferredClient.create({
            client: options.client,
            authorization: options.authorization,
            debug: isDebug,
            assetsUrl,
            name: "Hosted Fields"
          });
          hostedFieldsUrl = composeUrl(assetsUrl, componentId, isDebug);
          if (!options.fields || Object.keys(options.fields).length === 0) {
            throw new BraintreeError({
              type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
              code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
              message: "options.fields is required when instantiating Hosted Fields."
            });
          }
          EventEmitter.call(this);
          this._injectedNodes = [];
          this._destructor = new Destructor();
          this._fields = fields;
          this._state = {
            fields: {},
            cards: getCardTypes("")
          };
          this._bus = new Bus({
            channel: componentId,
            verifyDomain: isVerifiedDomain,
            targetFrames: [window]
          });
          this._destructor.registerFunctionForTeardown(function() {
            self2._bus.teardown();
          });
          if (!options.client) {
            analytics.sendEvent(this._clientPromise, "custom.hosted-fields.initialized.deferred-client");
          } else {
            analytics.sendEvent(this._clientPromise, "custom.hosted-fields.initialized");
          }
          Object.keys(options.fields).forEach(function(key) {
            var field, externalContainer, internalContainer, frame, frameReadyPromise;
            if (!constants.allowedFields.hasOwnProperty(key)) {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_INVALID_FIELD_KEY.type,
                code: errors.HOSTED_FIELDS_INVALID_FIELD_KEY.code,
                message: '"' + key + '" is not a valid field.'
              });
            }
            field = options.fields[key];
            externalContainer = field.container || field.selector;
            if (typeof externalContainer === "string") {
              externalContainer = document.querySelector(externalContainer);
            }
            if (!externalContainer || externalContainer.nodeType !== 1) {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.type,
                code: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.code,
                message: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.message,
                details: {
                  fieldSelector: field.selector,
                  fieldContainer: field.container,
                  fieldKey: key
                }
              });
            } else if (externalContainer.querySelector('iframe[name^="braintree-"]')) {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.type,
                code: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.code,
                message: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.message,
                details: {
                  fieldSelector: field.selector,
                  fieldContainer: field.container,
                  fieldKey: key
                }
              });
            }
            internalContainer = externalContainer;
            if (shadow.isShadowElement(internalContainer)) {
              internalContainer = shadow.transformToSlot(internalContainer, "height: 100%");
            }
            if (field.maxlength && typeof field.maxlength !== "number") {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.type,
                code: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.code,
                message: "The value for maxlength must be a number.",
                details: {
                  fieldKey: key
                }
              });
            }
            if (field.minlength && typeof field.minlength !== "number") {
              throw new BraintreeError({
                type: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.type,
                code: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.code,
                message: "The value for minlength must be a number.",
                details: {
                  fieldKey: key
                }
              });
            }
            frame = iFramer({
              type: key,
              name: "braintree-hosted-field-" + key,
              style: constants.defaultIFrameStyle,
              title: field.iframeTitle || "Secure Credit Card Frame - " + constants.allowedFields[key].label
            });
            this._bus.addTargetFrame(frame);
            this._injectedNodes.push.apply(this._injectedNodes, injectFrame(componentId, frame, internalContainer, function() {
              self2.focus(key);
            }));
            this._setupLabelFocus(key, externalContainer);
            fields[key] = {
              frameElement: frame,
              containerElement: externalContainer
            };
            frameReadyPromise = new Promise(function(resolve2) {
              frameReadyPromiseResolveFunctions[key] = resolve2;
            });
            frameReadyPromises.push(frameReadyPromise);
            this._state.fields[key] = {
              isEmpty: true,
              isValid: false,
              isPotentiallyValid: true,
              isFocused: false,
              container: externalContainer
            };
            setTimeout(function() {
              frame.src = hostedFieldsUrl;
            }, 0);
          }.bind(this));
          if (this._merchantConfigurationOptions.styles) {
            Object.keys(this._merchantConfigurationOptions.styles).forEach(function(selector) {
              var className = self2._merchantConfigurationOptions.styles[selector];
              if (typeof className === "string") {
                self2._merchantConfigurationOptions.styles[selector] = getStylesFromClass(className);
              }
            });
          }
          this._bus.on(events.REMOVE_FOCUS_INTERCEPTS, function(data2) {
            destroyFocusIntercept(data2 && data2.id);
          });
          this._bus.on(events.TRIGGER_FOCUS_CHANGE, focusChange.createFocusChangeHandler(componentId, {
            onRemoveFocusIntercepts: function(element) {
              self2._bus.emit(events.REMOVE_FOCUS_INTERCEPTS, {
                id: element
              });
            },
            onTriggerInputFocus: function(targetType) {
              self2.focus(targetType);
            }
          }));
          this._bus.on(events.READY_FOR_CLIENT, function(reply) {
            self2._clientPromise.then(function(client) {
              reply(client);
            });
          });
          this._bus.on(events.CARD_FORM_ENTRY_HAS_BEGUN, function() {
            analytics.sendEvent(self2._clientPromise, "hosted-fields.input.started");
          });
          this._bus.on(events.BIN_AVAILABLE, function(bin) {
            self2._emit("binAvailable", {
              bin
            });
          });
          failureTimeout = setTimeout(function() {
            analytics.sendEvent(self2._clientPromise, "custom.hosted-fields.load.timed-out");
            self2._emit("timeout");
          }, INTEGRATION_TIMEOUT_MS);
          Promise.all(frameReadyPromises).then(function(results) {
            var reply = results[0];
            clearTimeout(failureTimeout);
            reply(formatMerchantConfigurationForIframes(self2._merchantConfigurationOptions));
            self2._cleanUpFocusIntercepts();
            self2._emit("ready");
          });
          this._bus.on(events.FRAME_READY, function(data2, reply) {
            frameReadyPromiseResolveFunctions[data2.field](reply);
          });
          this._bus.on(events.INPUT_EVENT, createInputEventHandler(fields).bind(this));
          this._destructor.registerFunctionForTeardown(function() {
            var j, node, parent;
            for (j = 0; j < self2._injectedNodes.length; j++) {
              node = self2._injectedNodes[j];
              parent = node.parentNode;
              parent.removeChild(node);
              parent.classList.remove(constants.externalClasses.FOCUSED, constants.externalClasses.INVALID, constants.externalClasses.VALID);
            }
          });
          this._destructor.registerFunctionForTeardown(function() {
            destroyFocusIntercept();
          });
          this._destructor.registerFunctionForTeardown(function() {
            var methodNames = methods(HostedFields.prototype).concat(methods(EventEmitter.prototype));
            convertMethodsToError(self2, methodNames);
          });
        }
        EventEmitter.createChild(HostedFields);
        HostedFields.prototype._setupLabelFocus = function(type, container) {
          var labels, i;
          var self2 = this;
          var rootNode = findRootNode(container);
          if (container.id == null) {
            return;
          }
          function triggerFocus() {
            self2.focus(type);
          }
          labels = Array.prototype.slice.call(document.querySelectorAll('label[for="' + container.id + '"]'));
          if (rootNode !== document) {
            labels = labels.concat(Array.prototype.slice.call(rootNode.querySelectorAll('label[for="' + container.id + '"]')));
          }
          labels = labels.concat(findParentTags(container, "label"));
          labels = labels.filter(function(label, index, arr) {
            return arr.indexOf(label) === index;
          });
          for (i = 0; i < labels.length; i++) {
            labels[i].addEventListener("click", triggerFocus, false);
          }
          this._destructor.registerFunctionForTeardown(function() {
            for (i = 0; i < labels.length; i++) {
              labels[i].removeEventListener("click", triggerFocus, false);
            }
          });
        };
        HostedFields.prototype._getAnyFieldContainer = function() {
          var self2 = this;
          return Object.keys(this._fields).reduce(function(found, field) {
            return found || self2._fields[field].containerElement;
          }, null);
        };
        HostedFields.prototype._cleanUpFocusIntercepts = function() {
          var iframeContainer, checkoutForm;
          if (document.forms.length < 1) {
            this._bus.emit(events.REMOVE_FOCUS_INTERCEPTS);
          } else {
            iframeContainer = this._getAnyFieldContainer();
            checkoutForm = findParentTags(iframeContainer, "form")[0];
            if (checkoutForm) {
              focusChange.removeExtraFocusElements(checkoutForm, function(id) {
                this._bus.emit(events.REMOVE_FOCUS_INTERCEPTS, {
                  id
                });
              }.bind(this));
            } else {
              this._bus.emit(events.REMOVE_FOCUS_INTERCEPTS);
            }
          }
        };
        HostedFields.prototype._attachInvalidFieldContainersToError = function(err) {
          if (!(err.details && err.details.invalidFieldKeys && err.details.invalidFieldKeys.length > 0)) {
            return;
          }
          err.details.invalidFields = {};
          err.details.invalidFieldKeys.forEach(function(field) {
            err.details.invalidFields[field] = this._fields[field].containerElement;
          }.bind(this));
        };
        HostedFields.prototype.getChallenges = function() {
          return this._clientPromise.then(function(client) {
            return client.getConfiguration().gatewayConfiguration.challenges;
          });
        };
        HostedFields.prototype.getSupportedCardTypes = function() {
          return this._clientPromise.then(function(client) {
            var cards = client.getConfiguration().gatewayConfiguration.creditCards.supportedCardTypes.map(function(cardType) {
              if (cardType === "MasterCard") {
                return "Mastercard";
              }
              return cardType;
            });
            return cards;
          });
        };
        HostedFields.prototype.teardown = function() {
          var self2 = this;
          return new Promise(function(resolve2, reject) {
            self2._destructor.teardown(function(err) {
              analytics.sendEvent(self2._clientPromise, "custom.hosted-fields.teardown-completed");
              if (err) {
                reject(err);
              } else {
                resolve2();
              }
            });
          });
        };
        HostedFields.prototype.tokenize = function(options) {
          var self2 = this;
          if (!options) {
            options = {};
          }
          return new Promise(function(resolve2, reject) {
            self2._bus.emit(events.TOKENIZATION_REQUEST, options, function(response) {
              var err = response[0];
              var payload = response[1];
              if (err) {
                self2._attachInvalidFieldContainersToError(err);
                reject(new BraintreeError(err));
              } else {
                resolve2(payload);
              }
            });
          });
        };
        HostedFields.prototype.addClass = function(field, classname) {
          var err;
          if (!allowedFields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + field + '" is not a valid field. You must use a valid field option when adding a class.'
            });
          } else if (!this._fields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot add class to "' + field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            this._bus.emit(events.ADD_CLASS, {
              field,
              classname
            });
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.removeClass = function(field, classname) {
          var err;
          if (!allowedFields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + field + '" is not a valid field. You must use a valid field option when removing a class.'
            });
          } else if (!this._fields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot remove class from "' + field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            this._bus.emit(events.REMOVE_CLASS, {
              field,
              classname
            });
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.setAttribute = function(options) {
          var attributeErr, err;
          if (!allowedFields.hasOwnProperty(options.field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + options.field + '" is not a valid field. You must use a valid field option when setting an attribute.'
            });
          } else if (!this._fields.hasOwnProperty(options.field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot set attribute for "' + options.field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            attributeErr = attributeValidationError(options.attribute, options.value);
            if (attributeErr) {
              err = attributeErr;
            } else {
              this._bus.emit(events.SET_ATTRIBUTE, {
                field: options.field,
                attribute: options.attribute,
                value: options.value
              });
            }
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.setMonthOptions = function(options) {
          var self2 = this;
          var merchantOptions = this._merchantConfigurationOptions.fields;
          var errorMessage;
          if (!merchantOptions.expirationMonth) {
            errorMessage = "Expiration month field must exist to use setMonthOptions.";
          } else if (!merchantOptions.expirationMonth.select) {
            errorMessage = "Expiration month field must be a select element.";
          }
          if (errorMessage) {
            return Promise.reject(new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.code,
              message: errorMessage
            }));
          }
          return new Promise(function(resolve2) {
            self2._bus.emit(events.SET_MONTH_OPTIONS, options, resolve2);
          });
        };
        HostedFields.prototype.setMessage = function(options) {
          this._bus.emit(events.SET_MESSAGE, {
            field: options.field,
            message: options.message
          });
        };
        HostedFields.prototype.removeAttribute = function(options) {
          var attributeErr, err;
          if (!allowedFields.hasOwnProperty(options.field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + options.field + '" is not a valid field. You must use a valid field option when removing an attribute.'
            });
          } else if (!this._fields.hasOwnProperty(options.field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot remove attribute for "' + options.field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            attributeErr = attributeValidationError(options.attribute);
            if (attributeErr) {
              err = attributeErr;
            } else {
              this._bus.emit(events.REMOVE_ATTRIBUTE, {
                field: options.field,
                attribute: options.attribute
              });
            }
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.setPlaceholder = function(field, placeholder) {
          return this.setAttribute({
            field,
            attribute: "placeholder",
            value: placeholder
          });
        };
        HostedFields.prototype.clear = function(field) {
          var err;
          if (!allowedFields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + field + '" is not a valid field. You must use a valid field option when clearing a field.'
            });
          } else if (!this._fields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot clear "' + field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            this._bus.emit(events.CLEAR_FIELD, {
              field
            });
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.focus = function(field) {
          var err;
          var fieldConfig = this._fields[field];
          if (!allowedFields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
              code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
              message: '"' + field + '" is not a valid field. You must use a valid field option when focusing a field.'
            });
          } else if (!this._fields.hasOwnProperty(field)) {
            err = new BraintreeError({
              type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
              code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
              message: 'Cannot focus "' + field + '" field because it is not part of the current Hosted Fields options.'
            });
          } else {
            fieldConfig.frameElement.focus();
            this._bus.emit(events.TRIGGER_INPUT_FOCUS, {
              field
            });
            if (browserDetection.isIos()) {
              setTimeout(function() {
                if (!isVisibleEnough(fieldConfig.containerElement)) {
                  fieldConfig.containerElement.scrollIntoView();
                }
              }, SAFARI_FOCUS_TIMEOUT);
            }
          }
          if (err) {
            return Promise.reject(err);
          }
          return Promise.resolve();
        };
        HostedFields.prototype.getState = function() {
          return this._state;
        };
        function formatMerchantConfigurationForIframes(config) {
          var formattedConfig = assign2({}, config);
          formattedConfig.fields = assign2({}, formattedConfig.fields);
          Object.keys(formattedConfig.fields).forEach(function(field) {
            formattedConfig.fields[field] = assign2({}, formattedConfig.fields[field]);
            delete formattedConfig.fields[field].container;
          });
          return formattedConfig;
        }
        module2.exports = wrapPromise.wrapPrototype(HostedFields);
      }, { "../../lib/analytics": 86, "../../lib/assign": 88, "../../lib/braintree-error": 91, "../../lib/constants": 92, "../../lib/convert-methods-to-error": 93, "../../lib/create-assets-url": 95, "../../lib/create-deferred-client": 97, "../../lib/destructor": 99, "../../lib/errors": 101, "../../lib/find-root-node": 102, "../../lib/is-verified-domain": 119, "../../lib/methods": 121, "../../lib/shadow": 124, "../shared/browser-detection": 79, "../shared/constants": 80, "../shared/errors": 81, "../shared/find-parent-tags": 82, "../shared/focus-intercept": 83, "../shared/get-card-types": 84, "./attribute-validation-error": 72, "./compose-url": 73, "./focus-change": 74, "./get-styles-from-class": 75, "./inject-frame": 77, "@braintree/event-emitter": 37, "@braintree/iframer": 39, "@braintree/uuid": 43, "@braintree/wrap-promise": 47, "framebus": 167 }], 77: [function(require2, module2, exports2) {
        var focusIntercept = require2("../shared/focus-intercept");
        var directions = require2("../shared/constants").navigationDirections;
        module2.exports = function injectFrame(id, frame, container, focusHandler) {
          var frameType = frame.getAttribute("type");
          var clearboth = document.createElement("div");
          var fragment = document.createDocumentFragment();
          var focusInterceptBefore = focusIntercept.generate(id, frameType, directions.BACK, focusHandler);
          var focusInterceptAfter = focusIntercept.generate(id, frameType, directions.FORWARD, focusHandler);
          clearboth.style.clear = "both";
          fragment.appendChild(focusInterceptBefore);
          fragment.appendChild(frame);
          fragment.appendChild(focusInterceptAfter);
          fragment.appendChild(clearboth);
          container.appendChild(fragment);
          return [frame, clearboth];
        };
      }, { "../shared/constants": 80, "../shared/focus-intercept": 83 }], 78: [function(require2, module2, exports2) {
        var HostedFields = require2("./external/hosted-fields");
        var basicComponentVerification = require2("../lib/basic-component-verification");
        var errors = require2("./shared/errors");
        var supportsInputFormatting = require2("restricted-input/supports-input-formatting");
        var wrapPromise = require2("@braintree/wrap-promise");
        var BraintreeError = require2("../lib/braintree-error");
        var VERSION2 = "3.99.0";
        function create2(options) {
          return basicComponentVerification.verify({
            name: "Hosted Fields",
            authorization: options.authorization,
            client: options.client
          }).then(function() {
            var integration = new HostedFields(options);
            return new Promise(function(resolve2, reject) {
              integration.on("ready", function() {
                resolve2(integration);
              });
              integration.on("timeout", function() {
                reject(new BraintreeError(errors.HOSTED_FIELDS_TIMEOUT));
              });
            });
          });
        }
        module2.exports = {
          supportsInputFormatting,
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 89, "../lib/braintree-error": 91, "./external/hosted-fields": 76, "./shared/errors": 81, "@braintree/wrap-promise": 47, "restricted-input/supports-input-formatting": 187 }], 79: [function(require2, module2, exports2) {
        var isAndroid = require2("@braintree/browser-detection/is-android");
        var isChromeOS = require2("@braintree/browser-detection/is-chrome-os");
        var isIos = require2("@braintree/browser-detection/is-ios");
        var isChrome = require2("@braintree/browser-detection/is-chrome");
        function hasSoftwareKeyboard() {
          return isAndroid() || isChromeOS() || isIos();
        }
        function isChromeIos() {
          return isChrome() && isIos();
        }
        module2.exports = {
          isAndroid,
          isChromeOS,
          isChromeIos,
          isFirefox: require2("@braintree/browser-detection/is-firefox"),
          isIos,
          isIosWebview: require2("@braintree/browser-detection/is-ios-webview"),
          hasSoftwareKeyboard
        };
      }, { "@braintree/browser-detection/is-android": 25, "@braintree/browser-detection/is-chrome": 27, "@braintree/browser-detection/is-chrome-os": 26, "@braintree/browser-detection/is-firefox": 28, "@braintree/browser-detection/is-ios": 34, "@braintree/browser-detection/is-ios-webview": 32 }], 80: [function(require2, module2, exports2) {
        var enumerate = require2("../../lib/enumerate");
        var errors = require2("./errors");
        var VERSION2 = "3.99.0";
        var constants = {
          VERSION: VERSION2,
          maxExpirationYearAge: 19,
          externalEvents: {
            FOCUS: "focus",
            BLUR: "blur",
            EMPTY: "empty",
            NOT_EMPTY: "notEmpty",
            VALIDITY_CHANGE: "validityChange",
            CARD_TYPE_CHANGE: "cardTypeChange"
          },
          defaultMaxLengths: {
            number: 19,
            postalCode: 8,
            expirationDate: 7,
            expirationMonth: 2,
            expirationYear: 4,
            cvv: 3
          },
          externalClasses: {
            FOCUSED: "braintree-hosted-fields-focused",
            INVALID: "braintree-hosted-fields-invalid",
            VALID: "braintree-hosted-fields-valid"
          },
          navigationDirections: {
            BACK: "before",
            FORWARD: "after"
          },
          defaultIFrameStyle: {
            border: "none",
            width: "100%",
            height: "100%",
            float: "left"
          },
          tokenizationErrorCodes: {
            81724: errors.HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE,
            81736: errors.HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED
          },
          allowedStyles: [
            "-moz-appearance",
            "-moz-box-shadow",
            "-moz-osx-font-smoothing",
            "-moz-tap-highlight-color",
            "-moz-transition",
            "-webkit-appearance",
            "-webkit-box-shadow",
            "-webkit-font-smoothing",
            "-webkit-tap-highlight-color",
            "-webkit-transition",
            "appearance",
            "box-shadow",
            "color",
            "direction",
            "font",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-variant-alternates",
            "font-variant-caps",
            "font-variant-east-asian",
            "font-variant-ligatures",
            "font-variant-numeric",
            "font-weight",
            "letter-spacing",
            "line-height",
            "margin",
            "margin-top",
            "margin-right",
            "margin-bottom",
            "margin-left",
            "opacity",
            "outline",
            "padding",
            "padding-top",
            "padding-right",
            "padding-bottom",
            "padding-left",
            "text-align",
            "text-shadow",
            "transition"
          ],
          allowedFields: {
            cardholderName: {
              name: "cardholder-name",
              label: "Cardholder Name"
            },
            number: {
              name: "credit-card-number",
              label: "Credit Card Number"
            },
            cvv: {
              name: "cvv",
              label: "CVV"
            },
            expirationDate: {
              name: "expiration",
              label: "Expiration Date"
            },
            expirationMonth: {
              name: "expiration-month",
              label: "Expiration Month"
            },
            expirationYear: {
              name: "expiration-year",
              label: "Expiration Year"
            },
            postalCode: {
              name: "postal-code",
              label: "Postal Code"
            }
          },
          allowedAttributes: {
            "aria-invalid": "boolean",
            "aria-required": "boolean",
            disabled: "boolean",
            placeholder: "string"
          },
          autocompleteMappings: {
            "cardholder-name": "cc-name",
            "credit-card-number": "cc-number",
            expiration: "cc-exp",
            "expiration-month": "cc-exp-month",
            "expiration-year": "cc-exp-year",
            cvv: "cc-csc",
            "postal-code": "billing postal-code"
          }
        };
        constants.events = enumerate([
          "ADD_CLASS",
          "AUTOFILL_DATA_AVAILABLE",
          "BIN_AVAILABLE",
          "CARD_FORM_ENTRY_HAS_BEGUN",
          "CLEAR_FIELD",
          "CONFIGURATION",
          "FRAME_READY",
          "INPUT_EVENT",
          "READY_FOR_CLIENT",
          "REMOVE_ATTRIBUTE",
          "REMOVE_CLASS",
          "REMOVE_FOCUS_INTERCEPTS",
          "SET_ATTRIBUTE",
          "SET_MESSAGE",
          "SET_MONTH_OPTIONS",
          "TOKENIZATION_REQUEST",
          "TRIGGER_FOCUS_CHANGE",
          "TRIGGER_INPUT_FOCUS",
          "VALIDATE_STRICT"
        ], "hosted-fields:");
        module2.exports = constants;
      }, { "../../lib/enumerate": 100, "./errors": 81 }], 81: [function(require2, module2, exports2) {
        var BraintreeError = require2("../../lib/braintree-error");
        module2.exports = {
          HOSTED_FIELDS_TIMEOUT: {
            type: BraintreeError.types.UNKNOWN,
            code: "HOSTED_FIELDS_TIMEOUT",
            message: "Hosted Fields timed out when attempting to set up."
          },
          HOSTED_FIELDS_INVALID_FIELD_KEY: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_INVALID_FIELD_KEY"
          },
          HOSTED_FIELDS_INVALID_FIELD_SELECTOR: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_INVALID_FIELD_SELECTOR",
            message: "Selector does not reference a valid DOM node."
          },
          HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME",
            message: "Element already contains a Braintree iframe."
          },
          HOSTED_FIELDS_FIELD_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_FIELD_INVALID"
          },
          HOSTED_FIELDS_FIELD_NOT_PRESENT: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_FIELD_NOT_PRESENT"
          },
          HOSTED_FIELDS_TOKENIZATION_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "HOSTED_FIELDS_TOKENIZATION_NETWORK_ERROR",
            message: "A tokenization network error occurred."
          },
          HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE",
            message: "This credit card already exists in the merchant's vault."
          },
          HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED",
            message: "CVV verification failed during tokenization."
          },
          HOSTED_FIELDS_FAILED_TOKENIZATION: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_FAILED_TOKENIZATION",
            message: "The supplied card data failed tokenization."
          },
          HOSTED_FIELDS_FIELDS_EMPTY: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_FIELDS_EMPTY",
            message: "All fields are empty. Cannot tokenize empty card fields."
          },
          HOSTED_FIELDS_FIELDS_INVALID: {
            type: BraintreeError.types.CUSTOMER,
            code: "HOSTED_FIELDS_FIELDS_INVALID",
            message: "Some payment input fields are invalid. Cannot tokenize invalid card fields."
          },
          HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED"
          },
          HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED"
          },
          HOSTED_FIELDS_FIELD_PROPERTY_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "HOSTED_FIELDS_FIELD_PROPERTY_INVALID"
          }
        };
      }, { "../../lib/braintree-error": 91 }], 82: [function(require2, module2, exports2) {
        function findParentTags(element, tag) {
          var parent = element.parentNode;
          var parents = [];
          while (parent != null) {
            if (parent.tagName != null && parent.tagName.toLowerCase() === tag) {
              parents.push(parent);
            }
            parent = parent.parentNode;
          }
          return parents;
        }
        module2.exports = findParentTags;
      }, {}], 83: [function(require2, module2, exports2) {
        var browserDetection = require2("./browser-detection");
        var constants = require2("./constants");
        var allowedFields = Object.keys(constants.allowedFields);
        var directions = constants.navigationDirections;
        var focusIntercept = {
          generate: function(hostedFieldsId, type, direction, handler) {
            var input = document.createElement("input");
            var focusInterceptStyles = {
              border: "none !important",
              display: "block !important",
              height: "1px !important",
              left: "-1px !important",
              opacity: "0 !important",
              position: "absolute !important",
              top: "-1px !important",
              width: "1px !important"
            };
            var shouldCreateFocusIntercept = browserDetection.hasSoftwareKeyboard() || browserDetection.isFirefox();
            if (!shouldCreateFocusIntercept) {
              return document.createDocumentFragment();
            }
            input.setAttribute("aria-hidden", "true");
            input.setAttribute("autocomplete", "off");
            input.setAttribute("data-braintree-direction", direction);
            input.setAttribute("data-braintree-type", type);
            input.setAttribute("id", "bt-" + type + "-" + direction + "-" + hostedFieldsId);
            input.setAttribute("style", JSON.stringify(focusInterceptStyles).replace(/[{}"]/g, "").replace(/,/g, ";"));
            input.classList.add("focus-intercept");
            input.addEventListener("focus", function(event) {
              handler(event);
              if (!browserDetection.hasSoftwareKeyboard()) {
                input.blur();
              }
            });
            return input;
          },
          destroy: function(idString) {
            var focusInputs;
            if (!idString) {
              focusInputs = document.querySelectorAll("[data-braintree-direction]");
              focusInputs = [].slice.call(focusInputs);
            } else {
              focusInputs = [document.getElementById(idString)];
            }
            focusInputs.forEach(function(node) {
              if (node && node.nodeType === 1 && focusIntercept.matchFocusElement(node.getAttribute("id"))) {
                node.parentNode.removeChild(node);
              }
            });
          },
          matchFocusElement: function(idString) {
            var idComponents, hasBTPrefix, isAllowedType, isValidDirection;
            if (!idString) {
              return false;
            }
            idComponents = idString.split("-");
            if (idComponents.length < 4) {
              return false;
            }
            hasBTPrefix = idComponents[0] === "bt";
            isAllowedType = allowedFields.indexOf(idComponents[1]) > -1;
            isValidDirection = idComponents[2] === directions.BACK || idComponents[2] === directions.FORWARD;
            return Boolean(hasBTPrefix && isAllowedType && isValidDirection);
          }
        };
        module2.exports = focusIntercept;
      }, { "./browser-detection": 79, "./constants": 80 }], 84: [function(require2, module2, exports2) {
        var creditCardType = require2("credit-card-type");
        module2.exports = function(number2) {
          var results = creditCardType(number2);
          results.forEach(function(card) {
            if (card.type === "mastercard") {
              card.type = "master-card";
            }
          });
          return results;
        };
      }, { "credit-card-type": 159 }], 85: [function(require2, module2, exports2) {
        var createAuthorizationData = require2("./create-authorization-data");
        var jsonClone = require2("./json-clone");
        var constants = require2("./constants");
        function addMetadata(configuration, data2) {
          var key;
          var attrs = data2 ? jsonClone(data2) : {};
          var authAttrs = createAuthorizationData(configuration.authorization).attrs;
          var _meta = jsonClone(configuration.analyticsMetadata);
          attrs.braintreeLibraryVersion = constants.BRAINTREE_LIBRARY_VERSION;
          for (key in attrs._meta) {
            if (attrs._meta.hasOwnProperty(key)) {
              _meta[key] = attrs._meta[key];
            }
          }
          attrs._meta = _meta;
          if (authAttrs.tokenizationKey) {
            attrs.tokenizationKey = authAttrs.tokenizationKey;
          } else {
            attrs.authorizationFingerprint = authAttrs.authorizationFingerprint;
          }
          return attrs;
        }
        module2.exports = addMetadata;
      }, { "./constants": 92, "./create-authorization-data": 96, "./json-clone": 120 }], 86: [function(require2, module2, exports2) {
        var constants = require2("./constants");
        var addMetadata = require2("./add-metadata");
        function sendAnalyticsEvent(clientInstanceOrPromise, kind, callback) {
          var timestamp = Date.now();
          return Promise.resolve(clientInstanceOrPromise).then(function(client) {
            var timestampInPromise = Date.now();
            var configuration = client.getConfiguration();
            var request3 = client._request;
            var url = configuration.gatewayConfiguration.analytics.url;
            var data2 = {
              analytics: [
                {
                  kind: constants.ANALYTICS_PREFIX + kind,
                  isAsync: Math.floor(timestampInPromise / 1e3) !== Math.floor(timestamp / 1e3),
                  timestamp
                }
              ]
            };
            request3({
              url,
              method: "post",
              data: addMetadata(configuration, data2),
              timeout: constants.ANALYTICS_REQUEST_TIMEOUT_MS
            }, callback);
          }).catch(function(err) {
            if (callback) {
              callback(err);
            }
          });
        }
        module2.exports = {
          sendEvent: sendAnalyticsEvent
        };
      }, { "./add-metadata": 85, "./constants": 92 }], 87: [function(require2, module2, exports2) {
        var loadScript = require2("@braintree/asset-loader/load-script");
        module2.exports = {
          loadScript
        };
      }, { "@braintree/asset-loader/load-script": 5 }], 88: [function(require2, module2, exports2) {
        var assignNormalized = typeof Object.assign === "function" ? Object.assign : assignPolyfill;
        function assignPolyfill(destination) {
          var i, source2, key;
          for (i = 1; i < arguments.length; i++) {
            source2 = arguments[i];
            for (key in source2) {
              if (source2.hasOwnProperty(key)) {
                destination[key] = source2[key];
              }
            }
          }
          return destination;
        }
        module2.exports = {
          assign: assignNormalized,
          _assign: assignPolyfill
        };
      }, {}], 89: [function(require2, module2, exports2) {
        var BraintreeError = require2("./braintree-error");
        var sharedErrors = require2("./errors");
        var VERSION2 = "3.99.0";
        function basicComponentVerification(options) {
          var client, authorization, name;
          if (!options) {
            return Promise.reject(new BraintreeError({
              type: sharedErrors.INVALID_USE_OF_INTERNAL_FUNCTION.type,
              code: sharedErrors.INVALID_USE_OF_INTERNAL_FUNCTION.code,
              message: "Options must be passed to basicComponentVerification function."
            }));
          }
          name = options.name;
          client = options.client;
          authorization = options.authorization;
          if (!client && !authorization) {
            return Promise.reject(new BraintreeError({
              type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
              code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
              message: "options.client is required when instantiating " + name + "."
            }));
          }
          if (!authorization && client.getVersion() !== VERSION2) {
            return Promise.reject(new BraintreeError({
              type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
              code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
              message: "Client (version " + client.getVersion() + ") and " + name + " (version " + VERSION2 + ") components must be from the same SDK version."
            }));
          }
          return Promise.resolve();
        }
        module2.exports = {
          verify: basicComponentVerification
        };
      }, { "./braintree-error": 91, "./errors": 101 }], 90: [function(require2, module2, exports2) {
        var once = require2("./once");
        function call(fn, callback) {
          var isSync = fn.length === 0;
          if (isSync) {
            fn();
            callback(null);
          } else {
            fn(callback);
          }
        }
        module2.exports = function(functions, cb) {
          var i;
          var length = functions.length;
          var remaining = length;
          var callback = once(cb);
          if (length === 0) {
            callback(null);
            return;
          }
          function finish(err) {
            if (err) {
              callback(err);
              return;
            }
            remaining -= 1;
            if (remaining === 0) {
              callback(null);
            }
          }
          for (i = 0; i < length; i++) {
            call(functions[i], finish);
          }
        };
      }, { "./once": 122 }], 91: [function(require2, module2, exports2) {
        var enumerate = require2("./enumerate");
        function BraintreeError(options) {
          if (!BraintreeError.types.hasOwnProperty(options.type)) {
            throw new Error(options.type + " is not a valid type.");
          }
          if (!options.code) {
            throw new Error("Error code required.");
          }
          if (!options.message) {
            throw new Error("Error message required.");
          }
          this.name = "BraintreeError";
          this.code = options.code;
          this.message = options.message;
          this.type = options.type;
          this.details = options.details;
        }
        BraintreeError.prototype = Object.create(Error.prototype);
        BraintreeError.prototype.constructor = BraintreeError;
        BraintreeError.types = enumerate([
          "CUSTOMER",
          "MERCHANT",
          "NETWORK",
          "INTERNAL",
          "UNKNOWN"
        ]);
        BraintreeError.findRootError = function(err) {
          if (err instanceof BraintreeError && err.details && err.details.originalError) {
            return BraintreeError.findRootError(err.details.originalError);
          }
          return err;
        };
        module2.exports = BraintreeError;
      }, { "./enumerate": 100 }], 92: [function(require2, module2, exports2) {
        var VERSION2 = "3.99.0";
        var PLATFORM = "web";
        var CLIENT_API_URLS = {
          production: "https://api.braintreegateway.com:443",
          sandbox: "https://api.sandbox.braintreegateway.com:443"
        };
        var ASSETS_URLS = {
          production: "https://assets.braintreegateway.com",
          sandbox: "https://assets.braintreegateway.com"
        };
        var GRAPHQL_URLS = {
          production: "https://payments.braintree-api.com/graphql",
          sandbox: "https://payments.sandbox.braintree-api.com/graphql"
        };
        module2.exports = {
          ANALYTICS_PREFIX: PLATFORM + ".",
          ANALYTICS_REQUEST_TIMEOUT_MS: 2e3,
          ASSETS_URLS,
          CLIENT_API_URLS,
          FRAUDNET_SOURCE: "BRAINTREE_SIGNIN",
          FRAUDNET_FNCLS: "fnparams-dede7cc5-15fd-4c75-a9f4-36c430ee3a99",
          FRAUDNET_URL: "https://c.paypal.com/da/r/fb.js",
          BUS_CONFIGURATION_REQUEST_EVENT: "BUS_CONFIGURATION_REQUEST",
          GRAPHQL_URLS,
          INTEGRATION_TIMEOUT_MS: 6e4,
          VERSION: VERSION2,
          INTEGRATION: "custom",
          SOURCE: "client",
          PLATFORM,
          BRAINTREE_LIBRARY_VERSION: "braintree/" + PLATFORM + "/" + VERSION2
        };
      }, {}], 93: [function(require2, module2, exports2) {
        var BraintreeError = require2("./braintree-error");
        var sharedErrors = require2("./errors");
        module2.exports = function(instance, methodNames) {
          methodNames.forEach(function(methodName) {
            instance[methodName] = function() {
              throw new BraintreeError({
                type: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.type,
                code: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.code,
                message: methodName + " cannot be called after teardown."
              });
            };
          });
        };
      }, { "./braintree-error": 91, "./errors": 101 }], 94: [function(require2, module2, exports2) {
        var BraintreeError = require2("./braintree-error");
        function convertToBraintreeError(originalErr, btErrorObject) {
          if (originalErr instanceof BraintreeError) {
            return originalErr;
          }
          return new BraintreeError({
            type: btErrorObject.type,
            code: btErrorObject.code,
            message: btErrorObject.message,
            details: {
              originalError: originalErr
            }
          });
        }
        module2.exports = convertToBraintreeError;
      }, { "./braintree-error": 91 }], 95: [function(require2, module2, exports2) {
        var ASSETS_URLS = require2("./constants").ASSETS_URLS;
        function createAssetsUrl(authorization) {
          return ASSETS_URLS.production;
        }
        module2.exports = {
          create: createAssetsUrl
        };
      }, { "./constants": 92 }], 96: [function(require2, module2, exports2) {
        var atob2 = require2("../lib/vendor/polyfill").atob;
        var CLIENT_API_URLS = require2("../lib/constants").CLIENT_API_URLS;
        function _isTokenizationKey(str) {
          return /^[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9_]+$/.test(str);
        }
        function _parseTokenizationKey(tokenizationKey) {
          var tokens = tokenizationKey.split("_");
          var environment = tokens[0];
          var merchantId = tokens.slice(2).join("_");
          return {
            merchantId,
            environment
          };
        }
        function createAuthorizationData(authorization) {
          var parsedClientToken, parsedTokenizationKey;
          var data2 = {
            attrs: {},
            configUrl: ""
          };
          if (_isTokenizationKey(authorization)) {
            parsedTokenizationKey = _parseTokenizationKey(authorization);
            data2.environment = parsedTokenizationKey.environment;
            data2.attrs.tokenizationKey = authorization;
            data2.configUrl = CLIENT_API_URLS[parsedTokenizationKey.environment] + "/merchants/" + parsedTokenizationKey.merchantId + "/client_api/v1/configuration";
          } else {
            parsedClientToken = JSON.parse(atob2(authorization));
            data2.environment = parsedClientToken.environment;
            data2.attrs.authorizationFingerprint = parsedClientToken.authorizationFingerprint;
            data2.configUrl = parsedClientToken.configUrl;
            data2.graphQL = parsedClientToken.graphQL;
          }
          return data2;
        }
        module2.exports = createAuthorizationData;
      }, { "../lib/constants": 92, "../lib/vendor/polyfill": 127 }], 97: [function(require2, module2, exports2) {
        var BraintreeError = require2("./braintree-error");
        var assets = require2("./assets");
        var sharedErrors = require2("./errors");
        var VERSION2 = "3.99.0";
        function createDeferredClient(options) {
          var promise = Promise.resolve();
          if (options.client) {
            return Promise.resolve(options.client);
          }
          if (!(window.braintree && window.braintree.client)) {
            promise = assets.loadScript({
              src: options.assetsUrl + "/web/" + VERSION2 + "/js/client.min.js"
            }).catch(function(err) {
              return Promise.reject(new BraintreeError({
                type: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.type,
                code: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.code,
                message: sharedErrors.CLIENT_SCRIPT_FAILED_TO_LOAD.message,
                details: {
                  originalError: err
                }
              }));
            });
          }
          return promise.then(function() {
            if (window.braintree.client.VERSION !== VERSION2) {
              return Promise.reject(new BraintreeError({
                type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
                code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
                message: "Client (version " + window.braintree.client.VERSION + ") and " + options.name + " (version " + VERSION2 + ") components must be from the same SDK version."
              }));
            }
            return window.braintree.client.create({
              authorization: options.authorization,
              debug: options.debug
            });
          });
        }
        module2.exports = {
          create: createDeferredClient
        };
      }, { "./assets": 87, "./braintree-error": 91, "./errors": 101 }], 98: [function(require2, module2, exports2) {
        module2.exports = function(fn) {
          return function() {
            var args = arguments;
            setTimeout(function() {
              fn.apply(null, args);
            }, 1);
          };
        };
      }, {}], 99: [function(require2, module2, exports2) {
        var batchExecuteFunctions = require2("./batch-execute-functions");
        function Destructor() {
          this._teardownRegistry = [];
          this._isTearingDown = false;
        }
        Destructor.prototype.registerFunctionForTeardown = function(fn) {
          if (typeof fn === "function") {
            this._teardownRegistry.push(fn);
          }
        };
        Destructor.prototype.teardown = function(callback) {
          if (this._isTearingDown) {
            callback(new Error("Destructor is already tearing down"));
            return;
          }
          this._isTearingDown = true;
          batchExecuteFunctions(this._teardownRegistry, function(err) {
            this._teardownRegistry = [];
            this._isTearingDown = false;
            if (typeof callback === "function") {
              callback(err);
            }
          }.bind(this));
        };
        module2.exports = Destructor;
      }, { "./batch-execute-functions": 90 }], 100: [function(require2, module2, exports2) {
        function enumerate(values, prefix) {
          prefix = prefix == null ? "" : prefix;
          return values.reduce(function(enumeration, value) {
            enumeration[value] = prefix + value;
            return enumeration;
          }, {});
        }
        module2.exports = enumerate;
      }, {}], 101: [function(require2, module2, exports2) {
        var BraintreeError = require2("./braintree-error");
        module2.exports = {
          INVALID_USE_OF_INTERNAL_FUNCTION: {
            type: BraintreeError.types.INTERNAL,
            code: "INVALID_USE_OF_INTERNAL_FUNCTION"
          },
          INSTANTIATION_OPTION_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "INSTANTIATION_OPTION_REQUIRED"
          },
          INCOMPATIBLE_VERSIONS: {
            type: BraintreeError.types.MERCHANT,
            code: "INCOMPATIBLE_VERSIONS"
          },
          CLIENT_SCRIPT_FAILED_TO_LOAD: {
            type: BraintreeError.types.NETWORK,
            code: "CLIENT_SCRIPT_FAILED_TO_LOAD",
            message: "Braintree client script could not be loaded."
          },
          METHOD_CALLED_AFTER_TEARDOWN: {
            type: BraintreeError.types.MERCHANT,
            code: "METHOD_CALLED_AFTER_TEARDOWN"
          }
        };
      }, { "./braintree-error": 91 }], 102: [function(require2, module2, exports2) {
        module2.exports = function findRootNode(element) {
          while (element.parentNode) {
            element = element.parentNode;
          }
          return element;
        };
      }, {}], 103: [function(require2, module2, exports2) {
        module2.exports = function(array, key, value) {
          var i;
          for (i = 0; i < array.length; i++) {
            if (array[i].hasOwnProperty(key) && array[i][key] === value) {
              return array[i];
            }
          }
          return null;
        };
      }, {}], 104: [function(require2, module2, exports2) {
        var Popup = require2("./strategies/popup");
        var PopupBridge = require2("./strategies/popup-bridge");
        var Modal2 = require2("./strategies/modal");
        var Bus = require2("framebus");
        var events = require2("../shared/events");
        var errors = require2("../shared/errors");
        var constants = require2("../shared/constants");
        var uuid = require2("@braintree/uuid");
        var iFramer = require2("@braintree/iframer");
        var BraintreeError = require2("../../braintree-error");
        var browserDetection = require2("../shared/browser-detection");
        var assign2 = require2("./../../assign").assign;
        var BUS_CONFIGURATION_REQUEST_EVENT = require2("../../constants").BUS_CONFIGURATION_REQUEST_EVENT;
        var REQUIRED_CONFIG_KEYS = ["name", "dispatchFrameUrl", "openFrameUrl"];
        function noop2() {
        }
        function _validateFrameConfiguration(options) {
          if (!options) {
            throw new Error("Valid configuration is required");
          }
          REQUIRED_CONFIG_KEYS.forEach(function(key) {
            if (!options.hasOwnProperty(key)) {
              throw new Error("A valid frame " + key + " must be provided");
            }
          });
          if (!/^[\w_]+$/.test(options.name)) {
            throw new Error("A valid frame name must be provided");
          }
        }
        function FrameService(options) {
          _validateFrameConfiguration(options);
          this._serviceId = uuid().replace(/-/g, "");
          this._options = {
            name: options.name + "_" + this._serviceId,
            dispatchFrameUrl: options.dispatchFrameUrl,
            openFrameUrl: options.openFrameUrl,
            height: options.height,
            width: options.width,
            top: options.top,
            left: options.left
          };
          this.state = options.state || {};
          this._bus = new Bus({ channel: this._serviceId });
          this._setBusEvents();
        }
        FrameService.prototype.initialize = function(callback) {
          var dispatchFrameReadyHandler = function() {
            callback();
            this._bus.off(events.DISPATCH_FRAME_READY, dispatchFrameReadyHandler);
          }.bind(this);
          this._bus.on(events.DISPATCH_FRAME_READY, dispatchFrameReadyHandler);
          this._writeDispatchFrame();
        };
        FrameService.prototype._writeDispatchFrame = function() {
          var frameName = constants.DISPATCH_FRAME_NAME + "_" + this._serviceId;
          var frameSrc = this._options.dispatchFrameUrl;
          this._dispatchFrame = iFramer({
            "aria-hidden": true,
            name: frameName,
            title: frameName,
            src: frameSrc,
            class: constants.DISPATCH_FRAME_CLASS,
            height: 0,
            width: 0,
            style: {
              position: "absolute",
              left: "-9999px"
            }
          });
          document.body.appendChild(this._dispatchFrame);
        };
        FrameService.prototype._setBusEvents = function() {
          this._bus.on(events.DISPATCH_FRAME_REPORT, function(res, reply) {
            if (this._onCompleteCallback) {
              this._onCompleteCallback.call(null, res.err, res.payload);
            }
            this._frame.close();
            this._onCompleteCallback = null;
            if (reply) {
              reply();
            }
          }.bind(this));
          this._bus.on(BUS_CONFIGURATION_REQUEST_EVENT, function(reply) {
            reply(this.state);
          }.bind(this));
        };
        FrameService.prototype.open = function(options, callback) {
          options = options || {};
          this._frame = this._getFrameForEnvironment(options);
          this._frame.initialize(callback);
          if (this._frame instanceof PopupBridge) {
            return;
          }
          assign2(this.state, options.state);
          this._onCompleteCallback = callback;
          this._frame.open();
          if (this.isFrameClosed()) {
            this._cleanupFrame();
            if (callback) {
              callback(new BraintreeError(errors.FRAME_SERVICE_FRAME_OPEN_FAILED));
            }
            return;
          }
          this._pollForPopupClose();
        };
        FrameService.prototype.redirect = function(url) {
          if (this._frame && !this.isFrameClosed()) {
            this._frame.redirect(url);
          }
        };
        FrameService.prototype.close = function() {
          if (!this.isFrameClosed()) {
            this._frame.close();
          }
        };
        FrameService.prototype.focus = function() {
          if (!this.isFrameClosed()) {
            this._frame.focus();
          }
        };
        FrameService.prototype.createHandler = function(options) {
          options = options || {};
          return {
            close: function() {
              if (options.beforeClose) {
                options.beforeClose();
              }
              this.close();
            }.bind(this),
            focus: function() {
              if (options.beforeFocus) {
                options.beforeFocus();
              }
              this.focus();
            }.bind(this)
          };
        };
        FrameService.prototype.createNoopHandler = function() {
          return {
            close: noop2,
            focus: noop2
          };
        };
        FrameService.prototype.teardown = function() {
          this.close();
          this._dispatchFrame.parentNode.removeChild(this._dispatchFrame);
          this._dispatchFrame = null;
          this._cleanupFrame();
        };
        FrameService.prototype.isFrameClosed = function() {
          return this._frame == null || this._frame.isClosed();
        };
        FrameService.prototype._cleanupFrame = function() {
          this._frame = null;
          clearInterval(this._popupInterval);
          this._popupInterval = null;
        };
        FrameService.prototype._pollForPopupClose = function() {
          this._popupInterval = setInterval(function() {
            if (this.isFrameClosed()) {
              this._cleanupFrame();
              if (this._onCompleteCallback) {
                this._onCompleteCallback(new BraintreeError(errors.FRAME_SERVICE_FRAME_CLOSED));
              }
            }
          }.bind(this), constants.POPUP_POLL_INTERVAL);
          return this._popupInterval;
        };
        FrameService.prototype._getFrameForEnvironment = function(options) {
          var usePopup = browserDetection.supportsPopups();
          var popupBridgeExists = Boolean(window.popupBridge);
          var initOptions = assign2({}, this._options, options);
          if (popupBridgeExists) {
            return new PopupBridge(initOptions);
          } else if (usePopup) {
            return new Popup(initOptions);
          }
          return new Modal2(initOptions);
        };
        module2.exports = FrameService;
      }, { "../../braintree-error": 91, "../../constants": 92, "../shared/browser-detection": 111, "../shared/constants": 112, "../shared/errors": 113, "../shared/events": 114, "./../../assign": 88, "./strategies/modal": 106, "./strategies/popup": 109, "./strategies/popup-bridge": 107, "@braintree/iframer": 39, "@braintree/uuid": 43, "framebus": 167 }], 105: [function(require2, module2, exports2) {
        var FrameService = require2("./frame-service");
        module2.exports = {
          create: function createFrameService(options, callback) {
            var frameService = new FrameService(options);
            frameService.initialize(function() {
              callback(frameService);
            });
          }
        };
      }, { "./frame-service": 104 }], 106: [function(require2, module2, exports2) {
        var iFramer = require2("@braintree/iframer");
        var assign2 = require2("../../../assign").assign;
        var browserDetection = require2("../../shared/browser-detection");
        var ELEMENT_STYLES = {
          position: "fixed",
          top: 0,
          left: 0,
          bottom: 0,
          padding: 0,
          margin: 0,
          border: 0,
          outline: "none",
          zIndex: 20001,
          background: "#FFFFFF"
        };
        function noop2() {
        }
        function Modal2(options) {
          this._closed = null;
          this._frame = null;
          this._options = options || {};
          this._container = this._options.container || document.body;
        }
        Modal2.prototype.initialize = noop2;
        Modal2.prototype.open = function() {
          var iframerConfig = {
            src: this._options.openFrameUrl,
            name: this._options.name,
            scrolling: "yes",
            height: "100%",
            width: "100%",
            style: assign2({}, ELEMENT_STYLES),
            title: "Lightbox Frame"
          };
          if (browserDetection.isIos()) {
            if (browserDetection.isIosWKWebview()) {
              this._lockScrolling();
              iframerConfig.style = {};
            }
            this._el = document.createElement("div");
            assign2(this._el.style, ELEMENT_STYLES, {
              height: "100%",
              width: "100%",
              overflow: "auto",
              "-webkit-overflow-scrolling": "touch"
            });
            this._frame = iFramer(iframerConfig);
            this._el.appendChild(this._frame);
          } else {
            this._el = this._frame = iFramer(iframerConfig);
          }
          this._closed = false;
          this._container.appendChild(this._el);
        };
        Modal2.prototype.focus = noop2;
        Modal2.prototype.close = function() {
          this._container.removeChild(this._el);
          this._frame = null;
          this._closed = true;
          if (browserDetection.isIosWKWebview()) {
            this._unlockScrolling();
          }
        };
        Modal2.prototype.isClosed = function() {
          return Boolean(this._closed);
        };
        Modal2.prototype.redirect = function(redirectUrl) {
          this._frame.src = redirectUrl;
        };
        Modal2.prototype._unlockScrolling = function() {
          document.body.style.overflow = this._savedBodyProperties.overflowStyle;
          document.body.style.position = this._savedBodyProperties.positionStyle;
          window.scrollTo(this._savedBodyProperties.left, this._savedBodyProperties.top);
          delete this._savedBodyProperties;
        };
        Modal2.prototype._lockScrolling = function() {
          var doc2 = document.documentElement;
          this._savedBodyProperties = {
            left: (window.pageXOffset || doc2.scrollLeft) - (doc2.clientLeft || 0),
            top: (window.pageYOffset || doc2.scrollTop) - (doc2.clientTop || 0),
            overflowStyle: document.body.style.overflow,
            positionStyle: document.body.style.position
          };
          document.body.style.overflow = "hidden";
          document.body.style.position = "fixed";
          window.scrollTo(0, 0);
        };
        module2.exports = Modal2;
      }, { "../../../assign": 88, "../../shared/browser-detection": 111, "@braintree/iframer": 39 }], 107: [function(require2, module2, exports2) {
        var BraintreeError = require2("../../../braintree-error");
        var errors = require2("../../shared/errors");
        function noop2() {
        }
        function PopupBridge(options) {
          this._closed = null;
          this._options = options;
        }
        PopupBridge.prototype.initialize = function(callback) {
          var self2 = this;
          window.popupBridge.onComplete = function(err, payload) {
            var popupDismissed = !payload && !err;
            self2._closed = true;
            if (err || popupDismissed) {
              callback(new BraintreeError(errors.FRAME_SERVICE_FRAME_CLOSED));
              return;
            }
            callback(null, payload);
          };
        };
        PopupBridge.prototype.open = function(options) {
          var url;
          options = options || {};
          url = options.openFrameUrl || this._options.openFrameUrl;
          this._closed = false;
          window.popupBridge.open(url);
        };
        PopupBridge.prototype.focus = noop2;
        PopupBridge.prototype.close = noop2;
        PopupBridge.prototype.isClosed = function() {
          return Boolean(this._closed);
        };
        PopupBridge.prototype.redirect = function(redirectUrl) {
          this.open({ openFrameUrl: redirectUrl });
        };
        module2.exports = PopupBridge;
      }, { "../../../braintree-error": 91, "../../shared/errors": 113 }], 108: [function(require2, module2, exports2) {
        var constants = require2("../../../shared/constants");
        var position = require2("./position");
        function calculatePosition(type, userDefinedPosition, size2) {
          if (typeof userDefinedPosition !== "undefined") {
            return userDefinedPosition;
          }
          return position[type](size2);
        }
        module2.exports = function composePopupOptions(options) {
          var height = options.height || constants.DEFAULT_POPUP_HEIGHT;
          var width = options.width || constants.DEFAULT_POPUP_WIDTH;
          var top = calculatePosition("top", options.top, height);
          var left = calculatePosition("left", options.left, width);
          return [
            constants.POPUP_BASE_OPTIONS,
            "height=" + height,
            "width=" + width,
            "top=" + top,
            "left=" + left
          ].join(",");
        };
      }, { "../../../shared/constants": 112, "./position": 110 }], 109: [function(require2, module2, exports2) {
        var composeOptions = require2("./compose-options");
        function noop2() {
        }
        function Popup(options) {
          this._frame = null;
          this._options = options || {};
        }
        Popup.prototype.initialize = noop2;
        Popup.prototype.open = function() {
          this._frame = window.open(this._options.openFrameUrl, this._options.name, composeOptions(this._options));
        };
        Popup.prototype.focus = function() {
          this._frame.focus();
        };
        Popup.prototype.close = function() {
          if (this._frame.closed) {
            return;
          }
          this._frame.close();
        };
        Popup.prototype.isClosed = function() {
          return !this._frame || Boolean(this._frame.closed);
        };
        Popup.prototype.redirect = function(redirectUrl) {
          this._frame.location.href = redirectUrl;
        };
        module2.exports = Popup;
      }, { "./compose-options": 108 }], 110: [function(require2, module2, exports2) {
        function top(height) {
          var windowHeight = window.outerHeight || document.documentElement.clientHeight;
          var windowTop = window.screenY == null ? window.screenTop : window.screenY;
          return center(windowHeight, height, windowTop);
        }
        function left(width) {
          var windowWidth = window.outerWidth || document.documentElement.clientWidth;
          var windowLeft = window.screenX == null ? window.screenLeft : window.screenX;
          return center(windowWidth, width, windowLeft);
        }
        function center(windowMetric, popupMetric, offset) {
          return (windowMetric - popupMetric) / 2 + offset;
        }
        module2.exports = {
          top,
          left,
          center
        };
      }, {}], 111: [function(require2, module2, exports2) {
        module2.exports = {
          isIos: require2("@braintree/browser-detection/is-ios"),
          isIosWKWebview: require2("@braintree/browser-detection/is-ios-wkwebview"),
          supportsPopups: require2("@braintree/browser-detection/supports-popups")
        };
      }, { "@braintree/browser-detection/is-ios": 34, "@braintree/browser-detection/is-ios-wkwebview": 33, "@braintree/browser-detection/supports-popups": 36 }], 112: [function(require2, module2, exports2) {
        module2.exports = {
          DISPATCH_FRAME_NAME: "dispatch",
          DISPATCH_FRAME_CLASS: "braintree-dispatch-frame",
          POPUP_BASE_OPTIONS: "resizable,scrollbars",
          DEFAULT_POPUP_WIDTH: 450,
          DEFAULT_POPUP_HEIGHT: 535,
          POPUP_POLL_INTERVAL: 100,
          POPUP_CLOSE_TIMEOUT: 100
        };
      }, {}], 113: [function(require2, module2, exports2) {
        var BraintreeError = require2("../../braintree-error");
        module2.exports = {
          FRAME_SERVICE_FRAME_CLOSED: {
            type: BraintreeError.types.INTERNAL,
            code: "FRAME_SERVICE_FRAME_CLOSED",
            message: "Frame closed before tokenization could occur."
          },
          FRAME_SERVICE_FRAME_OPEN_FAILED: {
            type: BraintreeError.types.INTERNAL,
            code: "FRAME_SERVICE_FRAME_OPEN_FAILED",
            message: "Frame failed to open."
          }
        };
      }, { "../../braintree-error": 91 }], 114: [function(require2, module2, exports2) {
        var enumerate = require2("../../enumerate");
        module2.exports = enumerate(["DISPATCH_FRAME_READY", "DISPATCH_FRAME_REPORT"], "frameService:");
      }, { "../../enumerate": 100 }], 115: [function(require2, module2, exports2) {
        var VERSION2 = "3.99.0";
        var assign2 = require2("./assign").assign;
        function generateTokenizationParameters(configuration, overrides) {
          var metadata = configuration.analyticsMetadata;
          var basicTokenizationParameters = {
            gateway: "braintree",
            "braintree:merchantId": configuration.gatewayConfiguration.merchantId,
            "braintree:apiVersion": "v1",
            "braintree:sdkVersion": VERSION2,
            "braintree:metadata": JSON.stringify({
              source: metadata.source,
              integration: metadata.integration,
              sessionId: metadata.sessionId,
              version: VERSION2,
              platform: metadata.platform
            })
          };
          return assign2({}, basicTokenizationParameters, overrides);
        }
        module2.exports = function(configuration, googlePayVersion, googleMerchantId) {
          var data2, paypalPaymentMethod;
          var androidPayConfiguration = configuration.gatewayConfiguration.androidPay;
          var environment = configuration.gatewayConfiguration.environment === "production" ? "PRODUCTION" : "TEST";
          if (googlePayVersion === 2) {
            data2 = {
              apiVersion: 2,
              apiVersionMinor: 0,
              environment,
              allowedPaymentMethods: [
                {
                  type: "CARD",
                  parameters: {
                    allowedAuthMethods: ["PAN_ONLY", "CRYPTOGRAM_3DS"],
                    allowedCardNetworks: androidPayConfiguration.supportedNetworks.map(function(card) {
                      return card.toUpperCase();
                    })
                  },
                  tokenizationSpecification: {
                    type: "PAYMENT_GATEWAY",
                    parameters: generateTokenizationParameters(configuration, {
                      "braintree:authorizationFingerprint": androidPayConfiguration.googleAuthorizationFingerprint
                    })
                  }
                }
              ]
            };
            if (googleMerchantId) {
              data2.merchantInfo = {
                merchantId: googleMerchantId
              };
            }
            if (androidPayConfiguration.paypalClientId) {
              paypalPaymentMethod = {
                type: "PAYPAL",
                parameters: {
                  purchase_context: {
                    purchase_units: [
                      {
                        payee: {
                          client_id: androidPayConfiguration.paypalClientId
                        },
                        recurring_payment: true
                      }
                    ]
                  }
                },
                tokenizationSpecification: {
                  type: "PAYMENT_GATEWAY",
                  parameters: generateTokenizationParameters(configuration, {
                    "braintree:paypalClientId": androidPayConfiguration.paypalClientId
                  })
                }
              };
              data2.allowedPaymentMethods.push(paypalPaymentMethod);
            }
          } else {
            data2 = {
              environment,
              allowedPaymentMethods: ["CARD", "TOKENIZED_CARD"],
              paymentMethodTokenizationParameters: {
                tokenizationType: "PAYMENT_GATEWAY",
                parameters: generateTokenizationParameters(configuration, {
                  "braintree:authorizationFingerprint": androidPayConfiguration.googleAuthorizationFingerprint
                })
              },
              cardRequirements: {
                allowedCardNetworks: androidPayConfiguration.supportedNetworks.map(function(card) {
                  return card.toUpperCase();
                })
              }
            };
            if (configuration.authorizationType === "TOKENIZATION_KEY") {
              data2.paymentMethodTokenizationParameters.parameters["braintree:clientKey"] = configuration.authorization;
            }
            if (googleMerchantId) {
              data2.merchantId = googleMerchantId;
            }
            if (googlePayVersion) {
              data2.apiVersion = googlePayVersion;
            }
          }
          return data2;
        };
      }, { "./assign": 88 }], 116: [function(require2, module2, exports2) {
        module2.exports = function inIframe(win) {
          win = win || window;
          try {
            return win.self !== win.top;
          } catch (e) {
            return true;
          }
        };
      }, {}], 117: [function(require2, module2, exports2) {
        function convertDateStringToDate(dateString) {
          var splitDate = dateString.split("-");
          return new Date(splitDate[0], splitDate[1], splitDate[2]);
        }
        function isDateStringBeforeOrOn(firstDate, secondDate) {
          return convertDateStringToDate(firstDate) <= convertDateStringToDate(secondDate);
        }
        module2.exports = isDateStringBeforeOrOn;
      }, {}], 118: [function(require2, module2, exports2) {
        function isHTTPS(protocol) {
          protocol = protocol || window.location.protocol;
          return protocol === "https:";
        }
        module2.exports = {
          isHTTPS
        };
      }, {}], 119: [function(require2, module2, exports2) {
        var parser;
        var legalHosts = {
          "paypal.com": 1,
          "braintreepayments.com": 1,
          "braintreegateway.com": 1,
          "braintree-api.com": 1
        };
        function stripSubdomains(domain) {
          return domain.split(".").slice(-2).join(".");
        }
        function isVerifiedDomain(url) {
          var mainDomain;
          url = url.toLowerCase();
          if (!/^https:/.test(url)) {
            return false;
          }
          parser = parser || document.createElement("a");
          parser.href = url;
          mainDomain = stripSubdomains(parser.hostname);
          return legalHosts.hasOwnProperty(mainDomain);
        }
        module2.exports = isVerifiedDomain;
      }, {}], 120: [function(require2, module2, exports2) {
        module2.exports = function(value) {
          return JSON.parse(JSON.stringify(value));
        };
      }, {}], 121: [function(require2, module2, exports2) {
        module2.exports = function(obj) {
          return Object.keys(obj).filter(function(key) {
            return typeof obj[key] === "function";
          });
        };
      }, {}], 122: [function(require2, module2, exports2) {
        function once(fn) {
          var called = false;
          return function() {
            if (!called) {
              called = true;
              fn.apply(null, arguments);
            }
          };
        }
        module2.exports = once;
      }, {}], 123: [function(require2, module2, exports2) {
        function _notEmpty(obj) {
          var key;
          for (key in obj) {
            if (obj.hasOwnProperty(key)) {
              return true;
            }
          }
          return false;
        }
        function _isArray(value) {
          return value && typeof value === "object" && typeof value.length === "number" && Object.prototype.toString.call(value) === "[object Array]" || false;
        }
        function hasQueryParams(url) {
          url = url || window.location.href;
          return /\?/.test(url);
        }
        function parse2(url) {
          var query, params;
          url = url || window.location.href;
          if (!hasQueryParams(url)) {
            return {};
          }
          query = url.split("?")[1] || "";
          query = query.replace(/#.*$/, "").split("&");
          params = query.reduce(function(toReturn, keyValue) {
            var parts = keyValue.split("=");
            var key = decodeURIComponent(parts[0]);
            var value = decodeURIComponent(parts[1]);
            toReturn[key] = value;
            return toReturn;
          }, {});
          return params;
        }
        function stringify(params, namespace) {
          var k, v, p2;
          var query = [];
          for (p2 in params) {
            if (!params.hasOwnProperty(p2)) {
              continue;
            }
            v = params[p2];
            if (namespace) {
              if (_isArray(params)) {
                k = namespace + "[]";
              } else {
                k = namespace + "[" + p2 + "]";
              }
            } else {
              k = p2;
            }
            if (typeof v === "object") {
              query.push(stringify(v, k));
            } else {
              query.push(encodeURIComponent(k) + "=" + encodeURIComponent(v));
            }
          }
          return query.join("&");
        }
        function queryify(url, params) {
          url = url || "";
          if (params != null && typeof params === "object" && _notEmpty(params)) {
            url += url.indexOf("?") === -1 ? "?" : "";
            url += url.indexOf("=") !== -1 ? "&" : "";
            url += stringify(params);
          }
          return url;
        }
        module2.exports = {
          parse: parse2,
          stringify,
          queryify,
          hasQueryParams
        };
      }, {}], 124: [function(require2, module2, exports2) {
        var uuid = require2("@braintree/uuid");
        var findRootNode = require2("./find-root-node");
        function isShadowElement(element) {
          element = findRootNode(element);
          return element.toString() === "[object ShadowRoot]";
        }
        function getShadowHost(element) {
          element = findRootNode(element);
          if (!isShadowElement(element)) {
            return null;
          }
          return element.host;
        }
        function transformToSlot(element, styles) {
          var styleNode = findRootNode(element).querySelector("style");
          var shadowHost = getShadowHost(element);
          var slotName = "shadow-slot-" + uuid();
          var slot = document.createElement("slot");
          var slotProvider = document.createElement("div");
          slot.setAttribute("name", slotName);
          element.appendChild(slot);
          slotProvider.setAttribute("slot", slotName);
          shadowHost.appendChild(slotProvider);
          if (styles) {
            if (!styleNode) {
              styleNode = document.createElement("style");
              element.appendChild(styleNode);
            }
            styleNode.sheet.insertRule('::slotted([slot="' + slotName + '"]) { ' + styles + " }");
          }
          if (isShadowElement(shadowHost)) {
            return transformToSlot(slotProvider, styles);
          }
          return slotProvider;
        }
        module2.exports = {
          isShadowElement,
          getShadowHost,
          transformToSlot
        };
      }, { "./find-root-node": 102, "@braintree/uuid": 43 }], 125: [function(require2, module2, exports2) {
        module2.exports = function(snakeString) {
          if (snakeString.indexOf("_") === -1) {
            return snakeString;
          }
          return snakeString.toLowerCase().replace(/(\_\w)/g, function(match) {
            return match[1].toUpperCase();
          });
        };
      }, {}], 126: [function(require2, module2, exports2) {
        function useMin(isDebug) {
          return isDebug ? "" : ".min";
        }
        module2.exports = useMin;
      }, {}], 127: [function(require2, module2, exports2) {
        var atobNormalized = typeof atob === "function" ? atob : atobPolyfill;
        function atobPolyfill(base64String) {
          var a, b, c, b1, b2, b3, b4, i;
          var base64Matcher = new RegExp("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})([=]{1,2})?$");
          var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var result = "";
          if (!base64Matcher.test(base64String)) {
            throw new Error("Non base64 encoded input passed to window.atob polyfill");
          }
          i = 0;
          do {
            b1 = characters.indexOf(base64String.charAt(i++));
            b2 = characters.indexOf(base64String.charAt(i++));
            b3 = characters.indexOf(base64String.charAt(i++));
            b4 = characters.indexOf(base64String.charAt(i++));
            a = (b1 & 63) << 2 | b2 >> 4 & 3;
            b = (b2 & 15) << 4 | b3 >> 2 & 15;
            c = (b3 & 3) << 6 | b4 & 63;
            result += String.fromCharCode(a) + (b ? String.fromCharCode(b) : "") + (c ? String.fromCharCode(c) : "");
          } while (i < base64String.length);
          return result;
        }
        module2.exports = {
          atob: function(base64String) {
            return atobNormalized.call(window, base64String);
          },
          _atob: atobPolyfill
        };
      }, {}], 128: [function(require2, module2, exports2) {
        var BraintreeError = require2("../lib/braintree-error");
        module2.exports = {
          PAYPAL_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_NOT_ENABLED",
            message: "PayPal is not enabled for this merchant."
          },
          PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED",
            message: "A linked PayPal Sandbox account is required to use PayPal Checkout in Sandbox. See https://developer.paypal.com/braintree/docs/guides/paypal/testing-go-live#linked-paypal-testing for details on linking your PayPal sandbox with Braintree."
          },
          PAYPAL_ACCOUNT_TOKENIZATION_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "PAYPAL_ACCOUNT_TOKENIZATION_FAILED",
            message: "Could not tokenize user's PayPal account."
          },
          PAYPAL_FLOW_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "PAYPAL_FLOW_FAILED",
            message: "Could not initialize PayPal flow."
          },
          PAYPAL_FLOW_OPTION_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_FLOW_OPTION_REQUIRED",
            message: "PayPal flow property is invalid or missing."
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_PARAM_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_PARAM_REQUIRED"
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_SETUP_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_SETUP_FAILED",
            message: "Something went wrong when setting up the checkout workflow."
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED",
            message: "PayPal popup failed to open, make sure to initiate the vault checkout in response to a user action."
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_CANCELED",
            message: "Customer closed PayPal popup before authorizing."
          },
          PAYPAL_START_VAULT_INITIATED_CHECKOUT_IN_PROGRESS: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_START_VAULT_INITIATED_CHECKOUT_IN_PROGRESS",
            message: "Vault initiated checkout already in progress."
          },
          PAYPAL_INVALID_PAYMENT_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_INVALID_PAYMENT_OPTION",
            message: "PayPal payment options are invalid."
          },
          PAYPAL_MISSING_REQUIRED_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "PAYPAL_MISSING_REQUIRED_OPTION",
            message: "Missing required option."
          }
        };
      }, { "../lib/braintree-error": 91 }], 129: [function(require2, module2, exports2) {
        var basicComponentVerification = require2("../lib/basic-component-verification");
        var wrapPromise = require2("@braintree/wrap-promise");
        var PayPalCheckout = require2("./paypal-checkout");
        var VERSION2 = "3.99.0";
        function create2(options) {
          var name = "PayPal Checkout";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var instance = new PayPalCheckout(options);
            return instance._initialize(options);
          });
        }
        function isSupported() {
          return true;
        }
        module2.exports = {
          create: wrapPromise(create2),
          isSupported,
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 89, "./paypal-checkout": 130, "@braintree/wrap-promise": 47 }], 130: [function(require2, module2, exports2) {
        var analytics = require2("../lib/analytics");
        var assign2 = require2("../lib/assign").assign;
        var createDeferredClient = require2("../lib/create-deferred-client");
        var createAssetsUrl = require2("../lib/create-assets-url");
        var ExtendedPromise = require2("@braintree/extended-promise");
        var wrapPromise = require2("@braintree/wrap-promise");
        var BraintreeError = require2("../lib/braintree-error");
        var convertToBraintreeError = require2("../lib/convert-to-braintree-error");
        var errors = require2("./errors");
        var constants = require2("../paypal/shared/constants");
        var frameService = require2("../lib/frame-service/external");
        var createAuthorizationData = require2("../lib/create-authorization-data");
        var methods = require2("../lib/methods");
        var useMin = require2("../lib/use-min");
        var convertMethodsToError = require2("../lib/convert-methods-to-error");
        var querystring = require2("../lib/querystring");
        var VERSION2 = "3.99.0";
        var INTEGRATION_TIMEOUT_MS = require2("../lib/constants").INTEGRATION_TIMEOUT_MS;
        var REQUIRED_PARAMS_FOR_START_VAULT_INITIATED_CHECKOUT = [
          "amount",
          "currency",
          "vaultInitiatedCheckoutPaymentMethodToken"
        ];
        var PAYPAL_SDK_PRELOAD_URL = "https://www.{ENV}paypal.com/smart/buttons/preload";
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function PayPalCheckout(options) {
          this._merchantAccountId = options.merchantAccountId;
          this._autoSetDataUserIdToken = Boolean(options.autoSetDataUserIdToken);
        }
        PayPalCheckout.prototype._initialize = function(options) {
          var config;
          if (options.client) {
            config = options.client.getConfiguration();
            this._authorizationInformation = {
              fingerprint: config.authorizationFingerprint,
              environment: config.gatewayConfiguration.environment
            };
          } else {
            config = createAuthorizationData(options.authorization);
            this._authorizationInformation = {
              fingerprint: config.attrs.authorizationFingerprint,
              environment: config.environment
            };
          }
          this._clientPromise = createDeferredClient.create({
            authorization: options.authorization,
            client: options.client,
            debug: options.debug,
            assetsUrl: createAssetsUrl.create(options.authorization),
            name: "PayPal Checkout"
          }).then(function(client) {
            this._configuration = client.getConfiguration();
            if (!this._merchantAccountId) {
              if (!this._configuration.gatewayConfiguration.paypalEnabled) {
                this._setupError = new BraintreeError(errors.PAYPAL_NOT_ENABLED);
              } else if (this._configuration.gatewayConfiguration.paypal.environmentNoNetwork === true) {
                this._setupError = new BraintreeError(errors.PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED);
              }
            }
            if (this._setupError) {
              return Promise.reject(this._setupError);
            }
            analytics.sendEvent(client, "paypal-checkout.initialized");
            this._frameServicePromise = this._setupFrameService(client);
            return client;
          }.bind(this));
          if (options.client) {
            return this._clientPromise.then(function() {
              return this;
            }.bind(this));
          }
          return Promise.resolve(this);
        };
        PayPalCheckout.prototype._setupFrameService = function(client) {
          var frameServicePromise = new ExtendedPromise();
          var config = client.getConfiguration();
          var timeoutRef = setTimeout(function() {
            analytics.sendEvent(client, "paypal-checkout.frame-service.timed-out");
            frameServicePromise.reject(new BraintreeError(errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_SETUP_FAILED));
          }, INTEGRATION_TIMEOUT_MS);
          this._assetsUrl = config.gatewayConfiguration.paypal.assetsUrl + "/web/" + VERSION2;
          this._isDebug = config.isDebug;
          this._loadingFrameUrl = this._assetsUrl + "/html/paypal-landing-frame" + useMin(this._isDebug) + ".html";
          frameService.create({
            name: "braintreepaypallanding",
            dispatchFrameUrl: this._assetsUrl + "/html/dispatch-frame" + useMin(this._isDebug) + ".html",
            openFrameUrl: this._loadingFrameUrl
          }, function(service) {
            this._frameService = service;
            clearTimeout(timeoutRef);
            frameServicePromise.resolve();
          }.bind(this));
          return frameServicePromise;
        };
        PayPalCheckout.prototype.createPayment = function(options) {
          if (!options || !constants.FLOW_ENDPOINTS.hasOwnProperty(options.flow)) {
            return Promise.reject(new BraintreeError(errors.PAYPAL_FLOW_OPTION_REQUIRED));
          }
          analytics.sendEvent(this._clientPromise, "paypal-checkout.createPayment");
          return this._createPaymentResource(options).then(function(response) {
            var flowToken, urlParams;
            if (options.flow === "checkout") {
              urlParams = querystring.parse(response.paymentResource.redirectUrl);
              flowToken = urlParams.token;
            } else {
              flowToken = response.agreementSetup.tokenId;
            }
            return flowToken;
          });
        };
        PayPalCheckout.prototype._createPaymentResource = function(options, config) {
          var self2 = this;
          var endpoint = "paypal_hermes/" + constants.FLOW_ENDPOINTS[options.flow];
          delete this.intentFromCreatePayment;
          config = config || {};
          if (options.offerCredit === true) {
            analytics.sendEvent(this._clientPromise, "paypal-checkout.credit.offered");
          }
          return this._clientPromise.then(function(client) {
            return client.request({
              endpoint,
              method: "post",
              data: self2._formatPaymentResourceData(options, config)
            }).then(function(data2) {
              self2.intentFromCreatePayment = options.intent;
              return data2;
            });
          }).catch(function(err) {
            var status;
            if (self2._setupError) {
              return Promise.reject(self2._setupError);
            }
            status = err.details && err.details.httpStatus;
            if (status === 422) {
              return Promise.reject(new BraintreeError({
                type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
                code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
                message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
                details: {
                  originalError: err
                }
              }));
            }
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.PAYPAL_FLOW_FAILED.type,
              code: errors.PAYPAL_FLOW_FAILED.code,
              message: errors.PAYPAL_FLOW_FAILED.message
            }));
          });
        };
        PayPalCheckout.prototype.updatePayment = function(options) {
          var self2 = this;
          var endpoint = "paypal_hermes/patch_payment_resource";
          if (!options || this._hasMissingOption(options, constants.REQUIRED_OPTIONS)) {
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment.missing-options");
            return Promise.reject(new BraintreeError(errors.PAYPAL_MISSING_REQUIRED_OPTION));
          }
          if (!this._verifyConsistentCurrency(options)) {
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment.inconsistent-currencies");
            return Promise.reject(new BraintreeError({
              type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
              code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
              message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
              details: {
                originalError: new Error("One or more shipping option currencies differ from checkout currency.")
              }
            }));
          }
          analytics.sendEvent(this._clientPromise, "paypal-checkout.updatePayment");
          return this._clientPromise.then(function(client) {
            return client.request({
              endpoint,
              method: "post",
              data: self2._formatUpdatePaymentData(options)
            });
          }).catch(function(err) {
            var status = err.details && err.details.httpStatus;
            if (status === 422) {
              analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment.invalid");
              return Promise.reject(new BraintreeError({
                type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
                code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
                message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
                details: {
                  originalError: err
                }
              }));
            }
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment." + errors.PAYPAL_FLOW_FAILED.code);
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.PAYPAL_FLOW_FAILED.type,
              code: errors.PAYPAL_FLOW_FAILED.code,
              message: errors.PAYPAL_FLOW_FAILED.message
            }));
          });
        };
        PayPalCheckout.prototype.startVaultInitiatedCheckout = function(options) {
          var missingRequiredParam;
          var self2 = this;
          if (this._vaultInitiatedCheckoutInProgress) {
            analytics.sendEvent(this._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.error.already-in-progress");
            return Promise.reject(new BraintreeError(errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_IN_PROGRESS));
          }
          REQUIRED_PARAMS_FOR_START_VAULT_INITIATED_CHECKOUT.forEach(function(param) {
            if (!options.hasOwnProperty(param)) {
              missingRequiredParam = param;
            }
          });
          if (missingRequiredParam) {
            return Promise.reject(new BraintreeError({
              type: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_PARAM_REQUIRED.type,
              code: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_PARAM_REQUIRED.code,
              message: "Required param " + missingRequiredParam + " is missing."
            }));
          }
          this._vaultInitiatedCheckoutInProgress = true;
          this._addModalBackdrop(options);
          options = assign2({}, options, {
            flow: "checkout"
          });
          analytics.sendEvent(this._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.started");
          return this._waitForVaultInitiatedCheckoutDependencies().then(function() {
            var frameCommunicationPromise = new ExtendedPromise();
            var startVaultInitiatedCheckoutPromise = self2._createPaymentResource(options, {
              returnUrl: self2._constructVaultCheckutUrl("redirect-frame"),
              cancelUrl: self2._constructVaultCheckutUrl("cancel-frame")
            }).then(function(response) {
              var redirectUrl = response.paymentResource.redirectUrl;
              self2._frameService.redirect(redirectUrl);
              return frameCommunicationPromise;
            });
            self2._frameService.open({}, self2._createFrameServiceCallback(frameCommunicationPromise));
            return startVaultInitiatedCheckoutPromise;
          }).catch(function(err) {
            self2._vaultInitiatedCheckoutInProgress = false;
            self2._removeModalBackdrop();
            if (err.code === "FRAME_SERVICE_FRAME_CLOSED") {
              analytics.sendEvent(self2._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.canceled.by-customer");
              return Promise.reject(new BraintreeError(errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_CANCELED));
            }
            if (self2._frameService) {
              self2._frameService.close();
            }
            if (err.code && err.code.indexOf("FRAME_SERVICE_FRAME_OPEN_FAILED") > -1) {
              analytics.sendEvent(self2._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.failed.popup-not-opened");
              return Promise.reject(new BraintreeError({
                code: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED.code,
                type: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED.type,
                message: errors.PAYPAL_START_VAULT_INITIATED_CHECKOUT_POPUP_OPEN_FAILED.message,
                details: {
                  originalError: err
                }
              }));
            }
            return Promise.reject(err);
          }).then(function(response) {
            self2._frameService.close();
            self2._vaultInitiatedCheckoutInProgress = false;
            self2._removeModalBackdrop();
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.succeeded");
            return Promise.resolve(response);
          });
        };
        PayPalCheckout.prototype._addModalBackdrop = function(options) {
          if (options.optOutOfModalBackdrop) {
            return;
          }
          if (!this._modalBackdrop) {
            this._modalBackdrop = document.createElement("div");
            this._modalBackdrop.setAttribute("data-braintree-paypal-vault-initiated-checkout-modal", true);
            this._modalBackdrop.style.position = "fixed";
            this._modalBackdrop.style.top = 0;
            this._modalBackdrop.style.bottom = 0;
            this._modalBackdrop.style.left = 0;
            this._modalBackdrop.style.right = 0;
            this._modalBackdrop.style.zIndex = 9999;
            this._modalBackdrop.style.background = "black";
            this._modalBackdrop.style.opacity = "0.7";
            this._modalBackdrop.addEventListener("click", function() {
              this.focusVaultInitiatedCheckoutWindow();
            }.bind(this));
          }
          document.body.appendChild(this._modalBackdrop);
        };
        PayPalCheckout.prototype._removeModalBackdrop = function() {
          if (!(this._modalBackdrop && this._modalBackdrop.parentNode)) {
            return;
          }
          this._modalBackdrop.parentNode.removeChild(this._modalBackdrop);
        };
        PayPalCheckout.prototype.closeVaultInitiatedCheckoutWindow = function() {
          if (this._vaultInitiatedCheckoutInProgress) {
            analytics.sendEvent(this._clientPromise, "paypal-checkout.startVaultInitiatedCheckout.canceled.by-merchant");
          }
          return this._waitForVaultInitiatedCheckoutDependencies().then(function() {
            this._frameService.close();
          }.bind(this));
        };
        PayPalCheckout.prototype.focusVaultInitiatedCheckoutWindow = function() {
          return this._waitForVaultInitiatedCheckoutDependencies().then(function() {
            this._frameService.focus();
          }.bind(this));
        };
        PayPalCheckout.prototype._createFrameServiceCallback = function(frameCommunicationPromise) {
          var self2 = this;
          return function(err, payload) {
            if (err) {
              frameCommunicationPromise.reject(err);
            } else if (payload) {
              self2._frameService.redirect(self2._loadingFrameUrl);
              self2.tokenizePayment({
                paymentToken: payload.token,
                payerID: payload.PayerID,
                paymentID: payload.paymentId,
                orderID: payload.orderId
              }).then(function(res) {
                frameCommunicationPromise.resolve(res);
              }).catch(function(tokenizationError) {
                frameCommunicationPromise.reject(tokenizationError);
              });
            }
          };
        };
        PayPalCheckout.prototype._waitForVaultInitiatedCheckoutDependencies = function() {
          var self2 = this;
          return this._clientPromise.then(function() {
            return self2._frameServicePromise;
          });
        };
        PayPalCheckout.prototype._constructVaultCheckutUrl = function(frameName) {
          var serviceId = this._frameService._serviceId;
          return this._assetsUrl + "/html/" + frameName + useMin(this._isDebug) + ".html?channel=" + serviceId;
        };
        PayPalCheckout.prototype.tokenizePayment = function(tokenizeOptions) {
          var self2 = this;
          var shouldVault = true;
          var payload;
          var options = {
            flow: tokenizeOptions.billingToken && !tokenizeOptions.paymentID ? "vault" : "checkout",
            intent: tokenizeOptions.intent || this.intentFromCreatePayment
          };
          var params = {
            ecToken: tokenizeOptions.paymentToken,
            billingToken: tokenizeOptions.billingToken,
            payerId: tokenizeOptions.payerID,
            paymentId: tokenizeOptions.paymentID,
            orderId: tokenizeOptions.orderID,
            shippingOptionsId: tokenizeOptions.shippingOptionsId
          };
          if (tokenizeOptions.hasOwnProperty("vault")) {
            shouldVault = tokenizeOptions.vault;
          }
          options.vault = shouldVault;
          analytics.sendEvent(this._clientPromise, "paypal-checkout.tokenization.started");
          return this._clientPromise.then(function(client) {
            return client.request({
              endpoint: "payment_methods/paypal_accounts",
              method: "post",
              data: self2._formatTokenizeData(options, params)
            });
          }).then(function(response) {
            payload = self2._formatTokenizePayload(response);
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.tokenization.success");
            if (payload.creditFinancingOffered) {
              analytics.sendEvent(self2._clientPromise, "paypal-checkout.credit.accepted");
            }
            return payload;
          }).catch(function(err) {
            if (self2._setupError) {
              return Promise.reject(self2._setupError);
            }
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.tokenization.failed");
            return Promise.reject(convertToBraintreeError(err, {
              type: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.type,
              code: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.code,
              message: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.message
            }));
          });
        };
        PayPalCheckout.prototype.getClientId = function() {
          return this._clientPromise.then(function(client) {
            return client.getConfiguration().gatewayConfiguration.paypal.clientId;
          });
        };
        PayPalCheckout.prototype.loadPayPalSDK = function(options) {
          var idPromise, src;
          var loadPromise = new ExtendedPromise();
          var dataAttributes = options && options.dataAttributes || {};
          var userIdToken = dataAttributes["user-id-token"] || dataAttributes["data-user-id-token"];
          if (!userIdToken) {
            userIdToken = this._authorizationInformation.fingerprint && this._authorizationInformation.fingerprint.split("?")[0];
          }
          this._paypalScript = document.createElement("script");
          options = assign2({}, {
            components: "buttons"
          }, options);
          delete options.dataAttributes;
          if (options.vault) {
            options.intent = options.intent || "tokenize";
          } else {
            options.intent = options.intent || "authorize";
            options.currency = options.currency || "USD";
          }
          src = "https://www.paypal.com/sdk/js?";
          this._paypalScript.onload = function() {
            loadPromise.resolve();
          };
          Object.keys(dataAttributes).forEach(function(attribute) {
            this._paypalScript.setAttribute("data-" + attribute.replace(/^data\-/, ""), dataAttributes[attribute]);
          }.bind(this));
          if (options["client-id"]) {
            idPromise = Promise.resolve(options["client-id"]);
          } else {
            idPromise = this.getClientId();
          }
          idPromise.then(function(id) {
            options["client-id"] = id;
            if (this._autoSetDataUserIdToken && userIdToken) {
              this._paypalScript.setAttribute("data-user-id-token", userIdToken);
              this._attachPreloadPixel({
                id,
                userIdToken,
                amount: dataAttributes.amount,
                currency: options.currency,
                merchantId: options["merchant-id"]
              });
            }
            this._paypalScript.src = querystring.queryify(src, options);
            document.head.insertBefore(this._paypalScript, document.head.firstElementChild);
          }.bind(this));
          return loadPromise.then(function() {
            return this;
          }.bind(this));
        };
        PayPalCheckout.prototype._attachPreloadPixel = function(options) {
          var request3;
          var id = options.id;
          var userIdToken = options.userIdToken;
          var env = this._authorizationInformation.environment;
          var subdomain = env === "production" ? "" : "sandbox.";
          var url = PAYPAL_SDK_PRELOAD_URL.replace("{ENV}", subdomain);
          var preloadOptions = {
            "client-id": id,
            "user-id-token": userIdToken
          };
          if (options.amount) {
            preloadOptions.amount = options.amount;
          }
          if (options.currency) {
            preloadOptions.currency = options.currency;
          }
          if (options.merchantId) {
            preloadOptions["merchant-id"] = options.merchantId;
          }
          request3 = new XMLHttpRequest();
          request3.open("GET", querystring.queryify(url, preloadOptions));
          request3.send();
        };
        PayPalCheckout.prototype._formatPaymentResourceData = function(options, config) {
          var key;
          var gatewayConfiguration = this._configuration.gatewayConfiguration;
          var intent = options.intent;
          var paymentResource = {
            returnUrl: config.returnUrl || "https://www.paypal.com/checkoutnow/error",
            cancelUrl: config.cancelUrl || "https://www.paypal.com/checkoutnow/error",
            offerPaypalCredit: options.offerCredit === true,
            merchantAccountId: this._merchantAccountId,
            experienceProfile: {
              brandName: options.displayName || gatewayConfiguration.paypal.displayName,
              localeCode: options.locale,
              noShipping: (!options.enableShippingAddress).toString(),
              addressOverride: options.shippingAddressEditable === false,
              landingPageType: options.landingPageType
            },
            shippingOptions: options.shippingOptions
          };
          if (options.flow === "checkout") {
            paymentResource.amount = options.amount;
            paymentResource.currencyIsoCode = options.currency;
            paymentResource.requestBillingAgreement = options.requestBillingAgreement;
            if (intent) {
              if (intent === "capture") {
                intent = "sale";
              }
              paymentResource.intent = intent;
            }
            if (options.hasOwnProperty("lineItems")) {
              paymentResource.lineItems = options.lineItems;
            }
            if (options.hasOwnProperty("vaultInitiatedCheckoutPaymentMethodToken")) {
              paymentResource.vaultInitiatedCheckoutPaymentMethodToken = options.vaultInitiatedCheckoutPaymentMethodToken;
            }
            if (options.hasOwnProperty("shippingOptions")) {
              paymentResource.shippingOptions = options.shippingOptions;
            }
            for (key in options.shippingAddressOverride) {
              if (options.shippingAddressOverride.hasOwnProperty(key)) {
                paymentResource[key] = options.shippingAddressOverride[key];
              }
            }
            if (options.hasOwnProperty("billingAgreementDetails")) {
              paymentResource.billingAgreementDetails = options.billingAgreementDetails;
            }
          } else {
            paymentResource.shippingAddress = options.shippingAddressOverride;
            if (options.billingAgreementDescription) {
              paymentResource.description = options.billingAgreementDescription;
            }
          }
          this._riskCorrelationId = options.riskCorrelationId;
          if (options.riskCorrelationId) {
            paymentResource.correlationId = this._riskCorrelationId;
          }
          return paymentResource;
        };
        PayPalCheckout.prototype._verifyConsistentCurrency = function(options) {
          if (options.currency && options.hasOwnProperty("shippingOptions") && Array.isArray(options.shippingOptions)) {
            return options.shippingOptions.every(function(item) {
              return item.amount && item.amount.currency && options.currency.toLowerCase() === item.amount.currency.toLowerCase();
            });
          }
          return true;
        };
        PayPalCheckout.prototype._hasMissingOption = function(options, required) {
          var i, option;
          required = required || [];
          if (!options.hasOwnProperty("amount") && !options.hasOwnProperty("lineItems")) {
            return true;
          }
          for (i = 0; i < required.length; i++) {
            option = required[i];
            if (!options.hasOwnProperty(option)) {
              return true;
            }
          }
          return false;
        };
        PayPalCheckout.prototype._formatUpdatePaymentData = function(options) {
          var self2 = this;
          var paymentResource = {
            merchantAccountId: this._merchantAccountId,
            paymentId: options.paymentId || options.orderId,
            currencyIsoCode: options.currency
          };
          if (options.hasOwnProperty("amount")) {
            paymentResource.amount = options.amount;
          }
          if (options.hasOwnProperty("lineItems")) {
            paymentResource.lineItems = options.lineItems;
          }
          if (options.hasOwnProperty("shippingOptions")) {
            paymentResource.shippingOptions = options.shippingOptions;
          }
          if (options.hasOwnProperty("shippingAddress")) {
            analytics.sendEvent(self2._clientPromise, "paypal-checkout.updatePayment.shippingAddress.provided.by-the-merchant");
            paymentResource.line1 = options.shippingAddress.line1;
            if (options.shippingAddress.hasOwnProperty("line2")) {
              paymentResource.line2 = options.shippingAddress.line2;
            }
            paymentResource.city = options.shippingAddress.city;
            paymentResource.state = options.shippingAddress.state;
            paymentResource.postalCode = options.shippingAddress.postalCode;
            paymentResource.countryCode = options.shippingAddress.countryCode;
            if (options.shippingAddress.hasOwnProperty("phone")) {
              paymentResource.phone = options.shippingAddress.phone;
            }
            if (options.shippingAddress.hasOwnProperty("recipientName")) {
              paymentResource.recipientName = options.shippingAddress.recipientName;
            }
          }
          return paymentResource;
        };
        PayPalCheckout.prototype._formatTokenizeData = function(options, params) {
          var clientConfiguration = this._configuration;
          var gatewayConfiguration = clientConfiguration.gatewayConfiguration;
          var isTokenizationKey = clientConfiguration.authorizationType === "TOKENIZATION_KEY";
          var isVaultFlow = options.flow === "vault";
          var correlationId = this._riskCorrelationId || params.billingToken || params.ecToken;
          var data2 = {
            paypalAccount: {
              correlationId,
              options: {
                validate: isVaultFlow && !isTokenizationKey && options.vault
              }
            }
          };
          if (isVaultFlow) {
            data2.paypalAccount.billingAgreementToken = params.billingToken;
          } else {
            data2.paypalAccount.paymentToken = params.paymentId || params.orderId;
            data2.paypalAccount.payerId = params.payerId;
            data2.paypalAccount.unilateral = gatewayConfiguration.paypal.unvettedMerchant;
            if (options.intent) {
              data2.paypalAccount.intent = options.intent;
            }
          }
          if (this._merchantAccountId) {
            data2.merchantAccountId = this._merchantAccountId;
          }
          return data2;
        };
        PayPalCheckout.prototype._formatTokenizePayload = function(response) {
          var payload;
          var account = {};
          if (response.paypalAccounts) {
            account = response.paypalAccounts[0];
          }
          payload = {
            nonce: account.nonce,
            details: {},
            type: account.type
          };
          if (account.details && account.details.payerInfo) {
            payload.details = account.details.payerInfo;
          }
          if (account.details && account.details.creditFinancingOffered) {
            payload.creditFinancingOffered = account.details.creditFinancingOffered;
          }
          if (account.details && account.details.shippingOptionId) {
            payload.shippingOptionId = account.details.shippingOptionId;
          }
          if (account.details && account.details.cobrandedCardLabel) {
            payload.cobrandedCardLabel = account.details.cobrandedCardLabel;
          }
          return payload;
        };
        PayPalCheckout.prototype.teardown = function() {
          var self2 = this;
          convertMethodsToError(this, methods(PayPalCheckout.prototype));
          if (this._paypalScript && this._paypalScript.parentNode) {
            this._paypalScript.parentNode.removeChild(this._paypalScript);
          }
          return this._frameServicePromise.catch(function() {
          }).then(function() {
            if (!self2._frameService) {
              return Promise.resolve();
            }
            return self2._frameService.teardown();
          });
        };
        module2.exports = wrapPromise.wrapPrototype(PayPalCheckout);
      }, { "../lib/analytics": 86, "../lib/assign": 88, "../lib/braintree-error": 91, "../lib/constants": 92, "../lib/convert-methods-to-error": 93, "../lib/convert-to-braintree-error": 94, "../lib/create-assets-url": 95, "../lib/create-authorization-data": 96, "../lib/create-deferred-client": 97, "../lib/frame-service/external": 105, "../lib/methods": 121, "../lib/querystring": 123, "../lib/use-min": 126, "../paypal/shared/constants": 131, "./errors": 128, "@braintree/extended-promise": 38, "@braintree/wrap-promise": 47 }], 131: [function(require2, module2, exports2) {
        module2.exports = {
          LANDING_FRAME_NAME: "braintreepaypallanding",
          FLOW_ENDPOINTS: {
            checkout: "create_payment_resource",
            vault: "setup_billing_agreement"
          },
          REQUIRED_OPTIONS: ["paymentId", "currency"]
        };
      }, {}], 132: [function(require2, module2, exports2) {
        var assign2 = require2("../../../lib/assign").assign;
        var analytics = require2("../../../lib/analytics");
        var BraintreeError = require2("../../../lib/braintree-error");
        var isVerifiedDomain = require2("../../../lib/is-verified-domain");
        var ExtendedPromise = require2("@braintree/extended-promise");
        var EventEmitter = require2("@braintree/event-emitter");
        var errors = require2("../../shared/errors");
        var iFramer = require2("@braintree/iframer");
        var Bus = require2("framebus");
        var constants = require2("../../shared/constants");
        var uuid = require2("@braintree/uuid");
        var events = require2("../../shared/events");
        var useMin = require2("../../../lib/use-min");
        var BUS_CONFIGURATION_REQUEST_EVENT = require2("../../../lib/constants").BUS_CONFIGURATION_REQUEST_EVENT;
        var VERSION2 = "3.99.0";
        var IFRAME_HEIGHT = 400;
        var IFRAME_WIDTH = 400;
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function BaseFramework(options) {
          EventEmitter.call(this);
          this._client = options.client;
          this._createPromise = options.createPromise;
          this._createOptions = options;
          if (this._client) {
            this._isDebug = this._client.getConfiguration().isDebug;
            this._assetsUrl = this._client.getConfiguration().gatewayConfiguration.assetsUrl;
          } else {
            this._isDebug = Boolean(options.isDebug);
            this._assetsUrl = options.assetsUrl;
          }
          this._assetsUrl = this._assetsUrl + "/web/" + VERSION2;
        }
        EventEmitter.createChild(BaseFramework);
        BaseFramework.prototype._waitForClient = function() {
          if (this._client) {
            return Promise.resolve();
          }
          return this._createPromise.then(function(client) {
            this._client = client;
          }.bind(this));
        };
        BaseFramework.prototype.setUpEventListeners = function() {
          throw new BraintreeError(errors.THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED);
        };
        BaseFramework.prototype.verifyCard = function(options, privateOptions) {
          var formattedOptions, error;
          var self2 = this;
          privateOptions = privateOptions || {};
          error = this._checkForVerifyCardError(options, privateOptions);
          if (error) {
            return Promise.reject(error);
          }
          this._verifyCardInProgress = true;
          formattedOptions = this._formatVerifyCardOptions(options);
          return this._formatLookupData(formattedOptions).then(function(data2) {
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.started");
            return self2._performLookup(formattedOptions.nonce, data2);
          }).then(function(response) {
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.3ds-version." + response.lookup.threeDSecureVersion);
            return self2._onLookupComplete(response, formattedOptions);
          }).then(function(response) {
            return self2.initializeChallengeWithLookupResponse(response, formattedOptions);
          }).then(function(payload) {
            self2._resetVerificationState();
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.completed");
            return payload;
          }).catch(function(err) {
            self2._resetVerificationState();
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.failed");
            return Promise.reject(err);
          });
        };
        BaseFramework.prototype._checkForFrameworkSpecificVerifyCardErrors = function() {
          throw new BraintreeError(errors.THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED);
        };
        BaseFramework.prototype._presentChallenge = function() {
          throw new BraintreeError(errors.THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED);
        };
        BaseFramework.prototype.prepareLookup = function() {
          throw new BraintreeError(errors.THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED);
        };
        BaseFramework.prototype._resetVerificationState = function() {
          this._verifyCardInProgress = false;
          this._verifyCardPromisePlus = null;
          if (typeof this._reloadThreeDSecure === "function") {
            this._reloadThreeDSecure();
          }
        };
        BaseFramework.prototype._performLookup = function(nonce, data2) {
          var self2 = this;
          var url = "payment_methods/" + nonce + "/three_d_secure/lookup";
          return this._waitForClient().then(function() {
            return self2._client.request({
              endpoint: url,
              method: "post",
              data: data2
            }).catch(function(err) {
              var status = err && err.details && err.details.httpStatus;
              var analyticsMessage = "three-d-secure.verification-flow.lookup-failed";
              var lookupError;
              if (status === 404) {
                lookupError = errors.THREEDS_LOOKUP_TOKENIZED_CARD_NOT_FOUND_ERROR;
                analyticsMessage += ".404";
              } else if (status === 422) {
                lookupError = errors.THREEDS_LOOKUP_VALIDATION_ERROR;
                analyticsMessage += ".422";
              } else {
                lookupError = errors.THREEDS_LOOKUP_ERROR;
              }
              analytics.sendEvent(self2._createPromise, analyticsMessage);
              return Promise.reject(new BraintreeError({
                type: lookupError.type,
                code: lookupError.code,
                message: lookupError.message,
                details: {
                  originalError: err
                }
              }));
            });
          });
        };
        BaseFramework.prototype._checkForVerifyCardError = function(options, privateOptions) {
          var errorOption;
          if (this._verifyCardInProgress === true) {
            return new BraintreeError(errors.THREEDS_AUTHENTICATION_IN_PROGRESS);
          } else if (!options.nonce) {
            errorOption = "a nonce";
          } else if (!options.amount) {
            errorOption = "an amount";
          }
          if (!errorOption) {
            errorOption = this._checkForFrameworkSpecificVerifyCardErrors(options, privateOptions);
          }
          if (errorOption) {
            return new BraintreeError({
              type: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.type,
              code: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.code,
              message: "verifyCard options must include " + errorOption + "."
            });
          }
          return null;
        };
        BaseFramework.prototype.initializeChallengeWithLookupResponse = function(lookupResponse, options) {
          var self2 = this;
          options = options || {};
          this._lookupPaymentMethod = lookupResponse.paymentMethod;
          self2._verifyCardPromisePlus = self2._verifyCardPromisePlus || new ExtendedPromise();
          self2._handleLookupResponse(lookupResponse, options);
          return self2._verifyCardPromisePlus.then(function(payload) {
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.liability-shifted." + String(payload.liabilityShifted));
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.liability-shift-possible." + String(payload.liabilityShiftPossible));
            return payload;
          });
        };
        BaseFramework.prototype._handleLookupResponse = function(lookupResponse, options) {
          var challengeShouldBePresented = Boolean(lookupResponse.lookup && lookupResponse.lookup.acsUrl);
          var details;
          analytics.sendEvent(this._createPromise, "three-d-secure.verification-flow.challenge-presented." + String(challengeShouldBePresented));
          if (challengeShouldBePresented) {
            this._presentChallenge(lookupResponse, options);
          } else {
            details = this._formatAuthResponse(lookupResponse.paymentMethod, lookupResponse.threeDSecureInfo);
            details.verificationDetails = lookupResponse.threeDSecureInfo;
            this._verifyCardPromisePlus.resolve(details);
          }
        };
        BaseFramework.prototype._onLookupComplete = function(response) {
          this._lookupPaymentMethod = response.paymentMethod;
          this._verifyCardPromisePlus = new ExtendedPromise();
          return Promise.resolve(response);
        };
        BaseFramework.prototype._formatAuthResponse = function(paymentMethod, threeDSecureInfo) {
          return {
            nonce: paymentMethod.nonce,
            type: paymentMethod.type,
            binData: paymentMethod.binData,
            details: paymentMethod.details,
            description: paymentMethod.description && paymentMethod.description.replace(/\+/g, " "),
            liabilityShifted: threeDSecureInfo && threeDSecureInfo.liabilityShifted,
            liabilityShiftPossible: threeDSecureInfo && threeDSecureInfo.liabilityShiftPossible,
            threeDSecureInfo: paymentMethod.threeDSecureInfo
          };
        };
        BaseFramework.prototype._formatVerifyCardOptions = function(options) {
          return assign2({}, options);
        };
        BaseFramework.prototype._formatLookupData = function(options) {
          var data2 = {
            amount: options.amount
          };
          if (options.collectDeviceData === true) {
            data2.browserColorDepth = window.screen.colorDepth;
            data2.browserJavaEnabled = window.navigator.javaEnabled();
            data2.browserJavascriptEnabled = true;
            data2.browserLanguage = window.navigator.language;
            data2.browserScreenHeight = window.screen.height;
            data2.browserScreenWidth = window.screen.width;
            data2.browserTimeZone = new Date().getTimezoneOffset();
            data2.deviceChannel = "Browser";
          }
          return Promise.resolve(data2);
        };
        BaseFramework.prototype._handleV1AuthResponse = function(data2) {
          var authResponse = JSON.parse(data2.auth_response);
          if (authResponse.success) {
            this._verifyCardPromisePlus.resolve(this._formatAuthResponse(authResponse.paymentMethod, authResponse.threeDSecureInfo));
          } else if (authResponse.threeDSecureInfo && authResponse.threeDSecureInfo.liabilityShiftPossible) {
            this._verifyCardPromisePlus.resolve(this._formatAuthResponse(this._lookupPaymentMethod, authResponse.threeDSecureInfo));
          } else {
            this._verifyCardPromisePlus.reject(new BraintreeError({
              type: BraintreeError.types.UNKNOWN,
              code: "UNKNOWN_AUTH_RESPONSE",
              message: authResponse.error.message
            }));
          }
        };
        BaseFramework.prototype.cancelVerifyCard = function() {
          var response, threeDSecureInfo;
          this._verifyCardInProgress = false;
          if (!this._lookupPaymentMethod) {
            return Promise.reject(new BraintreeError(errors.THREEDS_NO_VERIFICATION_PAYLOAD));
          }
          threeDSecureInfo = this._lookupPaymentMethod.threeDSecureInfo;
          response = assign2({}, this._lookupPaymentMethod, {
            liabilityShiftPossible: threeDSecureInfo && threeDSecureInfo.liabilityShiftPossible,
            liabilityShifted: threeDSecureInfo && threeDSecureInfo.liabilityShifted,
            verificationDetails: threeDSecureInfo && threeDSecureInfo.verificationDetails
          });
          return Promise.resolve(response);
        };
        BaseFramework.prototype._setupV1Bus = function(options) {
          var clientConfiguration = this._client.getConfiguration();
          var parentURL = window.location.href.split("#")[0];
          var lookupResponse = options.lookupResponse;
          var channel = uuid();
          var bus = new Bus({
            channel,
            verifyDomain: isVerifiedDomain
          });
          var authenticationCompleteBaseUrl = this._assetsUrl + "/html/three-d-secure-authentication-complete-frame.html?channel=" + encodeURIComponent(channel) + "&";
          bus.on(BUS_CONFIGURATION_REQUEST_EVENT, function(reply) {
            reply({
              clientConfiguration,
              nonce: options.nonce,
              acsUrl: lookupResponse.acsUrl,
              pareq: lookupResponse.pareq,
              termUrl: lookupResponse.termUrl + "&three_d_secure_version=" + VERSION2 + "&authentication_complete_base_url=" + encodeURIComponent(authenticationCompleteBaseUrl),
              md: lookupResponse.md,
              parentUrl: parentURL
            });
          });
          bus.on(events.AUTHENTICATION_COMPLETE, options.handleAuthResponse);
          return bus;
        };
        BaseFramework.prototype._setupV1Iframe = function(options) {
          var url = this._assetsUrl + "/html/three-d-secure-bank-frame" + useMin(this._isDebug) + ".html?showLoader=" + options.showLoader;
          var bankIframe = iFramer({
            src: url,
            height: IFRAME_HEIGHT,
            width: IFRAME_WIDTH,
            name: constants.LANDING_FRAME_NAME + "_" + this._v1Bus.channel,
            title: "3D Secure Authorization Frame"
          });
          return bankIframe;
        };
        BaseFramework.prototype._setupV1Elements = function(options) {
          this._v1Bus = this._setupV1Bus(options);
          this._v1Iframe = this._setupV1Iframe(options);
        };
        BaseFramework.prototype._teardownV1Elements = function() {
          if (this._v1Bus) {
            this._v1Bus.teardown();
            this._v1Bus = null;
          }
          if (this._v1Iframe && this._v1Iframe.parentNode) {
            this._v1Iframe.parentNode.removeChild(this._v1Iframe);
            this._v1Iframe = null;
          }
          if (this._onV1Keyup) {
            document.removeEventListener("keyup", this._onV1Keyup);
            this._onV1Keyup = null;
          }
        };
        BaseFramework.prototype.teardown = function() {
          analytics.sendEvent(this._createPromise, "three-d-secure.teardown-completed");
          this._teardownV1Elements();
          return Promise.resolve();
        };
        module2.exports = BaseFramework;
      }, { "../../../lib/analytics": 86, "../../../lib/assign": 88, "../../../lib/braintree-error": 91, "../../../lib/constants": 92, "../../../lib/is-verified-domain": 119, "../../../lib/use-min": 126, "../../shared/constants": 141, "../../shared/errors": 142, "../../shared/events": 143, "@braintree/event-emitter": 37, "@braintree/extended-promise": 38, "@braintree/iframer": 39, "@braintree/uuid": 43, "framebus": 167 }], 133: [function(require2, module2, exports2) {
        var SongbirdFramework = require2("./songbird");
        function Bootstrap3ModalFramework(options) {
          SongbirdFramework.call(this, options);
        }
        Bootstrap3ModalFramework.prototype = Object.create(SongbirdFramework.prototype, {
          constructor: SongbirdFramework
        });
        Bootstrap3ModalFramework.prototype._createV1IframeModalElement = function(iframe) {
          var modal = document.createElement("div");
          modal.innerHTML = '<div class="modal fade in" tabindex="-1" role="dialog" aria-labelledby="CCAFrameModal-label" aria-hidden="true" style="display: block;"><div class="modal-dialog" style="width:440px;z-index:999999;"><div class="modal-content"><div class="modal-body" data-braintree-v1-fallback-iframe-container><button type="button" data-braintree-v1-fallback-close-button class="close" data-dismiss="modal" aria-hidden="true">\xD7</button></div></div></div><div data-braintree-v1-fallback-backdrop style="position: fixed;cursor: pointer;z-index: 999998;top: 0;left: 0;width: 100%;height: 100%;"></div></div>';
          modal.querySelector("[data-braintree-v1-fallback-iframe-container]").appendChild(iframe);
          return modal;
        };
        Bootstrap3ModalFramework.prototype._createCardinalConfigurationOptions = function(setupOptions) {
          var options = SongbirdFramework.prototype._createCardinalConfigurationOptions.call(this, setupOptions);
          options.payment.framework = "bootstrap3";
          return options;
        };
        module2.exports = Bootstrap3ModalFramework;
      }, { "./songbird": 138 }], 134: [function(require2, module2, exports2) {
        var SongbirdFramework = require2("./songbird");
        function CardinalModalFramework(options) {
          SongbirdFramework.call(this, options);
        }
        CardinalModalFramework.prototype = Object.create(SongbirdFramework.prototype, {
          constructor: SongbirdFramework
        });
        CardinalModalFramework.prototype._createV1IframeModalElement = function(iframe) {
          var modal = document.createElement("div");
          var addCloseButton = Boolean(this._createOptions && this._createOptions.cardinalSDKConfig && this._createOptions.cardinalSDKConfig.payment && this._createOptions.cardinalSDKConfig.payment.displayExitButton);
          modal.innerHTML = `<div style="position: fixed;z-index: 999999;top: 50%;left: 50%;padding: 24px 20px;transform: translate(-50%,-50%);border-radius: 2px;background: #fff;max-width: 100%;overflow: auto;"><div><button data-braintree-v1-fallback-close-button style="font-family: Helvetica,Arial,sans-serif;font-size: 25px;line-height: 12px;position: absolute;top: 2px;right: 0px;cursor: pointer;color: #999;border: 0;outline: none;background: none;" onMouseOver="this.style.color='#000'" onMouseOut="this.style.color='#999'">\xD7</button></div><div data-braintree-v1-fallback-iframe-container style="height: 400px;"></div></div><div data-braintree-v1-fallback-backdrop style="position: fixed;z-index: 999998;cursor: pointer;top: 0;left: 0;width: 100%;height: 100%;transition: opacity 1ms ease;background: rgba(0,0,0,.6);"></div>`;
          if (!addCloseButton) {
            modal.querySelector("[data-braintree-v1-fallback-close-button]").style.display = "none";
          }
          modal.querySelector("[data-braintree-v1-fallback-iframe-container]").appendChild(iframe);
          return modal;
        };
        module2.exports = CardinalModalFramework;
      }, { "./songbird": 138 }], 135: [function(require2, module2, exports2) {
        var LegacyFramework = require2("./legacy");
        var CardinalModalFramework = require2("./cardinal-modal");
        var Bootstrap3ModalFramework = require2("./bootstrap3-modal");
        var InlineIframeFramework = require2("./inline-iframe");
        module2.exports = {
          legacy: LegacyFramework,
          "cardinal-modal": CardinalModalFramework,
          "bootstrap3-modal": Bootstrap3ModalFramework,
          "inline-iframe": InlineIframeFramework
        };
      }, { "./bootstrap3-modal": 133, "./cardinal-modal": 134, "./inline-iframe": 136, "./legacy": 137 }], 136: [function(require2, module2, exports2) {
        var SongbirdFramework = require2("./songbird");
        var BraintreeError = require2("../../../lib/braintree-error");
        var errors = require2("../../shared/errors");
        var enumerate = require2("../../../lib/enumerate");
        function InlineIframeFramework(options) {
          SongbirdFramework.call(this, options);
        }
        InlineIframeFramework.prototype = Object.create(SongbirdFramework.prototype, {
          constructor: SongbirdFramework
        });
        InlineIframeFramework.events = enumerate(["AUTHENTICATION_IFRAME_AVAILABLE"], "inline-iframe-framework:");
        InlineIframeFramework.prototype.setUpEventListeners = function(reply) {
          SongbirdFramework.prototype.setUpEventListeners.call(this, reply);
          this.on(InlineIframeFramework.events.AUTHENTICATION_IFRAME_AVAILABLE, function(payload, next) {
            reply("authentication-iframe-available", payload, next);
          });
        };
        InlineIframeFramework.prototype._createCardinalConfigurationOptions = function(setupOptions) {
          var options = SongbirdFramework.prototype._createCardinalConfigurationOptions.call(this, setupOptions);
          options.payment.framework = "inline";
          return options;
        };
        InlineIframeFramework.prototype._addV1IframeToPage = function() {
          this._emit(InlineIframeFramework.events.AUTHENTICATION_IFRAME_AVAILABLE, {
            element: this._v1Modal
          }, function() {
          });
        };
        InlineIframeFramework.prototype._setupFrameworkSpecificListeners = function() {
          this.setCardinalListener("ui.inline.setup", this._onInlineSetup.bind(this));
        };
        InlineIframeFramework.prototype._onInlineSetup = function(htmlTemplate, details, resolve2, reject) {
          var container, hasError;
          if (!htmlTemplate || !details) {
            hasError = true;
          } else if (details.paymentType !== "CCA") {
            hasError = true;
          } else if (!(details.data.mode === "suppress" || details.data.mode === "static")) {
            hasError = true;
          }
          if (hasError) {
            reject(new BraintreeError(errors.THREEDS_INLINE_IFRAME_DETAILS_INCORRECT));
            return;
          }
          container = document.createElement("div");
          container.innerHTML = htmlTemplate;
          if (details.data.mode === "suppress") {
            container.style.display = "none";
            document.body.appendChild(container);
            resolve2();
          } else if (details.data.mode === "static") {
            this._emit(InlineIframeFramework.events.AUTHENTICATION_IFRAME_AVAILABLE, {
              element: container
            }, function() {
              resolve2();
            });
          }
        };
        module2.exports = InlineIframeFramework;
      }, { "../../../lib/braintree-error": 91, "../../../lib/enumerate": 100, "../../shared/errors": 142, "./songbird": 138 }], 137: [function(require2, module2, exports2) {
        var BaseFramework = require2("./base");
        var deferred = require2("../../../lib/deferred");
        function LegacyFramework(options) {
          BaseFramework.call(this, options);
        }
        LegacyFramework.prototype = Object.create(BaseFramework.prototype, {
          constructor: LegacyFramework
        });
        LegacyFramework.prototype.setUpEventListeners = function() {
        };
        LegacyFramework.prototype.transformV1CustomerBillingAddress = function(customer) {
          customer.billingAddress.line1 = customer.billingAddress.streetAddress;
          customer.billingAddress.line2 = customer.billingAddress.extendedAddress;
          customer.billingAddress.city = customer.billingAddress.locality;
          customer.billingAddress.state = customer.billingAddress.region;
          customer.billingAddress.countryCode = customer.billingAddress.countryCodeAlpha2;
          delete customer.billingAddress.streetAddress;
          delete customer.billingAddress.extendedAddress;
          delete customer.billingAddress.locality;
          delete customer.billingAddress.region;
          delete customer.billingAddress.countryCodeAlpha2;
          return customer;
        };
        LegacyFramework.prototype._createIframe = function(options) {
          var self2 = this;
          this._setupV1Elements({
            nonce: options.nonce,
            lookupResponse: options.lookupResponse,
            showLoader: options.showLoader,
            handleAuthResponse: function(data2) {
              self2._handleAuthResponse(data2, options);
            }
          });
          return this._v1Iframe;
        };
        LegacyFramework.prototype._handleAuthResponse = function(data2, options) {
          this._v1Bus.teardown();
          options.removeFrame();
          deferred(function() {
            this._handleV1AuthResponse(data2);
          }.bind(this))();
        };
        LegacyFramework.prototype._checkForFrameworkSpecificVerifyCardErrors = function(options) {
          var errorOption;
          if (typeof options.addFrame !== "function") {
            errorOption = "an addFrame function";
          } else if (typeof options.removeFrame !== "function") {
            errorOption = "a removeFrame function";
          }
          return errorOption;
        };
        LegacyFramework.prototype._formatVerifyCardOptions = function(options) {
          var modifiedOptions = BaseFramework.prototype._formatVerifyCardOptions.call(this, options);
          modifiedOptions.addFrame = deferred(options.addFrame);
          modifiedOptions.removeFrame = deferred(options.removeFrame);
          modifiedOptions.showLoader = options.showLoader !== false;
          return modifiedOptions;
        };
        LegacyFramework.prototype._formatLookupData = function(options) {
          var self2 = this;
          return BaseFramework.prototype._formatLookupData.call(this, options).then(function(data2) {
            if (options.customer && options.customer.billingAddress) {
              data2.customer = self2.transformV1CustomerBillingAddress(options.customer);
            }
            return data2;
          });
        };
        LegacyFramework.prototype._presentChallenge = function(lookupResponse, options) {
          options.addFrame(null, this._createIframe({
            showLoader: options.showLoader,
            lookupResponse: lookupResponse.lookup,
            nonce: lookupResponse.paymentMethod.nonce,
            removeFrame: options.removeFrame
          }));
        };
        module2.exports = LegacyFramework;
      }, { "../../../lib/deferred": 98, "./base": 132 }], 138: [function(require2, module2, exports2) {
        var BaseFramework = require2("./base");
        var assign2 = require2("../../../lib/assign").assign;
        var deferred = require2("../../../lib/deferred");
        var BraintreeError = require2("../../../lib/braintree-error");
        var convertToBraintreeError = require2("../../../lib/convert-to-braintree-error");
        var analytics = require2("../../../lib/analytics");
        var assets = require2("../../../lib/assets");
        var errors = require2("../../shared/errors");
        var enumerate = require2("../../../lib/enumerate");
        var constants = require2("../../shared/constants");
        var ExtendedPromise = require2("@braintree/extended-promise");
        var INTEGRATION_TIMEOUT_MS = require2("../../../lib/constants").INTEGRATION_TIMEOUT_MS;
        var PLATFORM = require2("../../../lib/constants").PLATFORM;
        var VERSION2 = "3.99.0";
        var CUSTOMER_CANCELED_SONGBIRD_MODAL = "01";
        var SONGBIRD_UI_EVENTS = [
          "ui.close",
          "ui.render",
          "ui.renderHidden",
          "ui.loading.close",
          "ui.loading.render"
        ];
        var SCA_EXEMPTION_TYPES = ["low_value", "transaction_risk_analysis"];
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function SongbirdFramework(options) {
          BaseFramework.call(this, options);
          this._useV1Fallback = false;
          this._clientMetadata = {
            requestedThreeDSecureVersion: "2",
            sdkVersion: PLATFORM + "/" + VERSION2
          };
          this.originalSetupOptions = options;
          this._getDfReferenceIdPromisePlus = new ExtendedPromise();
          this.setupSongbird(options);
          this._cardinalEvents = [];
        }
        SongbirdFramework.prototype = Object.create(BaseFramework.prototype, {
          constructor: SongbirdFramework
        });
        SongbirdFramework.events = enumerate([
          "LOOKUP_COMPLETE",
          "CUSTOMER_CANCELED",
          "UI.CLOSE",
          "UI.RENDER",
          "UI.RENDERHIDDEN",
          "UI.LOADING.CLOSE",
          "UI.LOADING.RENDER"
        ], "songbird-framework:");
        SongbirdFramework.prototype.setUpEventListeners = function(reply) {
          this.on(SongbirdFramework.events.LOOKUP_COMPLETE, function(data2, next) {
            reply("lookup-complete", data2, next);
          });
          this.on(SongbirdFramework.events.CUSTOMER_CANCELED, function() {
            reply("customer-canceled");
          });
          this.on(SongbirdFramework.events["UI.CLOSE"], function() {
            reply("authentication-modal-close");
          });
          this.on(SongbirdFramework.events["UI.RENDER"], function() {
            reply("authentication-modal-render");
          });
          this.on(SongbirdFramework.events["UI.RENDERHIDDEN"], function() {
            reply("authentication-modal-render-hidden");
          });
          this.on(SongbirdFramework.events["UI.LOADING.CLOSE"], function() {
            reply("authentication-modal-loader-close");
          });
          this.on(SongbirdFramework.events["UI.LOADING.RENDER"], function() {
            reply("authentication-modal-loader-render");
          });
        };
        SongbirdFramework.prototype.prepareLookup = function(options) {
          var data2 = assign2({}, options);
          var self2 = this;
          return this.getDfReferenceId().then(function(id) {
            data2.dfReferenceId = id;
          }).then(function() {
            return self2._triggerCardinalBinProcess(options.bin);
          }).catch(function() {
          }).then(function() {
            return self2._waitForClient();
          }).then(function() {
            data2.clientMetadata = self2._clientMetadata;
            data2.authorizationFingerprint = self2._client.getConfiguration().authorizationFingerprint;
            data2.braintreeLibraryVersion = "braintree/web/" + VERSION2;
            return data2;
          });
        };
        SongbirdFramework.prototype.initializeChallengeWithLookupResponse = function(lookupResponse, options) {
          return this.setupSongbird().then(function() {
            return BaseFramework.prototype.initializeChallengeWithLookupResponse.call(this, lookupResponse, options);
          }.bind(this));
        };
        SongbirdFramework.prototype.initiateV1Fallback = function(errorType) {
          this._useV1Fallback = true;
          this._removeSongbirdListeners();
          analytics.sendEvent(this._createPromise, "three-d-secure.v1-fallback." + errorType);
          if (this._songbirdPromise) {
            this._songbirdPromise.resolve();
          }
        };
        SongbirdFramework.prototype._triggerCardinalBinProcess = function(bin) {
          var self2 = this;
          var issuerStartTime = Date.now();
          return window.Cardinal.trigger("bin.process", bin).then(function(binResults) {
            self2._clientMetadata.issuerDeviceDataCollectionTimeElapsed = Date.now() - issuerStartTime;
            self2._clientMetadata.issuerDeviceDataCollectionResult = binResults && binResults.Status;
          });
        };
        SongbirdFramework.prototype.transformBillingAddress = function(additionalInformation, billingAddress) {
          if (billingAddress) {
            extractAddressData(billingAddress, additionalInformation, "billing");
            additionalInformation.billingPhoneNumber = billingAddress.phoneNumber;
            additionalInformation.billingGivenName = billingAddress.givenName;
            additionalInformation.billingSurname = billingAddress.surname;
          }
          return additionalInformation;
        };
        SongbirdFramework.prototype.transformShippingAddress = function(additionalInformation) {
          var shippingAddress = additionalInformation.shippingAddress;
          if (shippingAddress) {
            extractAddressData(shippingAddress, additionalInformation, "shipping");
            delete additionalInformation.shippingAddress;
          }
          return additionalInformation;
        };
        SongbirdFramework.prototype._createV1IframeModalElement = function(iframe) {
          var modal = document.createElement("div");
          modal.innerHTML = '<div data-braintree-v1-fallback-iframe-container="true" style="height: 400px;"></div>';
          modal.querySelector('[data-braintree-v1-fallback-iframe-container="true"]').appendChild(iframe);
          return modal;
        };
        SongbirdFramework.prototype._createV1IframeModal = function(iframe) {
          var modal = this._createV1IframeModalElement(iframe);
          var btn = modal.querySelector("[data-braintree-v1-fallback-close-button]");
          var backdrop = modal.querySelector("[data-braintree-v1-fallback-backdrop]");
          var self2 = this;
          function closeHandler() {
            modal.parentNode.removeChild(modal);
            self2.cancelVerifyCard(errors.THREEDS_CARDINAL_SDK_CANCELED);
            document.removeEventListener("keyup", self2._onV1Keyup);
            self2._onV1Keyup = null;
          }
          this._onV1Keyup = function(e) {
            if (e.key !== "Escape") {
              return;
            }
            if (!modal.parentNode) {
              return;
            }
            closeHandler();
          };
          if (btn) {
            btn.addEventListener("click", closeHandler);
          }
          if (backdrop) {
            backdrop.addEventListener("click", closeHandler);
          }
          document.addEventListener("keyup", this._onV1Keyup);
          return modal;
        };
        SongbirdFramework.prototype._addV1IframeToPage = function() {
          document.body.appendChild(this._v1Modal);
        };
        SongbirdFramework.prototype._handleAuthResponseFromV1Fallback = function(data2) {
          this._teardownV1Elements();
          this._v1Modal.parentNode.removeChild(this._v1Modal);
          this._handleV1AuthResponse(data2);
        };
        SongbirdFramework.prototype._presentChallengeWithV1Fallback = function(lookupResponse) {
          var self2 = this;
          this._setupV1Elements({
            lookupResponse,
            showLoader: true,
            handleAuthResponse: function(data2) {
              self2._handleAuthResponseFromV1Fallback(data2);
            }
          });
          this._v1Modal = this._createV1IframeModal(this._v1Iframe);
          this._addV1IframeToPage();
        };
        SongbirdFramework.prototype.setupSongbird = function(setupOptions) {
          var self2 = this;
          var startTime = Date.now();
          if (this._songbirdPromise) {
            return this._songbirdPromise;
          }
          setupOptions = setupOptions || {};
          this._songbirdPromise = new ExtendedPromise();
          this._v2SetupFailureReason = "reason-unknown";
          self2._loadCardinalScript(setupOptions).then(function() {
            if (!window.Cardinal) {
              self2._v2SetupFailureReason = "cardinal-global-unavailable";
              return Promise.reject(new BraintreeError(errors.THREEDS_CARDINAL_SDK_SETUP_FAILED));
            }
            return self2._configureCardinalSdk({
              setupOptions,
              setupStartTime: startTime
            });
          }).catch(function(err) {
            var error = convertToBraintreeError(err, {
              type: errors.THREEDS_CARDINAL_SDK_SETUP_FAILED.type,
              code: errors.THREEDS_CARDINAL_SDK_SETUP_FAILED.code,
              message: errors.THREEDS_CARDINAL_SDK_SETUP_FAILED.message
            });
            self2._getDfReferenceIdPromisePlus.reject(error);
            window.clearTimeout(self2._songbirdSetupTimeoutReference);
            analytics.sendEvent(self2._client, "three-d-secure.cardinal-sdk.init.setup-failed");
            self2.initiateV1Fallback("cardinal-sdk-setup-failed." + self2._v2SetupFailureReason);
          });
          return this._songbirdPromise;
        };
        SongbirdFramework.prototype._configureCardinalSdk = function(config) {
          var self2 = this;
          return this._waitForClient().then(function() {
            var threeDSConfig = self2._client.getConfiguration().gatewayConfiguration.threeDSecure;
            return threeDSConfig;
          }).then(function(threeDSConfig) {
            var jwt = threeDSConfig.cardinalAuthenticationJWT;
            var setupOptions = config.setupOptions;
            var setupStartTime = config.setupStartTime;
            var cardinalConfiguration = self2._createCardinalConfigurationOptions(setupOptions);
            SONGBIRD_UI_EVENTS.forEach(function(eventName) {
              self2.setCardinalListener(eventName, function() {
                self2._emit(SongbirdFramework.events[eventName.toUpperCase()]);
              });
            });
            self2.setCardinalListener("payments.setupComplete", self2._createPaymentsSetupCompleteCallback());
            self2._setupFrameworkSpecificListeners();
            window.Cardinal.configure(cardinalConfiguration);
            window.Cardinal.setup("init", {
              jwt
            });
            self2._clientMetadata.cardinalDeviceDataCollectionTimeElapsed = Date.now() - setupStartTime;
            self2.setCardinalListener("payments.validated", self2._createPaymentsValidatedCallback());
          }).catch(function(err) {
            self2._v2SetupFailureReason = "cardinal-configuration-threw-error";
            return Promise.reject(err);
          });
        };
        SongbirdFramework.prototype.setCardinalListener = function(eventName, cb) {
          this._cardinalEvents.push(eventName);
          window.Cardinal.on(eventName, cb);
        };
        SongbirdFramework.prototype._setupFrameworkSpecificListeners = function() {
        };
        SongbirdFramework.prototype._createCardinalConfigurationOptions = function(setupOptions) {
          var cardinalConfiguration = setupOptions.cardinalSDKConfig || {};
          var paymentSettings = cardinalConfiguration.payment || {};
          if (!cardinalConfiguration.logging && setupOptions.loggingEnabled) {
            cardinalConfiguration.logging = {
              level: "verbose"
            };
          }
          cardinalConfiguration.payment = {};
          if (paymentSettings.hasOwnProperty("displayLoading")) {
            cardinalConfiguration.payment.displayLoading = paymentSettings.displayLoading;
          }
          if (paymentSettings.hasOwnProperty("displayExitButton")) {
            cardinalConfiguration.payment.displayExitButton = paymentSettings.displayExitButton;
          }
          return cardinalConfiguration;
        };
        SongbirdFramework.prototype._loadCardinalScript = function(setupOptions) {
          var self2 = this;
          return this._waitForClient().then(function() {
            var scriptSource = self2._getCardinalScriptSource();
            self2._songbirdSetupTimeoutReference = window.setTimeout(function() {
              analytics.sendEvent(self2._client, "three-d-secure.cardinal-sdk.init.setup-timeout");
              self2.initiateV1Fallback("cardinal-sdk-setup-timeout");
            }, setupOptions.timeout || INTEGRATION_TIMEOUT_MS);
            return assets.loadScript({ src: scriptSource });
          }).catch(function(err) {
            self2._v2SetupFailureReason = "songbird-js-failed-to-load";
            return Promise.reject(convertToBraintreeError(err, errors.THREEDS_CARDINAL_SDK_SCRIPT_LOAD_FAILED));
          });
        };
        SongbirdFramework.prototype._getCardinalScriptSource = function() {
          var gatewayConfig = this._client.getConfiguration().gatewayConfiguration;
          if (gatewayConfig && gatewayConfig.environment === "production") {
            return constants.CARDINAL_SCRIPT_SOURCE.production;
          }
          return constants.CARDINAL_SCRIPT_SOURCE.sandbox;
        };
        SongbirdFramework.prototype._createPaymentsSetupCompleteCallback = function() {
          var self2 = this;
          return function(data2) {
            self2._getDfReferenceIdPromisePlus.resolve(data2.sessionId);
            window.clearTimeout(self2._songbirdSetupTimeoutReference);
            analytics.sendEvent(self2._createPromise, "three-d-secure.cardinal-sdk.init.setup-completed");
            self2._songbirdPromise.resolve();
          };
        };
        SongbirdFramework.prototype.getDfReferenceId = function() {
          return this._getDfReferenceIdPromisePlus;
        };
        SongbirdFramework.prototype._performJWTValidation = function(rawCardinalSDKVerificationData, jwt) {
          var self2 = this;
          var nonce = this._lookupPaymentMethod.nonce;
          var url = "payment_methods/" + nonce + "/three_d_secure/authenticate_from_jwt";
          var cancelCode = rawCardinalSDKVerificationData && rawCardinalSDKVerificationData.Payment && rawCardinalSDKVerificationData.Payment.ExtendedData && rawCardinalSDKVerificationData.Payment.ExtendedData.ChallengeCancel;
          if (cancelCode) {
            analytics.sendEvent(this._createPromise, "three-d-secure.verification-flow.cardinal-sdk.cancel-code." + cancelCode);
            if (cancelCode === CUSTOMER_CANCELED_SONGBIRD_MODAL) {
              this._emit(SongbirdFramework.events.CUSTOMER_CANCELED);
            }
          }
          analytics.sendEvent(this._createPromise, "three-d-secure.verification-flow.upgrade-payment-method.started");
          return this._waitForClient().then(function() {
            return self2._client.request({
              method: "post",
              endpoint: url,
              data: {
                jwt,
                paymentMethodNonce: nonce
              }
            });
          }).then(function(response) {
            var paymentMethod = response.paymentMethod || self2._lookupPaymentMethod;
            var formattedResponse = self2._formatAuthResponse(paymentMethod, response.threeDSecureInfo);
            formattedResponse.rawCardinalSDKVerificationData = rawCardinalSDKVerificationData;
            analytics.sendEvent(self2._client, "three-d-secure.verification-flow.upgrade-payment-method.succeeded");
            return Promise.resolve(formattedResponse);
          }).catch(function(err) {
            var error = new BraintreeError({
              type: errors.THREEDS_JWT_AUTHENTICATION_FAILED.type,
              code: errors.THREEDS_JWT_AUTHENTICATION_FAILED.code,
              message: errors.THREEDS_JWT_AUTHENTICATION_FAILED.message,
              details: {
                originalError: err
              }
            });
            analytics.sendEvent(self2._client, "three-d-secure.verification-flow.upgrade-payment-method.errored");
            return Promise.reject(error);
          });
        };
        SongbirdFramework.prototype._createPaymentsValidatedCallback = function() {
          var self2 = this;
          return function(data2, validatedJwt) {
            var formattedError;
            if (self2._useV1Fallback) {
              analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.cardinal-sdk.payments-validated-callback-called-in-v1-fallback-flow");
              return;
            }
            analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.cardinal-sdk.action-code." + data2.ActionCode.toLowerCase());
            if (!self2._verifyCardPromisePlus) {
              self2.initiateV1Fallback("cardinal-sdk-setup-error.number-" + data2.ErrorNumber);
              return;
            }
            switch (data2.ActionCode) {
              case "SUCCESS":
              case "NOACTION":
              case "FAILURE":
                self2._performJWTValidation(data2, validatedJwt).then(function(result) {
                  self2._verifyCardPromisePlus.resolve(result);
                }).catch(function(err) {
                  self2._verifyCardPromisePlus.reject(err);
                });
                break;
              case "ERROR":
                analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.cardinal-sdk-error." + data2.ErrorNumber);
                switch (data2.ErrorNumber) {
                  case 10001:
                  case 10002:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_SETUP_TIMEDOUT);
                    break;
                  case 10003:
                  case 10007:
                  case 10009:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_RESPONSE_TIMEDOUT);
                    break;
                  case 10005:
                  case 10006:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_BAD_CONFIG);
                    break;
                  case 10008:
                  case 10010:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_BAD_JWT);
                    break;
                  case 10011:
                    analytics.sendEvent(self2._createPromise, "three-d-secure.verification-flow.canceled");
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_CANCELED);
                    break;
                  default:
                    formattedError = new BraintreeError(errors.THREEDS_CARDINAL_SDK_ERROR);
                }
                formattedError.details = {
                  originalError: {
                    code: data2.ErrorNumber,
                    description: data2.ErrorDescription
                  }
                };
                self2._verifyCardPromisePlus.reject(formattedError);
                break;
            }
          };
        };
        SongbirdFramework.prototype._checkForVerifyCardError = function(options, privateOptions) {
          if (!options.bin) {
            return new BraintreeError({
              type: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.type,
              code: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.code,
              message: "verifyCard options must include a BIN."
            });
          }
          return BaseFramework.prototype._checkForVerifyCardError.call(this, options, privateOptions);
        };
        SongbirdFramework.prototype._checkForFrameworkSpecificVerifyCardErrors = function(options, privateOptions) {
          var errorOption;
          if (typeof options.onLookupComplete !== "function" && !privateOptions.ignoreOnLookupCompleteRequirement) {
            errorOption = "an onLookupComplete function";
          }
          return errorOption;
        };
        SongbirdFramework.prototype._formatVerifyCardOptions = function(options) {
          var modifiedOptions = BaseFramework.prototype._formatVerifyCardOptions.call(this, options);
          var additionalInformation = modifiedOptions.additionalInformation || {};
          additionalInformation = this.transformBillingAddress(additionalInformation, options.billingAddress);
          additionalInformation = this.transformShippingAddress(additionalInformation);
          if (options.onLookupComplete) {
            modifiedOptions.onLookupComplete = deferred(options.onLookupComplete);
          }
          if (options.email) {
            additionalInformation.email = options.email;
          }
          if (options.mobilePhoneNumber) {
            additionalInformation.mobilePhoneNumber = options.mobilePhoneNumber;
          }
          modifiedOptions.additionalInformation = additionalInformation;
          return modifiedOptions;
        };
        SongbirdFramework.prototype._onLookupComplete = function(lookupResponse, options) {
          var self2 = this;
          return BaseFramework.prototype._onLookupComplete.call(this, lookupResponse).then(function(response) {
            return new Promise(function(resolve2, reject) {
              response.requiresUserAuthentication = Boolean(response.lookup && response.lookup.acsUrl);
              function next() {
                resolve2(response);
              }
              self2._verifyCardPromisePlus.catch(reject);
              if (options.onLookupComplete) {
                options.onLookupComplete(response, next);
              } else {
                self2._emit(SongbirdFramework.events.LOOKUP_COMPLETE, response, next);
              }
            });
          });
        };
        SongbirdFramework.prototype._presentChallenge = function(lookupResponse) {
          if (this._useV1Fallback || !lookupResponse.lookup.transactionId) {
            this._presentChallengeWithV1Fallback(lookupResponse.lookup);
            return;
          }
          window.Cardinal.continue("cca", {
            AcsUrl: lookupResponse.lookup.acsUrl,
            Payload: lookupResponse.lookup.pareq
          }, {
            OrderDetails: { TransactionId: lookupResponse.lookup.transactionId }
          });
        };
        SongbirdFramework.prototype._formatLookupData = function(options) {
          var self2 = this;
          return BaseFramework.prototype._formatLookupData.call(this, options).then(function(data2) {
            data2.additionalInfo = options.additionalInformation;
            if (options.accountType) {
              data2.accountType = options.accountType;
            }
            if (options.challengeRequested) {
              data2.challengeRequested = options.challengeRequested;
            }
            if (options.requestedExemptionType) {
              if (!SCA_EXEMPTION_TYPES.includes(options.requestedExemptionType)) {
                throw new BraintreeError({
                  code: errors.THREEDS_REQUESTED_EXEMPTION_TYPE_INVALID.code,
                  type: errors.THREEDS_REQUESTED_EXEMPTION_TYPE_INVALID.type,
                  message: "requestedExemptionType `" + options.requestedExemptionType + "` is not a valid exemption. The accepted values are: `" + SCA_EXEMPTION_TYPES.join("`, `") + "`"
                });
              }
              data2.requestedExemptionType = options.requestedExemptionType;
            }
            if (options.customFields) {
              data2.customFields = options.customFields;
            }
            if (options.dataOnlyRequested) {
              data2.dataOnlyRequested = options.dataOnlyRequested;
            }
            if (options.exemptionRequested) {
              data2.exemptionRequested = options.exemptionRequested;
            }
            if (options.requestVisaDAF) {
              data2.requestVisaDAF = options.requestVisaDAF;
            }
            if (options.bin) {
              data2.bin = options.bin;
            }
            if (options.cardAdd != null) {
              data2.cardAdd = options.cardAdd;
            }
            if (options.cardAddChallengeRequested != null) {
              data2.cardAdd = options.cardAddChallengeRequested;
            }
            if (options.merchantName) {
              data2.merchantName = options.merchantName;
            }
            return self2.prepareLookup(data2);
          });
        };
        SongbirdFramework.prototype.cancelVerifyCard = function(verifyCardError) {
          var self2 = this;
          return BaseFramework.prototype.cancelVerifyCard.call(this).then(function(response) {
            if (self2._verifyCardPromisePlus) {
              verifyCardError = verifyCardError || new BraintreeError(errors.THREEDS_VERIFY_CARD_CANCELED_BY_MERCHANT);
              self2._verifyCardPromisePlus.reject(verifyCardError);
            }
            return response;
          });
        };
        SongbirdFramework.prototype._removeSongbirdListeners = function() {
          this._cardinalEvents.forEach(function(eventName) {
            window.Cardinal.off(eventName);
          });
          this._cardinalEvents = [];
        };
        SongbirdFramework.prototype.teardown = function() {
          if (window.Cardinal) {
            this._removeSongbirdListeners();
          }
          return BaseFramework.prototype.teardown.call(this);
        };
        SongbirdFramework.prototype._reloadThreeDSecure = function() {
          var self2 = this;
          var startTime = Date.now();
          return self2.teardown().then(function() {
            self2._configureCardinalSdk({
              setupOptions: self2.originalSetupOptions,
              setupStartTime: startTime
            });
          });
        };
        function extractAddressData(source2, target, prefix) {
          target[prefix + "Line1"] = source2.streetAddress;
          target[prefix + "Line2"] = source2.extendedAddress;
          target[prefix + "Line3"] = source2.line3;
          target[prefix + "City"] = source2.locality;
          target[prefix + "State"] = source2.region;
          target[prefix + "PostalCode"] = source2.postalCode;
          target[prefix + "CountryCode"] = source2.countryCodeAlpha2;
        }
        module2.exports = SongbirdFramework;
      }, { "../../../lib/analytics": 86, "../../../lib/assets": 87, "../../../lib/assign": 88, "../../../lib/braintree-error": 91, "../../../lib/constants": 92, "../../../lib/convert-to-braintree-error": 94, "../../../lib/deferred": 98, "../../../lib/enumerate": 100, "../../shared/constants": 141, "../../shared/errors": 142, "./base": 132, "@braintree/extended-promise": 38 }], 139: [function(require2, module2, exports2) {
        var wrapPromise = require2("@braintree/wrap-promise");
        var methods = require2("../../lib/methods");
        var convertMethodsToError = require2("../../lib/convert-methods-to-error");
        var EventEmitter = require2("@braintree/event-emitter");
        var FRAMEWORKS = require2("./frameworks");
        function ThreeDSecure(options) {
          var self2 = this;
          var Framework = FRAMEWORKS[options.framework];
          EventEmitter.call(this);
          this._framework = new Framework(options);
          this._framework.setUpEventListeners(function() {
            self2._emit.apply(self2, arguments);
          });
        }
        EventEmitter.createChild(ThreeDSecure);
        ThreeDSecure.prototype.verifyCard = function(options) {
          var privateOptions;
          if (this.hasListener("lookup-complete")) {
            privateOptions = {
              ignoreOnLookupCompleteRequirement: true
            };
          }
          return this._framework.verifyCard(options, privateOptions);
        };
        ThreeDSecure.prototype.initializeChallengeWithLookupResponse = function(lookupResponse) {
          if (typeof lookupResponse === "string") {
            lookupResponse = JSON.parse(lookupResponse);
          }
          return this._framework.initializeChallengeWithLookupResponse(lookupResponse);
        };
        ThreeDSecure.prototype.prepareLookup = function(options) {
          return this._framework.prepareLookup(options).then(function(data2) {
            return JSON.stringify(data2);
          });
        };
        ThreeDSecure.prototype.cancelVerifyCard = function() {
          return this._framework.cancelVerifyCard();
        };
        ThreeDSecure.prototype.teardown = function() {
          var methodNames = methods(ThreeDSecure.prototype).concat(methods(EventEmitter.prototype));
          convertMethodsToError(this, methodNames);
          return this._framework.teardown();
        };
        module2.exports = wrapPromise.wrapPrototype(ThreeDSecure);
      }, { "../../lib/convert-methods-to-error": 93, "../../lib/methods": 121, "./frameworks": 135, "@braintree/event-emitter": 37, "@braintree/wrap-promise": 47 }], 140: [function(require2, module2, exports2) {
        var ThreeDSecure = require2("./external/three-d-secure");
        var isHTTPS = require2("../lib/is-https").isHTTPS;
        var basicComponentVerification = require2("../lib/basic-component-verification");
        var createDeferredClient = require2("../lib/create-deferred-client");
        var createAssetsUrl = require2("../lib/create-assets-url");
        var BraintreeError = require2("../lib/braintree-error");
        var analytics = require2("../lib/analytics");
        var errors = require2("./shared/errors");
        var VERSION2 = "3.99.0";
        var wrapPromise = require2("@braintree/wrap-promise");
        function create2(options) {
          var name = "3D Secure";
          var framework = getFramework(options);
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var assetsUrl = createAssetsUrl.create(options.authorization);
            var createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl,
              name
            }).then(function(client) {
              var error, isProduction;
              var config = client.getConfiguration();
              var gwConfig = config.gatewayConfiguration;
              options.client = client;
              if (!gwConfig.threeDSecureEnabled) {
                error = errors.THREEDS_NOT_ENABLED;
              }
              if (config.authorizationType === "TOKENIZATION_KEY") {
                error = errors.THREEDS_CAN_NOT_USE_TOKENIZATION_KEY;
              }
              isProduction = gwConfig.environment === "production";
              if (isProduction && !isHTTPS()) {
                error = errors.THREEDS_HTTPS_REQUIRED;
              }
              if (framework !== "legacy" && !(gwConfig.threeDSecure && gwConfig.threeDSecure.cardinalAuthenticationJWT)) {
                analytics.sendEvent(options.client, "three-d-secure.initialization.failed.missing-cardinalAuthenticationJWT");
                error = errors.THREEDS_NOT_ENABLED_FOR_V2;
              }
              if (error) {
                return Promise.reject(new BraintreeError(error));
              }
              analytics.sendEvent(options.client, "three-d-secure.initialized");
              return client;
            });
            var instance = new ThreeDSecure({
              client: options.client,
              assetsUrl,
              createPromise,
              loggingEnabled: options.loggingEnabled,
              cardinalSDKConfig: options.cardinalSDKConfig,
              framework
            });
            if (options.client) {
              return createPromise.then(function() {
                return instance;
              });
            }
            return instance;
          });
        }
        function getFramework(options) {
          var version2 = String(options.version || "");
          if (!version2 || version2 === "1") {
            throw new BraintreeError({
              code: errors.THREEDS_UNSUPPORTED_VERSION.code,
              type: errors.THREEDS_UNSUPPORTED_VERSION.type,
              message: errors.THREEDS_UNSUPPORTED_VERSION.message
            });
          }
          switch (version2) {
            case "2":
            case "2-cardinal-modal":
              return "cardinal-modal";
            case "2-bootstrap3-modal":
              return "bootstrap3-modal";
            case "2-inline-iframe":
              return "inline-iframe";
            default:
              throw new BraintreeError({
                code: errors.THREEDS_UNRECOGNIZED_VERSION.code,
                type: errors.THREEDS_UNRECOGNIZED_VERSION.type,
                message: "Version `" + options.version + "` is not a recognized version. You may need to update the version of your Braintree SDK to support this version."
              });
          }
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 86, "../lib/basic-component-verification": 89, "../lib/braintree-error": 91, "../lib/create-assets-url": 95, "../lib/create-deferred-client": 97, "../lib/is-https": 118, "./external/three-d-secure": 139, "./shared/errors": 142, "@braintree/wrap-promise": 47 }], 141: [function(require2, module2, exports2) {
        module2.exports = {
          LANDING_FRAME_NAME: "braintreethreedsecurelanding",
          CARDINAL_SCRIPT_SOURCE: {
            production: "https://songbird.cardinalcommerce.com/edge/v1/songbird.js",
            sandbox: "https://songbirdstag.cardinalcommerce.com/edge/v1/songbird.js"
          }
        };
      }, {}], 142: [function(require2, module2, exports2) {
        var BraintreeError = require2("../../lib/braintree-error");
        module2.exports = {
          THREEDS_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_NOT_ENABLED",
            message: "3D Secure is not enabled for this merchant."
          },
          THREEDS_CAN_NOT_USE_TOKENIZATION_KEY: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_CAN_NOT_USE_TOKENIZATION_KEY",
            message: "3D Secure can not use a tokenization key for authorization."
          },
          THREEDS_HTTPS_REQUIRED: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_HTTPS_REQUIRED",
            message: "3D Secure requires HTTPS."
          },
          THREEDS_NOT_ENABLED_FOR_V2: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_NOT_ENABLED_FOR_V2",
            message: "3D Secure version 2 is not enabled for this merchant. Contact Braintree Support for assistance at https://help.braintreepayments.com/"
          },
          THREEDS_UNRECOGNIZED_VERSION: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_UNRECOGNIZED_VERSION"
          },
          THREEDS_CARDINAL_SDK_SETUP_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_CARDINAL_SDK_SETUP_FAILED",
            message: "Something went wrong setting up Cardinal's Songbird.js library."
          },
          THREEDS_CARDINAL_SDK_SCRIPT_LOAD_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "THREEDS_CARDINAL_SDK_SCRIPT_LOAD_FAILED",
            message: "Cardinal's Songbird.js library could not be loaded."
          },
          THREEDS_CARDINAL_SDK_SETUP_TIMEDOUT: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_CARDINAL_SDK_SETUP_TIMEDOUT",
            message: "Cardinal's Songbird.js took too long to setup."
          },
          THREEDS_CARDINAL_SDK_RESPONSE_TIMEDOUT: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_CARDINAL_SDK_RESPONSE_TIMEDOUT",
            message: "Cardinal's API took too long to respond."
          },
          THREEDS_CARDINAL_SDK_BAD_CONFIG: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_CARDINAL_SDK_BAD_CONFIG",
            message: "JWT or other required field missing. Please check your setup configuration."
          },
          THREEDS_CARDINAL_SDK_BAD_JWT: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_CARDINAL_SDK_BAD_JWT",
            message: "Cardinal JWT missing or malformed. Please check your setup configuration."
          },
          THREEDS_CARDINAL_SDK_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_CARDINAL_SDK_ERROR",
            message: "A general error has occurred with Cardinal. See description for more information."
          },
          THREEDS_CARDINAL_SDK_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "THREEDS_CARDINAL_SDK_CANCELED",
            message: "Canceled by user."
          },
          THREEDS_VERIFY_CARD_CANCELED_BY_MERCHANT: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_VERIFY_CARD_CANCELED_BY_MERCHANT",
            message: "3D Secure verfication canceled by merchant."
          },
          THREEDS_AUTHENTICATION_IN_PROGRESS: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_AUTHENTICATION_IN_PROGRESS",
            message: "Cannot call verifyCard while existing authentication is in progress."
          },
          THREEDS_MISSING_VERIFY_CARD_OPTION: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_MISSING_VERIFY_CARD_OPTION"
          },
          THREEDS_JWT_AUTHENTICATION_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_JWT_AUTHENTICATION_FAILED",
            message: "Something went wrong authenticating the JWT from Cardinal"
          },
          THREEDS_LOOKUP_TOKENIZED_CARD_NOT_FOUND_ERROR: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_LOOKUP_TOKENIZED_CARD_NOT_FOUND_ERROR",
            message: "Either the payment method nonce passed to `verifyCard` does not exist, or it was already consumed"
          },
          THREEDS_LOOKUP_VALIDATION_ERROR: {
            type: BraintreeError.types.CUSTOMER,
            code: "THREEDS_LOOKUP_VALIDATION_ERROR",
            message: "The data passed in `verifyCard` did not pass validation checks. See details for more info"
          },
          THREEDS_LOOKUP_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_LOOKUP_ERROR",
            message: "Something went wrong during the 3D Secure lookup"
          },
          THREEDS_INLINE_IFRAME_DETAILS_INCORRECT: {
            type: BraintreeError.types.UNKNOWN,
            code: "THREEDS_INLINE_IFRAME_DETAILS_INCORRECT",
            message: "Something went wrong when attempting to add the authentication iframe to the page."
          },
          THREEDS_NO_VERIFICATION_PAYLOAD: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_NO_VERIFICATION_PAYLOAD",
            message: "No verification payload available."
          },
          THREEDS_TERM_URL_REQUIRES_BRAINTREE_DOMAIN: {
            type: BraintreeError.types.INTERNAL,
            code: "THREEDS_TERM_URL_REQUIRES_BRAINTREE_DOMAIN",
            message: "Term Url must be on a Braintree domain."
          },
          THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED: {
            type: BraintreeError.types.INTERNAL,
            code: "THREEDS_FRAMEWORK_METHOD_NOT_IMPLEMENTED",
            message: "Method not implemented for this framework."
          },
          THREEDS_REQUESTED_EXEMPTION_TYPE_INVALID: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_REQUESTED_EXEMPTION_TYPE_INVALID",
            message: "Requested Exemption Type is invalid."
          },
          THREEDS_UNSUPPORTED_VERSION: {
            type: BraintreeError.types.MERCHANT,
            code: "THREEDS_UNSUPPORTED_VERSION",
            message: "3D Secure `1` is deprecated and no longer supported. See available versions at https://braintree.github.io/braintree-web/current/module-braintree-web_three-d-secure.html#.create"
          }
        };
      }, { "../../lib/braintree-error": 91 }], 143: [function(require2, module2, exports2) {
        var enumerate = require2("../../lib/enumerate");
        module2.exports = enumerate(["AUTHENTICATION_COMPLETE"], "threedsecure:");
      }, { "../../lib/enumerate": 100 }], 144: [function(require2, module2, exports2) {
        var BraintreeError = require2("../lib/braintree-error");
        module2.exports = {
          VAULT_MANAGER_DELETE_PAYMENT_METHOD_NONCE_REQUIRES_CLIENT_TOKEN: {
            type: BraintreeError.types.MERCHANT,
            code: "VAULT_MANAGER_DELETE_PAYMENT_METHOD_NONCE_REQUIRES_CLIENT_TOKEN",
            message: "A client token with a customer id must be used to delete a payment method nonce."
          },
          VAULT_MANAGER_PAYMENT_METHOD_NONCE_NOT_FOUND: {
            type: BraintreeError.types.MERCHANT,
            code: "VAULT_MANAGER_PAYMENT_METHOD_NONCE_NOT_FOUND"
          },
          VAULT_MANAGER_DELETE_PAYMENT_METHOD_UNKNOWN_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "VAULT_MANAGER_DELETE_PAYMENT_METHOD_UNKNOWN_ERROR"
          }
        };
      }, { "../lib/braintree-error": 91 }], 145: [function(require2, module2, exports2) {
        var basicComponentVerification = require2("../lib/basic-component-verification");
        var createDeferredClient = require2("../lib/create-deferred-client");
        var createAssetsUrl = require2("../lib/create-assets-url");
        var VaultManager = require2("./vault-manager");
        var VERSION2 = "3.99.0";
        var wrapPromise = require2("@braintree/wrap-promise");
        function create2(options) {
          var name = "Vault Manager";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            return new VaultManager({
              createPromise: createDeferredClient.create({
                authorization: options.authorization,
                client: options.client,
                debug: options.debug,
                assetsUrl: createAssetsUrl.create(options.authorization),
                name
              })
            });
          });
        }
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "../lib/basic-component-verification": 89, "../lib/create-assets-url": 95, "../lib/create-deferred-client": 97, "./vault-manager": 146, "@braintree/wrap-promise": 47 }], 146: [function(require2, module2, exports2) {
        var analytics = require2("../lib/analytics");
        var BraintreeError = require2("../lib/braintree-error");
        var errors = require2("./errors");
        var convertMethodsToError = require2("../lib/convert-methods-to-error");
        var methods = require2("../lib/methods");
        var wrapPromise = require2("@braintree/wrap-promise");
        var DELETE_PAYMENT_METHOD_MUTATION = "mutation DeletePaymentMethodFromSingleUseToken($input: DeletePaymentMethodFromSingleUseTokenInput!) {  deletePaymentMethodFromSingleUseToken(input: $input) {    clientMutationId  }}";
        function VaultManager(options) {
          this._createPromise = options.createPromise;
        }
        VaultManager.prototype.fetchPaymentMethods = function(options) {
          var defaultFirst;
          options = options || {};
          defaultFirst = options.defaultFirst === true ? 1 : 0;
          return this._createPromise.then(function(client) {
            return client.request({
              endpoint: "payment_methods",
              method: "get",
              data: {
                defaultFirst
              }
            });
          }).then(function(paymentMethodsPayload) {
            analytics.sendEvent(this._createPromise, "vault-manager.fetch-payment-methods.succeeded");
            return paymentMethodsPayload.paymentMethods.map(formatPaymentMethodPayload);
          }.bind(this));
        };
        VaultManager.prototype.deletePaymentMethod = function(paymentMethodNonce) {
          return this._createPromise.then(function(client) {
            var usesClientToken = client.getConfiguration().authorizationType === "CLIENT_TOKEN";
            if (!usesClientToken) {
              return Promise.reject(new BraintreeError(errors.VAULT_MANAGER_DELETE_PAYMENT_METHOD_NONCE_REQUIRES_CLIENT_TOKEN));
            }
            return client.request({
              api: "graphQLApi",
              data: {
                query: DELETE_PAYMENT_METHOD_MUTATION,
                variables: {
                  input: {
                    singleUseTokenId: paymentMethodNonce
                  }
                },
                operationName: "DeletePaymentMethodFromSingleUseToken"
              }
            }).then(function() {
              analytics.sendEvent(client, "vault-manager.delete-payment-method.succeeded");
            }).catch(function(error) {
              var originalError = error.details.originalError;
              var formattedError;
              analytics.sendEvent(client, "vault-manager.delete-payment-method.failed");
              if (originalError[0] && originalError[0].extensions.errorClass === "NOT_FOUND") {
                formattedError = new BraintreeError({
                  type: errors.VAULT_MANAGER_PAYMENT_METHOD_NONCE_NOT_FOUND.type,
                  code: errors.VAULT_MANAGER_PAYMENT_METHOD_NONCE_NOT_FOUND.code,
                  message: "A payment method for payment method nonce `" + paymentMethodNonce + "` could not be found.",
                  details: {
                    originalError
                  }
                });
              }
              if (!formattedError) {
                formattedError = new BraintreeError({
                  type: errors.VAULT_MANAGER_DELETE_PAYMENT_METHOD_UNKNOWN_ERROR.type,
                  code: errors.VAULT_MANAGER_DELETE_PAYMENT_METHOD_UNKNOWN_ERROR.code,
                  message: "An unknown error occured when attempting to delete the payment method assocaited with the payment method nonce `" + paymentMethodNonce + "`.",
                  details: {
                    originalError
                  }
                });
              }
              return Promise.reject(formattedError);
            });
          });
        };
        function formatPaymentMethodPayload(paymentMethod) {
          var formattedPaymentMethod = {
            nonce: paymentMethod.nonce,
            default: paymentMethod.default,
            details: paymentMethod.details,
            hasSubscription: paymentMethod.hasSubscription,
            type: paymentMethod.type
          };
          if (paymentMethod.description) {
            formattedPaymentMethod.description = paymentMethod.description;
          }
          if (paymentMethod.binData) {
            formattedPaymentMethod.binData = paymentMethod.binData;
          }
          return formattedPaymentMethod;
        }
        VaultManager.prototype.teardown = function() {
          convertMethodsToError(this, methods(VaultManager.prototype));
          return Promise.resolve();
        };
        module2.exports = wrapPromise.wrapPrototype(VaultManager);
      }, { "../lib/analytics": 86, "../lib/braintree-error": 91, "../lib/convert-methods-to-error": 93, "../lib/methods": 121, "./errors": 144, "@braintree/wrap-promise": 47 }], 147: [function(require2, module2, exports2) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
        var venmo_desktop_1 = __importDefault(require2("./venmo-desktop"));
        module2.exports = function createVenmoDesktop(options) {
          var instance = new venmo_desktop_1.default(options);
          return instance.initialize();
        };
      }, { "./venmo-desktop": 149 }], 148: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.VENMO_PAYMENT_CONTEXT_STATUS_QUERY = exports2.LEGACY_VENMO_PAYMENT_CONTEXT_STATUS_QUERY = exports2.UPDATE_PAYMENT_CONTEXT_QUERY = exports2.LEGACY_UPDATE_PAYMENT_CONTEXT_QUERY = exports2.CREATE_PAYMENT_CONTEXT_QUERY = exports2.LEGACY_CREATE_PAYMENT_CONTEXT_QUERY = void 0;
        exports2.LEGACY_CREATE_PAYMENT_CONTEXT_QUERY = "mutation CreateVenmoQRCodePaymentContext($input: CreateVenmoQRCodePaymentContextInput!) {\n  createVenmoQRCodePaymentContext(input: $input) {\n    clientMutationId\n    venmoQRCodePaymentContext {\n      id\n      merchantId\n      createdAt\n      expiresAt\n    }\n  }\n}";
        exports2.CREATE_PAYMENT_CONTEXT_QUERY = "mutation CreateVenmoPaymentContext($input: CreateVenmoPaymentContextInput!) {\n  createVenmoPaymentContext(input: $input) {\n    clientMutationId\n    venmoPaymentContext {\n      id\n      merchantId\n      createdAt\n      expiresAt\n    }\n  }\n}";
        exports2.LEGACY_UPDATE_PAYMENT_CONTEXT_QUERY = "mutation UpdateVenmoQRCodePaymentContext($input: UpdateVenmoQRCodePaymentContextInput!) {\n  updateVenmoQRCodePaymentContext(input: $input) {\n    clientMutationId\n  }\n}";
        exports2.UPDATE_PAYMENT_CONTEXT_QUERY = "mutation UpdateVenmoPaymentContextStatus($input: UpdateVenmoPaymentContextStatusInput!) {\n  updateVenmoPaymentContextStatus(input: $input) {\n    clientMutationId\n  }\n}";
        exports2.LEGACY_VENMO_PAYMENT_CONTEXT_STATUS_QUERY = "query PaymentContext($id: ID!) {\n  node(id: $id) {\n    ... on VenmoQRCodePaymentContext {\n      status\n      paymentMethodId\n      userName\n    }\n  }\n}";
        exports2.VENMO_PAYMENT_CONTEXT_STATUS_QUERY = "query PaymentContext($id: ID!) {\n  node(id: $id) {\n    ... on VenmoPaymentContext {\n      status\n      paymentMethodId\n      userName\n      payerInfo {\n        firstName\n        lastName\n        phoneNumber\n        email\n        externalId\n        userName\n        billingAddress {\n          fullName\n          addressLine1\n          addressLine2\n          adminArea1\n          adminArea2\n          postalCode\n          countryCode\n        }\n        shippingAddress {\n          fullName\n          addressLine1\n          addressLine2\n          adminArea1\n          adminArea2\n          postalCode\n          countryCode\n        }\n      }\n    }\n  }\n}";
      }, {}], 149: [function(require2, module2, exports2) {
        var __assign = this && this.__assign || function() {
          __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p2 in s)
                if (Object.prototype.hasOwnProperty.call(s, p2))
                  t[p2] = s[p2];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        var framebus_1 = __importDefault(require2("framebus"));
        var iframer_1 = __importDefault(require2("@braintree/iframer"));
        var uuid_1 = __importDefault(require2("@braintree/uuid"));
        var events_1 = require2("../shared/events");
        var queries_1 = require2("./queries");
        var VENMO_DESKTOP_POLLING_INTERVAL = 1e3;
        var VISUAL_DELAY_BEFORE_SIGNALLING_COMPLETION = 2e3;
        var VenmoDesktop = function() {
          function VenmoDesktop2(options) {
            this.isHidden = true;
            this.env = options.environment;
            this.id = uuid_1.default();
            this.profileId = options.profileId;
            this.displayName = options.displayName;
            this.paymentMethodUsage = options.paymentMethodUsage;
            this.shouldUseLegacyQRCodeMutation = !this.paymentMethodUsage;
            var frameUrl = options.url + "#" + this.env + "_" + this.id;
            this.bus = new framebus_1.default({
              channel: this.id,
              verifyDomain: options.verifyDomain,
              targetFrames: []
            });
            this.apiRequest = options.apiRequest;
            this.sendEvent = options.sendEvent;
            this.Promise = options.Promise;
            this.alertBox = document.createElement("div");
            this.alertBox.setAttribute("data-venmo-desktop-id", this.id);
            this.alertBox.setAttribute("role", "alert");
            this.alertBox.style.position = "fixed";
            this.alertBox.style.display = "none";
            this.alertBox.style.height = "1px";
            this.alertBox.style.width = "1px";
            this.alertBox.style.overflow = "hidden";
            this.alertBox.style.zIndex = "0";
            this.iframe = iframer_1.default({
              src: frameUrl,
              name: "venmo-desktop-iframe",
              style: {
                display: "none",
                position: "fixed",
                top: "0",
                bottom: "0",
                right: "0",
                left: "0",
                height: "100%",
                width: "100%",
                zIndex: "9999999"
              },
              title: "Venmo Desktop"
            });
            this.bus.addTargetFrame(this.iframe);
          }
          VenmoDesktop2.prototype.initialize = function() {
            var _this = this;
            return new this.Promise(function(resolve2) {
              _this.bus.on(events_1.VENMO_DESKTOP_IFRAME_READY, function() {
                resolve2(_this);
              });
              _this.bus.on(events_1.VENMO_DESKTOP_REQUEST_NEW_QR_CODE, function() {
                _this.sendEvent("venmo.tokenize.desktop.restarted-from-error-view");
                _this.startPolling();
              });
              document.body.appendChild(_this.iframe);
              document.body.appendChild(_this.alertBox);
            });
          };
          VenmoDesktop2.prototype.launchDesktopFlow = function() {
            var _this = this;
            this.isHidden = false;
            var promise = new this.Promise(function(resolve2, reject) {
              _this.launchDesktopPromiseRejectFunction = reject;
              var removeListeners = function() {
                _this.bus.off(events_1.VENMO_DESKTOP_CUSTOMER_CANCELED, customerCancelledHandler);
                _this.bus.off(events_1.VENMO_DESKTOP_UNKNOWN_ERROR, unknownErrorHandler);
              };
              var unknownErrorHandler = function(err) {
                removeListeners();
                _this.sendEvent("venmo.tokenize.desktop.unknown-error");
                reject({
                  allowUIToHandleError: false,
                  reason: "UNKNOWN_ERROR",
                  err
                });
              };
              var customerCancelledHandler = function() {
                removeListeners();
                _this.updateVenmoDesktopPaymentContext("CANCELED");
                _this.sendEvent("venmo.tokenize.desktop.status-change.canceled-from-modal");
                reject({
                  allowUIToHandleError: false,
                  reason: "CUSTOMER_CANCELED"
                });
              };
              _this.completedHandler = function(payload) {
                removeListeners();
                resolve2(payload);
              };
              _this.bus.on(events_1.VENMO_DESKTOP_CUSTOMER_CANCELED, customerCancelledHandler);
              _this.bus.on(events_1.VENMO_DESKTOP_UNKNOWN_ERROR, unknownErrorHandler);
            });
            this.iframe.style.display = "block";
            this.setAlert("Generating a QR code, get your Venmo app ready");
            this.iframe.focus();
            this.startPolling();
            return promise.then(function(result) {
              delete _this.venmoContextId;
              delete _this.launchDesktopPromiseRejectFunction;
              return result;
            }).catch(function(err) {
              delete _this.venmoContextId;
              delete _this.launchDesktopPromiseRejectFunction;
              return _this.Promise.reject(err);
            });
          };
          VenmoDesktop2.prototype.triggerCompleted = function(result) {
            var _this = this;
            if (this.isHidden) {
              return;
            }
            setTimeout(function() {
              if (_this.completedHandler) {
                _this.completedHandler(result);
              }
              delete _this.completedHandler;
            }, VISUAL_DELAY_BEFORE_SIGNALLING_COMPLETION);
          };
          VenmoDesktop2.prototype.triggerRejected = function(err) {
            if (this.launchDesktopPromiseRejectFunction) {
              this.launchDesktopPromiseRejectFunction(err);
            }
          };
          VenmoDesktop2.prototype.hideDesktopFlow = function() {
            this.setAlert("");
            this.iframe.style.display = "none";
            this.bus.emit(events_1.VENMO_DESKTOP_CLOSED_FROM_PARENT);
            this.isHidden = true;
          };
          VenmoDesktop2.prototype.displayError = function(message) {
            if (this.isHidden) {
              return;
            }
            this.bus.emit(events_1.VENMO_DESKTOP_DISPLAY_ERROR, {
              message
            });
            this.setAlert(message);
          };
          VenmoDesktop2.prototype.displayQRCode = function(id, merchantId) {
            if (this.isHidden) {
              return;
            }
            this.bus.emit(events_1.VENMO_DESKTOP_DISPLAY_QR_CODE, {
              id,
              merchantId
            });
            this.setAlert("To scan the QR code, open your Venmo app");
          };
          VenmoDesktop2.prototype.authorize = function() {
            if (this.isHidden) {
              return;
            }
            this.bus.emit(events_1.VENMO_DESKTOP_AUTHORIZE);
            this.setAlert("Venmo account authorized");
          };
          VenmoDesktop2.prototype.authorizing = function() {
            if (this.isHidden) {
              return;
            }
            this.bus.emit(events_1.VENMO_DESKTOP_AUTHORIZING);
            this.setAlert("Authorize on your Venmo app");
          };
          VenmoDesktop2.prototype.startPolling = function() {
            var _this = this;
            return this.createVenmoDesktopPaymentContext().then(function(result) {
              var expiresIn = new Date(result.expiresAt).getTime() - new Date(result.createdAt).getTime();
              var expiredTime = Date.now() + expiresIn;
              _this.displayQRCode(result.id, result.merchantId);
              return _this.pollForStatusChange(result.status, expiredTime);
            }).then(function(result) {
              if (!result) {
                return;
              }
              var username = result.userName || "";
              username = "@" + username.replace("@", "");
              _this.triggerCompleted({
                paymentMethodNonce: result.paymentMethodId,
                username,
                payerInfo: result.payerInfo,
                id: _this.venmoContextId || ""
              });
            }).catch(function(err) {
              if (err.allowUIToHandleError) {
                return;
              }
              _this.sendEvent("venmo.tokenize.desktop.unhandled-error");
              _this.triggerRejected(err);
            });
          };
          VenmoDesktop2.prototype.pollForStatusChange = function(status, expiredTime) {
            var _this = this;
            if (!this.venmoContextId) {
              return this.Promise.resolve();
            }
            if (Date.now() > expiredTime) {
              return this.updateVenmoDesktopPaymentContext("EXPIRED").then(function() {
                _this.displayError("Something went wrong");
                _this.sendEvent("venmo.tokenize.desktop.status-change.sdk-timeout");
                return _this.Promise.reject({
                  allowUIToHandleError: true,
                  reason: "TIMEOUT"
                });
              });
            }
            return this.lookupVenmoDesktopPaymentContext().then(function(response) {
              if (!_this.venmoContextId || !response) {
                return _this.Promise.resolve();
              }
              var newStatus = response.status;
              if (newStatus !== status) {
                status = newStatus;
                _this.sendEvent("venmo.tokenize.desktop.status-change." + status.toLowerCase());
                switch (status) {
                  case "CREATED":
                    break;
                  case "EXPIRED":
                  case "FAILED":
                  case "CANCELED":
                    var message = status === "CANCELED" ? "The authorization was canceled" : "Something went wrong";
                    _this.displayError(message);
                    return _this.Promise.reject({
                      allowUIToHandleError: true,
                      reason: status
                    });
                  case "SCANNED":
                    _this.authorizing();
                    break;
                  case "APPROVED":
                    _this.authorize();
                    return _this.Promise.resolve(response);
                }
              }
              return new _this.Promise(function(resolve2, reject) {
                setTimeout(function() {
                  _this.pollForStatusChange(status, expiredTime).then(resolve2).catch(reject);
                }, VENMO_DESKTOP_POLLING_INTERVAL);
              });
            });
          };
          VenmoDesktop2.prototype.teardown = function() {
            this.bus.teardown();
            if (this.iframe.parentNode) {
              this.iframe.parentNode.removeChild(this.iframe);
            }
            if (this.alertBox.parentNode) {
              this.alertBox.parentNode.removeChild(this.alertBox);
            }
          };
          VenmoDesktop2.prototype.setAlert = function(message) {
            this.alertBox.style.display = message ? "block" : "none";
            this.alertBox.textContent = message;
          };
          VenmoDesktop2.prototype.createPaymentContextFromGraphqlLegacyQRCodeMutation = function(intent) {
            return this.apiRequest(queries_1.LEGACY_CREATE_PAYMENT_CONTEXT_QUERY, {
              input: {
                environment: this.env,
                intent
              }
            }).then(function(response) {
              return response.createVenmoQRCodePaymentContext.venmoQRCodePaymentContext;
            });
          };
          VenmoDesktop2.prototype.createPaymentContextFromGraphQL = function(intent) {
            var input = {
              intent,
              paymentMethodUsage: this.paymentMethodUsage,
              customerClient: "DESKTOP"
            };
            if (this.profileId) {
              input.merchantProfileId = this.profileId;
            }
            if (this.displayName) {
              input.displayName = this.displayName;
            }
            return this.apiRequest(queries_1.CREATE_PAYMENT_CONTEXT_QUERY, {
              input
            }).then(function(response) {
              return response.createVenmoPaymentContext.venmoPaymentContext;
            });
          };
          VenmoDesktop2.prototype.createVenmoDesktopPaymentContext = function() {
            var _this = this;
            var contextPromise = this.shouldUseLegacyQRCodeMutation ? this.createPaymentContextFromGraphqlLegacyQRCodeMutation("PAY_FROM_APP") : this.createPaymentContextFromGraphQL("PAY_FROM_APP");
            return contextPromise.then(function(context) {
              _this.venmoContextId = context.id;
              var merchantId = _this.profileId || context.merchantId;
              return {
                id: context.id,
                status: context.status,
                merchantId,
                createdAt: context.createdAt,
                expiresAt: context.expiresAt
              };
            });
          };
          VenmoDesktop2.prototype.updateVenmoDesktopPaymentContext = function(status, additionalOptions) {
            if (additionalOptions === void 0) {
              additionalOptions = {};
            }
            if (!this.venmoContextId) {
              return this.Promise.resolve();
            }
            var data2 = {
              input: __assign({ id: this.venmoContextId, status }, additionalOptions)
            };
            var query = this.shouldUseLegacyQRCodeMutation ? queries_1.LEGACY_UPDATE_PAYMENT_CONTEXT_QUERY : queries_1.UPDATE_PAYMENT_CONTEXT_QUERY;
            return this.apiRequest(query, data2).then(function() {
            });
          };
          VenmoDesktop2.prototype.lookupVenmoDesktopPaymentContext = function() {
            if (!this.venmoContextId) {
              return this.Promise.resolve();
            }
            var query = this.shouldUseLegacyQRCodeMutation ? queries_1.LEGACY_VENMO_PAYMENT_CONTEXT_STATUS_QUERY : queries_1.VENMO_PAYMENT_CONTEXT_STATUS_QUERY;
            return this.apiRequest(query, {
              id: this.venmoContextId
            }).then(function(response) {
              return response.node;
            });
          };
          return VenmoDesktop2;
        }();
        exports2.default = VenmoDesktop;
      }, { "../shared/events": 154, "./queries": 148, "@braintree/iframer": 39, "@braintree/uuid": 43, "framebus": 167 }], 150: [function(require2, module2, exports2) {
        var analytics = require2("../lib/analytics");
        var basicComponentVerification = require2("../lib/basic-component-verification");
        var createDeferredClient = require2("../lib/create-deferred-client");
        var createAssetsUrl = require2("../lib/create-assets-url");
        var errors = require2("./shared/errors");
        var wrapPromise = require2("@braintree/wrap-promise");
        var BraintreeError = require2("../lib/braintree-error");
        var Venmo = require2("./venmo");
        var supportsVenmo = require2("./shared/supports-venmo");
        var VERSION2 = "3.99.0";
        function create2(options) {
          var name = "Venmo";
          return basicComponentVerification.verify({
            name,
            client: options.client,
            authorization: options.authorization
          }).then(function() {
            var createPromise, instance;
            if (options.profileId && typeof options.profileId !== "string") {
              return Promise.reject(new BraintreeError(errors.VENMO_INVALID_PROFILE_ID));
            }
            if (options.deepLinkReturnUrl && typeof options.deepLinkReturnUrl !== "string") {
              return Promise.reject(new BraintreeError(errors.VENMO_INVALID_DEEP_LINK_RETURN_URL));
            }
            createPromise = createDeferredClient.create({
              authorization: options.authorization,
              client: options.client,
              debug: options.debug,
              assetsUrl: createAssetsUrl.create(options.authorization),
              name
            }).then(function(client) {
              var configuration = client.getConfiguration();
              options.client = client;
              if (!configuration.gatewayConfiguration.payWithVenmo) {
                return Promise.reject(new BraintreeError(errors.VENMO_NOT_ENABLED));
              }
              return client;
            });
            options.createPromise = createPromise;
            instance = new Venmo(options);
            analytics.sendEvent(createPromise, "venmo.initialized");
            return createPromise.then(function() {
              return instance;
            });
          });
        }
        function isBrowserSupported(options) {
          return supportsVenmo.isBrowserSupported(options);
        }
        module2.exports = {
          create: wrapPromise(create2),
          isBrowserSupported,
          VERSION: VERSION2
        };
      }, { "../lib/analytics": 86, "../lib/basic-component-verification": 89, "../lib/braintree-error": 91, "../lib/create-assets-url": 95, "../lib/create-deferred-client": 97, "./shared/errors": 153, "./shared/supports-venmo": 156, "./venmo": 158, "@braintree/wrap-promise": 47 }], 151: [function(require2, module2, exports2) {
        var isAndroid = require2("@braintree/browser-detection/is-android");
        var isChrome = require2("@braintree/browser-detection/is-chrome");
        var isIos = require2("@braintree/browser-detection/is-ios");
        var isIosSafari = require2("@braintree/browser-detection/is-ios-safari");
        var isIosWebview = require2("@braintree/browser-detection/is-ios-webview");
        var isSamsung = require2("@braintree/browser-detection/is-samsung");
        function isAndroidWebview() {
          return isAndroid() && window.navigator.userAgent.toLowerCase().indexOf("wv") > -1;
        }
        function doesNotSupportWindowOpenInIos() {
          if (!isIos()) {
            return false;
          }
          return isIosWebview() || !isIosSafari();
        }
        function isFacebookOwnedBrowserOnAndroid() {
          var ua = window.navigator.userAgent.toLowerCase();
          if (ua.indexOf("huawei") > -1 && ua.indexOf("fban") > -1) {
            return true;
          }
          if (!isAndroid()) {
            return false;
          }
          return ua.indexOf("fb_iab") > -1 || ua.indexOf("instagram") > -1;
        }
        function isIosChrome() {
          return isIos() && isChrome();
        }
        module2.exports = {
          isAndroid,
          isAndroidWebview,
          isChrome,
          isIos,
          isIosChrome,
          isSamsung,
          isIosSafari,
          isIosWebview,
          isFacebookOwnedBrowserOnAndroid,
          doesNotSupportWindowOpenInIos
        };
      }, { "@braintree/browser-detection/is-android": 25, "@braintree/browser-detection/is-chrome": 27, "@braintree/browser-detection/is-ios": 34, "@braintree/browser-detection/is-ios-safari": 31, "@braintree/browser-detection/is-ios-webview": 32, "@braintree/browser-detection/is-samsung": 35 }], 152: [function(require2, module2, exports2) {
        module2.exports = {
          DOCUMENT_VISIBILITY_CHANGE_EVENT_DELAY: 500,
          DEFAULT_PROCESS_RESULTS_DELAY: 1e3,
          VENMO_APP_OR_MOBILE_AUTH_URL: "https://venmo.com/go/checkout",
          VENMO_MOBILE_APP_AUTH_ONLY_URL: "https://venmo.com/braintree/checkout",
          VENMO_WEB_LOGIN_URL: "https://account.venmo.com/go/web"
        };
      }, {}], 153: [function(require2, module2, exports2) {
        var BraintreeError = require2("../../lib/braintree-error");
        module2.exports = {
          VENMO_NOT_ENABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_NOT_ENABLED",
            message: "Venmo is not enabled for this merchant."
          },
          VENMO_TOKENIZATION_REQUEST_ACTIVE: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_TOKENIZATION_REQUEST_ACTIVE",
            message: "Another tokenization request is active."
          },
          VENMO_TOKENIZATION_REQUEST_NOT_ACTIVE: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_TOKENIZATION_REQUEST_NOT_ACTIVE",
            message: "No tokenization in progress."
          },
          VENMO_APP_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_APP_FAILED",
            message: "Venmo app encountered a problem."
          },
          VENMO_APP_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_APP_CANCELED",
            message: "Venmo app authorization was canceled."
          },
          VENMO_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_CANCELED",
            message: "User canceled Venmo authorization, or Venmo app is not available."
          },
          VENMO_CUSTOMER_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_CUSTOMER_CANCELED",
            message: "User canceled Venmo authorization."
          },
          VENMO_NETWORK_ERROR: {
            type: BraintreeError.types.NETWORK,
            code: "VENMO_NETWORK_ERROR",
            message: "Something went wrong making the request"
          },
          VENMO_DESKTOP_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_DESKTOP_CANCELED",
            message: "User canceled Venmo authorization by closing the Venmo Desktop modal."
          },
          VENMO_TOKENIZATION_CANCELED_BY_MERCHANT: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_TOKENIZATION_CANCELED_BY_MERCHANT",
            message: "The Venmo tokenization was canceled by the merchant."
          },
          VENMO_DESKTOP_UNKNOWN_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_DESKTOP_UNKNOWN_ERROR",
            message: "Something went wrong with the Venmo Desktop flow."
          },
          VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED: {
            type: BraintreeError.types.NETWORK,
            code: "VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED",
            message: "Something went wrong creating the Venmo Payment Context."
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR",
            message: "Something went wrong during mobile polling."
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_EXPIRED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_EXPIRED",
            message: "The Venmo authorization request is expired."
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_CANCELED: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_CANCELED",
            message: "The Venmo authorization was canceled"
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_TIMEOUT: {
            type: BraintreeError.types.CUSTOMER,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_TIMEOUT",
            message: "Customer took too long to authorize Venmo payment."
          },
          VENMO_MOBILE_POLLING_TOKENIZATION_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_MOBILE_POLLING_TOKENIZATION_FAILED",
            message: "The Venmo authorization failed."
          },
          VENMO_INVALID_PROFILE_ID: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_INVALID_PROFILE_ID",
            message: "Venmo profile ID is invalid."
          },
          VENMO_INVALID_DEEP_LINK_RETURN_URL: {
            type: BraintreeError.types.MERCHANT,
            code: "VENMO_INVALID_DEEP_LINK_RETURN_URL",
            message: "Venmo deep link return URL is invalid."
          },
          VENMO_TOKENIZATION_FAILED: {
            type: BraintreeError.types.UNKNOWN,
            code: "VENMO_TOKENIZATION_FAILED",
            message: "Venmo encountered a problem"
          },
          VENMO_ECD_DISABLED: {
            type: BraintreeError.types.MERCHANT,
            code: "ECD_DISABLED",
            message: "Cannot collect customer data when ECD is disabled. Enable this feature in the Control Panel to collect this data."
          }
        };
      }, { "../../lib/braintree-error": 91 }], 154: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.VENMO_DESKTOP_UNKNOWN_ERROR = exports2.VENMO_DESKTOP_REQUEST_NEW_QR_CODE = exports2.VENMO_DESKTOP_CLOSED_FROM_PARENT = exports2.VENMO_DESKTOP_IFRAME_READY = exports2.VENMO_DESKTOP_DISPLAY_QR_CODE = exports2.VENMO_DESKTOP_DISPLAY_ERROR = exports2.VENMO_DESKTOP_CUSTOMER_CANCELED = exports2.VENMO_DESKTOP_AUTHORIZING = exports2.VENMO_DESKTOP_AUTHORIZE = exports2.VENMO_DESKTOP_AUTHORIZATION_TIMED_OUT = void 0;
        exports2.VENMO_DESKTOP_AUTHORIZATION_TIMED_OUT = "VENMO_DESKTOP_AUTHORIZATION_TIMED_OUT";
        exports2.VENMO_DESKTOP_AUTHORIZE = "VENMO_DESKTOP_AUTHORIZE";
        exports2.VENMO_DESKTOP_AUTHORIZING = "VENMO_DESKTOP_AUTHORIZING";
        exports2.VENMO_DESKTOP_CUSTOMER_CANCELED = "VENMO_DESKTOP_CUSTOMER_CANCELED";
        exports2.VENMO_DESKTOP_DISPLAY_ERROR = "VENMO_DESKTOP_DISPLAY_ERROR";
        exports2.VENMO_DESKTOP_DISPLAY_QR_CODE = "VENMO_DESKTOP_DISPLAY_QR_CODE";
        exports2.VENMO_DESKTOP_IFRAME_READY = "VENMO_DESKTOP_IFRAME_READY";
        exports2.VENMO_DESKTOP_CLOSED_FROM_PARENT = "VENMO_DESKTOP_CLOSED_FROM_PARENT";
        exports2.VENMO_DESKTOP_REQUEST_NEW_QR_CODE = "VENMO_DESKTOP_REQUEST_NEW_QR_CODE";
        exports2.VENMO_DESKTOP_UNKNOWN_ERROR = "VENMO_DESKTOP_UNKNOWN_ERROR";
      }, {}], 155: [function(require2, module2, exports2) {
        var venmoConstants = require2("./constants");
        function getVenmoUrl(options) {
          if (options.useAllowDesktopWebLogin)
            return venmoConstants.VENMO_WEB_LOGIN_URL;
          if (options.mobileWebFallBack)
            return venmoConstants.VENMO_APP_OR_MOBILE_AUTH_URL;
          return venmoConstants.VENMO_MOBILE_APP_AUTH_ONLY_URL;
        }
        module2.exports = getVenmoUrl;
      }, { "./constants": 152 }], 156: [function(require2, module2, exports2) {
        var browserDetection = require2("./browser-detection");
        var inIframe = require2("../../lib/in-iframe");
        function isBrowserSupported(options) {
          var isKnownUnsupportedMobileBrowser, merchantAllowsDesktopBrowsers, merchantAllowsIosChrome, merchantAllowsReturningToNewBrowserTab, merchantAllowsWebviews;
          var isAndroid = browserDetection.isAndroid();
          var isMobileDevice = isAndroid || browserDetection.isIos();
          var isAndroidChrome = isAndroid && browserDetection.isChrome();
          var isMobileDeviceThatSupportsReturnToSameTab = browserDetection.isIosSafari() || isAndroidChrome;
          options = options || {};
          merchantAllowsDesktopBrowsers = (options.allowDesktopWebLogin || options.allowDesktop) === true;
          merchantAllowsReturningToNewBrowserTab = options.hasOwnProperty("allowNewBrowserTab") ? options.allowNewBrowserTab : true;
          merchantAllowsWebviews = options.hasOwnProperty("allowWebviews") ? options.allowWebviews : true;
          merchantAllowsIosChrome = merchantAllowsReturningToNewBrowserTab && !inIframe();
          isKnownUnsupportedMobileBrowser = !merchantAllowsIosChrome && browserDetection.isIosChrome() || browserDetection.isFacebookOwnedBrowserOnAndroid() || browserDetection.isSamsung();
          if (isKnownUnsupportedMobileBrowser) {
            return false;
          }
          if (!merchantAllowsWebviews && (browserDetection.isAndroidWebview() || browserDetection.isIosWebview())) {
            return false;
          }
          if (!isMobileDevice) {
            return merchantAllowsDesktopBrowsers;
          }
          if (!merchantAllowsReturningToNewBrowserTab) {
            return isMobileDeviceThatSupportsReturnToSameTab;
          }
          return isMobileDevice;
        }
        module2.exports = {
          isBrowserSupported
        };
      }, { "../../lib/in-iframe": 116, "./browser-detection": 151 }], 157: [function(require2, module2, exports2) {
        var frameService = require2("../../lib/frame-service/external");
        var useMin = require2("../../lib/use-min");
        var ExtendedPromise = require2("@braintree/extended-promise");
        var VERSION2 = "3.99.0";
        var VENMO_LOGO_SVG = '<svg width="198" height="58" viewBox="0 0 198 58" fill="none" xmlns="http://www.w3.org/2000/svg">\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M43.0702 13.6572C44.1935 15.4585 44.6999 17.3139 44.6999 19.6576C44.6999 27.1328 38.1277 36.8436 32.7935 43.6625H20.6099L15.7236 15.2939L26.3917 14.3105L28.9751 34.4966C31.389 30.6783 34.3678 24.6779 34.3678 20.587C34.3678 18.3477 33.9727 16.8225 33.3553 15.5666L43.0702 13.6572Z" fill="white"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M56.8965 26.1491C58.8596 26.1491 63.8018 25.2772 63.8018 22.5499C63.8018 21.2402 62.8481 20.587 61.7242 20.587C59.7579 20.587 57.1776 22.8763 56.8965 26.1491ZM56.6715 31.5506C56.6715 34.8807 58.5787 36.1873 61.107 36.1873C63.8603 36.1873 66.4966 35.534 69.923 33.8433L68.6324 42.3523C66.2183 43.4976 62.4559 44.2617 58.8039 44.2617C49.5403 44.2617 46.2249 38.8071 46.2249 31.9879C46.2249 23.1496 51.6179 13.765 62.7365 13.765C68.858 13.765 72.2809 17.0949 72.2809 21.7317C72.2815 29.2066 62.4005 31.4965 56.6715 31.5506Z" fill="white"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M103.067 20.3142C103.067 21.4052 102.897 22.9875 102.727 24.0216L99.5262 43.6622H89.1385L92.0585 25.658C92.1139 25.1696 92.284 24.1865 92.284 23.6411C92.284 22.3314 91.4414 22.0047 90.4282 22.0047C89.0826 22.0047 87.7337 22.6042 86.8354 23.0418L83.5234 43.6625H73.0772L77.8495 14.257H86.8908L87.0052 16.6041C89.1382 15.2404 91.9469 13.7656 95.932 13.7656C101.212 13.765 103.067 16.3845 103.067 20.3142Z" fill="white"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M133.906 16.9841C136.881 14.9131 139.69 13.765 143.563 13.765C148.897 13.765 150.753 16.3845 150.753 20.3142C150.753 21.4052 150.583 22.9875 150.413 24.0216L147.216 43.6622H136.825L139.801 25.2774C139.855 24.786 139.971 24.1865 139.971 23.8063C139.971 22.3317 139.128 22.0047 138.115 22.0047C136.824 22.0047 135.535 22.5501 134.577 23.0418L131.266 43.6625H120.878L123.854 25.2777C123.908 24.7863 124.02 24.1868 124.02 23.8065C124.02 22.332 123.177 22.0049 122.167 22.0049C120.819 22.0049 119.473 22.6045 118.574 23.0421L115.26 43.6628H104.817L109.589 14.2573H118.52L118.8 16.7122C120.878 15.241 123.684 13.7662 127.446 13.7662C130.704 13.765 132.837 15.129 133.906 16.9841Z" fill="white"/>\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M171.426 25.5502C171.426 23.1496 170.808 21.513 168.956 21.513C164.857 21.513 164.015 28.55 164.015 32.1498C164.015 34.8807 164.802 36.5709 166.653 36.5709C170.528 36.5709 171.426 29.1497 171.426 25.5502ZM153.458 31.7152C153.458 22.442 158.511 13.765 170.136 13.765C178.896 13.765 182.098 18.7854 182.098 25.7148C182.098 34.8805 177.099 44.3723 165.194 44.3723C156.378 44.3723 153.458 38.7525 153.458 31.7152Z" fill="white"/>\n</svg>';
        var CONTINUE_OR_CANCEL_INSTRUCTIONS = "Tap cancel payment to cancel and return to the business. Continue payment will relaunch the payment window.";
        var POPUP_WIDTH = 400;
        var POPUP_HEIGHT = 570;
        var ELEMENT_IDS = {
          backdrop: "venmo-desktop-web-backdrop",
          backdropHidden: "venmo-desktop-web-backdrop.hidden",
          backdropContainer: "venmo-backdrop-container",
          cancelButton: "venmo-popup-cancel-button",
          continueButton: "venmo-popup-continue-button",
          message: "venmo-message",
          instructions: "venmo-instructions",
          venmoLogo: "venmo-full-logo"
        };
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function openPopup(options) {
          var frameServiceInstance = options.frameServiceInstance;
          var venmoUrl = options.venmoUrl;
          var checkForStatusChange = options.checkForStatusChange;
          var cancelTokenization = options.cancelTokenization;
          var extendedPromise = new ExtendedPromise();
          document.getElementById(ELEMENT_IDS.continueButton).addEventListener("click", function() {
            frameServiceInstance.focus();
          });
          document.getElementById(ELEMENT_IDS.cancelButton).addEventListener("click", function() {
            frameServiceInstance.close();
            cancelTokenization();
            closeBackdrop();
          });
          frameServiceInstance.open({}, function(frameServiceErr) {
            var retryStartingCount = 1;
            if (frameServiceErr) {
              extendedPromise.reject(frameServiceErr);
            } else {
              checkForStatusChange(retryStartingCount).then(function(data2) {
                extendedPromise.resolve(data2);
              }).catch(function(statusCheckError) {
                extendedPromise.reject(statusCheckError);
              });
            }
            frameServiceInstance.close();
            closeBackdrop();
          });
          frameServiceInstance.redirect(venmoUrl);
          return extendedPromise;
        }
        function centeredPopupDimensions() {
          var popupTop = Math.round((window.outerHeight - POPUP_HEIGHT) / 2) + window.screenTop;
          var popupLeft = Math.round((window.outerWidth - POPUP_WIDTH) / 2) + window.screenLeft;
          return {
            top: popupTop,
            left: popupLeft
          };
        }
        function closeBackdrop() {
          document.getElementById("venmo-desktop-web-backdrop").classList.add("hidden");
        }
        function getElementStyles() {
          var backdropStyles = [
            "#" + ELEMENT_IDS.backdropHidden + " {",
            "display: none;",
            "}",
            "#" + ELEMENT_IDS.backdrop + " {",
            "z-index: 3141592632;",
            "cursor: pointer;",
            "position: fixed;",
            "top: 0;",
            "left: 0;",
            "bottom: 0;",
            "width: 100%;",
            "background: rgba(0, 0, 0, 0.8);",
            "}"
          ];
          var backdropContainerStyles = [
            "#" + ELEMENT_IDS.backdropContainer + " {",
            "display: flex;",
            "align-content: center;",
            "justify-content: center;",
            "align-items: center;",
            "width: 100%;",
            "height: 100%;",
            "flex-direction: column;",
            "}"
          ];
          var cancelButtonStyles = [
            "#" + ELEMENT_IDS.cancelButton + " {",
            "height: 24px;",
            "width: 380px;",
            "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;",
            "font-style: normal;",
            "font-weight: 700;",
            "font-size: 18px;",
            "line-height: 24px;",
            "text-align: center;",
            "background-color: transparent;",
            "border: none;",
            "color: #FFFFFF;",
            "margin-top: 28px;",
            "}"
          ];
          var continueButtonStyles = [
            "#" + ELEMENT_IDS.continueButton + " {",
            "width: 400px;",
            "height: 50px;",
            "background: #0074DE;",
            "border-radius: 24px;",
            "border: none;",
            "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;",
            "font-style: normal;",
            "font-weight: 700;",
            "font-size: 18px;",
            "color: #FFFFFF;",
            "margin-top: 44px;",
            "}"
          ];
          var messageStyles = [
            "#" + ELEMENT_IDS.message + " {",
            "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;",
            "font-style: normal;",
            "font-weight: 500;",
            "font-size: 24px;",
            "line-height: 32px;",
            "text-align: center;",
            "color: #FFFFFF;",
            "margin-top: 32px;",
            "}"
          ];
          var instructionStyles = [
            "#" + ELEMENT_IDS.instructions + " {",
            "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;",
            "font-style: normal;",
            "font-weight: 400;",
            "font-size: 16px;",
            "line-height: 20px;",
            "text-align: center;",
            "color: #FFFFFF;",
            "margin-top: 16px;",
            "width: 400px;",
            "}"
          ];
          var allStyles = backdropStyles.concat(backdropContainerStyles, cancelButtonStyles, continueButtonStyles, messageStyles, instructionStyles);
          return allStyles.join("\n");
        }
        function buildAndStyleElements() {
          var alreadyRenderedBackdrop = document.getElementById(ELEMENT_IDS.backdrop);
          var backdropStylesElement, backdropDiv, backDropContentContainer, venmoLogoDiv, venmoMessageDiv, instructionsDiv, continueButton, cancelButton;
          if (alreadyRenderedBackdrop) {
            alreadyRenderedBackdrop.classList.remove("hidden");
            return;
          }
          backdropStylesElement = document.createElement("style");
          backdropDiv = document.createElement("div");
          backDropContentContainer = document.createElement("div");
          venmoLogoDiv = document.createElement("div");
          venmoMessageDiv = document.createElement("div");
          instructionsDiv = document.createElement("div");
          continueButton = document.createElement("button");
          cancelButton = document.createElement("button");
          backdropStylesElement.id = "venmo-desktop-web__injected-styles";
          backdropStylesElement.innerHTML = getElementStyles();
          backdropDiv.id = ELEMENT_IDS.backdrop;
          backDropContentContainer.id = ELEMENT_IDS.backdropContainer;
          venmoLogoDiv.id = ELEMENT_IDS.venmoLogo;
          venmoLogoDiv.innerHTML = VENMO_LOGO_SVG;
          venmoMessageDiv.id = ELEMENT_IDS.message;
          venmoMessageDiv.innerText = "What would you like to do?";
          instructionsDiv.id = ELEMENT_IDS.instructions;
          instructionsDiv.innerText = CONTINUE_OR_CANCEL_INSTRUCTIONS;
          continueButton.id = ELEMENT_IDS.continueButton;
          continueButton.innerText = "Continue payment";
          cancelButton.id = ELEMENT_IDS.cancelButton;
          cancelButton.innerText = "Cancel payment";
          document.head.appendChild(backdropStylesElement);
          backDropContentContainer.appendChild(venmoLogoDiv);
          backDropContentContainer.appendChild(venmoMessageDiv);
          backDropContentContainer.appendChild(instructionsDiv);
          backDropContentContainer.appendChild(continueButton);
          backDropContentContainer.appendChild(cancelButton);
          backdropDiv.appendChild(backDropContentContainer);
          document.body.appendChild(backdropDiv);
          backdropDiv.addEventListener("click", function(event) {
            event.stopPropagation();
          });
        }
        function runWebLogin(options) {
          buildAndStyleElements();
          return openPopup(options);
        }
        function setupDesktopWebLogin(options) {
          var extendedPromise = new ExtendedPromise();
          var popupName = "venmoDesktopWebLogin";
          var assetsUrl = options.assetsUrl;
          var debug = options.debug || false;
          var popupLocation = centeredPopupDimensions();
          var assetsBaseUrl = assetsUrl + "/web/" + VERSION2 + "/html";
          frameService.create({
            name: popupName,
            dispatchFrameUrl: assetsBaseUrl + "/dispatch-frame" + useMin(debug) + ".html",
            openFrameUrl: assetsBaseUrl + "/venmo-landing-frame" + useMin(debug) + ".html",
            top: popupLocation.top,
            left: popupLocation.left,
            height: POPUP_HEIGHT,
            width: POPUP_WIDTH
          }, function(frameServiceInstance) {
            extendedPromise.resolve(frameServiceInstance);
          });
          return extendedPromise;
        }
        module2.exports = {
          runWebLogin,
          openPopup,
          setupDesktopWebLogin,
          POPUP_WIDTH,
          POPUP_HEIGHT
        };
      }, { "../../lib/frame-service/external": 105, "../../lib/use-min": 126, "@braintree/extended-promise": 38 }], 158: [function(require2, module2, exports2) {
        var analytics = require2("../lib/analytics");
        var isBrowserSupported = require2("./shared/supports-venmo");
        var browserDetection = require2("./shared/browser-detection");
        var constants = require2("./shared/constants");
        var errors = require2("./shared/errors");
        var querystring = require2("../lib/querystring");
        var isVerifiedDomain = require2("../lib/is-verified-domain");
        var methods = require2("../lib/methods");
        var convertMethodsToError = require2("../lib/convert-methods-to-error");
        var wrapPromise = require2("@braintree/wrap-promise");
        var BraintreeError = require2("../lib/braintree-error");
        var inIframe = require2("../lib/in-iframe");
        var ExtendedPromise = require2("@braintree/extended-promise");
        var getVenmoUrl = require2("./shared/get-venmo-url");
        var desktopWebLogin = require2("./shared/web-login-backdrop");
        var snakeCaseToCamelCase = require2("../lib/snake-case-to-camel-case");
        var createVenmoDesktop = require2("./external/");
        var graphqlQueries = require2("./external/queries");
        var VERSION2 = "3.99.0";
        var DEFAULT_MOBILE_POLLING_INTERVAL = 250;
        var DEFAULT_MOBILE_EXPIRING_THRESHOLD = 3e5;
        ExtendedPromise.suppressUnhandledPromiseMessage = true;
        function Venmo(options) {
          var self2 = this;
          this._allowDesktopWebLogin = options.allowDesktopWebLogin || false;
          this._mobileWebFallBack = options.mobileWebFallBack || false;
          this._createPromise = options.createPromise;
          this._allowNewBrowserTab = options.allowNewBrowserTab !== false;
          this._allowWebviews = options.allowWebviews !== false;
          this._allowDesktop = options.allowDesktop === true;
          this._useRedirectForIOS = options.useRedirectForIOS === true;
          this._profileId = options.profileId;
          this._displayName = options.displayName;
          this._deepLinkReturnUrl = options.deepLinkReturnUrl;
          this._ignoreHistoryChanges = options.ignoreHistoryChanges;
          this._paymentMethodUsage = (options.paymentMethodUsage || "").toUpperCase();
          this._shouldUseLegacyFlow = !this._paymentMethodUsage;
          this._requireManualReturn = options.requireManualReturn === true;
          this._useDesktopQRFlow = this._allowDesktop && this._isDesktop() && !this._allowDesktopWebLogin;
          this._useAllowDesktopWebLogin = this._allowDesktopWebLogin && this._isDesktop();
          this._cannotHaveReturnUrls = inIframe() || this._requireManualReturn;
          this._allowAndroidRecreation = options.allowAndroidRecreation !== false;
          this._maxRetryCount = 3;
          this._collectCustomerBillingAddress = options.collectCustomerBillingAddress || false;
          this._collectCustomerShippingAddress = options.collectCustomerShippingAddress || false;
          this._lineItems = options.lineItems;
          this._subTotalAmount = options.subTotalAmount;
          this._discountAmount = options.discountAmount;
          this._taxAmount = options.taxAmount;
          this._shippingAmount = options.shippingAmount;
          this._totalAmount = options.totalAmount;
          this._shouldCreateVenmoPaymentContext = this._cannotHaveReturnUrls || !this._shouldUseLegacyFlow;
          analytics.sendEvent(this._createPromise, "venmo.desktop-flow.configured." + String(Boolean(this._allowDesktop)));
          if (this.hasTokenizationResult()) {
            analytics.sendEvent(this._createPromise, "venmo.appswitch.return-in-new-tab");
          } else if (this._useDesktopQRFlow) {
            this._createPromise = this._createPromise.then(function(client) {
              var config = client.getConfiguration().gatewayConfiguration;
              return createVenmoDesktop({
                url: config.assetsUrl + "/web/" + VERSION2 + "/html/venmo-desktop-frame.html",
                environment: config.environment === "production" ? "PRODUCTION" : "SANDBOX",
                profileId: self2._profileId || config.payWithVenmo.merchantId,
                paymentMethodUsage: self2._paymentMethodUsage,
                displayName: self2._displayName,
                Promise,
                apiRequest: function(query, data2) {
                  return client.request({
                    api: "graphQLApi",
                    data: {
                      query,
                      variables: data2
                    }
                  }).then(function(response) {
                    return response.data;
                  });
                },
                sendEvent: function(eventName) {
                  analytics.sendEvent(self2._createPromise, eventName);
                },
                verifyDomain: isVerifiedDomain
              }).then(function(venmoDesktopInstance) {
                self2._venmoDesktopInstance = venmoDesktopInstance;
                analytics.sendEvent(self2._createPromise, "venmo.desktop-flow.presented");
                return client;
              }).catch(function() {
                analytics.sendEvent(self2._createPromise, "venmo.desktop-flow.setup-failed");
                self2._useDesktopQRFlow = false;
                return client;
              });
            });
          } else if (this._shouldCreateVenmoPaymentContext) {
            this._mobilePollingInterval = DEFAULT_MOBILE_POLLING_INTERVAL;
            this._mobilePollingExpiresThreshold = DEFAULT_MOBILE_EXPIRING_THRESHOLD;
            this._createPromise = this._createPromise.then(function(client) {
              var paymentContextPromise, webLoginPromise;
              var analyticsCategory = self2._cannotHaveReturnUrls ? "manual-return" : "mobile-payment-context";
              var config = client.getConfiguration();
              webLoginPromise = desktopWebLogin.setupDesktopWebLogin({
                assetsUrl: config.gatewayConfiguration.assetsUrl,
                debug: config.isDebug
              }).then(function(frameServiceInstance) {
                self2._frameServiceInstance = frameServiceInstance;
              }).catch(function(desktopWebErr) {
                return desktopWebErr;
              });
              self2._mobilePollingContextEnvironment = config.gatewayConfiguration.environment.toUpperCase();
              paymentContextPromise = self2._createVenmoPaymentContext(client).then(function() {
                analytics.sendEvent(self2._createPromise, "venmo." + analyticsCategory + ".presented");
                return client;
              }).catch(function(err) {
                analytics.sendEvent(self2._createPromise, "venmo." + analyticsCategory + ".setup-failed");
                return Promise.reject(new BraintreeError({
                  type: errors.VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED.type,
                  code: errors.VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED.code,
                  message: isValidationError(err) ? err.details.originalError[0].message : errors.VENMO_MOBILE_PAYMENT_CONTEXT_SETUP_FAILED.message,
                  details: {
                    originalError: err
                  }
                }));
              });
              return ExtendedPromise.all([webLoginPromise, paymentContextPromise]).then(function(results) {
                var paymentContextResult = results[1];
                return Promise.resolve(paymentContextResult);
              }).catch(function(promiseErr) {
                return Promise.reject(promiseErr);
              });
            });
          }
        }
        function isValidationError(err) {
          return err.details && err.details.originalError && err.details.originalError[0] && err.details.originalError[0].extensions && err.details.originalError[0].extensions.errorClass === "VALIDATION" && err.details.originalError[0].extensions.errorType === "user_error";
        }
        Venmo.prototype._createVenmoPaymentContext = function(client, cancelIfTokenizationInProgress) {
          var self2 = this;
          var promise, transactionDetails;
          var configuration = client.getConfiguration();
          var venmoConfiguration = configuration.gatewayConfiguration.payWithVenmo;
          var transactionDetailsPresent = false;
          if (!this._shouldCreateVenmoPaymentContext) {
            return Promise.resolve();
          }
          if (this._shouldUseLegacyFlow) {
            promise = client.request({
              api: "graphQLApi",
              data: {
                query: graphqlQueries.LEGACY_CREATE_PAYMENT_CONTEXT_QUERY,
                variables: {
                  input: {
                    environment: this._mobilePollingContextEnvironment,
                    intent: "PAY_FROM_APP"
                  }
                }
              }
            }).then(function(response) {
              return response.data.createVenmoQRCodePaymentContext.venmoQRCodePaymentContext;
            });
          } else {
            if ((this._collectCustomerBillingAddress || this._collectCustomerShippingAddress) && !venmoConfiguration.enrichedCustomerDataEnabled) {
              return Promise.reject(new BraintreeError(errors.VENMO_ECD_DISABLED));
            }
            if (this._lineItems) {
              this._lineItems.forEach(function(item) {
                item.unitTaxAmount = item.unitTaxAmount || "0";
              });
            }
            transactionDetails = {
              subTotalAmount: this._subTotalAmount,
              discountAmount: this._discountAmount,
              taxAmount: this._taxAmount,
              shippingAmount: this._shippingAmount,
              totalAmount: this._totalAmount,
              lineItems: this._lineItems
            };
            transactionDetailsPresent = Object.keys(transactionDetails).some(function(detail) {
              return transactionDetails[detail] !== void 0;
            });
            promise = client.request({
              api: "graphQLApi",
              data: {
                query: graphqlQueries.CREATE_PAYMENT_CONTEXT_QUERY,
                variables: {
                  input: {
                    paymentMethodUsage: this._paymentMethodUsage,
                    intent: "CONTINUE",
                    customerClient: "MOBILE_WEB",
                    displayName: this._displayName,
                    paysheetDetails: {
                      collectCustomerBillingAddress: this._collectCustomerBillingAddress,
                      collectCustomerShippingAddress: this._collectCustomerShippingAddress,
                      transactionDetails: transactionDetailsPresent ? transactionDetails : void 0
                    }
                  }
                }
              }
            }).then(function(response) {
              return response.data.createVenmoPaymentContext.venmoPaymentContext;
            });
          }
          return promise.then(function(context) {
            var expiredTime = new Date(context.expiresAt) - new Date(context.createdAt);
            var refreshIn = expiredTime * 0.6666;
            clearTimeout(self2._refreshPaymentContextTimeout);
            self2._refreshPaymentContextTimeout = setTimeout(function() {
              if (self2._tokenizationInProgress) {
                return;
              }
              self2._createVenmoPaymentContext(client, true);
            }, refreshIn);
            if (cancelIfTokenizationInProgress && self2._tokenizationInProgress) {
              return;
            }
            self2._venmoPaymentContextStatus = context.status;
            self2._venmoPaymentContextId = context.id;
          });
        };
        Venmo.prototype.appSwitch = function(url) {
          if (this._deepLinkReturnUrl) {
            if (isIosWebviewInDeepLinkReturnUrlFlow()) {
              analytics.sendEvent(this._createPromise, "venmo.appswitch.start.ios-webview");
              window.location.href = url;
            } else if (window.popupBridge && typeof window.popupBridge.open === "function") {
              analytics.sendEvent(this._createPromise, "venmo.appswitch.start.popup-bridge");
              window.popupBridge.open(url);
            } else {
              analytics.sendEvent(this._createPromise, "venmo.appswitch.start.webview");
              window.open(url);
            }
          } else {
            analytics.sendEvent(this._createPromise, "venmo.appswitch.start.browser");
            if (browserDetection.doesNotSupportWindowOpenInIos() || this._shouldUseRedirectStrategy()) {
              window.location.href = url;
            } else {
              window.open(url);
            }
          }
        };
        Venmo.prototype.getUrl = function() {
          return this._createPromise.then(function(client) {
            var configuration = client.getConfiguration();
            var params = {};
            var currentUrl = this._deepLinkReturnUrl || window.location.href.replace(window.location.hash, "");
            var venmoConfiguration = configuration.gatewayConfiguration.payWithVenmo;
            var analyticsMetadata = configuration.analyticsMetadata;
            var accessToken = venmoConfiguration.accessToken;
            var braintreeData = {
              _meta: {
                version: analyticsMetadata.sdkVersion,
                integration: analyticsMetadata.integration,
                platform: analyticsMetadata.platform,
                sessionId: analyticsMetadata.sessionId
              }
            };
            this._isDebug = configuration.isDebug;
            this._assetsUrl = configuration.gatewayConfiguration.assetsUrl;
            currentUrl = currentUrl.replace(/#*$/, "");
            if (this._venmoPaymentContextId) {
              if (this._shouldUseLegacyFlow) {
                accessToken += "|pcid:" + this._venmoPaymentContextId;
              } else {
                params.resource_id = this._venmoPaymentContextId;
              }
            }
            if (this._shouldIncludeReturnUrls() || this._useAllowDesktopWebLogin) {
              if (this._useAllowDesktopWebLogin) {
                currentUrl = this._assetsUrl + "/web/" + VERSION2 + "/html/redirect-frame.html";
              }
              params["x-success"] = currentUrl + "#venmoSuccess=1";
              params["x-cancel"] = currentUrl + "#venmoCancel=1";
              params["x-error"] = currentUrl + "#venmoError=1";
            } else {
              params["x-success"] = "NOOP";
              params["x-cancel"] = "NOOP";
              params["x-error"] = "NOOP";
            }
            if (!this._allowAndroidRecreation) {
              params.allowAndroidRecreation = 0;
            } else {
              params.allowAndroidRecreation = 1;
            }
            params.ua = window.navigator.userAgent;
            params.braintree_merchant_id = this._profileId || venmoConfiguration.merchantId;
            params.braintree_access_token = accessToken;
            params.braintree_environment = venmoConfiguration.environment;
            params.braintree_sdk_data = btoa(JSON.stringify(braintreeData));
            return getVenmoUrl({
              useAllowDesktopWebLogin: this._useAllowDesktopWebLogin,
              mobileWebFallBack: this._mobileWebFallBack
            }) + "?" + querystring.stringify(params);
          }.bind(this));
        };
        Venmo.prototype.isBrowserSupported = function() {
          return isBrowserSupported.isBrowserSupported({
            allowNewBrowserTab: this._allowNewBrowserTab,
            allowWebviews: this._allowWebviews,
            allowDesktop: this._allowDesktop,
            allowDesktopWebLogin: this._allowDesktopWebLogin
          });
        };
        Venmo.prototype.hasTokenizationResult = function() {
          return this._hasTokenizationResult();
        };
        Venmo.prototype._hasTokenizationResult = function(hash) {
          var params = getFragmentParameters(hash);
          return typeof (params.venmoSuccess || params.venmoError || params.venmoCancel) !== "undefined";
        };
        Venmo.prototype._shouldIncludeReturnUrls = function() {
          if (this._deepLinkReturnUrl) {
            return true;
          }
          return !this._cannotHaveReturnUrls;
        };
        Venmo.prototype._isDesktop = function() {
          return !(browserDetection.isIos() || browserDetection.isAndroid());
        };
        Venmo.prototype.tokenize = function(options) {
          var self2 = this;
          var tokenizationPromise;
          options = options || {};
          if (this._tokenizationInProgress === true) {
            return Promise.reject(new BraintreeError(errors.VENMO_TOKENIZATION_REQUEST_ACTIVE));
          }
          this._tokenizationInProgress = true;
          if (this._useDesktopQRFlow) {
            tokenizationPromise = this._tokenizeForDesktopQRFlow(options);
          } else if (this._useAllowDesktopWebLogin) {
            tokenizationPromise = this._tokenizeWebLoginWithRedirect();
          } else if (this._cannotHaveReturnUrls) {
            tokenizationPromise = this._tokenizeForMobileWithManualReturn();
          } else {
            tokenizationPromise = this._tokenizeForMobileWithHashChangeListeners(options);
          }
          return tokenizationPromise.then(function(payload) {
            return self2._createPromise.then(function(client) {
              return self2._createVenmoPaymentContext(client);
            }).then(function() {
              self2._tokenizationInProgress = false;
              return formatTokenizePayload(payload);
            });
          }).catch(function(err) {
            return self2._createPromise.then(function(client) {
              return self2._createVenmoPaymentContext(client);
            }).then(function() {
              self2._tokenizationInProgress = false;
              return Promise.reject(err);
            });
          });
        };
        Venmo.prototype.cancelTokenization = function() {
          if (!this._tokenizationInProgress) {
            return Promise.reject(new BraintreeError(errors.VENMO_TOKENIZATION_REQUEST_NOT_ACTIVE));
          }
          this._removeVisibilityEventListener();
          if (this._tokenizePromise) {
            this._tokenizePromise.reject(new BraintreeError(errors.VENMO_TOKENIZATION_CANCELED_BY_MERCHANT));
          }
          return Promise.all([
            this._cancelMobilePaymentContext(),
            this._cancelVenmoDesktopContext()
          ]);
        };
        Venmo.prototype._tokenizeWebLoginWithRedirect = function() {
          var self2 = this;
          analytics.sendEvent(self2._createPromise, "venmo.tokenize.web-login.start");
          this._tokenizePromise = new ExtendedPromise();
          return this.getUrl().then(function(url) {
            desktopWebLogin.runWebLogin({
              checkForStatusChange: self2._checkPaymentContextStatusAndProcessResult.bind(self2),
              cancelTokenization: self2.cancelTokenization.bind(self2),
              frameServiceInstance: self2._frameServiceInstance,
              venmoUrl: url,
              debug: self2._isDebug
            }).then(function(payload) {
              analytics.sendEvent(self2._createPromise, "venmo.tokenize.web-login.success");
              self2._tokenizePromise.resolve({
                paymentMethodNonce: payload.paymentMethodId,
                username: payload.userName,
                payerInfo: payload.payerInfo,
                id: self2._venmoPaymentContextId
              });
            }).catch(function(err) {
              analytics.sendEvent(self2._createPromise, "venmo.tokenize.web-login.failure");
              self2._tokenizePromise.reject(err);
            });
            return self2._tokenizePromise;
          });
        };
        Venmo.prototype._queryPaymentContextStatus = function(id) {
          var self2 = this;
          return this._createPromise.then(function(client) {
            var query = self2._shouldUseLegacyFlow ? graphqlQueries.LEGACY_VENMO_PAYMENT_CONTEXT_STATUS_QUERY : graphqlQueries.VENMO_PAYMENT_CONTEXT_STATUS_QUERY;
            return client.request({
              api: "graphQLApi",
              data: {
                query,
                variables: {
                  id
                }
              }
            });
          }).then(function(response) {
            return response.data.node;
          });
        };
        Venmo.prototype._checkPaymentContextStatusAndProcessResult = function(retryCount) {
          var self2 = this;
          return self2._queryPaymentContextStatus(self2._venmoPaymentContextId).catch(function(networkError) {
            return Promise.reject(new BraintreeError({
              type: errors.VENMO_NETWORK_ERROR.type,
              code: errors.VENMO_NETWORK_ERROR.code,
              message: errors.VENMO_NETWORK_ERROR.message,
              details: networkError
            }));
          }).then(function(node) {
            var resultStatus = node.status;
            if (resultStatus !== self2._venmoPaymentContextStatus) {
              self2._venmoPaymentContextStatus = resultStatus;
              analytics.sendEvent(self2._createPromise, "venmo.tokenize.web-login.status-change");
              switch (resultStatus) {
                case "APPROVED":
                  return Promise.resolve(node);
                case "CANCELED":
                  return Promise.reject(new BraintreeError(errors.VENMO_CUSTOMER_CANCELED));
                case "FAILED":
                  return Promise.reject(new BraintreeError(errors.VENMO_TOKENIZATION_FAILED));
              }
            }
            return new Promise(function(resolve2, reject) {
              if (retryCount < self2._maxRetryCount) {
                retryCount++;
                return self2._checkPaymentContextStatusAndProcessResult(retryCount).then(resolve2).catch(reject);
              }
              return reject(new BraintreeError(errors.VENMO_TOKENIZATION_FAILED));
            });
          });
        };
        Venmo.prototype._pollForStatusChange = function() {
          var self2 = this;
          if (Date.now() > self2._mobilePollingContextExpiresIn) {
            return Promise.reject(new BraintreeError(errors.VENMO_MOBILE_POLLING_TOKENIZATION_TIMEOUT));
          }
          return this._queryPaymentContextStatus(this._venmoPaymentContextId).catch(function(networkError) {
            return Promise.reject(new BraintreeError({
              type: errors.VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR.type,
              code: errors.VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR.code,
              message: errors.VENMO_MOBILE_POLLING_TOKENIZATION_NETWORK_ERROR.message,
              details: {
                originalError: networkError
              }
            }));
          }).then(function(node) {
            var newStatus = node.status;
            if (newStatus !== self2._venmoPaymentContextStatus) {
              self2._venmoPaymentContextStatus = newStatus;
              analytics.sendEvent(self2._createPromise, "venmo.tokenize.manual-return.status-change." + newStatus.toLowerCase());
              switch (newStatus) {
                case "EXPIRED":
                case "FAILED":
                case "CANCELED":
                  return Promise.reject(new BraintreeError(errors["VENMO_MOBILE_POLLING_TOKENIZATION_" + newStatus]));
                case "APPROVED":
                  return Promise.resolve(node);
              }
            }
            return new Promise(function(resolve2, reject) {
              setTimeout(function() {
                self2._pollForStatusChange().then(resolve2).catch(reject);
              }, self2._mobilePollingInterval);
            });
          });
        };
        Venmo.prototype._tokenizeForMobileWithManualReturn = function() {
          var self2 = this;
          analytics.sendEvent(this._createPromise, "venmo.tokenize.manual-return.start");
          this._mobilePollingContextExpiresIn = Date.now() + this._mobilePollingExpiresThreshold;
          this._tokenizePromise = new ExtendedPromise();
          this._pollForStatusChange().then(function(payload) {
            analytics.sendEvent(self2._createPromise, "venmo.tokenize.manual-return.success");
            self2._tokenizePromise.resolve({
              paymentMethodNonce: payload.paymentMethodId,
              username: payload.userName,
              payerInfo: payload.payerInfo,
              id: self2._venmoPaymentContextId
            });
          }).catch(function(err) {
            analytics.sendEvent(self2._createPromise, "venmo.tokenize.manual-return.failure");
            self2._tokenizePromise.reject(err);
          });
          return this.getUrl().then(function(url) {
            self2.appSwitch(url);
            return self2._tokenizePromise;
          });
        };
        Venmo.prototype._shouldUseRedirectStrategy = function() {
          if (!browserDetection.isIos()) {
            return false;
          }
          if (this._mobileWebFallBack === true) {
            return true;
          }
          return this._useRedirectForIOS;
        };
        Venmo.prototype._tokenizeForMobileWithHashChangeListeners = function(options) {
          var self2 = this;
          var resultProcessingInProgress, visibilityChangeListenerTimeout;
          if (this.hasTokenizationResult()) {
            return this.processHashChangeFlowResults();
          }
          analytics.sendEvent(this._createPromise, "venmo.tokenize.mobile.start");
          this._tokenizePromise = new ExtendedPromise();
          this._previousHash = window.location.hash;
          function completeFlow(hash) {
            var error;
            self2.processHashChangeFlowResults(hash).catch(function(err) {
              error = err;
            }).then(function(res) {
              if (!self2._ignoreHistoryChanges && window.location.hash !== self2._previousHash) {
                window.location.hash = self2._previousHash;
              }
              self2._removeVisibilityEventListener();
              if (error) {
                self2._tokenizePromise.reject(error);
              } else {
                self2._tokenizePromise.resolve(res);
              }
              delete self2._tokenizePromise;
            });
          }
          this._onHashChangeListener = function(e) {
            var hash = e.newURL.split("#")[1];
            if (!self2._hasTokenizationResult(hash)) {
              return;
            }
            resultProcessingInProgress = true;
            clearTimeout(visibilityChangeListenerTimeout);
            completeFlow(hash);
          };
          window.addEventListener("hashchange", this._onHashChangeListener, false);
          this._visibilityChangeListener = function() {
            var delay = options.processResultsDelay || constants.DEFAULT_PROCESS_RESULTS_DELAY;
            if (!window.document.hidden) {
              if (!resultProcessingInProgress) {
                visibilityChangeListenerTimeout = setTimeout(completeFlow, delay);
              }
            }
          };
          return this.getUrl().then(function(url) {
            self2.appSwitch(url);
            setTimeout(function() {
              window.document.addEventListener(documentVisibilityChangeEventName(), self2._visibilityChangeListener);
            }, constants.DOCUMENT_VISIBILITY_CHANGE_EVENT_DELAY);
            return self2._tokenizePromise;
          });
        };
        Venmo.prototype._tokenizeForDesktopQRFlow = function() {
          var self2 = this;
          analytics.sendEvent(this._createPromise, "venmo.tokenize.desktop.start");
          this._tokenizePromise = new ExtendedPromise();
          this._createPromise.then(function() {
            return self2._venmoDesktopInstance.launchDesktopFlow();
          }).then(function(payload) {
            self2._venmoDesktopInstance.hideDesktopFlow();
            analytics.sendEvent(self2._createPromise, "venmo.tokenize.desktop.success");
            self2._tokenizePromise.resolve(payload);
          }).catch(function(err) {
            analytics.sendEvent(self2._createPromise, "venmo.tokenize.desktop.failure");
            if (self2._venmoDesktopInstance) {
              self2._venmoDesktopInstance.hideDesktopFlow();
            }
            if (err && err.reason === "CUSTOMER_CANCELED") {
              self2._tokenizePromise.reject(new BraintreeError(errors.VENMO_DESKTOP_CANCELED));
              return;
            }
            self2._tokenizePromise.reject(new BraintreeError({
              type: errors.VENMO_DESKTOP_UNKNOWN_ERROR.type,
              code: errors.VENMO_DESKTOP_UNKNOWN_ERROR.code,
              message: errors.VENMO_DESKTOP_UNKNOWN_ERROR.message,
              details: {
                originalError: err
              }
            }));
          });
          return this._tokenizePromise;
        };
        Venmo.prototype._cancelMobilePaymentContext = function() {
          var self2 = this;
          return this._createPromise.then(function(client) {
            var query;
            if (self2._venmoPaymentContextId) {
              query = self2._shouldUseLegacyFlow ? graphqlQueries.LEGACY_UPDATE_PAYMENT_CONTEXT_QUERY : graphqlQueries.UPDATE_PAYMENT_CONTEXT_QUERY;
              return client.request({
                api: "graphQLApi",
                data: {
                  query,
                  variables: {
                    input: {
                      id: self2._venmoPaymentContextId,
                      status: "CANCELED"
                    }
                  }
                }
              });
            }
            return Promise.resolve();
          });
        };
        Venmo.prototype._cancelVenmoDesktopContext = function() {
          var self2 = this;
          return this._createPromise.then(function() {
            if (self2._venmoDesktopInstance) {
              self2._venmoDesktopInstance.updateVenmoDesktopPaymentContext("CANCELED");
            }
            return Promise.resolve();
          });
        };
        Venmo.prototype.teardown = function() {
          var self2 = this;
          this._removeVisibilityEventListener();
          return this._createPromise.then(function() {
            if (self2._venmoDesktopInstance) {
              self2._venmoDesktopInstance.teardown();
            }
            clearTimeout(self2._refreshPaymentContextTimeout);
            self2._cancelMobilePaymentContext();
            convertMethodsToError(this, methods(Venmo.prototype));
          }.bind(this));
        };
        Venmo.prototype._removeVisibilityEventListener = function() {
          window.removeEventListener("hashchange", this._onHashChangeListener);
          window.document.removeEventListener(documentVisibilityChangeEventName(), this._visibilityChangeListener);
          delete this._visibilityChangeListener;
          delete this._onHashChangeListener;
        };
        Venmo.prototype.processHashChangeFlowResults = function(hash) {
          var self2 = this;
          var params = getFragmentParameters(hash);
          return new Promise(function(resolve2, reject) {
            if (!self2._shouldUseLegacyFlow) {
              self2._pollForStatusChange().then(function(payload) {
                analytics.sendEvent(self2._createPromise, "venmo.appswitch.handle.payment-context-status-query.success");
                return resolve2({
                  paymentMethodNonce: payload.paymentMethodId,
                  username: payload.userName,
                  payerInfo: payload.payerInfo,
                  id: self2._venmoPaymentContextId
                });
              }).catch(function(err) {
                if (err.type === errors.VENMO_MOBILE_POLLING_TOKENIZATION_CANCELED.type) {
                  reject(err);
                }
                analytics.sendEvent(self2._createPromise, "venmo.process-results.payment-context-status-query-failed");
                resolve2(params);
              });
            } else if (params.venmoSuccess) {
              analytics.sendEvent(self2._createPromise, "venmo.appswitch.handle.success");
              resolve2(params);
            } else if (params.venmoError) {
              analytics.sendEvent(self2._createPromise, "venmo.appswitch.handle.error");
              reject(new BraintreeError({
                type: errors.VENMO_APP_FAILED.type,
                code: errors.VENMO_APP_FAILED.code,
                message: errors.VENMO_APP_FAILED.message,
                details: {
                  originalError: {
                    message: decodeURIComponent(params.errorMessage),
                    code: params.errorCode
                  }
                }
              }));
            } else if (params.venmoCancel) {
              analytics.sendEvent(self2._createPromise, "venmo.appswitch.handle.cancel");
              reject(new BraintreeError(errors.VENMO_APP_CANCELED));
            } else {
              analytics.sendEvent(self2._createPromise, "venmo.appswitch.cancel-or-unavailable");
              reject(new BraintreeError(errors.VENMO_CANCELED));
            }
            self2._clearFragmentParameters();
          });
        };
        Venmo.prototype._clearFragmentParameters = function() {
          if (this._ignoreHistoryChanges) {
            return;
          }
          if (typeof window.history.replaceState === "function" && window.location.hash) {
            history.pushState({}, "", window.location.href.slice(0, window.location.href.indexOf("#")));
          }
        };
        function getFragmentParameters(hash) {
          var keyValuesArray = (hash || window.location.hash.substring(1)).split("&");
          var parsedParams = keyValuesArray.reduce(function(toReturn, keyValue) {
            var parts = keyValue.split("=");
            var decodedKey = decodeURIComponent(parts[0]).replace(/\W/g, "");
            var key = snakeCaseToCamelCase(decodedKey);
            var value = decodeURIComponent(parts[1]);
            toReturn[key] = value;
            return toReturn;
          }, {});
          if (parsedParams.resourceId) {
            parsedParams.id = parsedParams.resourceId;
          }
          return parsedParams;
        }
        function formatUserName(username) {
          username = username || "";
          return "@" + username.replace("@", "");
        }
        function formatTokenizePayload(payload) {
          var formattedPayload = {
            nonce: payload.paymentMethodNonce,
            type: "VenmoAccount",
            details: {
              username: formatUserName(payload.username),
              paymentContextId: payload.id
            }
          };
          if (payload.payerInfo) {
            formattedPayload.details.payerInfo = payload.payerInfo;
            formattedPayload.details.payerInfo.userName = formatUserName(payload.payerInfo.userName);
          }
          return formattedPayload;
        }
        function documentVisibilityChangeEventName() {
          var visibilityChange;
          if (typeof window.document.hidden !== "undefined") {
            visibilityChange = "visibilitychange";
          } else if (typeof window.document.msHidden !== "undefined") {
            visibilityChange = "msvisibilitychange";
          } else if (typeof window.document.webkitHidden !== "undefined") {
            visibilityChange = "webkitvisibilitychange";
          }
          return visibilityChange;
        }
        function isIosWebviewInDeepLinkReturnUrlFlow() {
          return window.navigator.platform && /iPhone|iPad|iPod/.test(window.navigator.platform);
        }
        module2.exports = wrapPromise.wrapPrototype(Venmo);
      }, { "../lib/analytics": 86, "../lib/braintree-error": 91, "../lib/convert-methods-to-error": 93, "../lib/in-iframe": 116, "../lib/is-verified-domain": 119, "../lib/methods": 121, "../lib/querystring": 123, "../lib/snake-case-to-camel-case": 125, "./external/": 147, "./external/queries": 148, "./shared/browser-detection": 151, "./shared/constants": 152, "./shared/errors": 153, "./shared/get-venmo-url": 155, "./shared/supports-venmo": 156, "./shared/web-login-backdrop": 157, "@braintree/extended-promise": 38, "@braintree/wrap-promise": 47 }], 159: [function(require2, module2, exports2) {
        var __assign = this && this.__assign || function() {
          __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p2 in s)
                if (Object.prototype.hasOwnProperty.call(s, p2))
                  t[p2] = s[p2];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        var cardTypes = require2("./lib/card-types");
        var add_matching_cards_to_results_1 = require2("./lib/add-matching-cards-to-results");
        var is_valid_input_type_1 = require2("./lib/is-valid-input-type");
        var find_best_match_1 = require2("./lib/find-best-match");
        var clone_1 = require2("./lib/clone");
        var customCards = {};
        var cardNames = {
          VISA: "visa",
          MASTERCARD: "mastercard",
          AMERICAN_EXPRESS: "american-express",
          DINERS_CLUB: "diners-club",
          DISCOVER: "discover",
          JCB: "jcb",
          UNIONPAY: "unionpay",
          MAESTRO: "maestro",
          ELO: "elo",
          MIR: "mir",
          HIPER: "hiper",
          HIPERCARD: "hipercard"
        };
        var ORIGINAL_TEST_ORDER = [
          cardNames.VISA,
          cardNames.MASTERCARD,
          cardNames.AMERICAN_EXPRESS,
          cardNames.DINERS_CLUB,
          cardNames.DISCOVER,
          cardNames.JCB,
          cardNames.UNIONPAY,
          cardNames.MAESTRO,
          cardNames.ELO,
          cardNames.MIR,
          cardNames.HIPER,
          cardNames.HIPERCARD
        ];
        var testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
        function findType(cardType) {
          return customCards[cardType] || cardTypes[cardType];
        }
        function getAllCardTypes() {
          return testOrder.map(function(cardType) {
            return clone_1.clone(findType(cardType));
          });
        }
        function getCardPosition(name, ignoreErrorForNotExisting) {
          if (ignoreErrorForNotExisting === void 0) {
            ignoreErrorForNotExisting = false;
          }
          var position = testOrder.indexOf(name);
          if (!ignoreErrorForNotExisting && position === -1) {
            throw new Error('"' + name + '" is not a supported card type.');
          }
          return position;
        }
        function creditCardType(cardNumber) {
          var results = [];
          if (!is_valid_input_type_1.isValidInputType(cardNumber)) {
            return results;
          }
          if (cardNumber.length === 0) {
            return getAllCardTypes();
          }
          testOrder.forEach(function(cardType) {
            var cardConfiguration = findType(cardType);
            add_matching_cards_to_results_1.addMatchingCardsToResults(cardNumber, cardConfiguration, results);
          });
          var bestMatch = find_best_match_1.findBestMatch(results);
          if (bestMatch) {
            return [bestMatch];
          }
          return results;
        }
        creditCardType.getTypeInfo = function(cardType) {
          return clone_1.clone(findType(cardType));
        };
        creditCardType.removeCard = function(name) {
          var position = getCardPosition(name);
          testOrder.splice(position, 1);
        };
        creditCardType.addCard = function(config) {
          var existingCardPosition = getCardPosition(config.type, true);
          customCards[config.type] = config;
          if (existingCardPosition === -1) {
            testOrder.push(config.type);
          }
        };
        creditCardType.updateCard = function(cardType, updates) {
          var originalObject = customCards[cardType] || cardTypes[cardType];
          if (!originalObject) {
            throw new Error('"' + cardType + "\" is not a recognized type. Use `addCard` instead.'");
          }
          if (updates.type && originalObject.type !== updates.type) {
            throw new Error("Cannot overwrite type parameter.");
          }
          var clonedCard = clone_1.clone(originalObject);
          clonedCard = __assign(__assign({}, clonedCard), updates);
          customCards[clonedCard.type] = clonedCard;
        };
        creditCardType.changeOrder = function(name, position) {
          var currentPosition = getCardPosition(name);
          testOrder.splice(currentPosition, 1);
          testOrder.splice(position, 0, name);
        };
        creditCardType.resetModifications = function() {
          testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
          customCards = {};
        };
        creditCardType.types = cardNames;
        module2.exports = creditCardType;
      }, { "./lib/add-matching-cards-to-results": 160, "./lib/card-types": 161, "./lib/clone": 162, "./lib/find-best-match": 163, "./lib/is-valid-input-type": 164 }], 160: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.addMatchingCardsToResults = void 0;
        var clone_1 = require2("./clone");
        var matches_1 = require2("./matches");
        function addMatchingCardsToResults(cardNumber, cardConfiguration, results) {
          var i, patternLength;
          for (i = 0; i < cardConfiguration.patterns.length; i++) {
            var pattern = cardConfiguration.patterns[i];
            if (!matches_1.matches(cardNumber, pattern)) {
              continue;
            }
            var clonedCardConfiguration = clone_1.clone(cardConfiguration);
            if (Array.isArray(pattern)) {
              patternLength = String(pattern[0]).length;
            } else {
              patternLength = String(pattern).length;
            }
            if (cardNumber.length >= patternLength) {
              clonedCardConfiguration.matchStrength = patternLength;
            }
            results.push(clonedCardConfiguration);
            break;
          }
        }
        exports2.addMatchingCardsToResults = addMatchingCardsToResults;
      }, { "./clone": 162, "./matches": 165 }], 161: [function(require2, module2, exports2) {
        var cardTypes = {
          visa: {
            niceType: "Visa",
            type: "visa",
            patterns: [4],
            gaps: [4, 8, 12],
            lengths: [16, 18, 19],
            code: {
              name: "CVV",
              size: 3
            }
          },
          mastercard: {
            niceType: "Mastercard",
            type: "mastercard",
            patterns: [[51, 55], [2221, 2229], [223, 229], [23, 26], [270, 271], 2720],
            gaps: [4, 8, 12],
            lengths: [16],
            code: {
              name: "CVC",
              size: 3
            }
          },
          "american-express": {
            niceType: "American Express",
            type: "american-express",
            patterns: [34, 37],
            gaps: [4, 10],
            lengths: [15],
            code: {
              name: "CID",
              size: 4
            }
          },
          "diners-club": {
            niceType: "Diners Club",
            type: "diners-club",
            patterns: [[300, 305], 36, 38, 39],
            gaps: [4, 10],
            lengths: [14, 16, 19],
            code: {
              name: "CVV",
              size: 3
            }
          },
          discover: {
            niceType: "Discover",
            type: "discover",
            patterns: [6011, [644, 649], 65],
            gaps: [4, 8, 12],
            lengths: [16, 19],
            code: {
              name: "CID",
              size: 3
            }
          },
          jcb: {
            niceType: "JCB",
            type: "jcb",
            patterns: [2131, 1800, [3528, 3589]],
            gaps: [4, 8, 12],
            lengths: [16, 17, 18, 19],
            code: {
              name: "CVV",
              size: 3
            }
          },
          unionpay: {
            niceType: "UnionPay",
            type: "unionpay",
            patterns: [
              620,
              [624, 626],
              [62100, 62182],
              [62184, 62187],
              [62185, 62197],
              [62200, 62205],
              [622010, 622999],
              622018,
              [622019, 622999],
              [62207, 62209],
              [622126, 622925],
              [623, 626],
              6270,
              6272,
              6276,
              [627700, 627779],
              [627781, 627799],
              [6282, 6289],
              6291,
              6292,
              810,
              [8110, 8131],
              [8132, 8151],
              [8152, 8163],
              [8164, 8171]
            ],
            gaps: [4, 8, 12],
            lengths: [14, 15, 16, 17, 18, 19],
            code: {
              name: "CVN",
              size: 3
            }
          },
          maestro: {
            niceType: "Maestro",
            type: "maestro",
            patterns: [
              493698,
              [5e5, 504174],
              [504176, 506698],
              [506779, 508999],
              [56, 59],
              63,
              67,
              6
            ],
            gaps: [4, 8, 12],
            lengths: [12, 13, 14, 15, 16, 17, 18, 19],
            code: {
              name: "CVC",
              size: 3
            }
          },
          elo: {
            niceType: "Elo",
            type: "elo",
            patterns: [
              401178,
              401179,
              438935,
              457631,
              457632,
              431274,
              451416,
              457393,
              504175,
              [506699, 506778],
              [509e3, 509999],
              627780,
              636297,
              636368,
              [650031, 650033],
              [650035, 650051],
              [650405, 650439],
              [650485, 650538],
              [650541, 650598],
              [650700, 650718],
              [650720, 650727],
              [650901, 650978],
              [651652, 651679],
              [655e3, 655019],
              [655021, 655058]
            ],
            gaps: [4, 8, 12],
            lengths: [16],
            code: {
              name: "CVE",
              size: 3
            }
          },
          mir: {
            niceType: "Mir",
            type: "mir",
            patterns: [[2200, 2204]],
            gaps: [4, 8, 12],
            lengths: [16, 17, 18, 19],
            code: {
              name: "CVP2",
              size: 3
            }
          },
          hiper: {
            niceType: "Hiper",
            type: "hiper",
            patterns: [637095, 63737423, 63743358, 637568, 637599, 637609, 637612],
            gaps: [4, 8, 12],
            lengths: [16],
            code: {
              name: "CVC",
              size: 3
            }
          },
          hipercard: {
            niceType: "Hipercard",
            type: "hipercard",
            patterns: [606282],
            gaps: [4, 8, 12],
            lengths: [16],
            code: {
              name: "CVC",
              size: 3
            }
          }
        };
        module2.exports = cardTypes;
      }, {}], 162: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.clone = void 0;
        function clone2(originalObject) {
          if (!originalObject) {
            return null;
          }
          return JSON.parse(JSON.stringify(originalObject));
        }
        exports2.clone = clone2;
      }, {}], 163: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.findBestMatch = void 0;
        function hasEnoughResultsToDetermineBestMatch(results) {
          var numberOfResultsWithMaxStrengthProperty = results.filter(function(result) {
            return result.matchStrength;
          }).length;
          return numberOfResultsWithMaxStrengthProperty > 0 && numberOfResultsWithMaxStrengthProperty === results.length;
        }
        function findBestMatch(results) {
          if (!hasEnoughResultsToDetermineBestMatch(results)) {
            return null;
          }
          return results.reduce(function(bestMatch, result) {
            if (!bestMatch) {
              return result;
            }
            if (Number(bestMatch.matchStrength) < Number(result.matchStrength)) {
              return result;
            }
            return bestMatch;
          });
        }
        exports2.findBestMatch = findBestMatch;
      }, {}], 164: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isValidInputType = void 0;
        function isValidInputType(cardNumber) {
          return typeof cardNumber === "string" || cardNumber instanceof String;
        }
        exports2.isValidInputType = isValidInputType;
      }, {}], 165: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.matches = void 0;
        function matchesRange(cardNumber, min, max) {
          var maxLengthToCheck = String(min).length;
          var substr = cardNumber.substr(0, maxLengthToCheck);
          var integerRepresentationOfCardNumber = parseInt(substr, 10);
          min = parseInt(String(min).substr(0, substr.length), 10);
          max = parseInt(String(max).substr(0, substr.length), 10);
          return integerRepresentationOfCardNumber >= min && integerRepresentationOfCardNumber <= max;
        }
        function matchesPattern(cardNumber, pattern) {
          pattern = String(pattern);
          return pattern.substring(0, cardNumber.length) === cardNumber.substring(0, pattern.length);
        }
        function matches(cardNumber, pattern) {
          if (Array.isArray(pattern)) {
            return matchesRange(cardNumber, pattern[0], pattern[1]);
          }
          return matchesPattern(cardNumber, pattern);
        }
        exports2.matches = matches;
      }, {}], 166: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Framebus = void 0;
        var lib_1 = require2("./lib");
        var DefaultPromise = typeof window !== "undefined" && window.Promise;
        var Framebus = function() {
          function Framebus2(options) {
            if (options === void 0) {
              options = {};
            }
            this.origin = options.origin || "*";
            this.channel = options.channel || "";
            this.verifyDomain = options.verifyDomain;
            this.targetFrames = options.targetFrames || [];
            this.limitBroadcastToFramesArray = Boolean(options.targetFrames);
            this.isDestroyed = false;
            this.listeners = [];
            this.hasAdditionalChecksForOnListeners = Boolean(this.verifyDomain || this.limitBroadcastToFramesArray);
          }
          Framebus2.setPromise = function(PromiseGlobal) {
            Framebus2.Promise = PromiseGlobal;
          };
          Framebus2.target = function(options) {
            return new Framebus2(options);
          };
          Framebus2.prototype.addTargetFrame = function(frame) {
            if (!this.limitBroadcastToFramesArray) {
              return;
            }
            this.targetFrames.push(frame);
          };
          Framebus2.prototype.include = function(childWindow) {
            if (childWindow == null) {
              return false;
            }
            if (childWindow.Window == null) {
              return false;
            }
            if (childWindow.constructor !== childWindow.Window) {
              return false;
            }
            lib_1.childWindows.push(childWindow);
            return true;
          };
          Framebus2.prototype.target = function(options) {
            return Framebus2.target(options);
          };
          Framebus2.prototype.emit = function(eventName, data2, reply) {
            if (this.isDestroyed) {
              return false;
            }
            var origin = this.origin;
            eventName = this.namespaceEvent(eventName);
            if ((0, lib_1.isntString)(eventName)) {
              return false;
            }
            if ((0, lib_1.isntString)(origin)) {
              return false;
            }
            if (typeof data2 === "function") {
              reply = data2;
              data2 = void 0;
            }
            var payload = (0, lib_1.packagePayload)(eventName, origin, data2, reply);
            if (!payload) {
              return false;
            }
            if (this.limitBroadcastToFramesArray) {
              this.targetFramesAsWindows().forEach(function(frame) {
                (0, lib_1.sendMessage)(frame, payload, origin);
              });
            } else {
              (0, lib_1.broadcast)(payload, {
                origin,
                frame: window.top || window.self
              });
            }
            return true;
          };
          Framebus2.prototype.emitAsPromise = function(eventName, data2) {
            var _this = this;
            return new Framebus2.Promise(function(resolve2, reject) {
              var didAttachListener = _this.emit(eventName, data2, function(payload) {
                resolve2(payload);
              });
              if (!didAttachListener) {
                reject(new Error('Listener not added for "'.concat(eventName, '"')));
              }
            });
          };
          Framebus2.prototype.on = function(eventName, originalHandler) {
            if (this.isDestroyed) {
              return false;
            }
            var self2 = this;
            var origin = this.origin;
            var handler = originalHandler;
            eventName = this.namespaceEvent(eventName);
            if ((0, lib_1.subscriptionArgsInvalid)(eventName, handler, origin)) {
              return false;
            }
            if (this.hasAdditionalChecksForOnListeners) {
              handler = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                if (!self2.passesVerifyDomainCheck(this && this.origin)) {
                  return;
                }
                if (!self2.hasMatchingTargetFrame(this && this.source)) {
                  return;
                }
                originalHandler.apply(void 0, args);
              };
            }
            this.listeners.push({
              eventName,
              handler,
              originalHandler
            });
            lib_1.subscribers[origin] = lib_1.subscribers[origin] || {};
            lib_1.subscribers[origin][eventName] = lib_1.subscribers[origin][eventName] || [];
            lib_1.subscribers[origin][eventName].push(handler);
            return true;
          };
          Framebus2.prototype.off = function(eventName, originalHandler) {
            var handler = originalHandler;
            if (this.isDestroyed) {
              return false;
            }
            if (this.verifyDomain) {
              for (var i = 0; i < this.listeners.length; i++) {
                var listener = this.listeners[i];
                if (listener.originalHandler === originalHandler) {
                  handler = listener.handler;
                }
              }
            }
            eventName = this.namespaceEvent(eventName);
            var origin = this.origin;
            if ((0, lib_1.subscriptionArgsInvalid)(eventName, handler, origin)) {
              return false;
            }
            var subscriberList = lib_1.subscribers[origin] && lib_1.subscribers[origin][eventName];
            if (!subscriberList) {
              return false;
            }
            for (var i = 0; i < subscriberList.length; i++) {
              if (subscriberList[i] === handler) {
                subscriberList.splice(i, 1);
                return true;
              }
            }
            return false;
          };
          Framebus2.prototype.teardown = function() {
            if (this.isDestroyed) {
              return;
            }
            this.isDestroyed = true;
            for (var i = 0; i < this.listeners.length; i++) {
              var listener = this.listeners[i];
              this.off(listener.eventName, listener.handler);
            }
            this.listeners.length = 0;
          };
          Framebus2.prototype.passesVerifyDomainCheck = function(origin) {
            if (!this.verifyDomain) {
              return true;
            }
            return this.checkOrigin(origin);
          };
          Framebus2.prototype.targetFramesAsWindows = function() {
            if (!this.limitBroadcastToFramesArray) {
              return [];
            }
            return this.targetFrames.map(function(frame) {
              if (frame instanceof HTMLIFrameElement) {
                return frame.contentWindow;
              }
              return frame;
            }).filter(function(win) {
              return win;
            });
          };
          Framebus2.prototype.hasMatchingTargetFrame = function(source2) {
            if (!this.limitBroadcastToFramesArray) {
              return true;
            }
            var matchingFrame = this.targetFramesAsWindows().find(function(frame) {
              return frame === source2;
            });
            return Boolean(matchingFrame);
          };
          Framebus2.prototype.checkOrigin = function(postMessageOrigin) {
            var merchantHost;
            var a = document.createElement("a");
            a.href = location.href;
            if (a.protocol === "https:") {
              merchantHost = a.host.replace(/:443$/, "");
            } else if (a.protocol === "http:") {
              merchantHost = a.host.replace(/:80$/, "");
            } else {
              merchantHost = a.host;
            }
            var merchantOrigin = a.protocol + "//" + merchantHost;
            if (merchantOrigin === postMessageOrigin) {
              return true;
            }
            if (this.verifyDomain) {
              return this.verifyDomain(postMessageOrigin);
            }
            return true;
          };
          Framebus2.prototype.namespaceEvent = function(eventName) {
            if (!this.channel) {
              return eventName;
            }
            return "".concat(this.channel, ":").concat(eventName);
          };
          Framebus2.Promise = DefaultPromise;
          return Framebus2;
        }();
        exports2.Framebus = Framebus;
      }, { "./lib": 174 }], 167: [function(require2, module2, exports2) {
        var lib_1 = require2("./lib");
        var framebus_1 = require2("./framebus");
        (0, lib_1.attach)();
        module2.exports = framebus_1.Framebus;
      }, { "./framebus": 166, "./lib": 174 }], 168: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.detach = exports2.attach = void 0;
        var _1 = require2("./");
        var isAttached = false;
        function attach() {
          if (isAttached || typeof window === "undefined") {
            return;
          }
          isAttached = true;
          window.addEventListener("message", _1.onMessage, false);
        }
        exports2.attach = attach;
        function detach() {
          isAttached = false;
          window.removeEventListener("message", _1.onMessage, false);
        }
        exports2.detach = detach;
      }, { "./": 174 }], 169: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.broadcastToChildWindows = void 0;
        var _1 = require2("./");
        function broadcastToChildWindows(payload, origin, source2) {
          for (var i = _1.childWindows.length - 1; i >= 0; i--) {
            var childWindow = _1.childWindows[i];
            if (childWindow.closed) {
              _1.childWindows.splice(i, 1);
            } else if (source2 !== childWindow) {
              (0, _1.broadcast)(payload, {
                origin,
                frame: childWindow.top
              });
            }
          }
        }
        exports2.broadcastToChildWindows = broadcastToChildWindows;
      }, { "./": 174 }], 170: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.broadcast = void 0;
        var _1 = require2("./");
        function broadcast(payload, options) {
          var i = 0;
          var frameToBroadcastTo;
          var origin = options.origin, frame = options.frame;
          try {
            frame.postMessage(payload, origin);
            if ((0, _1.hasOpener)(frame) && frame.opener.top !== window.top) {
              broadcast(payload, {
                origin,
                frame: frame.opener.top
              });
            }
            while (frameToBroadcastTo = frame.frames[i]) {
              broadcast(payload, {
                origin,
                frame: frameToBroadcastTo
              });
              i++;
            }
          } catch (_) {
          }
        }
        exports2.broadcast = broadcast;
      }, { "./": 174 }], 171: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.subscribers = exports2.childWindows = exports2.prefix = void 0;
        exports2.prefix = "/*framebus*/";
        exports2.childWindows = [];
        exports2.subscribers = {};
      }, {}], 172: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.dispatch = void 0;
        var _1 = require2("./");
        function dispatch(origin, event, data2, reply, e) {
          if (!_1.subscribers[origin]) {
            return;
          }
          if (!_1.subscribers[origin][event]) {
            return;
          }
          var args = [];
          if (data2) {
            args.push(data2);
          }
          if (reply) {
            args.push(reply);
          }
          for (var i = 0; i < _1.subscribers[origin][event].length; i++) {
            _1.subscribers[origin][event][i].apply(e, args);
          }
        }
        exports2.dispatch = dispatch;
      }, { "./": 174 }], 173: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.hasOpener = void 0;
        function hasOpener(frame) {
          if (frame.top !== frame) {
            return false;
          }
          if (frame.opener == null) {
            return false;
          }
          if (frame.opener === frame) {
            return false;
          }
          if (frame.opener.closed === true) {
            return false;
          }
          return true;
        }
        exports2.hasOpener = hasOpener;
      }, {}], 174: [function(require2, module2, exports2) {
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        });
        var __exportStar = this && this.__exportStar || function(m, exports3) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
              __createBinding(exports3, m, p2);
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        __exportStar(require2("./attach"), exports2);
        __exportStar(require2("./broadcast-to-child-windows"), exports2);
        __exportStar(require2("./broadcast"), exports2);
        __exportStar(require2("./constants"), exports2);
        __exportStar(require2("./dispatch"), exports2);
        __exportStar(require2("./has-opener"), exports2);
        __exportStar(require2("./is-not-string"), exports2);
        __exportStar(require2("./message"), exports2);
        __exportStar(require2("./package-payload"), exports2);
        __exportStar(require2("./send-message"), exports2);
        __exportStar(require2("./subscribe-replier"), exports2);
        __exportStar(require2("./subscription-args-invalid"), exports2);
        __exportStar(require2("./types"), exports2);
        __exportStar(require2("./unpack-payload"), exports2);
      }, { "./attach": 168, "./broadcast": 170, "./broadcast-to-child-windows": 169, "./constants": 171, "./dispatch": 172, "./has-opener": 173, "./is-not-string": 175, "./message": 176, "./package-payload": 177, "./send-message": 178, "./subscribe-replier": 179, "./subscription-args-invalid": 180, "./types": 181, "./unpack-payload": 182 }], 175: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isntString = void 0;
        function isntString(str) {
          return typeof str !== "string";
        }
        exports2.isntString = isntString;
      }, {}], 176: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.onMessage = void 0;
        var _1 = require2("./");
        function onMessage(e) {
          if ((0, _1.isntString)(e.data)) {
            return;
          }
          var payload = (0, _1.unpackPayload)(e);
          if (!payload) {
            return;
          }
          var data2 = payload.eventData;
          var reply = payload.reply;
          (0, _1.dispatch)("*", payload.event, data2, reply, e);
          (0, _1.dispatch)(e.origin, payload.event, data2, reply, e);
          (0, _1.broadcastToChildWindows)(e.data, payload.origin, e.source);
        }
        exports2.onMessage = onMessage;
      }, { "./": 174 }], 177: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.packagePayload = void 0;
        var _1 = require2("./");
        function packagePayload(event, origin, data2, reply) {
          var packaged;
          var payload = {
            event,
            origin
          };
          if (typeof reply === "function") {
            payload.reply = (0, _1.subscribeReplier)(reply, origin);
          }
          payload.eventData = data2;
          try {
            packaged = _1.prefix + JSON.stringify(payload);
          } catch (e) {
            throw new Error("Could not stringify event: ".concat(e.message));
          }
          return packaged;
        }
        exports2.packagePayload = packagePayload;
      }, { "./": 174 }], 178: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.sendMessage = void 0;
        function sendMessage(frame, payload, origin) {
          try {
            frame.postMessage(payload, origin);
          } catch (error) {
          }
        }
        exports2.sendMessage = sendMessage;
      }, {}], 179: [function(require2, module2, exports2) {
        var __importDefault = this && this.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.subscribeReplier = void 0;
        var framebus_1 = require2("../framebus");
        var uuid_1 = __importDefault(require2("@braintree/uuid"));
        function subscribeReplier(fn, origin) {
          var uuid = (0, uuid_1.default)();
          function replier(data2, replyOriginHandler) {
            fn(data2, replyOriginHandler);
            framebus_1.Framebus.target({
              origin
            }).off(uuid, replier);
          }
          framebus_1.Framebus.target({
            origin
          }).on(uuid, replier);
          return uuid;
        }
        exports2.subscribeReplier = subscribeReplier;
      }, { "../framebus": 166, "@braintree/uuid": 43 }], 180: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.subscriptionArgsInvalid = void 0;
        var _1 = require2("./");
        function subscriptionArgsInvalid(event, fn, origin) {
          if ((0, _1.isntString)(event)) {
            return true;
          }
          if (typeof fn !== "function") {
            return true;
          }
          return (0, _1.isntString)(origin);
        }
        exports2.subscriptionArgsInvalid = subscriptionArgsInvalid;
      }, { "./": 174 }], 181: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
      }, {}], 182: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.unpackPayload = void 0;
        var _1 = require2("./");
        function unpackPayload(e) {
          var payload;
          if (e.data.slice(0, _1.prefix.length) !== _1.prefix) {
            return false;
          }
          try {
            payload = JSON.parse(e.data.slice(_1.prefix.length));
          } catch (err) {
            return false;
          }
          if (payload.reply) {
            var replyOrigin_1 = e.origin;
            var replySource_1 = e.source;
            var replyEvent_1 = payload.reply;
            payload.reply = function reply(replyData) {
              if (!replySource_1) {
                return;
              }
              var replyPayload = (0, _1.packagePayload)(replyEvent_1, replyOrigin_1, replyData);
              if (!replyPayload) {
                return;
              }
              replySource_1.postMessage(replyPayload, replyOrigin_1);
            };
          }
          return payload;
        }
        exports2.unpackPayload = unpackPayload;
      }, { "./": 174 }], 183: [function(require2, module2, exports2) {
        var process2 = module2.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue2 = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue2 = currentQueue.concat(queue2);
          } else {
            queueIndex = -1;
          }
          if (queue2.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue2.length;
          while (len) {
            currentQueue = queue2;
            queue2 = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue2.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process2.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue2.push(new Item(fun, args));
          if (queue2.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process2.title = "browser";
        process2.browser = true;
        process2.env = {};
        process2.argv = [];
        process2.version = "";
        process2.versions = {};
        function noop2() {
        }
        process2.on = noop2;
        process2.addListener = noop2;
        process2.once = noop2;
        process2.off = noop2;
        process2.removeListener = noop2;
        process2.removeAllListeners = noop2;
        process2.emit = noop2;
        process2.prependListener = noop2;
        process2.prependOnceListener = noop2;
        process2.listeners = function(name) {
          return [];
        };
        process2.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process2.cwd = function() {
          return "/";
        };
        process2.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process2.umask = function() {
          return 0;
        };
      }, {}], 184: [function(require2, module2, exports2) {
        (function(setImmediate2) {
          (function() {
            function finallyConstructor(callback) {
              var constructor = this.constructor;
              return this.then(function(value) {
                return constructor.resolve(callback()).then(function() {
                  return value;
                });
              }, function(reason) {
                return constructor.resolve(callback()).then(function() {
                  return constructor.reject(reason);
                });
              });
            }
            function allSettled(arr) {
              var P = this;
              return new P(function(resolve3, reject2) {
                if (!(arr && typeof arr.length !== "undefined")) {
                  return reject2(new TypeError(typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
                }
                var args = Array.prototype.slice.call(arr);
                if (args.length === 0)
                  return resolve3([]);
                var remaining = args.length;
                function res(i2, val) {
                  if (val && (typeof val === "object" || typeof val === "function")) {
                    var then = val.then;
                    if (typeof then === "function") {
                      then.call(val, function(val2) {
                        res(i2, val2);
                      }, function(e) {
                        args[i2] = { status: "rejected", reason: e };
                        if (--remaining === 0) {
                          resolve3(args);
                        }
                      });
                      return;
                    }
                  }
                  args[i2] = { status: "fulfilled", value: val };
                  if (--remaining === 0) {
                    resolve3(args);
                  }
                }
                for (var i = 0; i < args.length; i++) {
                  res(i, args[i]);
                }
              });
            }
            var setTimeoutFunc = setTimeout;
            function isArray2(x) {
              return Boolean(x && typeof x.length !== "undefined");
            }
            function noop2() {
            }
            function bind3(fn, thisArg) {
              return function() {
                fn.apply(thisArg, arguments);
              };
            }
            function Promise2(fn) {
              if (!(this instanceof Promise2))
                throw new TypeError("Promises must be constructed via new");
              if (typeof fn !== "function")
                throw new TypeError("not a function");
              this._state = 0;
              this._handled = false;
              this._value = void 0;
              this._deferreds = [];
              doResolve(fn, this);
            }
            function handle(self2, deferred) {
              while (self2._state === 3) {
                self2 = self2._value;
              }
              if (self2._state === 0) {
                self2._deferreds.push(deferred);
                return;
              }
              self2._handled = true;
              Promise2._immediateFn(function() {
                var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                if (cb === null) {
                  (self2._state === 1 ? resolve2 : reject)(deferred.promise, self2._value);
                  return;
                }
                var ret;
                try {
                  ret = cb(self2._value);
                } catch (e) {
                  reject(deferred.promise, e);
                  return;
                }
                resolve2(deferred.promise, ret);
              });
            }
            function resolve2(self2, newValue) {
              try {
                if (newValue === self2)
                  throw new TypeError("A promise cannot be resolved with itself.");
                if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                  var then = newValue.then;
                  if (newValue instanceof Promise2) {
                    self2._state = 3;
                    self2._value = newValue;
                    finale(self2);
                    return;
                  } else if (typeof then === "function") {
                    doResolve(bind3(then, newValue), self2);
                    return;
                  }
                }
                self2._state = 1;
                self2._value = newValue;
                finale(self2);
              } catch (e) {
                reject(self2, e);
              }
            }
            function reject(self2, newValue) {
              self2._state = 2;
              self2._value = newValue;
              finale(self2);
            }
            function finale(self2) {
              if (self2._state === 2 && self2._deferreds.length === 0) {
                Promise2._immediateFn(function() {
                  if (!self2._handled) {
                    Promise2._unhandledRejectionFn(self2._value);
                  }
                });
              }
              for (var i = 0, len = self2._deferreds.length; i < len; i++) {
                handle(self2, self2._deferreds[i]);
              }
              self2._deferreds = null;
            }
            function Handler(onFulfilled, onRejected, promise) {
              this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
              this.onRejected = typeof onRejected === "function" ? onRejected : null;
              this.promise = promise;
            }
            function doResolve(fn, self2) {
              var done = false;
              try {
                fn(function(value) {
                  if (done)
                    return;
                  done = true;
                  resolve2(self2, value);
                }, function(reason) {
                  if (done)
                    return;
                  done = true;
                  reject(self2, reason);
                });
              } catch (ex) {
                if (done)
                  return;
                done = true;
                reject(self2, ex);
              }
            }
            Promise2.prototype["catch"] = function(onRejected) {
              return this.then(null, onRejected);
            };
            Promise2.prototype.then = function(onFulfilled, onRejected) {
              var prom = new this.constructor(noop2);
              handle(this, new Handler(onFulfilled, onRejected, prom));
              return prom;
            };
            Promise2.prototype["finally"] = finallyConstructor;
            Promise2.all = function(arr) {
              return new Promise2(function(resolve3, reject2) {
                if (!isArray2(arr)) {
                  return reject2(new TypeError("Promise.all accepts an array"));
                }
                var args = Array.prototype.slice.call(arr);
                if (args.length === 0)
                  return resolve3([]);
                var remaining = args.length;
                function res(i2, val) {
                  try {
                    if (val && (typeof val === "object" || typeof val === "function")) {
                      var then = val.then;
                      if (typeof then === "function") {
                        then.call(val, function(val2) {
                          res(i2, val2);
                        }, reject2);
                        return;
                      }
                    }
                    args[i2] = val;
                    if (--remaining === 0) {
                      resolve3(args);
                    }
                  } catch (ex) {
                    reject2(ex);
                  }
                }
                for (var i = 0; i < args.length; i++) {
                  res(i, args[i]);
                }
              });
            };
            Promise2.allSettled = allSettled;
            Promise2.resolve = function(value) {
              if (value && typeof value === "object" && value.constructor === Promise2) {
                return value;
              }
              return new Promise2(function(resolve3) {
                resolve3(value);
              });
            };
            Promise2.reject = function(value) {
              return new Promise2(function(resolve3, reject2) {
                reject2(value);
              });
            };
            Promise2.race = function(arr) {
              return new Promise2(function(resolve3, reject2) {
                if (!isArray2(arr)) {
                  return reject2(new TypeError("Promise.race accepts an array"));
                }
                for (var i = 0, len = arr.length; i < len; i++) {
                  Promise2.resolve(arr[i]).then(resolve3, reject2);
                }
              });
            };
            Promise2._immediateFn = typeof setImmediate2 === "function" && function(fn) {
              setImmediate2(fn);
            } || function(fn) {
              setTimeoutFunc(fn, 0);
            };
            Promise2._unhandledRejectionFn = function _unhandledRejectionFn(err) {
              if (typeof console !== "undefined" && console) {
                console.warn("Possible Unhandled Promise Rejection:", err);
              }
            };
            module2.exports = Promise2;
          }).call(this);
        }).call(this, require2("timers").setImmediate);
      }, { "timers": 188 }], 185: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.isIos = exports2.isIE9 = exports2.isSamsungBrowser = exports2.isAndroidChrome = exports2.isKitKatWebview = void 0;
        var UA = typeof window !== "undefined" && window.navigator && window.navigator.userAgent;
        var isAndroid = require2("@braintree/browser-detection/is-android");
        var isChromeOs = require2("@braintree/browser-detection/is-chrome-os");
        var isChrome = require2("@braintree/browser-detection/is-chrome");
        var isIos = require2("@braintree/browser-detection/is-ios");
        exports2.isIos = isIos;
        var isIE9 = require2("@braintree/browser-detection/is-ie9");
        exports2.isIE9 = isIE9;
        var KITKAT_WEBVIEW_REGEX = /Version\/\d\.\d* Chrome\/\d*\.0\.0\.0/;
        function isOldSamsungBrowserOrSamsungWebview(ua) {
          return !isChrome(ua) && ua.indexOf("Samsung") > -1;
        }
        function isKitKatWebview(ua) {
          if (ua === void 0) {
            ua = UA;
          }
          return isAndroid(ua) && KITKAT_WEBVIEW_REGEX.test(ua);
        }
        exports2.isKitKatWebview = isKitKatWebview;
        function isAndroidChrome(ua) {
          if (ua === void 0) {
            ua = UA;
          }
          return (isAndroid(ua) || isChromeOs(ua)) && isChrome(ua);
        }
        exports2.isAndroidChrome = isAndroidChrome;
        function isSamsungBrowser(ua) {
          if (ua === void 0) {
            ua = UA;
          }
          return /SamsungBrowser/.test(ua) || isOldSamsungBrowserOrSamsungWebview(ua);
        }
        exports2.isSamsungBrowser = isSamsungBrowser;
      }, { "@braintree/browser-detection/is-android": 25, "@braintree/browser-detection/is-chrome": 27, "@braintree/browser-detection/is-chrome-os": 26, "@braintree/browser-detection/is-ie9": 30, "@braintree/browser-detection/is-ios": 34 }], 186: [function(require2, module2, exports2) {
        var device_1 = require2("./lib/device");
        module2.exports = function supportsInputFormatting() {
          return !(0, device_1.isSamsungBrowser)();
        };
      }, { "./lib/device": 185 }], 187: [function(require2, module2, exports2) {
        module2.exports = require2("./dist/supports-input-formatting");
      }, { "./dist/supports-input-formatting": 186 }], 188: [function(require2, module2, exports2) {
        (function(setImmediate2, clearImmediate) {
          (function() {
            var nextTick2 = require2("process/browser.js").nextTick;
            var apply2 = Function.prototype.apply;
            var slice = Array.prototype.slice;
            var immediateIds = {};
            var nextImmediateId = 0;
            exports2.setTimeout = function() {
              return new Timeout(apply2.call(setTimeout, window, arguments), clearTimeout);
            };
            exports2.setInterval = function() {
              return new Timeout(apply2.call(setInterval, window, arguments), clearInterval);
            };
            exports2.clearTimeout = exports2.clearInterval = function(timeout) {
              timeout.close();
            };
            function Timeout(id, clearFn) {
              this._id = id;
              this._clearFn = clearFn;
            }
            Timeout.prototype.unref = Timeout.prototype.ref = function() {
            };
            Timeout.prototype.close = function() {
              this._clearFn.call(window, this._id);
            };
            exports2.enroll = function(item, msecs) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = msecs;
            };
            exports2.unenroll = function(item) {
              clearTimeout(item._idleTimeoutId);
              item._idleTimeout = -1;
            };
            exports2._unrefActive = exports2.active = function(item) {
              clearTimeout(item._idleTimeoutId);
              var msecs = item._idleTimeout;
              if (msecs >= 0) {
                item._idleTimeoutId = setTimeout(function onTimeout() {
                  if (item._onTimeout)
                    item._onTimeout();
                }, msecs);
              }
            };
            exports2.setImmediate = typeof setImmediate2 === "function" ? setImmediate2 : function(fn) {
              var id = nextImmediateId++;
              var args = arguments.length < 2 ? false : slice.call(arguments, 1);
              immediateIds[id] = true;
              nextTick2(function onNextTick() {
                if (immediateIds[id]) {
                  if (args) {
                    fn.apply(null, args);
                  } else {
                    fn.call(null);
                  }
                  exports2.clearImmediate(id);
                }
              });
              return id;
            };
            exports2.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
              delete immediateIds[id];
            };
          }).call(this);
        }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
      }, { "process/browser.js": 183, "timers": 188 }], 189: [function(require2, module2, exports2) {
        module2.exports = {
          paymentOptionIDs: {
            card: "card",
            paypal: "paypal",
            paypalCredit: "paypalCredit",
            applePay: "applePay",
            venmo: "venmo",
            googlePay: "googlePay"
          },
          paymentMethodTypes: {
            card: "CreditCard",
            paypal: "PayPalAccount",
            paypalCredit: "PayPalAccount",
            applePay: "ApplePayCard",
            venmo: "VenmoAccount",
            googlePay: "AndroidPayCard"
          },
          analyticsKinds: {
            CreditCard: "card",
            PayPalAccount: "paypal",
            ApplePayCard: "applepay",
            VenmoAccount: "venmo",
            AndroidPayCard: "googlepay"
          },
          paymentMethodCardTypes: {
            Visa: "visa",
            MasterCard: "master-card",
            "American Express": "american-express",
            "Diners Club": "diners-club",
            Discover: "discover",
            JCB: "jcb",
            UnionPay: "unionpay",
            Maestro: "maestro",
            Elo: "elo",
            Hiper: "hiper",
            Hipercard: "hipercard"
          },
          cardTypeIcons: {
            visa: "visa",
            mastercard: "master-card",
            "american-express": "american-express",
            "diners-club": "diners-club",
            discover: "discover",
            jcb: "jcb",
            "union-pay": "unionpay",
            maestro: "maestro",
            elo: "elo",
            hiper: "hiper",
            hipercard: "hipercard"
          },
          configurationCardTypes: {
            visa: "Visa",
            "master-card": "MasterCard",
            "american-express": "American Express",
            "diners-club": "Discover",
            discover: "Discover",
            jcb: "JCB",
            unionpay: "UnionPay",
            maestro: "Maestro",
            elo: "Elo",
            hiper: "Hiper",
            hipercard: "Hipercard"
          },
          dependencySetupStates: {
            DONE: "done",
            FAILED: "failed",
            INITIALIZING: "initializing",
            NOT_ENABLED: "not-enabled"
          },
          errors: {
            NO_PAYMENT_METHOD_ERROR: "No payment method is available.",
            DEVELOPER_MISCONFIGURATION_MESSAGE: "Developer Error: Something went wrong. Check the console for details."
          },
          ANALYTICS_REQUEST_TIMEOUT_MS: 2e3,
          ANALYTICS_PREFIX: "web.dropin.",
          CHANGE_ACTIVE_PAYMENT_METHOD_TIMEOUT: 200,
          CHECKOUT_JS_SOURCE: "https://www.paypalobjects.com/api/checkout.min.js",
          GOOGLE_PAYMENT_SOURCE: "https://pay.google.com/gp/p/js/pay.js",
          INTEGRATION: "dropin2",
          PAYPAL_CHECKOUT_SCRIPT_ID: "braintree-dropin-paypal-checkout-script",
          GOOGLE_PAYMENT_SCRIPT_ID: "braintree-dropin-google-payment-script",
          DATA_COLLECTOR_SCRIPT_ID: "braintree-dropin-data-collector-script",
          STYLESHEET_ID: "braintree-dropin-stylesheet"
        };
      }, {}], 190: [function(require2, module2, exports2) {
        var analytics = require2("./lib/analytics");
        var DropinError = require2("./lib/dropin-error");
        var EventEmitter = require2("@braintree/event-emitter");
        var constants = require2("./constants");
        var paymentMethodTypes = constants.paymentMethodTypes;
        var paymentOptionIDs = constants.paymentOptionIDs;
        var dependencySetupStates = constants.dependencySetupStates;
        var isGuestCheckout = require2("./lib/is-guest-checkout");
        var paymentSheetViews = require2("./views/payment-sheet-views");
        var vaultManager = require2("braintree-web/vault-manager");
        var paymentOptionsViewID = require2("./views/payment-options-view").ID;
        var VAULTED_PAYMENT_METHOD_TYPES_THAT_SHOULD_ALWAYS_BE_HIDDEN = [
          paymentMethodTypes.applePay,
          paymentMethodTypes.googlePay,
          paymentMethodTypes.venmo
        ];
        var DEFAULT_PAYMENT_OPTION_PRIORITY = [
          paymentOptionIDs.card,
          paymentOptionIDs.paypal,
          paymentOptionIDs.paypalCredit,
          paymentOptionIDs.venmo,
          paymentOptionIDs.applePay,
          paymentOptionIDs.googlePay
        ];
        var NON_PAYMENT_OPTION_DEPENDENCIES = ["threeDSecure", "dataCollector"];
        var ASYNC_DEPENDENCIES = DEFAULT_PAYMENT_OPTION_PRIORITY.concat(NON_PAYMENT_OPTION_DEPENDENCIES);
        var DEPENDENCY_READY_CHECK_INTERVAL = 200;
        function DropinModel(options) {
          this.rootNode = options.container;
          this.componentID = options.componentID;
          this.merchantConfiguration = options.merchantConfiguration;
          this.isGuestCheckout = isGuestCheckout(options.client);
          this.dependencyStates = ASYNC_DEPENDENCIES.reduce(function(total, dependencyKey) {
            if (this._shouldIncludeDependency(dependencyKey)) {
              total[dependencyKey] = dependencySetupStates.INITIALIZING;
            }
            return total;
          }.bind(this), {});
          this.hiddenVaultedPaymentMethodTypes = constructHiddenPaymentMethodTypes(options.merchantConfiguration.hiddenVaultedPaymentMethodTypes);
          this.failedDependencies = {};
          this._options = options;
          this._setupComplete = false;
          this.shouldWaitForVerifyCard = false;
          while (this.rootNode.parentNode) {
            this.rootNode = this.rootNode.parentNode;
          }
          this.isInShadowDom = this.rootNode.toString() === "[object ShadowRoot]";
          EventEmitter.call(this);
        }
        EventEmitter.createChild(DropinModel);
        DropinModel.prototype.initialize = function() {
          var dep;
          var self2 = this;
          var dependencyReadyInterval = setInterval(function() {
            for (dep in self2.dependencyStates) {
              if (self2.dependencyStates[dep] === dependencySetupStates.INITIALIZING) {
                return;
              }
            }
            clearInterval(dependencyReadyInterval);
            self2._emit("asyncDependenciesReady");
          }, DEPENDENCY_READY_CHECK_INTERVAL);
          return vaultManager.create({
            client: self2._options.client
          }).then(function(vaultManagerInstance) {
            self2._vaultManager = vaultManagerInstance;
            return self2._getSupportedPaymentOptions(self2._options);
          }).then(function(paymentOptions) {
            self2.supportedPaymentOptions = paymentOptions;
            return self2.getVaultedPaymentMethods();
          }).then(function(paymentMethods2) {
            self2._paymentMethods = paymentMethods2;
            self2._paymentMethodIsRequestable = self2._paymentMethods.length > 0;
          });
        };
        DropinModel.prototype.confirmDropinReady = function() {
          this._setupComplete = true;
        };
        DropinModel.prototype.isPaymentMethodRequestable = function() {
          return Boolean(this._paymentMethodIsRequestable);
        };
        DropinModel.prototype.addPaymentMethod = function(paymentMethod) {
          this._paymentMethods.push(paymentMethod);
          this._emit("addPaymentMethod", paymentMethod);
          this.changeActivePaymentMethod(paymentMethod);
        };
        DropinModel.prototype.removePaymentMethod = function(paymentMethod) {
          var paymentMethodLocation = this._paymentMethods.indexOf(paymentMethod);
          if (paymentMethodLocation === -1) {
            return;
          }
          this._paymentMethods.splice(paymentMethodLocation, 1);
          this._emit("removePaymentMethod", paymentMethod);
        };
        DropinModel.prototype.refreshPaymentMethods = function() {
          var self2 = this;
          return self2.getVaultedPaymentMethods().then(function(paymentMethods2) {
            self2._paymentMethods = paymentMethods2;
            self2._emit("refreshPaymentMethods");
          });
        };
        DropinModel.prototype.changeActivePaymentMethod = function(paymentMethod) {
          this._activePaymentMethod = paymentMethod;
          this._emit("changeActivePaymentMethod", paymentMethod);
        };
        DropinModel.prototype.changeActiveView = function(paymentViewID) {
          var previousViewId = this._activePaymentViewId;
          this._activePaymentViewId = paymentViewID;
          this._emit("changeActiveView", {
            previousViewId,
            newViewId: paymentViewID
          });
        };
        DropinModel.prototype.removeActivePaymentMethod = function() {
          this._activePaymentMethod = null;
          this._emit("removeActivePaymentMethod");
          this.setPaymentMethodRequestable({
            isRequestable: false
          });
        };
        DropinModel.prototype.selectPaymentOption = function(paymentViewID) {
          this._emit("paymentOptionSelected", {
            paymentOption: paymentViewID
          });
        };
        DropinModel.prototype.enableEditMode = function() {
          analytics.sendEvent(this._options.client, "manager.appeared");
          this._isInEditMode = true;
          this._emit("enableEditMode");
        };
        DropinModel.prototype.disableEditMode = function() {
          this._isInEditMode = false;
          this._emit("disableEditMode");
        };
        DropinModel.prototype.isInEditMode = function() {
          return Boolean(this._isInEditMode);
        };
        DropinModel.prototype.confirmPaymentMethodDeletion = function(paymentMethod) {
          this._paymentMethodWaitingToBeDeleted = paymentMethod;
          this._emit("confirmPaymentMethodDeletion", paymentMethod);
        };
        DropinModel.prototype._shouldIncludeDependency = function(key) {
          if (key === "card") {
            if (this.merchantConfiguration.card === false) {
              return false;
            }
          } else if (!this.merchantConfiguration[key]) {
            return false;
          }
          if (NON_PAYMENT_OPTION_DEPENDENCIES.indexOf(key) > -1) {
            return true;
          }
          if (this.merchantConfiguration.paymentOptionPriority) {
            return this.merchantConfiguration.paymentOptionPriority.indexOf(key) > -1;
          }
          return DEFAULT_PAYMENT_OPTION_PRIORITY.indexOf(key) > -1;
        };
        DropinModel.prototype._shouldEmitRequestableEvent = function(options) {
          var requestableStateHasNotChanged = this.isPaymentMethodRequestable() === options.isRequestable;
          var nonce = options.selectedPaymentMethod && options.selectedPaymentMethod.nonce;
          var nonceHasNotChanged = nonce === this._paymentMethodRequestableNonce;
          if (!this._setupComplete) {
            return false;
          }
          if (this.shouldWaitForVerifyCard) {
            return false;
          }
          if (requestableStateHasNotChanged && (!options.isRequestable || nonceHasNotChanged)) {
            return false;
          }
          return true;
        };
        DropinModel.prototype.setPaymentMethodRequestable = function(options) {
          var shouldEmitEvent = this._shouldEmitRequestableEvent(options);
          var paymentMethodRequestableResponse = {
            paymentMethodIsSelected: Boolean(options.selectedPaymentMethod),
            type: options.type
          };
          this._paymentMethodIsRequestable = options.isRequestable;
          if (options.isRequestable) {
            this._paymentMethodRequestableNonce = options.selectedPaymentMethod && options.selectedPaymentMethod.nonce;
          } else {
            delete this._paymentMethodRequestableNonce;
          }
          if (!shouldEmitEvent) {
            return;
          }
          if (options.isRequestable) {
            this._emit("paymentMethodRequestable", paymentMethodRequestableResponse);
          } else {
            this._emit("noPaymentMethodRequestable");
          }
        };
        DropinModel.prototype.getPaymentMethods = function() {
          return this._paymentMethods.slice();
        };
        DropinModel.prototype.getActivePaymentMethod = function() {
          return this._activePaymentMethod;
        };
        DropinModel.prototype.hasPaymentMethods = function() {
          return this.getPaymentMethods().length > 0;
        };
        DropinModel.prototype.getInitialViewId = function() {
          if (this.supportedPaymentOptions.length > 1) {
            return paymentOptionsViewID;
          }
          return this.supportedPaymentOptions[0];
        };
        DropinModel.prototype.getActivePaymentViewId = function() {
          return this._activePaymentViewId;
        };
        DropinModel.prototype.reportAppSwitchPayload = function(payload) {
          this.appSwitchPayload = payload;
        };
        DropinModel.prototype.reportAppSwitchError = function(sheetId, error) {
          this.appSwitchError = {
            id: sheetId,
            error
          };
        };
        DropinModel.prototype.hasAtLeastOneAvailablePaymentOption = function() {
          var self2 = this;
          var i;
          for (i = 0; i < this.supportedPaymentOptions.length; i++) {
            if (self2.dependencyStates[this.supportedPaymentOptions[i]] === dependencySetupStates.DONE) {
              return true;
            }
          }
          return false;
        };
        DropinModel.prototype.asyncDependencyReady = function(key) {
          this.dependencyStates[key] = dependencySetupStates.DONE;
        };
        DropinModel.prototype.asyncDependencyFailed = function(options) {
          if (this.failedDependencies.hasOwnProperty(options.view)) {
            return;
          }
          this.failedDependencies[options.view] = options.error;
          this.dependencyStates[options.view] = dependencySetupStates.FAILED;
        };
        DropinModel.prototype.cancelInitialization = function(error) {
          this._emit("cancelInitialization", error);
        };
        DropinModel.prototype.reportError = function(error) {
          this._emit("errorOccurred", error);
        };
        DropinModel.prototype.clearError = function() {
          this._emit("errorCleared");
        };
        DropinModel.prototype.preventUserAction = function() {
          this._emit("preventUserAction");
        };
        DropinModel.prototype.allowUserAction = function() {
          this._emit("allowUserAction");
        };
        DropinModel.prototype.deleteVaultedPaymentMethod = function() {
          var self2 = this;
          var promise = Promise.resolve();
          var error;
          this._emit("startVaultedPaymentMethodDeletion");
          if (!self2.isGuestCheckout) {
            promise = this._vaultManager.deletePaymentMethod(this._paymentMethodWaitingToBeDeleted.nonce).catch(function(err) {
              error = err;
            });
          }
          return promise.then(function() {
            delete self2._paymentMethodWaitingToBeDeleted;
            return self2.refreshPaymentMethods();
          }).then(function() {
            self2.disableEditMode();
            self2._emit("finishVaultedPaymentMethodDeletion", error);
          });
        };
        DropinModel.prototype.cancelDeleteVaultedPaymentMethod = function() {
          this._emit("cancelVaultedPaymentMethodDeletion");
          delete this._paymentMethodWaitingToBeDeleted;
        };
        DropinModel.prototype.getVaultedPaymentMethods = function() {
          var self2 = this;
          if (self2.isGuestCheckout) {
            return Promise.resolve([]);
          }
          return self2._vaultManager.fetchPaymentMethods({
            defaultFirst: this.merchantConfiguration.showDefaultPaymentMethodFirst !== false
          }).then(function(paymentMethods2) {
            return self2._getSupportedPaymentMethods(paymentMethods2).map(function(paymentMethod) {
              paymentMethod.vaulted = true;
              return paymentMethod;
            });
          }).catch(function() {
            return Promise.resolve([]);
          });
        };
        DropinModel.prototype._getSupportedPaymentMethods = function(paymentMethods2) {
          var self2 = this;
          var supportedPaymentMethods = this.supportedPaymentOptions.reduce(function(array, key) {
            var paymentMethodType = paymentMethodTypes[key];
            if (canShowVaultedPaymentMethodType(paymentMethodType, self2.hiddenVaultedPaymentMethodTypes)) {
              array.push(paymentMethodType);
            }
            return array;
          }, []);
          return paymentMethods2.filter(function(paymentMethod) {
            return supportedPaymentMethods.indexOf(paymentMethod.type) > -1;
          });
        };
        DropinModel.prototype._getSupportedPaymentOptions = function(options) {
          var self2 = this;
          var paymentOptionPriority = options.merchantConfiguration.paymentOptionPriority || DEFAULT_PAYMENT_OPTION_PRIORITY;
          var promises;
          if (!(paymentOptionPriority instanceof Array)) {
            throw new DropinError("paymentOptionPriority must be an array.");
          }
          paymentOptionPriority = paymentOptionPriority.filter(function(item, pos) {
            return paymentOptionPriority.indexOf(item) === pos;
          });
          promises = paymentOptionPriority.map(function(paymentOption) {
            return getPaymentOption(paymentOption, options).then(function(result) {
              if (!result.success) {
                self2.dependencyStates[result.id] = dependencySetupStates.NOT_ENABLED;
              }
              return result;
            });
          });
          return Promise.all(promises).then(function(result) {
            result = result.filter(function(item) {
              return item.success;
            });
            if (result.length === 0) {
              return Promise.reject(new DropinError("No valid payment options available."));
            }
            return result.map(function(item) {
              return item.id;
            });
          });
        };
        function getPaymentOption(paymentOption, options) {
          return isPaymentOptionEnabled(paymentOption, options).then(function(success) {
            return {
              success,
              id: paymentOptionIDs[paymentOption]
            };
          });
        }
        function isPaymentOptionEnabled(paymentOption, options) {
          var SheetView = paymentSheetViews[paymentOptionIDs[paymentOption]];
          if (!SheetView) {
            return Promise.reject(new DropinError("paymentOptionPriority: Invalid payment option specified."));
          }
          return SheetView.isEnabled({
            client: options.client,
            merchantConfiguration: options.merchantConfiguration
          }).catch(function(error) {
            console.error(SheetView.ID + " view errored when checking if it was supported.");
            console.error(error);
            return Promise.resolve(false);
          });
        }
        function canShowVaultedPaymentMethodType(paymentMethodType, hiddenVaultedPaymentMethodTypes) {
          return paymentMethodType && hiddenVaultedPaymentMethodTypes.indexOf(paymentMethodType) === -1;
        }
        function constructHiddenPaymentMethodTypes(paymentMethods2) {
          var hiddenVaultedPaymentMethodTypes = [].concat(VAULTED_PAYMENT_METHOD_TYPES_THAT_SHOULD_ALWAYS_BE_HIDDEN);
          if (Array.isArray(paymentMethods2)) {
            paymentMethods2.forEach(function(paymentMethod) {
              var paymentMethodId = paymentMethodTypes[paymentMethod];
              if (!paymentMethodId) {
                return;
              }
              if (hiddenVaultedPaymentMethodTypes.indexOf(paymentMethodId) > -1) {
                return;
              }
              hiddenVaultedPaymentMethodTypes.push(paymentMethodId);
            });
          }
          return hiddenVaultedPaymentMethodTypes;
        }
        module2.exports = DropinModel;
      }, { "./constants": 189, "./lib/analytics": 194, "./lib/dropin-error": 199, "./lib/is-guest-checkout": 201, "./views/payment-options-view": 251, "./views/payment-sheet-views": 256, "@braintree/event-emitter": 37, "braintree-web/vault-manager": 145 }], 191: [function(require2, module2, exports2) {
        var assign2 = require2("./lib/assign").assign;
        var analytics = require2("./lib/analytics");
        var constants = require2("./constants");
        var DropinError = require2("./lib/dropin-error");
        var DropinModel = require2("./dropin-model");
        var EventEmitter = require2("@braintree/event-emitter");
        var assets = require2("@braintree/asset-loader");
        var MainView = require2("./views/main-view");
        var paymentOptionIDs = constants.paymentOptionIDs;
        var translations = require2("./translations").translations;
        var isUtf8 = require2("./lib/is-utf-8");
        var uuid = require2("@braintree/uuid");
        var sanitizeHtml = require2("./lib/sanitize-html");
        var DataCollector = require2("./lib/data-collector");
        var ThreeDSecure = require2("./lib/three-d-secure");
        var wrapPrototype = require2("@braintree/wrap-promise").wrapPrototype;
        var mainHTML = '<div class="braintree-dropin">\n  <div data-braintree-id="methods-label" class="braintree-heading">&nbsp;</div>\n  <div data-braintree-id="methods-edit" class="braintree-hidden braintree-heading" role="button" tabindex="0">{{edit}}</div>\n  <div data-braintree-id="choose-a-way-to-pay" class="braintree-heading">{{chooseAWayToPay}}</div>\n  <div class="braintree-placeholder">&nbsp;</div>\n\n  <div data-braintree-id="upper-container" class="braintree-upper-container">\n    <div data-braintree-id="loading-container" class="braintree-loader__container">\n      <div data-braintree-id="loading-indicator" class="braintree-loader__indicator">\n        <svg width="14" height="16" class="braintree-loader__lock">\n          <use xlink:href="#iconLockLoader"></use>\n        </svg>\n      </div>\n    </div>\n\n    <div data-braintree-id="delete-confirmation" class="braintree-delete-confirmation braintree-sheet">\n      <div data-braintree-id="delete-confirmation__message"></div>\n      <div class="braintree-delete-confirmation__button-container">\n        <div tabindex="0" role="button" data-braintree-id="delete-confirmation__no" class="braintree-delete-confirmation__button">{{deleteCancelButton}}</div>\n        <div tabindex="0" role="button" data-braintree-id="delete-confirmation__yes" class="braintree-delete-confirmation__button">{{deleteConfirmationButton}}</div>\n      </div>\n    </div>\n\n    <div data-braintree-id="methods" class="braintree-methods braintree-methods-initial">\n      <div data-braintree-id="methods-container"></div>\n    </div>\n\n    <div data-braintree-id="options" class="braintree-test-class braintree-options braintree-options-initial">\n      <div data-braintree-id="payment-options-container" class="braintree-options-list"></div>\n    </div>\n\n    <div data-braintree-id="sheet-container" class="braintree-sheet__container">\n      <div data-braintree-id="paypal" class="braintree-paypal braintree-sheet">\n        <div data-braintree-id="paypal-sheet-header" class="braintree-sheet__header">\n          <div class="braintree-sheet__header-label">\n            <div class="braintree-sheet__logo--header">\n              <svg width="40" height="24">\n                <use xlink:href="#logoPayPal"></use>\n              </svg>\n            </div>\n            <div class="braintree-sheet__label">{{PayPal}}</div>\n          </div>\n        </div>\n        <div class="braintree-sheet__content braintree-sheet__content--button">\n          <div data-braintree-id="paypal-button" class="braintree-sheet__button--paypal"></div>\n        </div>\n      </div>\n      <div data-braintree-id="paypalCredit" class="braintree-paypalCredit braintree-sheet">\n        <div data-braintree-id="paypal-credit-sheet-header" class="braintree-sheet__header">\n          <div class="braintree-sheet__header-label">\n            <div class="braintree-sheet__logo--header">\n              <svg width="40" height="24">\n                <use xlink:href="#logoPayPalCredit"></use>\n              </svg>\n            </div>\n            <div class="braintree-sheet__label">{{PayPal Credit}}</div>\n          </div>\n        </div>\n        <div class="braintree-sheet__content braintree-sheet__content--button">\n          <div data-braintree-id="paypal-credit-button" class="braintree-sheet__button--paypal"></div>\n        </div>\n      </div>\n      <div data-braintree-id="applePay" class="braintree-applePay braintree-sheet">\n        <div data-braintree-id="apple-pay-sheet-header" class="braintree-sheet__header">\n          <div class="braintree-sheet__header-label">\n            <div class="braintree-sheet__logo--header">\n              <svg height="24" width="40">\n              <use xlink:href="#logoApplePay"></use>\n              </svg>\n            </div>\n            <div class="braintree-sheet__label">{{Apple Pay}}</div>\n          </div>\n        </div>\n        <div class="braintree-sheet__content braintree-sheet__content--button">\n          <div data-braintree-id="apple-pay-button" class="braintree-sheet__button--apple-pay apple-pay-button"></div>\n        </div>\n      </div>\n      <div data-braintree-id="googlePay" class="braintree-googlePay braintree-sheet">\n        <div data-braintree-id="google-pay-sheet-header" class="braintree-sheet__header">\n          <div class="braintree-sheet__header-label">\n            <div class="braintree-sheet__logo--header">\n              <svg height="24" width="40">\n              <use xlink:href="#logoGooglePay"></use>\n              </svg>\n            </div>\n            <div class="braintree-sheet__label">{{Google Pay}}</div>\n          </div>\n        </div>\n        <div class="braintree-sheet__content braintree-sheet__content--button">\n          <div data-braintree-id="google-pay-button"></div>\n        </div>\n      </div>\n      <div data-braintree-id="venmo" class="braintree-venmo braintree-sheet">\n        <div data-braintree-id="venmo-sheet-header" class="braintree-sheet__header">\n          <div class="braintree-sheet__header-label">\n            <div class="braintree-sheet__logo--header">\n              <svg height="24" width="40">\n              <use xlink:href="#logoVenmo"></use>\n              </svg>\n            </div>\n            <div class="braintree-sheet__label">{{Venmo}}</div>\n          </div>\n        </div>\n        <div class="braintree-sheet__content braintree-sheet__content--button">\n          <svg data-braintree-id="venmo-button" class="braintree-sheet__button--venmo">\n            <use xlink:href="#buttonVenmo"></use>\n          </svg>\n        </div>\n      </div>\n      <div data-braintree-id="card" class="braintree-card braintree-form braintree-sheet">\n        <div data-braintree-id="card-sheet-header" class="braintree-sheet__header">\n          <div class="braintree-sheet__header-label">\n            <div class="braintree-sheet__logo--header">\n              <svg width="40" height="24" class="braintree-icon--bordered" aria-hidden="true">\n                <use xlink:href="#iconCardFront"></use>\n              </svg>\n            </div>\n            <div class="braintree-sheet__text">{{payWithCard}}</div>\n          </div>\n          <div data-braintree-id="card-view-icons" class="braintree-sheet__icons"></div>\n        </div>\n        <div class="braintree-sheet__content braintree-sheet__content--form">\n          <div data-braintree-id="cardholder-name-field-group" class="braintree-form__field-group">\n            <label for="braintree__card-view-input__cardholder-name">\n              <div class="braintree-form__label">{{cardholderNameLabel}}</div>\n              <div class="braintree-form__field">\n                <div class="braintree-form-cardholder-name braintree-form__hosted-field"></div>\n                <div class="braintree-form__icon-container">\n                  <div class="braintree-form__icon braintree-form__field-error-icon">\n                    <svg width="24" height="24">\n                      <use xlink:href="#iconError"></use>\n                    </svg>\n                  </div>\n                </div>\n              </div>\n            </label>\n            <div data-braintree-id="cardholder-name-field-error" class="braintree-form__field-error" role="alert"></div>\n          </div>\n          <div data-braintree-id="number-field-group" class="braintree-form__field-group">\n            <label>\n              <div class="braintree-form__label">{{cardNumberLabel}}</div>\n              <div class="braintree-form__field">\n                <div class="braintree-form-number braintree-form__hosted-field"></div>\n                <div class="braintree-form__icon-container">\n                  <div data-braintree-id="card-number-icon" class="braintree-form__icon braintree-form__field-secondary-icon">\n                    <svg width="40" height="24" class="braintree-icon--bordered">\n                    <use data-braintree-id="card-number-icon-svg" xlink:href="#iconCardFront"></use>\n                    </svg>\n                  </div>\n                  <div class="braintree-form__icon braintree-form__field-error-icon">\n                    <svg width="24" height="24">\n                      <use xlink:href="#iconError"></use>\n                    </svg>\n                  </div>\n                </div>\n              </div>\n            </label>\n            <div data-braintree-id="number-field-error" class="braintree-form__field-error" role="alert"></div>\n          </div>\n\n          <div class="braintree-form__flexible-fields">\n            <div data-braintree-id="expiration-date-field-group" class="braintree-form__field-group">\n              <label>\n                <div class="braintree-form__label">{{expirationDateLabel}}\n                  <span class="braintree-form__descriptor">{{expirationDateLabelSubheading}}</span>\n                </div>\n                <div class="braintree-form__field">\n                  <div class="braintree-form__hosted-field braintree-form-expiration"></div>\n                  <div class="braintree-form__icon-container">\n                    <div class="braintree-form__icon braintree-form__field-error-icon">\n                      <svg width="24" height="24">\n                        <use xlink:href="#iconError"></use>\n                      </svg>\n                    </div>\n                  </div>\n                </div>\n              </label>\n              <div data-braintree-id="expiration-date-field-error" class="braintree-form__field-error" role="alert"></div>\n            </div>\n\n\n            <div data-braintree-id="cvv-field-group" class="braintree-form__field-group">\n              <label>\n                <div class="braintree-form__label">{{cvvLabel}}\n                  <span data-braintree-id="cvv-label-descriptor" class="braintree-form__descriptor">{{cvvThreeDigitLabelSubheading}}</span>\n                </div>\n                <div class="braintree-form__field">\n                  <div class="braintree-form__hosted-field braintree-form-cvv"></div>\n                  <div class="braintree-form__icon-container">\n                    <div data-braintree-id="cvv-icon" class="braintree-form__icon braintree-form__field-secondary-icon">\n                      <svg width="40" height="24" class="braintree-icon--bordered">\n                      <use data-braintree-id="cvv-icon-svg" xlink:href="#iconCVVBack"></use>\n                      </svg>\n                    </div>\n                    <div class="braintree-form__icon braintree-form__field-error-icon">\n                      <svg width="24" height="24">\n                        <use xlink:href="#iconError"></use>\n                      </svg>\n                    </div>\n                  </div>\n                </div>\n              </label>\n              <div data-braintree-id="cvv-field-error" class="braintree-form__field-error" role="alert"></div>\n            </div>\n\n            <div data-braintree-id="postal-code-field-group" class="braintree-form__field-group">\n              <label>\n                <div class="braintree-form__label">{{postalCodeLabel}}</div>\n                <div class="braintree-form__field">\n                  <div class="braintree-form__hosted-field braintree-form-postal-code"></div>\n                  <div class="braintree-form__icon-container">\n                    <div class="braintree-form__icon braintree-form__field-error-icon">\n                      <svg width="24" height="24">\n                        <use xlink:href="#iconError"></use>\n                      </svg>\n                    </div>\n                  </div>\n                </div>\n              </label>\n              <div data-braintree-id="postal-code-field-error" class="braintree-form__field-error" role="alert"></div>\n            </div>\n\n            <div class="braintree-form__notice-of-collection">\n              <a href="https://www.paypal.com/us/legalhub/home" target="_blank" rel="noopener noreferrer">{{noticeOfCollection}}</a>\n            </div>\n          </div>\n\n          <div data-braintree-id="save-card-field-group" class="braintree-form__field-group braintree-hidden">\n            <label>\n              <div class="braintree-form__field braintree-form__checkbox">\n                <input type="checkbox" data-braintree-id="save-card-input" checked />\n              </div>\n              <div class="braintree-form__label">{{saveCardLabel}}</div>\n            </label>\n          </div>\n        </div>\n      </div>\n\n      <div data-braintree-id="sheet-error" class="braintree-sheet__error">\n        <div class="braintree-form__icon braintree-sheet__error-icon">\n          <svg width="24" height="24">\n            <use xlink:href="#iconError"></use>\n          </svg>\n        </div>\n        <div data-braintree-id="sheet-error-text" class="braintree-sheet__error-text"></div>\n      </div>\n    </div>\n  </div>\n\n  <div data-braintree-id="lower-container" class="braintree-test-class braintree-options braintree-hidden">\n    <div data-braintree-id="other-ways-to-pay" class="braintree-heading">{{otherWaysToPay}}</div>\n  </div>\n\n  <div data-braintree-id="toggle" class="braintree-large-button braintree-toggle braintree-hidden" tabindex="0" role="button">\n    <span>{{chooseAnotherWayToPay}}</span>\n  </div>\n</div>\n<div data-braintree-id="disable-wrapper" class="braintree-dropin__disabled braintree-hidden"></div>\n';
        var svgHTML = '<svg data-braintree-id="svgs">\n  <defs>\n    <symbol id="icon-visa" viewBox="0 0 44 14.2">\n      <title>Visa</title>\n      <path fill="#1434CB" d="M16.8,0.2L11,13.9H7.3L4.5,3C4.3,2.3,4.2,2.1,3.6,1.8C2.8,1.3,1.4,0.9,0.1,0.6l0.1-0.4h6   c0.8,0,1.5,0.5,1.6,1.4l1.5,7.9L13,0.2H16.8z M31.4,9.4c0-3.6-5-3.8-5-5.4c0-0.5,0.5-1,1.5-1.1c0.5-0.1,1.9-0.1,3.5,0.6L32,0.6   C31.2,0.3,30.1,0,28.7,0c-3.5,0-6,1.9-6,4.5c0,2,1.8,3.1,3.1,3.7c1.4,0.7,1.8,1.1,1.8,1.7c0,0.9-1.1,1.3-2.1,1.3   c-1.8,0-2.8-0.5-3.6-0.9l-0.6,3c0.8,0.4,2.3,0.7,3.9,0.7C28.9,14.1,31.4,12.3,31.4,9.4 M40.6,13.9h3.3L41,0.2h-3   c-0.7,0-1.3,0.4-1.5,1l-5.3,12.7h3.7l0.7-2h4.5L40.6,13.9z M36.7,9.1l1.9-5.1l1.1,5.1H36.7z M21.8,0.2l-2.9,13.7h-3.5l2.9-13.7   H21.8z"/>\n    </symbol>\n\n    <symbol id="icon-master-card" viewBox="0 0 40 24">\n      <title>MasterCard</title>\n      <path d="M0 1.927C0 .863.892 0 1.992 0h36.016C39.108 0 40 .863 40 1.927v20.146C40 23.137 39.108 24 38.008 24H1.992C.892 24 0 23.137 0 22.073V1.927z" fill="#FFF" />\n      <path d="M11.085 22.2v-1.36c0-.522-.318-.863-.864-.863-.272 0-.568.09-.773.386-.16-.25-.386-.386-.727-.386-.228 0-.455.068-.637.318v-.272h-.478V22.2h.478v-1.202c0-.386.204-.567.523-.567.318 0 .478.205.478.568V22.2h.477v-1.202c0-.386.23-.567.524-.567.32 0 .478.205.478.568V22.2h.523zm7.075-2.177h-.774v-.658h-.478v.658h-.432v.43h.432v.998c0 .5.205.795.75.795.206 0 .433-.068.592-.16l-.136-.407c-.136.09-.296.114-.41.114-.227 0-.318-.137-.318-.363v-.976h.774v-.43zm4.048-.046c-.273 0-.454.136-.568.318v-.272h-.478V22.2h.478v-1.225c0-.363.16-.567.455-.567.09 0 .204.023.295.046l.137-.454c-.09-.023-.228-.023-.32-.023zm-6.118.227c-.228-.16-.546-.227-.888-.227-.546 0-.91.272-.91.703 0 .363.274.567.75.635l.23.023c.25.045.385.113.385.227 0 .16-.182.272-.5.272-.32 0-.57-.113-.728-.227l-.228.363c.25.18.59.272.932.272.637 0 1-.295 1-.703 0-.385-.295-.59-.75-.658l-.227-.022c-.205-.023-.364-.068-.364-.204 0-.16.16-.25.41-.25.272 0 .545.114.682.182l.205-.386zm12.692-.227c-.273 0-.455.136-.568.318v-.272h-.478V22.2h.478v-1.225c0-.363.16-.567.455-.567.09 0 .203.023.294.046L29.1 20c-.09-.023-.227-.023-.318-.023zm-6.096 1.134c0 .66.455 1.135 1.16 1.135.32 0 .546-.068.774-.25l-.228-.385c-.182.136-.364.204-.57.204-.385 0-.658-.272-.658-.703 0-.407.273-.68.66-.702.204 0 .386.068.568.204l.228-.385c-.228-.182-.455-.25-.774-.25-.705 0-1.16.477-1.16 1.134zm4.413 0v-1.087h-.48v.272c-.158-.204-.385-.318-.68-.318-.615 0-1.093.477-1.093 1.134 0 .66.478 1.135 1.092 1.135.317 0 .545-.113.68-.317v.272h.48v-1.09zm-1.753 0c0-.384.25-.702.66-.702.387 0 .66.295.66.703 0 .387-.273.704-.66.704-.41-.022-.66-.317-.66-.703zm-5.71-1.133c-.636 0-1.09.454-1.09 1.134 0 .682.454 1.135 1.114 1.135.32 0 .638-.09.888-.295l-.228-.34c-.18.136-.41.227-.636.227-.296 0-.592-.136-.66-.522h1.615v-.18c.022-.704-.388-1.158-1.002-1.158zm0 .41c.297 0 .502.18.547.52h-1.137c.045-.295.25-.52.59-.52zm11.852.724v-1.95h-.48v1.135c-.158-.204-.385-.318-.68-.318-.615 0-1.093.477-1.093 1.134 0 .66.478 1.135 1.092 1.135.318 0 .545-.113.68-.317v.272h.48v-1.09zm-1.752 0c0-.384.25-.702.66-.702.386 0 .66.295.66.703 0 .387-.274.704-.66.704-.41-.022-.66-.317-.66-.703zm-15.97 0v-1.087h-.476v.272c-.16-.204-.387-.318-.683-.318-.615 0-1.093.477-1.093 1.134 0 .66.478 1.135 1.092 1.135.318 0 .545-.113.682-.317v.272h.477v-1.09zm-1.773 0c0-.384.25-.702.66-.702.386 0 .66.295.66.703 0 .387-.274.704-.66.704-.41-.022-.66-.317-.66-.703z" fill="#000" />\n      <path fill="#FF5F00" d="M23.095 3.49H15.93v12.836h7.165" />\n      <path d="M16.382 9.91c0-2.61 1.23-4.922 3.117-6.42-1.39-1.087-3.14-1.745-5.05-1.745-4.528 0-8.19 3.65-8.19 8.164 0 4.51 3.662 8.162 8.19 8.162 1.91 0 3.66-.657 5.05-1.746-1.89-1.474-3.118-3.81-3.118-6.417z" fill="#EB001B" />\n      <path d="M32.76 9.91c0 4.51-3.664 8.162-8.19 8.162-1.91 0-3.662-.657-5.05-1.746 1.91-1.496 3.116-3.81 3.116-6.417 0-2.61-1.228-4.922-3.116-6.42 1.388-1.087 3.14-1.745 5.05-1.745 4.526 0 8.19 3.674 8.19 8.164z" fill="#F79E1B" />\n    </symbol>\n\n    <symbol id="icon-unionpay" viewBox="0 0 40 24">\n      <title>Union Pay</title>\n      <path d="M38.333 24H1.667C.75 24 0 23.28 0 22.4V1.6C0 .72.75 0 1.667 0h36.666C39.25 0 40 .72 40 1.6v20.8c0 .88-.75 1.6-1.667 1.6z" fill="#FFF" />\n      <path d="M9.877 2h8.126c1.135 0 1.84.93 1.575 2.077l-3.783 16.35c-.267 1.142-1.403 2.073-2.538 2.073H5.13c-1.134 0-1.84-.93-1.574-2.073L7.34 4.076C7.607 2.93 8.74 2 9.878 2z" fill="#E21836" />\n      <path d="M17.325 2h9.345c1.134 0 .623.93.356 2.077l-3.783 16.35c-.265 1.142-.182 2.073-1.32 2.073H12.58c-1.137 0-1.84-.93-1.574-2.073l3.783-16.35C15.056 2.93 16.19 2 17.324 2z" fill="#00447B" />\n      <path d="M26.3 2h8.126c1.136 0 1.84.93 1.575 2.077l-3.782 16.35c-.266 1.142-1.402 2.073-2.54 2.073h-8.122c-1.137 0-1.842-.93-1.574-2.073l3.78-16.35C24.03 2.93 25.166 2 26.303 2z" fill="#007B84" />\n      <path d="M27.633 14.072l-.99 3.3h.266l-.208.68h-.266l-.062.212h-.942l.064-.21H23.58l.193-.632h.194l1.005-3.35.2-.676h.962l-.1.34s.255-.184.498-.248c.242-.064 1.636-.088 1.636-.088l-.206.672h-.33zm-1.695 0l-.254.843s.285-.13.44-.172c.16-.04.395-.057.395-.057l.182-.614h-.764zm-.38 1.262l-.263.877s.29-.15.447-.196c.157-.037.396-.066.396-.066l.185-.614h-.766zm-.614 2.046h.767l.222-.74h-.765l-.223.74z" fill="#FEFEFE" />\n      <path d="M28.055 13.4h1.027l.01.385c-.005.065.05.096.17.096h.208l-.19.637h-.555c-.48.035-.662-.172-.65-.406l-.02-.71zM28.193 16.415h-.978l.167-.566H28.5l.16-.517h-1.104l.19-.638h3.072l-.193.638h-1.03l-.16.516h1.032l-.17.565H29.18l-.2.24h.454l.11.712c.013.07.014.116.036.147.023.026.158.038.238.038h.137l-.21.694h-.348c-.054 0-.133-.004-.243-.01-.105-.008-.18-.07-.25-.105-.064-.03-.16-.11-.182-.24l-.11-.712-.507.7c-.162.222-.38.39-.748.39h-.712l.186-.62h.273c.078 0 .15-.03.2-.056.052-.023.098-.05.15-.126l.74-1.05zM17.478 14.867h2.59l-.19.622H18.84l-.16.53h1.06l-.194.64h-1.06l-.256.863c-.03.095.25.108.353.108l.53-.072-.212.71h-1.193c-.096 0-.168-.013-.272-.037-.1-.023-.145-.07-.19-.138-.043-.07-.11-.128-.064-.278l.343-1.143h-.588l.195-.65h.592l.156-.53h-.588l.188-.623zM19.223 13.75h1.063l-.194.65H18.64l-.157.136c-.067.066-.09.038-.18.087-.08.04-.254.123-.477.123h-.466l.19-.625h.14c.118 0 .198-.01.238-.036.046-.03.098-.096.157-.203l.267-.487h1.057l-.187.356zM20.74 13.4h.905l-.132.46s.286-.23.487-.313c.2-.075.65-.143.65-.143l1.464-.007-.498 1.672c-.085.286-.183.472-.244.555-.055.087-.12.16-.248.23-.124.066-.236.104-.34.115-.096.007-.244.01-.45.012h-1.41l-.4 1.324c-.037.13-.055.194-.03.23.02.03.068.066.135.066l.62-.06-.21.726h-.698c-.22 0-.383-.004-.495-.013-.108-.01-.22 0-.295-.058-.065-.058-.164-.133-.162-.21.007-.073.037-.192.082-.356l1.268-4.23zm1.922 1.69h-1.484l-.09.3h1.283c.152-.018.184.004.196-.003l.096-.297zm-1.402-.272s.29-.266.786-.353c.112-.022.82-.015.82-.015l.106-.357h-1.496l-.216.725z" fill="#FEFEFE" />\n      <path d="M23.382 16.1l-.084.402c-.036.125-.067.22-.16.302-.1.084-.216.172-.488.172l-.502.02-.004.455c-.006.13.028.117.048.138.024.022.045.032.067.04l.157-.008.48-.028-.198.663h-.552c-.385 0-.67-.008-.765-.084-.092-.057-.105-.132-.103-.26l.035-1.77h.88l-.013.362h.212c.072 0 .12-.007.15-.026.027-.02.047-.048.06-.093l.087-.282h.692zM10.84 7.222c-.032.143-.596 2.763-.598 2.764-.12.53-.21.91-.508 1.152-.172.14-.37.21-.6.21-.37 0-.587-.185-.624-.537l-.007-.12.113-.712s.593-2.388.7-2.703c.002-.017.005-.026.007-.035-1.152.01-1.357 0-1.37-.018-.007.024-.037.173-.037.173l-.605 2.688-.05.23-.1.746c0 .22.042.4.13.553.275.485 1.06.557 1.504.557.573 0 1.11-.123 1.47-.345.63-.375.797-.962.944-1.48l.067-.267s.61-2.48.716-2.803c.003-.017.006-.026.01-.035-.835.01-1.08 0-1.16-.018zM14.21 12.144c-.407-.006-.55-.006-1.03.018l-.018-.036c.042-.182.087-.363.127-.548l.06-.25c.086-.39.173-.843.184-.98.007-.084.036-.29-.2-.29-.1 0-.203.048-.307.096-.058.207-.174.79-.23 1.055-.118.558-.126.62-.178.897l-.036.037c-.42-.006-.566-.006-1.05.018l-.024-.04c.08-.332.162-.668.24-.998.203-.9.25-1.245.307-1.702l.04-.028c.47-.067.585-.08 1.097-.185l.043.047-.077.287c.086-.052.168-.104.257-.15.242-.12.51-.155.658-.155.223 0 .468.062.57.323.098.232.034.52-.094 1.084l-.066.287c-.13.627-.152.743-.225 1.174l-.05.036zM15.87 12.144c-.245 0-.405-.006-.56 0-.153 0-.303.008-.532.018l-.013-.02-.015-.02c.062-.238.097-.322.128-.406.03-.084.06-.17.115-.41.072-.315.116-.535.147-.728.033-.187.052-.346.075-.53l.02-.014.02-.018c.244-.036.4-.057.56-.082.16-.024.32-.055.574-.103l.008.023.008.022c-.047.195-.094.39-.14.588-.047.197-.094.392-.137.587-.093.414-.13.57-.152.68-.02.105-.026.163-.063.377l-.022.02-.023.017zM19.542 10.728c.143-.633.033-.928-.108-1.11-.213-.273-.59-.36-.978-.36-.235 0-.793.023-1.23.43-.312.29-.458.687-.546 1.066-.088.387-.19 1.086.447 1.344.198.085.48.108.662.108.466 0 .945-.13 1.304-.513.278-.312.405-.775.448-.965zm-1.07-.046c-.02.106-.113.503-.24.673-.086.123-.19.198-.305.198-.033 0-.235 0-.238-.3-.003-.15.027-.304.063-.47.108-.478.236-.88.56-.88.255 0 .27.298.16.78zM29.536 12.187c-.493-.004-.635-.004-1.09.015l-.03-.037c.124-.472.248-.943.358-1.42.142-.62.175-.882.223-1.244l.037-.03c.49-.07.625-.09 1.135-.186l.015.044c-.093.388-.186.777-.275 1.166-.19.816-.258 1.23-.33 1.658l-.044.035z" fill="#FEFEFE" />\n      <path d="M29.77 10.784c.144-.63-.432-.056-.525-.264-.14-.323-.052-.98-.62-1.2-.22-.085-.732.025-1.17.428-.31.29-.458.683-.544 1.062-.088.38-.19 1.078.444 1.328.2.085.384.11.567.103.638-.034 1.124-1.002 1.483-1.386.277-.303.326.115.368-.07zm-.974-.047c-.024.1-.117.503-.244.67-.083.117-.283.192-.397.192-.032 0-.232 0-.24-.3 0-.146.03-.3.067-.467.11-.47.235-.87.56-.87.254 0 .363.293.254.774zM22.332 12.144c-.41-.006-.55-.006-1.03.018l-.018-.036c.04-.182.087-.363.13-.548l.057-.25c.09-.39.176-.843.186-.98.008-.084.036-.29-.198-.29-.1 0-.203.048-.308.096-.057.207-.175.79-.232 1.055-.115.558-.124.62-.176.897l-.035.037c-.42-.006-.566-.006-1.05.018l-.022-.04.238-.998c.203-.9.25-1.245.307-1.702l.038-.028c.472-.067.587-.08 1.098-.185l.04.047-.073.287c.084-.052.17-.104.257-.15.24-.12.51-.155.655-.155.224 0 .47.062.575.323.095.232.03.52-.098 1.084l-.065.287c-.133.627-.154.743-.225 1.174l-.05.036zM26.32 8.756c-.07.326-.282.603-.554.736-.225.114-.498.123-.78.123h-.183l.013-.074.336-1.468.01-.076.007-.058.132.015.71.062c.275.105.388.38.31.74zM25.88 7.22l-.34.003c-.883.01-1.238.006-1.383-.012l-.037.182-.315 1.478-.793 3.288c.77-.01 1.088-.01 1.22.004l.21-1.024s.153-.644.163-.667c0 0 .047-.066.096-.092h.07c.665 0 1.417 0 2.005-.437.4-.298.675-.74.797-1.274.03-.132.054-.29.054-.446 0-.205-.04-.41-.16-.568-.3-.423-.896-.43-1.588-.433zM33.572 9.28l-.04-.043c-.502.1-.594.118-1.058.18l-.034.034-.005.023-.003-.007c-.345.803-.334.63-.615 1.26-.003-.03-.003-.048-.004-.077l-.07-1.37-.044-.043c-.53.1-.542.118-1.03.18l-.04.034-.006.056.003.007c.06.315.047.244.108.738.03.244.065.49.093.73.05.4.077.6.134 1.21-.328.55-.408.757-.722 1.238l.017.044c.478-.018.587-.018.94-.018l.08-.088c.265-.578 2.295-4.085 2.295-4.085zM16.318 9.62c.27-.19.304-.45.076-.586-.23-.137-.634-.094-.906.095-.273.186-.304.45-.075.586.228.134.633.094.905-.096z" fill="#FEFEFE" />\n      <path d="M31.238 13.415l-.397.684c-.124.232-.357.407-.728.41l-.632-.01.184-.618h.124c.064 0 .11-.004.148-.022.03-.01.054-.035.08-.072l.233-.373h.988z" fill="#FEFEFE" />\n    </symbol>\n\n    <symbol id="icon-american-express" viewBox="0 0 40 24">\n      <title>American Express</title>\n      <path d="M38.333 24H1.667C.75 24 0 23.28 0 22.4V1.6C0 .72.75 0 1.667 0h36.666C39.25 0 40 .72 40 1.6v20.8c0 .88-.75 1.6-1.667 1.6z" fill="#FFF" />\n      <path fill="#1478BE" d="M6.26 12.32h2.313L7.415 9.66M27.353 9.977h-3.738v1.23h3.666v1.384h-3.675v1.385h3.821v1.005c.623-.77 1.33-1.466 2.025-2.235l.707-.77c-.934-1.004-1.87-2.08-2.804-3.075v1.077z" />\n      <path d="M38.25 7h-5.605l-1.328 1.4L30.072 7H16.984l-1.017 2.416L14.877 7h-9.58L1.25 16.5h4.826l.623-1.556h1.4l.623 1.556H29.99l1.327-1.483 1.328 1.483h5.605l-4.36-4.667L38.25 7zm-17.685 8.1h-1.557V9.883L16.673 15.1h-1.33L13.01 9.883l-.084 5.217H9.73l-.623-1.556h-3.27L5.132 15.1H3.42l2.884-6.772h2.42l2.645 6.233V8.33h2.646l2.107 4.51 1.868-4.51h2.575V15.1zm14.727 0h-2.024l-2.024-2.26-2.023 2.26H22.06V8.328H29.53l1.795 2.177 2.024-2.177h2.025L32.26 11.75l3.032 3.35z" fill="#1478BE" />\n    </symbol>\n\n    <symbol id="icon-jcb" viewBox="0 0 40 24">\n      <title>JCB</title>\n      <path d="M38.333 24H1.667C.75 24 0 23.28 0 22.4V1.6C0 .72.75 0 1.667 0h36.666C39.25 0 40 .72 40 1.6v20.8c0 .88-.75 1.6-1.667 1.6z" fill="#FFF" />\n      <path d="M33.273 2.01h.013v17.062c-.004 1.078-.513 2.103-1.372 2.746-.63.47-1.366.67-2.14.67-.437 0-4.833.026-4.855 0-.01-.01 0-.07 0-.082v-6.82c0-.04.004-.064.033-.064h5.253c.867 0 1.344-.257 1.692-.61.44-.448.574-1.162.294-1.732-.24-.488-.736-.78-1.244-.913-.158-.04-.32-.068-.483-.083-.01 0-.064 0-.07-.006-.03-.034.023-.04.038-.046.102-.033.215-.042.32-.073.532-.164.993-.547 1.137-1.105.15-.577-.05-1.194-.524-1.552-.34-.257-.768-.376-1.187-.413-.43-.038-4.774-.022-5.21-.022-.072 0-.05-.02-.05-.09V5.63c0-.31.01-.616.073-.92.126-.592.41-1.144.815-1.59.558-.615 1.337-1.01 2.16-1.093.478-.048 4.89-.017 5.305-.017zm-4.06 8.616c.06.272-.01.567-.204.77-.173.176-.407.25-.648.253-.195.003-1.725 0-1.788 0l.003-1.645c.012-.027.02-.018.06-.018.097 0 1.713-.004 1.823.005.232.02.45.12.598.306.076.096.128.208.155.328zm-2.636 2.038h1.944c.242.002.47.063.652.228.226.204.327.515.283.815-.04.263-.194.5-.422.634-.187.112-.39.125-.6.125h-1.857v-1.8z" fill="#53B230" />\n      <path d="M6.574 13.89c-.06-.03-.06-.018-.07-.06-.006-.026-.005-8.365.003-8.558.04-.95.487-1.857 1.21-2.47.517-.434 1.16-.71 1.83-.778.396-.04.803-.018 1.2-.018.69 0 4.11-.013 4.12 0 .008.008.002 16.758 0 17.074-.003.956-.403 1.878-1.105 2.523-.506.465-1.15.77-1.83.86-.41.056-5.02.032-5.363.032-.066 0-.054.013-.066-.024-.01-.025 0-7 0-7.17.66.178 1.35.28 2.03.348.662.067 1.33.093 1.993.062.93-.044 1.947-.192 2.712-.762.32-.238.574-.553.73-.922.148-.353.2-.736.2-1.117 0-.348.006-3.93-.016-3.942-.023-.014-2.885-.015-2.9.012-.012.022 0 3.87 0 3.95-.003.47-.16.933-.514 1.252-.468.42-1.11.47-1.707.423-.687-.055-1.357-.245-1.993-.508-.157-.065-.312-.135-.466-.208z" fill="#006CB9" />\n      <path d="M15.95 9.835c-.025.02-.05.04-.072.06V6.05c0-.295-.012-.594.01-.888.12-1.593 1.373-2.923 2.944-3.126.382-.05 5.397-.042 5.41-.026.01.01 0 .062 0 .074v16.957c0 1.304-.725 2.52-1.89 3.1-.504.25-1.045.35-1.605.35-.322 0-4.757.015-4.834 0-.05-.01-.023.01-.035-.02-.007-.022 0-6.548 0-7.44v-.422c.554.48 1.256.75 1.96.908.536.12 1.084.176 1.63.196.537.02 1.076.01 1.61-.037.546-.05 1.088-.136 1.625-.244.137-.028.274-.057.41-.09.033-.006.17-.017.187-.044.013-.02 0-.097 0-.12v-1.324c-.582.292-1.19.525-1.83.652-.778.155-1.64.198-2.385-.123-.752-.326-1.2-1.024-1.274-1.837-.076-.837.173-1.716.883-2.212.736-.513 1.7-.517 2.553-.38.634.1 1.245.305 1.825.58.078.037.154.075.23.113V9.322c0-.02.013-.1 0-.118-.02-.028-.152-.038-.188-.046-.066-.016-.133-.03-.2-.045C22.38 9 21.84 8.908 21.3 8.85c-.533-.06-1.068-.077-1.603-.066-.542.01-1.086.054-1.62.154-.662.125-1.32.337-1.883.716-.085.056-.167.117-.245.18z" fill="#E20138" />\n    </symbol>\n\n    <symbol id="icon-discover" viewBox="0 0 40 24">\n      <title>Discover</title>\n      <path d="M38.333 24H1.667C.75 24 0 23.28 0 22.4V1.6C0 .72.75 0 1.667 0h36.666C39.25 0 40 .72 40 1.6v20.8c0 .88-.75 1.6-1.667 1.6z" fill="#FFF" />\n      <path d="M38.995 11.75S27.522 20.1 6.5 23.5h31.495c.552 0 1-.448 1-1V11.75z" fill="#F48024" />\n      <path d="M5.332 11.758c-.338.305-.776.438-1.47.438h-.29V8.55h.29c.694 0 1.115.124 1.47.446.37.33.595.844.595 1.372 0 .53-.224 1.06-.595 1.39zM4.077 7.615H2.5v5.515h1.57c.833 0 1.435-.197 1.963-.637.63-.52 1-1.305 1-2.116 0-1.628-1.214-2.762-2.956-2.762zM7.53 13.13h1.074V7.616H7.53M11.227 9.732c-.645-.24-.834-.397-.834-.695 0-.347.338-.61.8-.61.322 0 .587.132.867.446l.562-.737c-.462-.405-1.015-.612-1.618-.612-.975 0-1.718.678-1.718 1.58 0 .76.346 1.15 1.355 1.513.42.148.635.247.743.314.215.14.322.34.322.57 0 .448-.354.78-.834.78-.51 0-.924-.258-1.17-.736l-.695.67c.495.726 1.09 1.05 1.907 1.05 1.116 0 1.9-.745 1.9-1.812 0-.876-.363-1.273-1.585-1.72zM13.15 10.377c0 1.62 1.27 2.877 2.907 2.877.462 0 .858-.09 1.347-.32v-1.267c-.43.43-.81.604-1.297.604-1.082 0-1.85-.785-1.85-1.9 0-1.06.792-1.895 1.8-1.895.512 0 .9.183 1.347.62V7.83c-.472-.24-.86-.34-1.322-.34-1.627 0-2.932 1.283-2.932 2.887zM25.922 11.32l-1.468-3.705H23.28l2.337 5.656h.578l2.38-5.655H27.41M29.06 13.13h3.046v-.934h-1.973v-1.488h1.9v-.934h-1.9V8.55h1.973v-.935H29.06M34.207 10.154h-.314v-1.67h.33c.67 0 1.034.28 1.034.818 0 .554-.364.852-1.05.852zm2.155-.91c0-1.033-.71-1.628-1.95-1.628H32.82v5.514h1.073v-2.215h.14l1.487 2.215h1.32l-1.733-2.323c.81-.165 1.255-.72 1.255-1.563z" fill="#221F20" />\n      <path d="M23.6 10.377c0 1.62-1.31 2.93-2.927 2.93-1.617.002-2.928-1.31-2.928-2.93s1.31-2.932 2.928-2.932c1.618 0 2.928 1.312 2.928 2.932z" fill="#F48024" />\n    </symbol>\n\n    <symbol id="icon-diners-club" viewBox="0 0 40 24">\n      <title>Diners Club</title>\n      <path d="M38.333 24H1.667C.75 24 0 23.28 0 22.4V1.6C0 .72.75 0 1.667 0h36.666C39.25 0 40 .72 40 1.6v20.8c0 .88-.75 1.6-1.667 1.6z" fill="#FFF" />\n      <path d="M9.02 11.83c0-5.456 4.54-9.88 10.14-9.88 5.6 0 10.139 4.424 10.139 9.88-.002 5.456-4.54 9.88-10.14 9.88-5.6 0-10.14-4.424-10.14-9.88z" fill="#FEFEFE" />\n      <path fill="#FFF" d="M32.522 22H8.5V1.5h24.022" />\n      <path d="M25.02 11.732c-.003-2.534-1.607-4.695-3.868-5.55v11.102c2.26-.857 3.865-3.017 3.87-5.552zm-8.182 5.55V6.18c-2.26.86-3.86 3.017-3.867 5.55.007 2.533 1.61 4.69 3.868 5.55zm2.158-14.934c-5.25.002-9.503 4.202-9.504 9.384 0 5.182 4.254 9.38 9.504 9.382 5.25 0 9.504-4.2 9.505-9.382 0-5.182-4.254-9.382-9.504-9.384zM18.973 22C13.228 22.027 8.5 17.432 8.5 11.84 8.5 5.726 13.228 1.5 18.973 1.5h2.692c5.677 0 10.857 4.225 10.857 10.34 0 5.59-5.18 10.16-10.857 10.16h-2.692z" fill="#004A97" />\n    </symbol>\n\n    <symbol id="icon-maestro" viewBox="0 0 40 24">\n      <title>Maestro</title>\n      <path d="M38.333 24H1.667C.75 24 0 23.28 0 22.4V1.6C0 .72.75 0 1.667 0h36.666C39.25 0 40 .72 40 1.6v20.8c0 .88-.75 1.6-1.667 1.6z" fill="#FFF" />\n      <path d="M14.67 22.39V21c.022-.465-.303-.86-.767-.882h-.116c-.3-.023-.603.14-.788.394-.164-.255-.442-.417-.743-.394-.256-.023-.51.116-.65.324v-.278h-.487v2.203h.487v-1.183c-.046-.278.162-.533.44-.58h.094c.325 0 .488.21.488.58v1.23h.487v-1.23c-.047-.278.162-.556.44-.58h.093c.325 0 .487.21.487.58v1.23l.534-.024zm2.712-1.09v-1.113h-.487v.28c-.162-.21-.417-.326-.695-.326-.65 0-1.16.51-1.16 1.16 0 .65.51 1.16 1.16 1.16.278 0 .533-.117.695-.325v.278h.487V21.3zm-1.786 0c.024-.37.348-.65.72-.626.37.023.65.348.626.72-.023.347-.302.625-.673.625-.372 0-.674-.28-.674-.65-.023-.047-.023-.047 0-.07zm12.085-1.16c.163 0 .325.024.465.094.14.046.278.14.37.255.117.115.186.23.256.37.117.3.117.626 0 .927-.046.14-.138.255-.254.37-.116.117-.232.186-.37.256-.303.116-.65.116-.952 0-.14-.046-.28-.14-.37-.255-.118-.116-.187-.232-.257-.37-.116-.302-.116-.627 0-.928.047-.14.14-.255.256-.37.115-.117.23-.187.37-.256.163-.07.325-.116.488-.093zm0 .465c-.092 0-.185.023-.278.046-.092.024-.162.094-.232.14-.07.07-.116.14-.14.232-.068.185-.068.394 0 .58.024.092.094.162.14.23.07.07.14.117.232.14.186.07.37.07.557 0 .092-.023.16-.092.23-.14.07-.068.117-.138.14-.23.07-.186.07-.395 0-.58-.023-.093-.093-.162-.14-.232-.07-.07-.138-.116-.23-.14-.094-.045-.187-.07-.28-.045zm-7.677.695c0-.695-.44-1.16-1.043-1.16-.65 0-1.16.534-1.137 1.183.023.65.534 1.16 1.183 1.136.325 0 .65-.093.905-.302l-.23-.348c-.187.14-.42.232-.65.232-.326.023-.627-.21-.673-.533h1.646v-.21zm-1.646-.21c.023-.3.278-.532.58-.532.3 0 .556.232.556.533h-1.136zm3.664-.346c-.207-.116-.44-.186-.695-.186-.255 0-.417.093-.417.255 0 .163.162.186.37.21l.233.022c.488.07.766.278.766.672 0 .395-.37.72-1.02.72-.348 0-.673-.094-.95-.28l.23-.37c.21.162.465.232.743.232.324 0 .51-.094.51-.28 0-.115-.117-.185-.395-.23l-.232-.024c-.487-.07-.765-.302-.765-.65 0-.44.37-.718.927-.718.325 0 .627.07.905.232l-.21.394zm2.32-.116h-.788v.997c0 .23.07.37.325.37.14 0 .3-.046.417-.115l.14.417c-.186.116-.395.162-.604.162-.58 0-.765-.302-.765-.812v-1.02h-.44v-.44h.44v-.673h.487v.672h.79v.44zm1.67-.51c.117 0 .233.023.35.07l-.14.463c-.093-.045-.21-.045-.302-.045-.325 0-.464.208-.464.58v1.25h-.487v-2.2h.487v.277c.116-.255.325-.37.557-.394z" fill="#000" />\n      <path fill="#7673C0" d="M23.64 3.287h-7.305V16.41h7.306" />\n      <path d="M16.8 9.848c0-2.55 1.183-4.985 3.2-6.56C16.384.435 11.12 1.06 8.29 4.7 5.435 8.32 6.06 13.58 9.703 16.41c3.038 2.387 7.283 2.387 10.32 0-2.04-1.578-3.223-3.99-3.223-6.562z" fill="#EB001B" />\n      <path d="M33.5 9.848c0 4.613-3.735 8.346-8.35 8.346-1.88 0-3.69-.626-5.15-1.785 3.618-2.83 4.245-8.092 1.415-11.71-.418-.532-.882-.996-1.415-1.413C23.618.437 28.883 1.06 31.736 4.7 32.873 6.163 33.5 7.994 33.5 9.85z" fill="#00A1DF" />\n    </symbol>\n\n    <symbol id="icon-elo" viewBox="0 0 48 29">\n      <title>Elo</title>\n      <path d="M46.177 29H1.823C.9 29 0 28.13 0 27.187V1.813C0 .87.9 0 1.823 0h44.354C47.1 0 48 .87 48 1.813v25.375C48 28.13 47.1 29 46.177 29z" fill="#FFF" />\n      <path d="M4.8 9.14c0-.427.57-.973 1.067-.973h7.466c.496 0 1.067.546 1.067.972v3.888c0 .425-.57.972-1.067.972H5.867c-.496 0-1.067-.547-1.067-.972v-3.89z" fill="#828282" />\n      <rect fill="#828282" x="10.8" y="22.167" width="3.6" height="2.333" rx="1.167" />\n      <rect fill="#828282" x="4.8" y="22.167" width="3.6" height="2.333" rx="1.167" />\n      <path d="M6.55 16.333h34.9c.966 0 1.75.784 1.75 1.75 0 .967-.784 1.75-1.75 1.75H6.55c-.966 0-1.75-.783-1.75-1.75 0-.966.784-1.75 1.75-1.75z" fill="#828282" />\n      <ellipse fill="#828282" cx="40.2" cy="6.417" rx="3" ry="2.917" />\n    </symbol>\n\n    <symbol id="icon-hiper" viewBox="0 0 48 29">\n      <title>Hiper</title>\n      <path d="M46.177 29H1.823C.9 29 0 28.13 0 27.187V1.813C0 .87.9 0 1.823 0h44.354C47.1 0 48 .87 48 1.813v25.375C48 28.13 47.1 29 46.177 29z" fill="#FFF" />\n      <path d="M4.8 9.14c0-.427.57-.973 1.067-.973h7.466c.496 0 1.067.546 1.067.972v3.888c0 .425-.57.972-1.067.972H5.867c-.496 0-1.067-.547-1.067-.972v-3.89z" fill="#828282" />\n      <rect fill="#828282" x="10.8" y="22.167" width="3.6" height="2.333" rx="1.167" />\n      <rect fill="#828282" x="4.8" y="22.167" width="3.6" height="2.333" rx="1.167" />\n      <path d="M6.55 16.333h34.9c.966 0 1.75.784 1.75 1.75 0 .967-.784 1.75-1.75 1.75H6.55c-.966 0-1.75-.783-1.75-1.75 0-.966.784-1.75 1.75-1.75z" fill="#828282" />\n      <ellipse fill="#828282" cx="40.2" cy="6.417" rx="3" ry="2.917" />\n    </symbol>\n\n    <symbol id="icon-hipercard" viewBox="0 0 48 29">\n      <title>Hipercard</title>\n      <path d="M46.177 29H1.823C.9 29 0 28.13 0 27.187V1.813C0 .87.9 0 1.823 0h44.354C47.1 0 48 .87 48 1.813v25.375C48 28.13 47.1 29 46.177 29z" fill="#FFF" />\n      <path d="M4.8 9.14c0-.427.57-.973 1.067-.973h7.466c.496 0 1.067.546 1.067.972v3.888c0 .425-.57.972-1.067.972H5.867c-.496 0-1.067-.547-1.067-.972v-3.89z" fill="#828282" />\n      <rect fill="#828282" x="10.8" y="22.167" width="3.6" height="2.333" rx="1.167" />\n      <rect fill="#828282" x="4.8" y="22.167" width="3.6" height="2.333" rx="1.167" />\n      <path d="M6.55 16.333h34.9c.966 0 1.75.784 1.75 1.75 0 .967-.784 1.75-1.75 1.75H6.55c-.966 0-1.75-.783-1.75-1.75 0-.966.784-1.75 1.75-1.75z" fill="#828282" />\n      <ellipse fill="#828282" cx="40.2" cy="6.417" rx="3" ry="2.917" />\n    </symbol>\n\n    <symbol id="logoPayPal" viewBox="0 0 48 29">\n      <title>PayPal Logo</title>\n      <path d="M46 29H2c-1.1 0-2-.87-2-1.932V1.934C0 .87.9 0 2 0h44c1.1 0 2 .87 2 1.934v25.134C48 28.13 47.1 29 46 29z" fill-opacity="0" fill="#FFF" />\n      <path d="M31.216 16.4c.394-.7.69-1.5.886-2.4.196-.8.196-1.6.1-2.2-.1-.7-.396-1.2-.79-1.7-.195-.3-.59-.5-.885-.7.1-.8.1-1.5 0-2.1-.1-.6-.394-1.1-.886-1.6-.885-1-2.56-1.6-4.922-1.6h-6.4c-.492 0-.787.3-.886.8l-2.658 17.2c0 .2 0 .3.1.4.097.1.294.2.393.2h4.036l-.295 1.8c0 .1 0 .3.1.4.098.1.195.2.393.2h3.35c.393 0 .688-.3.786-.7v-.2l.59-4.1v-.2c.1-.4.395-.7.788-.7h.59c1.675 0 3.152-.4 4.137-1.1.59-.5 1.083-1 1.478-1.7h-.002z" fill="#263B80" />\n      <path d="M21.364 9.4c0-.3.196-.5.492-.6.098-.1.196-.1.394-.1h5.02c.592 0 1.183 0 1.675.1.1 0 .295.1.394.1.098 0 .294.1.393.1.1 0 .1 0 .197.102.295.1.492.2.69.3.295-1.6 0-2.7-.887-3.8-.985-1.1-2.658-1.6-4.923-1.6h-6.4c-.49 0-.885.3-.885.8l-2.758 17.3c-.098.3.197.6.59.6h3.94l.985-6.4 1.083-6.9z" fill="#263B80" />\n      <path d="M30.523 9.4c0 .1 0 .3-.098.4-.887 4.4-3.742 5.9-7.484 5.9h-1.87c-.492 0-.787.3-.886.8l-.985 6.2-.296 1.8c0 .3.196.6.492.6h3.348c.394 0 .69-.3.787-.7v-.2l.592-4.1v-.2c.1-.4.394-.7.787-.7h.69c3.248 0 5.808-1.3 6.497-5.2.296-1.6.197-3-.69-3.9-.196-.3-.49-.5-.885-.7z" fill="#159BD7" />\n      <path d="M29.635 9c-.098 0-.295-.1-.394-.1-.098 0-.294-.1-.393-.1-.492-.102-1.083-.102-1.673-.102h-5.022c-.1 0-.197 0-.394.1-.198.1-.394.3-.492.6l-1.083 6.9v.2c.1-.5.492-.8.886-.8h1.87c3.742 0 6.598-1.5 7.484-5.9 0-.1 0-.3.098-.4-.196-.1-.492-.2-.69-.3 0-.1-.098-.1-.196-.1z" fill="#232C65" />\n    </symbol>\n\n    <symbol id="logoPayPalCredit" viewBox="0 0 48 29">\n      <title>PayPal Credit Logo</title>\n      <path d="M46 29H2c-1.1 0-2-.87-2-1.932V1.934C0 .87.9 0 2 0h44c1.1 0 2 .87 2 1.934v25.134C48 28.13 47.1 29 46 29z" fill-opacity="0" fill="#FFF" fill-rule="nonzero" />\n      <path d="M27.44 21.6h.518c1.377 0 2.67-.754 2.953-2.484.248-1.588-.658-2.482-2.14-2.482h-.38c-.093 0-.172.067-.187.16l-.763 4.805zm-1.254-6.646c.024-.158.16-.273.32-.273h2.993c2.47 0 4.2 1.942 3.81 4.436-.4 2.495-2.752 4.436-5.21 4.436h-3.05c-.116 0-.205-.104-.187-.218l1.323-8.38zM22.308 16.907l-.192 1.21h2.38c.116 0 .204.103.186.217l-.23 1.462c-.023.157-.16.273-.318.273h-2.048c-.16 0-.294.114-.32.27l-.203 1.26h2.52c.117 0 .205.102.187.217l-.228 1.46c-.025.16-.16.275-.32.275h-4.55c-.116 0-.204-.104-.186-.218l1.322-8.38c.025-.158.16-.273.32-.273h4.55c.116 0 .205.104.187.22l-.23 1.46c-.024.158-.16.274-.32.274H22.63c-.16 0-.295.115-.32.273M35.325 23.552h-1.81c-.115 0-.203-.104-.185-.218l1.322-8.38c.025-.158.16-.273.32-.273h1.81c.115 0 .203.104.185.22l-1.322 8.38c-.025.156-.16.272-.32.272M14.397 18.657h.224c.754 0 1.62-.14 1.777-1.106.158-.963-.345-1.102-1.15-1.104h-.326c-.097 0-.18.07-.197.168l-.326 2.043zm3.96 4.895h-2.37c-.102 0-.194-.058-.238-.15l-1.565-3.262h-.023l-.506 3.19c-.02.128-.13.222-.26.222h-1.86c-.116 0-.205-.104-.187-.218l1.33-8.432c.02-.128.13-.22.26-.22h3.222c1.753 0 2.953.834 2.66 2.728-.2 1.224-1.048 2.283-2.342 2.506l2.037 3.35c.076.125-.014.286-.16.286zM40.216 23.552h-1.808c-.116 0-.205-.104-.187-.218l1.06-6.7h-1.684c-.116 0-.205-.104-.187-.218l.228-1.462c.025-.157.16-.273.32-.273h5.62c.116 0 .205.104.186.22l-.228 1.46c-.025.158-.16.274-.32.274h-1.63l-1.05 6.645c-.025.156-.16.272-.32.272M11.467 17.202c-.027.164-.228.223-.345.104-.395-.405-.975-.62-1.6-.62-1.41 0-2.526 1.083-2.75 2.458-.21 1.4.588 2.41 2.022 2.41.592 0 1.22-.225 1.74-.6.144-.105.34.02.313.194l-.328 2.03c-.02.12-.108.22-.226.254-.702.207-1.24.355-1.9.355-3.823 0-4.435-3.266-4.238-4.655.553-3.894 3.712-4.786 5.65-4.678.623.034 1.182.117 1.73.323.177.067.282.25.252.436l-.32 1.99" fill="#21306F" />\n      <path d="M23.184 7.67c-.11.717-.657.717-1.186.717h-.302l.212-1.34c.013-.08.082-.14.164-.14h.138c.36 0 .702 0 .877.206.105.123.137.305.097.557zm-.23-1.87h-1.998c-.137 0-.253.098-.274.233l-.808 5.123c-.016.1.062.192.165.192h1.024c.095 0 .177-.07.192-.164l.23-1.452c.02-.135.136-.235.273-.235h.63c1.317 0 2.076-.636 2.275-1.898.09-.553.003-.987-.255-1.29-.284-.334-.788-.51-1.456-.51z" fill="#0093C7" />\n      <path d="M8.936 7.67c-.11.717-.656.717-1.186.717h-.302l.212-1.34c.013-.08.082-.14.164-.14h.138c.36 0 .702 0 .877.206.104.123.136.305.096.557zm-.23-1.87H6.708c-.136 0-.253.098-.274.233l-.808 5.123c-.016.1.062.192.165.192h.955c.136 0 .252-.1.274-.234l.217-1.382c.02-.135.137-.235.274-.235h.633c1.316 0 2.075-.636 2.274-1.898.09-.553.003-.987-.255-1.29-.284-.334-.788-.51-1.456-.51zM13.343 9.51c-.092.545-.526.912-1.08.912-.277 0-.5-.09-.642-.258-.14-.168-.193-.406-.148-.672.086-.542.527-.92 1.072-.92.27 0 .492.09.637.26.148.172.205.412.163.677zm1.334-1.863h-.957c-.082 0-.152.06-.164.14l-.042.268-.067-.097c-.208-.3-.67-.4-1.13-.4-1.057 0-1.96.8-2.135 1.923-.092.56.038 1.097.356 1.47.29.344.708.487 1.204.487.852 0 1.325-.548 1.325-.548l-.043.265c-.016.1.062.193.164.193h.862c.136 0 .253-.1.274-.234l.517-3.275c.017-.102-.06-.193-.163-.193z" fill="#21306F" />\n      <path d="M27.59 9.51c-.09.545-.525.912-1.078.912-.278 0-.5-.09-.643-.258-.142-.168-.195-.406-.15-.672.086-.542.526-.92 1.07-.92.273 0 .494.09.64.26.146.172.203.412.16.677zm1.334-1.863h-.956c-.082 0-.152.06-.164.14l-.043.268-.065-.097c-.208-.3-.67-.4-1.13-.4-1.057 0-1.96.8-2.136 1.923-.092.56.038 1.097.355 1.47.292.344.71.487 1.205.487.852 0 1.325-.548 1.325-.548l-.043.265c-.016.1.062.193.164.193h.862c.136 0 .253-.1.274-.234l.517-3.275c.015-.102-.063-.193-.166-.193z" fill="#0093C7" />\n      <path d="M19.77 7.647h-.96c-.092 0-.178.045-.23.122L17.254 9.72l-.562-1.877c-.035-.118-.143-.198-.266-.198h-.945c-.113 0-.194.112-.157.22l1.06 3.108-.997 1.404c-.078.11 0 .262.136.262h.96c.092 0 .177-.044.23-.12l3.196-4.614c.077-.11-.002-.26-.137-.26" fill="#21306F" />\n      <path d="M30.052 5.94l-.82 5.216c-.016.1.062.192.165.192h.824c.138 0 .254-.1.275-.234l.81-5.122c.015-.1-.064-.193-.166-.193h-.924c-.082 0-.15.06-.164.14" fill="#0093C7" />\n    </symbol>\n\n    <symbol id="iconCardFront" viewBox="0 0 48 29">\n      <title>Generic Card</title>\n      <path d="M46.177 29H1.823C.9 29 0 28.13 0 27.187V1.813C0 .87.9 0 1.823 0h44.354C47.1 0 48 .87 48 1.813v25.375C48 28.13 47.1 29 46.177 29z" fill="#FFF" />\n      <path d="M4.8 9.14c0-.427.57-.973 1.067-.973h7.466c.496 0 1.067.546 1.067.972v3.888c0 .425-.57.972-1.067.972H5.867c-.496 0-1.067-.547-1.067-.972v-3.89z" fill="#828282" />\n      <rect fill="#828282" x="10.8" y="22.167" width="3.6" height="2.333" rx="1.167" />\n      <rect fill="#828282" x="4.8" y="22.167" width="3.6" height="2.333" rx="1.167" />\n      <path d="M6.55 16.333h34.9c.966 0 1.75.784 1.75 1.75 0 .967-.784 1.75-1.75 1.75H6.55c-.966 0-1.75-.783-1.75-1.75 0-.966.784-1.75 1.75-1.75z" fill="#828282" />\n      <ellipse fill="#828282" cx="40.2" cy="6.417" rx="3" ry="2.917" />\n    </symbol>\n\n    <symbol id="iconCVVBack" viewBox="0 0 40 24">\n      <title>CVV Back</title>\n      <path d="M38.48 24H1.52C.75 24 0 23.28 0 22.5v-21C0 .72.75 0 1.52 0h36.96C39.25 0 40 .72 40 1.5v21c0 .78-.75 1.5-1.52 1.5z" fill="#FFF"/>\n      <path fill="#828282" d="M0 5h40v4H0z" />\n      <path d="M20 13.772v5.456c0 .423.37.772.82.772h13.36c.45 0 .82-.35.82-.772v-5.456c0-.423-.37-.772-.82-.772H20.82c-.45 0-.82.35-.82.772zm-1-.142c0-.9.76-1.63 1.68-1.63h13.64c.928 0 1.68.737 1.68 1.63v5.74c0 .9-.76 1.63-1.68 1.63H20.68c-.928 0-1.68-.737-1.68-1.63v-5.74z" fill="#000" fill-rule="nonzero" />\n      <circle fill="#828282" cx="23.5" cy="16.5" r="1.5" />\n      <circle fill="#828282" cx="27.5" cy="16.5" r="1.5" />\n      <circle fill="#828282" cx="31.5" cy="16.5" r="1.5" />\n    </symbol>\n\n    <symbol id="iconCVVFront" viewBox="0 0 40 24">\n      <title>CVV Front</title>\n      <path d="M38.48 24H1.52C.75 24 0 23.28 0 22.5v-21C0 .72.75 0 1.52 0h36.96C39.25 0 40 .72 40 1.5v21c0 .78-.75 1.5-1.52 1.5z" fill="#FFF" />\n      <path d="M16 5.772v5.456c0 .423.366.772.81.772h17.38c.444 0 .81-.348.81-.772V5.772C35 5.35 34.634 5 34.19 5H16.81c-.444 0-.81.348-.81.772zm-1-.142c0-.9.75-1.63 1.66-1.63h17.68c.917 0 1.66.737 1.66 1.63v5.74c0 .9-.75 1.63-1.66 1.63H16.66c-.917 0-1.66-.737-1.66-1.63V5.63z" fill="#000" fill-rule="nonzero" />\n      <circle fill="#828282" cx="19.5" cy="8.5" r="1.5" />\n      <circle fill="#828282" cx="27.5" cy="8.5" r="1.5" />\n      <circle fill="#828282" cx="23.5" cy="8.5" r="1.5" />\n      <circle fill="#828282" cx="31.5" cy="8.5" r="1.5" />\n      <path d="M4 7.833C4 7.47 4.476 7 4.89 7h6.22c.414 0 .89.47.89.833v3.334c0 .364-.476.833-.89.833H4.89c-.414 0-.89-.47-.89-.833V7.833zM4 18.5c0-.828.668-1.5 1.5-1.5h29c.828 0 1.5.666 1.5 1.5 0 .828-.668 1.5-1.5 1.5h-29c-.828 0-1.5-.666-1.5-1.5z" fill="#828282" />\n    </symbol>\n\n    <symbol id="iconCheck" viewBox="0 0 42 32">\n      <title>Check</title>\n      <path class="path1" d="M14.379 29.76L39.741 3.415 36.194.001l-21.815 22.79-10.86-11.17L0 15.064z" />\n    </symbol>\n\n    <symbol id="iconX" viewBox="0 0 32 32">\n      <title>X</title>\n      <path d="M29 3.54L25.46 0 14.5 10.97 3.54 0.01 0 3.54 10.96 14.5 0.01 25.46 3.54 28.99 14.5 18.04 25.46 29 28.99 25.46 18.03 14.5 29 3.54z"/>\n    </symbol>\n\n    <symbol id="iconLockLoader" viewBox="0 0 28 32">\n      <title>Lock Loader</title>\n      <path d="M6 10V8c0-4.422 3.582-8 8-8 4.41 0 8 3.582 8 8v2h-4V7.995C18 5.79 16.205 4 14 4c-2.21 0-4 1.792-4 3.995V10H6zM.997 14c-.55 0-.997.445-.997.993v16.014c0 .548.44.993.997.993h26.006c.55 0 .997-.445.997-.993V14.993c0-.548-.44-.993-.997-.993H.997z" />\n    </symbol>\n\n    <symbol id="iconError" height="24" viewBox="0 0 24 24" width="24">\n      <path d="M0 0h24v24H0z" fill="none" />\n      <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" />\n    </symbol>\n\n    <symbol id="logoApplePay" viewBox="0 0 165.52 105.97">\n      <title>Apple Pay Logo</title>\n      <path id="_Path_" data-name="&lt;Path&gt;" fill="#231f20" d="M150.7 0h-139a20.78 20.78 0 0 0-3.12.3 10.51 10.51 0 0 0-3 1 9.94 9.94 0 0 0-4.31 4.32 10.46 10.46 0 0 0-1 3A20.65 20.65 0 0 0 0 11.7v82.57a20.64 20.64 0 0 0 .3 3.11 10.46 10.46 0 0 0 1 3 9.94 9.94 0 0 0 4.35 4.35 10.47 10.47 0 0 0 3 1 20.94 20.94 0 0 0 3.11.27h142.06a21 21 0 0 0 3.11-.27 10.48 10.48 0 0 0 3-1 9.94 9.94 0 0 0 4.35-4.35 10.4 10.4 0 0 0 1-3 20.63 20.63 0 0 0 .27-3.11V11.69a20.64 20.64 0 0 0-.27-3.11 10.4 10.4 0 0 0-1-3 9.94 9.94 0 0 0-4.35-4.35 10.52 10.52 0 0 0-3-1 20.84 20.84 0 0 0-3.1-.23h-1.43z"/>\n      <path id="_Path_2" data-name="&lt;Path&gt;" fill="#fff" d="M150.7 3.53h3.03a17.66 17.66 0 0 1 2.58.22 7 7 0 0 1 2 .65 6.41 6.41 0 0 1 2.8 2.81 6.88 6.88 0 0 1 .64 2 17.56 17.56 0 0 1 .22 2.58v82.38a17.54 17.54 0 0 1-.22 2.59 6.85 6.85 0 0 1-.64 2 6.41 6.41 0 0 1-2.81 2.81 6.92 6.92 0 0 1-2 .65 18 18 0 0 1-2.57.22H11.79a18 18 0 0 1-2.58-.22 6.94 6.94 0 0 1-2-.65 6.41 6.41 0 0 1-2.8-2.8 6.93 6.93 0 0 1-.65-2 17.47 17.47 0 0 1-.22-2.58v-82.4a17.49 17.49 0 0 1 .22-2.59 6.92 6.92 0 0 1 .65-2 6.41 6.41 0 0 1 2.8-2.8 7 7 0 0 1 2-.65 17.63 17.63 0 0 1 2.58-.22H150.7"/>\n      <g id="_Group_" data-name="&lt;Group&gt;">\n      <g id="_Group_2" data-name="&lt;Group&gt;">\n      <path id="_Path_3" data-name="&lt;Path&gt;" class="cls-1" d="M43.51 35.77a9.15 9.15 0 0 0 2.1-6.52 9.07 9.07 0 0 0-6 3.11 8.56 8.56 0 0 0-2.16 6.27 7.57 7.57 0 0 0 6.06-2.86"/>\n      <path id="_Path_4" data-name="&lt;Path&gt;" class="cls-1" d="M45.59 39.08c-3.35-.2-6.2 1.9-7.79 1.9s-4-1.8-6.7-1.75a9.87 9.87 0 0 0-8.4 5.1c-3.6 6.2-.95 15.4 2.55 20.45 1.7 2.5 3.75 5.25 6.45 5.15s3.55-1.65 6.65-1.65 4 1.65 6.7 1.6 4.55-2.5 6.25-5a22.2 22.2 0 0 0 2.8-5.75 9.08 9.08 0 0 1-5.45-8.25A9.26 9.26 0 0 1 53 43.13a9.57 9.57 0 0 0-7.45-4"/>\n      </g>\n      <g id="_Group_3" data-name="&lt;Group&gt;">\n      <path id="_Compound_Path_" data-name="&lt;Compound Path&gt;" fill="#231f20" d="M79 32.11c7.28 0 12.35 5 12.35 12.32S86.15 56.8 78.79 56.8h-8.06v12.82h-5.82V32.11zm-8.27 19.81h6.68c5.07 0 8-2.73 8-7.46S82.48 37 77.44 37h-6.71z"/>\n      <path id="_Compound_Path_2" data-name="&lt;Compound Path&gt;" fill="#231f20" d="M92.76 61.85c0-4.81 3.67-7.56 10.42-8l7.25-.44v-2.06c0-3-2-4.7-5.56-4.7-2.94 0-5.07 1.51-5.51 3.82h-5.24c.16-4.86 4.73-8.4 10.92-8.4 6.65 0 11 3.48 11 8.89v18.66h-5.38v-4.5h-.13a9.59 9.59 0 0 1-8.58 4.78c-5.42 0-9.19-3.22-9.19-8.05zm17.68-2.42v-2.11l-6.47.42c-3.64.23-5.54 1.59-5.54 4s2 3.77 5.07 3.77c3.95-.05 6.94-2.57 6.94-6.08z"/>\n      <path id="_Compound_Path_3" data-name="&lt;Compound Path&gt;" fill="#231f20" d="M121 79.65v-4.5a17.14 17.14 0 0 0 1.72.1c2.57 0 4-1.09 4.91-3.9l.52-1.66-9.88-27.29h6.08l6.86 22.15h.13l6.86-22.15h5.93l-10.21 28.67c-2.34 6.58-5 8.73-10.68 8.73a15.93 15.93 0 0 1-2.24-.15z"/>\n      </g>\n      </g>\n    </symbol>\n    <symbol id="logoGooglePay" viewbox="0 0 752 400" >\n      <g>\n        <title>Google Pay Mark</title>\n        <path d="m552.7,0l-352,0c-110,0 -200,90 -200,200l0,0c0,110 90,200 200,200l352,0c110,0 200,-90 200,-200l0,0c0,-110 -90,-200 -200,-200z" fill="#FFFFFF" id="Base_1_"/>\n        <path d="m552.7,16.2c24.7,0 48.7,4.9 71.3,14.5c21.9,9.3 41.5,22.6 58.5,39.5c16.9,16.9 30.2,36.6 39.5,58.5c9.6,22.6 14.5,46.6 14.5,71.3s-4.9,48.7 -14.5,71.3c-9.3,21.9 -22.6,41.5 -39.5,58.5c-16.9,16.9 -36.6,30.2 -58.5,39.5c-22.6,9.6 -46.6,14.5 -71.3,14.5l-352,0c-24.7,0 -48.7,-4.9 -71.3,-14.5c-21.9,-9.3 -41.5,-22.6 -58.5,-39.5c-16.9,-16.9 -30.2,-36.6 -39.5,-58.5c-9.6,-22.6 -14.5,-46.6 -14.5,-71.3s4.9,-48.7 14.5,-71.3c9.3,-21.9 22.6,-41.5 39.5,-58.5c16.9,-16.9 36.6,-30.2 58.5,-39.5c22.6,-9.6 46.6,-14.5 71.3,-14.5l352,0m0,-16.2l-352,0c-110,0 -200,90 -200,200l0,0c0,110 90,200 200,200l352,0c110,0 200,-90 200,-200l0,0c0,-110 -90,-200 -200,-200l0,0z" fill="#3C4043" id="Outline"/>\n        <g id="G_Pay_Lockup_1_">\n         <g id="Pay_Typeface_3_">\n          <path d="m359.3,214.2l0,60.5l-19.2,0l0,-149.4l50.9,0c12.9,0 23.9,4.3 32.9,12.9c9.2,8.6 13.8,19.1 13.8,31.5c0,12.7 -4.6,23.2 -13.8,31.7c-8.9,8.5 -19.9,12.7 -32.9,12.7l-31.7,0l0,0.1zm0,-70.5l0,52.1l32.1,0c7.6,0 14,-2.6 19,-7.7c5.1,-5.1 7.7,-11.3 7.7,-18.3c0,-6.9 -2.6,-13 -7.7,-18.1c-5,-5.3 -11.3,-7.9 -19,-7.9l-32.1,0l0,-0.1z" fill="#3C4043" id="Letter_p_3_"/>\n          <path d="m487.9,169.1c14.2,0 25.4,3.8 33.6,11.4c8.2,7.6 12.3,18 12.3,31.2l0,63l-18.3,0l0,-14.2l-0.8,0c-7.9,11.7 -18.5,17.5 -31.7,17.5c-11.3,0 -20.7,-3.3 -28.3,-10s-11.4,-15 -11.4,-25c0,-10.6 4,-19 12,-25.2c8,-6.3 18.7,-9.4 32,-9.4c11.4,0 20.8,2.1 28.1,6.3l0,-4.4c0,-6.7 -2.6,-12.3 -7.9,-17c-5.3,-4.7 -11.5,-7 -18.6,-7c-10.7,0 -19.2,4.5 -25.4,13.6l-16.9,-10.6c9.3,-13.5 23.1,-20.2 41.3,-20.2zm-24.8,74.2c0,5 2.1,9.2 6.4,12.5c4.2,3.3 9.2,5 14.9,5c8.1,0 15.3,-3 21.6,-9s9.5,-13 9.5,-21.1c-6,-4.7 -14.3,-7.1 -25,-7.1c-7.8,0 -14.3,1.9 -19.5,5.6c-5.3,3.9 -7.9,8.6 -7.9,14.1z" fill="#3C4043" id="Letter_a_3_"/>\n          <path d="m638.2,172.4l-64,147.2l-19.8,0l23.8,-51.5l-42.2,-95.7l20.9,0l30.4,73.4l0.4,0l29.6,-73.4l20.9,0z" fill="#3C4043" id="Letter_y_3_"/>\n         </g>\n         <g id="G_Mark_1_">\n          <path d="m282.93,202c0,-6.26 -0.56,-12.25 -1.6,-18.01l-80.48,0l0,33l46.35,0.01c-1.88,10.98 -7.93,20.34 -17.2,26.58l0,21.41l27.59,0c16.11,-14.91 25.34,-36.95 25.34,-62.99z" fill="#4285F4" id="Blue_500"/>\n          <path d="m230.01,243.58c-7.68,5.18 -17.57,8.21 -29.14,8.21c-22.35,0 -41.31,-15.06 -48.1,-35.36l-28.46,0l0,22.08c14.1,27.98 43.08,47.18 76.56,47.18c23.14,0 42.58,-7.61 56.73,-20.71l-27.59,-21.4z" fill="#34A853" id="Green_500_1_"/>\n          <path d="m150.09,200.05c0,-5.7 0.95,-11.21 2.68,-16.39l0,-22.08l-28.46,0c-5.83,11.57 -9.11,24.63 -9.11,38.47s3.29,26.9 9.11,38.47l28.46,-22.08c-1.73,-5.18 -2.68,-10.69 -2.68,-16.39z" fill="#FABB05" id="Yellow_500_1_"/>\n          <path d="m200.87,148.3c12.63,0 23.94,4.35 32.87,12.85l24.45,-24.43c-14.85,-13.83 -34.21,-22.32 -57.32,-22.32c-33.47,0 -62.46,19.2 -76.56,47.18l28.46,22.08c6.79,-20.3 25.75,-35.36 48.1,-35.36z" fill="#E94235" id="Red_500"/>\n         </g>\n        </g>\n       </g>\n    </symbol>\n\n    <symbol id="logoVenmo" viewBox="0 0 48 32">\n      <title>Venmo</title>\n      <g fill="none" fill-rule="evenodd">\n        <rect fill="#3D95CE" width="47.4074074" height="31.6049383" rx="3.16049383"/>\n        <path d="M33.1851852,10.1131555 C33.1851852,14.8373944 29.2425262,20.9745161 26.0425868,25.2839506 L18.7337285,25.2839506 L15.8024691,7.35534396 L22.202175,6.73384536 L23.7519727,19.4912014 C25.2000422,17.0781163 26.9870326,13.2859484 26.9870326,10.7005 C26.9870326,9.28531656 26.7500128,8.32139205 26.3796046,7.52770719 L32.207522,6.32098765 C32.8813847,7.45939896 33.1851852,8.63196439 33.1851852,10.1131555 Z" fill="#FFF"/>\n      </g>\n    </symbol>\n    <symbol id="buttonVenmo" viewBox="0 0 295 42">\n      <g fill="none" fill-rule="evenodd">\n        <rect fill="#3D95CE" width="295" height="42" rx="3"/>\n        <path d="M11.3250791 0C11.7902741.780434316 12 1.58428287 12 2.59970884 12 5.838396 9.27822123 10.0456806 7.06917212 13L2.02356829 13 0 .709099732 4.41797878.283033306 5.48786751 9.02879887C6.48752911 7.3745159 7.72116169 4.77480706 7.72116169 3.00236102 7.72116169 2.03218642 7.55753727 1.37137098 7.30182933.827262801L11.3250791 0 11.3250791 0zM17.5051689 5.68512193C18.333931 5.68512193 20.4203856 5.28483546 20.4203856 4.03281548 20.4203856 3.43161451 20.0177536 3.13172102 19.5432882 3.13172102 18.7131868 3.13172102 17.6238766 4.18269796 17.5051689 5.68512193L17.5051689 5.68512193zM17.4102028 8.1647385C17.4102028 9.69351403 18.2153451 10.293301 19.2827401 10.293301 20.4451012 10.293301 21.5580312 9.99340752 23.0045601 9.21725797L22.4597224 13.1234575C21.440541 13.649203 19.8521716 14 18.310433 14 14.3996547 14 13 11.49596 13 8.36552446 13 4.30815704 15.2767521 0 19.9706358 0 22.554932 0 24 1.52864698 24 3.65720949 24.0002435 7.08869546 19.8287953 8.13992948 17.4102028 8.1647385L17.4102028 8.1647385zM37 2.84753211C37 3.32189757 36.9261179 4.00994664 36.8526108 4.45959542L35.4649774 12.9998782 30.9621694 12.9998782 32.2279161 5.1711436C32.2519185 4.95879931 32.3256755 4.53131032 32.3256755 4.29412759 32.3256755 3.72466988 31.9603904 3.5825794 31.5212232 3.5825794 30.9379171 3.5825794 30.3532359 3.84326124 29.9638234 4.03356751L28.5281854 13 24 13 26.0686989.213683657 29.9878258.213683657 30.0374555 1.23425123C30.9620444.641294408 32.1795365 3.90379019e-8 33.9069526 3.90379019e-8 36.1955476-.000243475057 37 1.1387937 37 2.84753211L37 2.84753211zM51.2981937 1.39967969C52.6582977.49918987 53.9425913 0 55.7133897 0 58.1518468 0 59 1.13900518 59 2.84769558 59 3.32204771 58.9223438 4.01007745 58.8448195 4.4597136L57.3830637 12.9997565 52.6328518 12.9997565 53.9932194 5.00577861C54.0182698 4.792101 54.0708756 4.53142648 54.0708756 4.36608506 54.0708756 3.72493046 53.6854953 3.58272222 53.2224587 3.58272222 52.6325881 3.58272222 52.0429812 3.81989829 51.6052587 4.03369766L50.0914245 12.9998782 45.3423992 12.9998782 46.7027668 5.00590037C46.7278172 4.79222275 46.7788409 4.53154824 46.7788409 4.36620681 46.7788409 3.72505221 46.3933287 3.58284398 45.9318743 3.58284398 45.3153711 3.58284398 44.7000546 3.84351849 44.2893602 4.03381941L42.7740757 13 38 13 40.1814929.214042876 44.2643098.214042876 44.3925941 1.28145692C45.3423992.641763367 46.6253743.000487014507 48.3452809.000487014507 49.8344603 0 50.8094476.593061916 51.2981937 1.39967969L51.2981937 1.39967969zM67.5285327 5.39061542C67.5285327 4.29258876 67.2694573 3.54396333 66.4936812 3.54396333 64.7759775 3.54396333 64.4232531 6.76273249 64.4232531 8.4093242 64.4232531 9.65848482 64.7530184 10.4315735 65.5285529 10.4315735 67.1521242 10.4315735 67.5285327 7.03707905 67.5285327 5.39061542L67.5285327 5.39061542zM60 8.21054461C60 3.96893154 62.1170713 0 66.988027 0 70.6583423 0 72 2.29633967 72 5.46592624 72 9.65835674 69.905767 14 64.9173573 14 61.2233579 14 60 11.4294418 60 8.21054461L60 8.21054461z" transform="translate(112 14)" fill="#FFF"/>\n      </g>\n    </symbol>\n\n    <symbol id="iconClose" width="21" height="21" viewBox="0 0 21 21" overflow="visible">\n      <path d="M16 5.414L14.586 4 10 8.586 5.414 4 4 5.414 8.586 10 4 14.586 5.414 16 10 11.414 14.586 16 16 14.586 11.414 10"/>\n    </symbol>\n  </defs>\n</svg>\n';
        var PASS_THROUGH_EVENTS = [
          "changeActiveView",
          "paymentMethodRequestable",
          "noPaymentMethodRequestable",
          "paymentOptionSelected",
          "card:binAvailable",
          "card:blur",
          "card:cardTypeChange",
          "card:empty",
          "card:focus",
          "card:inputSubmitRequest",
          "card:notEmpty",
          "card:validityChange",
          "3ds:customer-canceled",
          "3ds:authentication-modal-render",
          "3ds:authentication-modal-close"
        ];
        var UPDATABLE_CONFIGURATION_OPTIONS = [
          paymentOptionIDs.paypal,
          paymentOptionIDs.paypalCredit,
          paymentOptionIDs.applePay,
          paymentOptionIDs.googlePay,
          "threeDSecure"
        ];
        var UPDATABLE_CONFIGURATION_OPTIONS_THAT_REQUIRE_UNVAULTED_PAYMENT_METHODS_TO_BE_REMOVED = [
          paymentOptionIDs.paypal,
          paymentOptionIDs.paypalCredit,
          paymentOptionIDs.applePay,
          paymentOptionIDs.googlePay
        ];
        var HAS_RAW_PAYMENT_DATA = {};
        var VERSION2 = "1.42.0";
        HAS_RAW_PAYMENT_DATA[constants.paymentMethodTypes.googlePay] = true;
        HAS_RAW_PAYMENT_DATA[constants.paymentMethodTypes.applePay] = true;
        function Dropin(options) {
          this._client = options.client;
          this._componentID = uuid();
          this._dropinWrapper = document.createElement("div");
          this._dropinWrapper.id = "braintree--dropin__" + this._componentID;
          this._dropinWrapper.setAttribute("data-braintree-id", "wrapper");
          this._dropinWrapper.style.display = "none";
          this._dropinWrapper.className = "braintree-loading";
          this._merchantConfiguration = options.merchantConfiguration;
          EventEmitter.call(this);
        }
        EventEmitter.createChild(Dropin);
        Dropin.prototype._initialize = function(callback) {
          var localizedStrings, localizedHTML;
          var self2 = this;
          var container = self2._merchantConfiguration.container || self2._merchantConfiguration.selector;
          if (!container) {
            analytics.sendEvent(self2._client, "configuration-error");
            callback(new DropinError("options.container is required."));
            return;
          } else if (self2._merchantConfiguration.container && self2._merchantConfiguration.selector) {
            analytics.sendEvent(self2._client, "configuration-error");
            callback(new DropinError("Must only have one options.selector or options.container."));
            return;
          }
          if (typeof container === "string") {
            container = document.querySelector(container);
          }
          if (!container || container.nodeType !== 1) {
            analytics.sendEvent(self2._client, "configuration-error");
            callback(new DropinError("options.selector or options.container must reference a valid DOM node."));
            return;
          }
          if (container.innerHTML.trim()) {
            analytics.sendEvent(self2._client, "configuration-error");
            callback(new DropinError("options.selector or options.container must reference an empty DOM node."));
            return;
          }
          self2._strings = assign2({}, translations.en);
          if (self2._merchantConfiguration.locale) {
            localizedStrings = translations[self2._merchantConfiguration.locale] || translations[self2._merchantConfiguration.locale.split("_")[0]];
            self2._strings = assign2(self2._strings, localizedStrings);
          }
          if (!isUtf8()) {
            self2._strings.endingIn = self2._strings.endingIn.replace(//g, "*");
          }
          if (self2._merchantConfiguration.translations) {
            Object.keys(self2._merchantConfiguration.translations).forEach(function(key) {
              self2._strings[key] = sanitizeHtml(self2._merchantConfiguration.translations[key]);
            });
          }
          localizedHTML = Object.keys(self2._strings).reduce(function(result, stringKey) {
            var stringValue = self2._strings[stringKey];
            return result.replace(RegExp("{{" + stringKey + "}}", "g"), stringValue);
          }, mainHTML);
          self2._dropinWrapper.innerHTML = svgHTML + localizedHTML;
          container.appendChild(self2._dropinWrapper);
          self2._model = new DropinModel({
            client: self2._client,
            container,
            componentID: self2._componentID,
            merchantConfiguration: self2._merchantConfiguration
          });
          self2._injectStylesheet();
          self2._model.initialize().then(function() {
            self2._model.on("cancelInitialization", function(err) {
              self2._dropinWrapper.innerHTML = "";
              analytics.sendEvent(self2._client, "load-error");
              callback(err);
            });
            self2._model.on("asyncDependenciesReady", function() {
              if (self2._model.hasAtLeastOneAvailablePaymentOption()) {
                analytics.sendEvent(self2._client, "appeared");
                self2._disableErroredPaymentMethods();
                self2._handleAppSwitch();
                self2._model.confirmDropinReady();
                callback(null, self2);
              } else {
                self2._model.cancelInitialization(new DropinError("All payment options failed to load."));
              }
            });
            PASS_THROUGH_EVENTS.forEach(function(eventName) {
              self2._model.on(eventName, function(event) {
                self2._emit(eventName, event);
              });
            });
            return self2._setUpDependenciesAndViews();
          }).catch(function(err) {
            self2.teardown().then(function() {
              callback(err);
            });
          });
        };
        Dropin.prototype.updateConfiguration = function(property, key, value) {
          var view;
          if (UPDATABLE_CONFIGURATION_OPTIONS.indexOf(property) === -1) {
            return;
          }
          if (property === "threeDSecure") {
            if (this._threeDSecure) {
              this._threeDSecure.updateConfiguration(key, value);
            }
            return;
          }
          view = this._mainView.getView(property);
          if (!view) {
            return;
          }
          view.updateConfiguration(key, value);
          if (UPDATABLE_CONFIGURATION_OPTIONS_THAT_REQUIRE_UNVAULTED_PAYMENT_METHODS_TO_BE_REMOVED.indexOf(property) === -1) {
            return;
          }
          this._removeUnvaultedPaymentMethods(function(paymentMethod) {
            return paymentMethod.type === constants.paymentMethodTypes[property];
          });
          this._navigateToInitialView();
        };
        Dropin.prototype.getAvailablePaymentOptions = function() {
          return this._model.supportedPaymentOptions;
        };
        Dropin.prototype.clearSelectedPaymentMethod = function() {
          this._removeUnvaultedPaymentMethods();
          this._model.removeActivePaymentMethod();
          if (this._model.getPaymentMethods().length === 0) {
            this._navigateToInitialView();
            return;
          }
          this._mainView.showLoadingIndicator();
          this._model.refreshPaymentMethods().then(function() {
            this._navigateToInitialView();
            this._mainView.hideLoadingIndicator();
          }.bind(this));
        };
        Dropin.prototype._setUpDataCollector = function() {
          var self2 = this;
          var config = assign2({}, self2._merchantConfiguration.dataCollector, { client: self2._client });
          this._dataCollector = new DataCollector(config);
          this._dataCollector.initialize().then(function() {
            self2._model.asyncDependencyReady("dataCollector");
          }).catch(function(err) {
            self2._model.cancelInitialization(new DropinError({
              message: "Data Collector failed to set up.",
              braintreeWebError: err
            }));
          });
        };
        Dropin.prototype._setUpThreeDSecure = function() {
          var self2 = this;
          this._threeDSecure = new ThreeDSecure(this._client, this._model);
          this._threeDSecure.initialize().then(function() {
            self2._model.asyncDependencyReady("threeDSecure");
          }).catch(function(err) {
            self2._model.cancelInitialization(new DropinError({
              message: "3D Secure failed to set up.",
              braintreeWebError: err
            }));
          });
        };
        Dropin.prototype._setUpDependenciesAndViews = function() {
          if (this._merchantConfiguration.dataCollector) {
            this._setUpDataCollector();
          }
          if (this._merchantConfiguration.threeDSecure) {
            this._setUpThreeDSecure();
          }
          this._mainView = new MainView({
            client: this._client,
            element: this._dropinWrapper,
            model: this._model,
            strings: this._strings
          });
        };
        Dropin.prototype._removeUnvaultedPaymentMethods = function(filter) {
          filter = filter || function() {
            return true;
          };
          this._model.getPaymentMethods().forEach(function(paymentMethod) {
            if (filter(paymentMethod) && !paymentMethod.vaulted) {
              this._model.removePaymentMethod(paymentMethod);
            }
          }.bind(this));
        };
        Dropin.prototype._navigateToInitialView = function() {
          var initViewId = this._model.getInitialViewId();
          var isOnInitView = this._mainView.primaryView.ID === initViewId;
          if (isOnInitView) {
            return;
          }
          if (this._model.hasPaymentMethods()) {
            return;
          }
          this._mainView.setPrimaryView(initViewId);
        };
        Dropin.prototype._supportsPaymentOption = function(paymentOption) {
          return this._model.supportedPaymentOptions.indexOf(paymentOption) !== -1;
        };
        Dropin.prototype._disableErroredPaymentMethods = function() {
          var paymentMethodOptionsElements;
          var failedDependencies = Object.keys(this._model.failedDependencies);
          if (failedDependencies.length === 0) {
            return;
          }
          paymentMethodOptionsElements = this._mainView.getOptionsElements();
          failedDependencies.forEach(function(paymentMethodId) {
            var element = paymentMethodOptionsElements[paymentMethodId];
            var div = element.div;
            var clickHandler = element.clickHandler;
            var error = this._model.failedDependencies[paymentMethodId];
            var errorMessageDiv = div.querySelector(".braintree-option__disabled-message");
            div.classList.add("braintree-disabled");
            div.removeEventListener("click", clickHandler);
            errorMessageDiv.innerHTML = constants.errors.DEVELOPER_MISCONFIGURATION_MESSAGE;
            console.error(error);
          }.bind(this));
        };
        Dropin.prototype._sendVaultedPaymentMethodAppearAnalyticsEvents = function() {
          var i, type;
          var typesThatSentAnEvent = {};
          var paymentMethods2 = this._model._paymentMethods;
          for (i = 0; i < paymentMethods2.length; i++) {
            type = paymentMethods2[i].type;
            if (type in typesThatSentAnEvent) {
              continue;
            }
            typesThatSentAnEvent[type] = true;
            analytics.sendEvent(this._client, "vaulted-" + constants.analyticsKinds[type] + ".appear");
          }
        };
        Dropin.prototype._handleAppSwitch = function() {
          if (this._model.appSwitchError) {
            this._mainView.setPrimaryView(this._model.appSwitchError.id);
            this._model.reportError(this._model.appSwitchError.error);
          } else if (this._model.appSwitchPayload) {
            this._model.addPaymentMethod(this._model.appSwitchPayload);
          } else {
            this._sendVaultedPaymentMethodAppearAnalyticsEvents();
          }
        };
        Dropin.prototype.requestPaymentMethod = function(options) {
          var self2 = this;
          options = options || {};
          return this._mainView.requestPaymentMethod().then(function(payload) {
            if (self2._shouldPerformThreeDSecureVerification(payload)) {
              self2._mainView.showLoadingIndicator();
              return self2._threeDSecure.verify(payload, options.threeDSecure).then(function(newPayload) {
                self2._model.shouldWaitForVerifyCard = false;
                payload.nonce = newPayload.nonce;
                payload.liabilityShifted = newPayload.liabilityShifted;
                payload.liabilityShiftPossible = newPayload.liabilityShiftPossible;
                payload.threeDSecureInfo = newPayload.threeDSecureInfo;
                self2._model.setPaymentMethodRequestable({
                  isRequestable: Boolean(newPayload),
                  type: newPayload.type,
                  selectedPaymentMethod: payload
                });
                self2._mainView.hideLoadingIndicator();
                return payload;
              }).catch(function(err) {
                self2.clearSelectedPaymentMethod();
                return self2._model.refreshPaymentMethods().then(function() {
                  self2._mainView.hideLoadingIndicator();
                  return Promise.reject(new DropinError({
                    message: "Something went wrong during 3D Secure authentication. Please try again.",
                    braintreeWebError: err
                  }));
                });
              });
            }
            return payload;
          }).then(function(payload) {
            if (self2._dataCollector) {
              payload.deviceData = self2._dataCollector.getDeviceData();
            }
            return payload;
          }).then(function(payload) {
            return formatPaymentMethodPayload(payload);
          });
        };
        Dropin.prototype._shouldPerformThreeDSecureVerification = function(payload) {
          if (!this._threeDSecure) {
            return false;
          }
          if (payload.liabilityShifted != null) {
            return false;
          }
          if (payload.type === constants.paymentMethodTypes.card) {
            return true;
          }
          if (payload.type === constants.paymentMethodTypes.googlePay && payload.details.isNetworkTokenized === false) {
            return true;
          }
          return false;
        };
        Dropin.prototype._removeStylesheet = function() {
          var stylesheet = document.getElementById(constants.STYLESHEET_ID);
          if (stylesheet) {
            stylesheet.parentNode.removeChild(stylesheet);
          }
        };
        Dropin.prototype._injectStylesheet = function() {
          var assetsUrl;
          var loadStylesheetOptions = {
            id: constants.STYLESHEET_ID
          };
          if (document.getElementById(constants.STYLESHEET_ID)) {
            return;
          }
          assetsUrl = this._client.getConfiguration().gatewayConfiguration.assetsUrl;
          loadStylesheetOptions.href = assetsUrl + "/web/dropin/" + VERSION2 + "/css/dropin.css";
          if (this._model.isInShadowDom) {
            loadStylesheetOptions.container = this._model.rootNode;
          }
          assets.loadStylesheet(loadStylesheetOptions);
        };
        Dropin.prototype.teardown = function() {
          var teardownError;
          var promise = Promise.resolve();
          var self2 = this;
          this._removeStylesheet();
          if (this._mainView) {
            promise.then(function() {
              return self2._mainView.teardown().catch(function(err) {
                teardownError = err;
              });
            });
          }
          if (this._dataCollector) {
            promise.then(function() {
              return this._dataCollector.teardown().catch(function(error) {
                teardownError = new DropinError({
                  message: "Drop-in errored tearing down Data Collector.",
                  braintreeWebError: error
                });
              });
            }.bind(this));
          }
          if (this._threeDSecure) {
            promise.then(function() {
              return this._threeDSecure.teardown().catch(function(error) {
                teardownError = new DropinError({
                  message: "Drop-in errored tearing down 3D Secure.",
                  braintreeWebError: error
                });
              });
            }.bind(this));
          }
          return promise.then(function() {
            return self2._removeDropinWrapper();
          }).then(function() {
            if (teardownError) {
              return Promise.reject(teardownError);
            }
            return Promise.resolve();
          });
        };
        Dropin.prototype.isPaymentMethodRequestable = function() {
          return this._model.isPaymentMethodRequestable();
        };
        Dropin.prototype._removeDropinWrapper = function() {
          this._dropinWrapper.parentNode.removeChild(this._dropinWrapper);
          return Promise.resolve();
        };
        function formatPaymentMethodPayload(paymentMethod) {
          var formattedPaymentMethod = {
            nonce: paymentMethod.nonce,
            details: paymentMethod.details,
            type: paymentMethod.type
          };
          if (paymentMethod.vaulted != null) {
            formattedPaymentMethod.vaulted = paymentMethod.vaulted;
          }
          if (paymentMethod.type === constants.paymentMethodTypes.card) {
            formattedPaymentMethod.description = paymentMethod.description;
          }
          if (paymentMethod.type in HAS_RAW_PAYMENT_DATA) {
            formattedPaymentMethod.details.rawPaymentData = paymentMethod.rawPaymentData;
          }
          if (typeof paymentMethod.liabilityShiftPossible === "boolean") {
            formattedPaymentMethod.liabilityShifted = paymentMethod.liabilityShifted;
            formattedPaymentMethod.liabilityShiftPossible = paymentMethod.liabilityShiftPossible;
          }
          if (paymentMethod.threeDSecureInfo) {
            formattedPaymentMethod.threeDSecureInfo = paymentMethod.threeDSecureInfo;
          }
          if (paymentMethod.deviceData) {
            formattedPaymentMethod.deviceData = paymentMethod.deviceData;
          }
          if (paymentMethod.binData) {
            formattedPaymentMethod.binData = paymentMethod.binData;
          }
          return formattedPaymentMethod;
        }
        module2.exports = wrapPrototype(Dropin);
      }, { "./constants": 189, "./dropin-model": 190, "./lib/analytics": 194, "./lib/assign": 195, "./lib/data-collector": 198, "./lib/dropin-error": 199, "./lib/is-utf-8": 203, "./lib/sanitize-html": 206, "./lib/three-d-secure": 208, "./translations": 229, "./views/main-view": 248, "@braintree/asset-loader": 1, "@braintree/event-emitter": 37, "@braintree/uuid": 43, "@braintree/wrap-promise": 47 }], 192: [function(require2, module2, exports2) {
        var Dropin = require2("./dropin");
        var client = require2("braintree-web/client");
        var createFromScriptTag = require2("./lib/create-from-script-tag");
        var constants = require2("./constants");
        var analytics = require2("./lib/analytics");
        var DropinError = require2("./lib/dropin-error");
        var wrapPromise = require2("@braintree/wrap-promise");
        var VERSION2 = "1.42.0";
        function create2(options) {
          if (!options.authorization) {
            return Promise.reject(new DropinError("options.authorization is required."));
          }
          return client.create({
            authorization: options.authorization
          }).catch(function(err) {
            return Promise.reject(new DropinError({
              message: "There was an error creating Drop-in.",
              braintreeWebError: err
            }));
          }).then(function(clientInstance) {
            clientInstance = setAnalyticsIntegration(clientInstance);
            if (clientInstance.getConfiguration().authorizationType === "TOKENIZATION_KEY") {
              analytics.sendEvent(clientInstance, "started.tokenization-key");
            } else {
              analytics.sendEvent(clientInstance, "started.client-token");
            }
            return new Promise(function(resolve2, reject) {
              new Dropin({
                merchantConfiguration: options,
                client: clientInstance
              })._initialize(function(err, instance) {
                if (err) {
                  reject(err);
                  return;
                }
                resolve2(instance);
              });
            });
          });
        }
        function setAnalyticsIntegration(clientInstance) {
          var configuration = clientInstance.getConfiguration();
          configuration.analyticsMetadata.integration = constants.INTEGRATION;
          configuration.analyticsMetadata.integrationType = constants.INTEGRATION;
          configuration.analyticsMetadata.dropinVersion = VERSION2;
          clientInstance.getConfiguration = function() {
            return configuration;
          };
          return clientInstance;
        }
        createFromScriptTag(create2, typeof document !== "undefined" && document.querySelector("script[data-braintree-dropin-authorization]"));
        module2.exports = {
          create: wrapPromise(create2),
          VERSION: VERSION2
        };
      }, { "./constants": 189, "./dropin": 191, "./lib/analytics": 194, "./lib/create-from-script-tag": 197, "./lib/dropin-error": 199, "@braintree/wrap-promise": 47, "braintree-web/client": 55 }], 193: [function(require2, module2, exports2) {
        function addSelectionEventHandler(element, func) {
          element.addEventListener("click", func);
          element.addEventListener("keyup", function(event) {
            if (event.keyCode === 13) {
              func();
            }
          });
        }
        module2.exports = addSelectionEventHandler;
      }, {}], 194: [function(require2, module2, exports2) {
        var atob2 = require2("./polyfill").atob;
        var constants = require2("../constants");
        var braintreeClientVersion = require2("braintree-web/client").VERSION;
        function _millisToSeconds(millis) {
          return Math.floor(millis / 1e3);
        }
        function sendAnalyticsEvent(client, kind, callback) {
          var configuration = client.getConfiguration();
          var analyticsRequest = client._request;
          var timestamp = _millisToSeconds(Date.now());
          var url = configuration.gatewayConfiguration.analytics.url;
          var data2 = {
            analytics: [{
              kind: constants.ANALYTICS_PREFIX + kind,
              timestamp
            }],
            _meta: configuration.analyticsMetadata,
            braintreeLibraryVersion: braintreeClientVersion
          };
          if (configuration.authorizationType === "TOKENIZATION_KEY") {
            data2.tokenizationKey = configuration.authorization;
          } else {
            data2.authorizationFingerprint = JSON.parse(atob2(configuration.authorization)).authorizationFingerprint;
          }
          analyticsRequest({
            url,
            method: "post",
            data: data2,
            timeout: constants.ANALYTICS_REQUEST_TIMEOUT_MS
          }, callback);
        }
        module2.exports = {
          sendEvent: sendAnalyticsEvent
        };
      }, { "../constants": 189, "./polyfill": 205, "braintree-web/client": 55 }], 195: [function(require2, module2, exports2) {
        var assignNormalized = typeof Object.assign === "function" ? Object.assign : assignPolyfill;
        function assignPolyfill(destination) {
          var i, source2, key;
          for (i = 1; i < arguments.length; i++) {
            source2 = arguments[i];
            for (key in source2) {
              if (source2.hasOwnProperty(key)) {
                destination[key] = source2[key];
              }
            }
          }
          return destination;
        }
        module2.exports = {
          assign: assignNormalized,
          _assign: assignPolyfill
        };
      }, {}], 196: [function(require2, module2, exports2) {
        var isIe9 = require2("@braintree/browser-detection/is-ie9");
        var isIe10 = require2("@braintree/browser-detection/is-ie10");
        module2.exports = {
          isIe9,
          isIe10
        };
      }, { "@braintree/browser-detection/is-ie10": 29, "@braintree/browser-detection/is-ie9": 30 }], 197: [function(require2, module2, exports2) {
        var analytics = require2("./analytics");
        var find = require2("./find-parent-form");
        var uuid = require2("@braintree/uuid");
        var DropinError = require2("./dropin-error");
        var kebabCaseToCamelCase = require2("./kebab-case-to-camel-case");
        var WHITELISTED_DATA_ATTRIBUTES = [
          "locale",
          "payment-option-priority",
          "data-collector.kount",
          "data-collector.paypal",
          "card.cardholderName",
          "card.cardholderName.required",
          "card.cardholder-name",
          "card.cardholder-name.required",
          "paypal.amount",
          "paypal.currency",
          "paypal.flow",
          "paypal.landing-page-type",
          "paypal-credit.amount",
          "paypal-credit.currency",
          "paypal-credit.flow",
          "paypal-credit.landing-page-type"
        ];
        function injectHiddenInput(name, value, form) {
          var input = form.querySelector('[name="' + name + '"]');
          if (!input) {
            input = document.createElement("input");
            input.type = "hidden";
            input.name = name;
            form.appendChild(input);
          }
          input.value = value;
        }
        function addCompositeKeyValuePairToObject(obj, key, value) {
          var decomposedKeys = key.split(".");
          var topLevelKey = kebabCaseToCamelCase(decomposedKeys[0]);
          if (decomposedKeys.length === 1) {
            obj[topLevelKey] = deserialize(value);
          } else {
            obj[topLevelKey] = obj[topLevelKey] || {};
            addCompositeKeyValuePairToObject(obj[topLevelKey], decomposedKeys.slice(1).join("."), value);
          }
        }
        function deserialize(value) {
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        function createFromScriptTag(createFunction, scriptTag) {
          var authorization, container, createOptions, form;
          if (!scriptTag) {
            return;
          }
          authorization = scriptTag.getAttribute("data-braintree-dropin-authorization");
          if (!authorization) {
            throw new DropinError("Authorization not found in data-braintree-dropin-authorization attribute");
          }
          container = document.createElement("div");
          container.id = "braintree-dropin-" + uuid();
          form = find.findParentForm(scriptTag);
          if (!form) {
            throw new DropinError("No form found for script tag integration.");
          }
          form.addEventListener("submit", function(event) {
            event.preventDefault();
          });
          scriptTag.parentNode.insertBefore(container, scriptTag);
          createOptions = {
            authorization,
            container
          };
          WHITELISTED_DATA_ATTRIBUTES.forEach(function(compositeKey) {
            var value = scriptTag.getAttribute("data-" + compositeKey);
            if (value == null) {
              return;
            }
            addCompositeKeyValuePairToObject(createOptions, compositeKey, value);
          });
          createFunction(createOptions).then(function(instance) {
            analytics.sendEvent(instance._client, "integration-type.script-tag");
            form.addEventListener("submit", function() {
              instance.requestPaymentMethod(function(requestPaymentError, payload) {
                if (requestPaymentError) {
                  return;
                }
                injectHiddenInput("payment_method_nonce", payload.nonce, form);
                if (payload.deviceData) {
                  injectHiddenInput("device_data", payload.deviceData, form);
                }
                form.submit();
              });
            });
          });
        }
        module2.exports = createFromScriptTag;
      }, { "./analytics": 194, "./dropin-error": 199, "./find-parent-form": 200, "./kebab-case-to-camel-case": 204, "@braintree/uuid": 43 }], 198: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            var constants = require2("../constants");
            var analytics = require2("./analytics");
            var assets = require2("@braintree/asset-loader");
            function DataCollector(config) {
              this._config = config;
            }
            DataCollector.prototype.initialize = function() {
              var self2 = this;
              return Promise.resolve().then(function() {
                var braintreeWebVersion;
                if (global2.braintree && global2.braintree.dataCollector) {
                  return Promise.resolve();
                }
                braintreeWebVersion = self2._config.client.getVersion();
                return assets.loadScript({
                  src: "https://js.braintreegateway.com/web/" + braintreeWebVersion + "/js/data-collector.min.js",
                  id: constants.DATA_COLLECTOR_SCRIPT_ID
                });
              }).then(function() {
                return global2.braintree.dataCollector.create(self2._config);
              }).then(function(instance) {
                self2._instance = instance;
              }).catch(function(err) {
                analytics.sendEvent(self2._config.client, "data-collector.setup-failed");
                self2.log(err);
              });
            };
            DataCollector.prototype.log = function(message) {
              console.log(message);
            };
            DataCollector.prototype.getDeviceData = function() {
              if (!this._instance) {
                return "";
              }
              return this._instance.deviceData;
            };
            DataCollector.prototype.teardown = function() {
              if (!this._instance) {
                return Promise.resolve();
              }
              return this._instance.teardown();
            };
            module2.exports = DataCollector;
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../constants": 189, "./analytics": 194, "@braintree/asset-loader": 1 }], 199: [function(require2, module2, exports2) {
        function isBraintreeWebError(err) {
          return err.name === "BraintreeError";
        }
        function DropinError(err) {
          this.name = "DropinError";
          if (typeof err === "string") {
            this.message = err;
          } else {
            this.message = err.message;
          }
          if (isBraintreeWebError(err)) {
            this._braintreeWebError = err;
          } else {
            this._braintreeWebError = err.braintreeWebError;
          }
        }
        DropinError.prototype = Object.create(Error.prototype);
        DropinError.prototype.constructor = DropinError;
        module2.exports = DropinError;
      }, {}], 200: [function(require2, module2, exports2) {
        function findParentForm(element) {
          var parentNode = element.parentNode;
          if (!parentNode || parentNode.nodeName === "FORM") {
            return parentNode;
          }
          return findParentForm(parentNode);
        }
        module2.exports = {
          findParentForm
        };
      }, {}], 201: [function(require2, module2, exports2) {
        var atob2 = require2("./polyfill").atob;
        module2.exports = function(client) {
          var authorizationFingerprint;
          var configuration = client.getConfiguration();
          if (configuration.authorizationType !== "TOKENIZATION_KEY") {
            authorizationFingerprint = JSON.parse(atob2(configuration.authorization)).authorizationFingerprint;
            return !authorizationFingerprint || authorizationFingerprint.indexOf("customer_id=") === -1;
          }
          return true;
        };
      }, { "./polyfill": 205 }], 202: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            function isHTTPS() {
              return global2.location.protocol === "https:";
            }
            module2.exports = {
              isHTTPS
            };
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 203: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            module2.exports = function(win) {
              win = win || global2;
              return Boolean(win.document.characterSet && win.document.characterSet.toLowerCase() === "utf-8");
            };
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 204: [function(require2, module2, exports2) {
        function kebabCaseToCamelCase(kebab) {
          var parts = kebab.split("-");
          var first = parts.shift();
          var capitalizedParts = parts.map(function(part) {
            return part.charAt(0).toUpperCase() + part.substring(1);
          });
          return [first].concat(capitalizedParts).join("");
        }
        module2.exports = kebabCaseToCamelCase;
      }, {}], 205: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            var atobNormalized = typeof global2.atob === "function" ? global2.atob : atob2;
            function atob2(base64String) {
              var a, b, c, b1, b2, b3, b4, i;
              var base64Matcher = new RegExp("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})([=]{1,2})?$");
              var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              var result = "";
              if (!base64Matcher.test(base64String)) {
                throw new Error("Non base64 encoded input passed to window.atob polyfill");
              }
              i = 0;
              do {
                b1 = characters.indexOf(base64String.charAt(i++));
                b2 = characters.indexOf(base64String.charAt(i++));
                b3 = characters.indexOf(base64String.charAt(i++));
                b4 = characters.indexOf(base64String.charAt(i++));
                a = (b1 & 63) << 2 | b2 >> 4 & 3;
                b = (b2 & 15) << 4 | b3 >> 2 & 15;
                c = (b3 & 3) << 6 | b4 & 63;
                result += String.fromCharCode(a) + (b ? String.fromCharCode(b) : "") + (c ? String.fromCharCode(c) : "");
              } while (i < base64String.length);
              return result;
            }
            module2.exports = {
              atob: function(base64String) {
                return atobNormalized.call(global2, base64String);
              },
              _atob: atob2
            };
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 206: [function(require2, module2, exports2) {
        module2.exports = function(string) {
          if (typeof string !== "string") {
            return "";
          }
          return string.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };
      }, {}], 207: [function(require2, module2, exports2) {
        module2.exports = function() {
          var el = document.createElement("div");
          var prop = "flex-basis: 1px";
          var prefixes2 = [
            "-webkit-",
            "-moz-",
            "-ms-",
            "-o-",
            ""
          ];
          prefixes2.forEach(function(prefix) {
            el.style.cssText += prefix + prop;
          });
          return Boolean(el.style.length);
        };
      }, {}], 208: [function(require2, module2, exports2) {
        var assign2 = require2("./assign").assign;
        var threeDSecure = require2("braintree-web/three-d-secure");
        var DEFAULT_ACS_WINDOW_SIZE = "03";
        var PASSTHROUGH_EVENTS = [
          "customer-canceled",
          "authentication-modal-render",
          "authentication-modal-close"
        ];
        function ThreeDSecure(client, model) {
          this._client = client;
          this._model = model;
          this._config = assign2({}, model.merchantConfiguration.threeDSecure);
        }
        ThreeDSecure.prototype.initialize = function() {
          var self2 = this;
          var options = {
            client: this._client,
            version: 2
          };
          if (this._config.cardinalSDKConfig) {
            options.cardinalSDKConfig = this._config.cardinalSDKConfig;
          }
          return threeDSecure.create(options).then(function(instance) {
            self2._instance = instance;
            PASSTHROUGH_EVENTS.forEach(function(eventName) {
              self2._instance.on(eventName, function(event) {
                self2._model._emit("3ds:" + eventName, event);
              });
            });
          });
        };
        ThreeDSecure.prototype.verify = function(payload, merchantProvidedData) {
          var verifyOptions = assign2({
            amount: this._config.amount
          }, merchantProvidedData, {
            nonce: payload.nonce,
            bin: payload.details.bin,
            onLookupComplete: function(data2, next) {
              next();
            }
          });
          verifyOptions.additionalInformation = verifyOptions.additionalInformation || {};
          verifyOptions.additionalInformation.acsWindowSize = verifyOptions.additionalInformation.acsWindowSize || DEFAULT_ACS_WINDOW_SIZE;
          this._model.shouldWaitForVerifyCard = true;
          return this._instance.verifyCard(verifyOptions);
        };
        ThreeDSecure.prototype.updateConfiguration = function(key, value) {
          this._config[key] = value;
        };
        ThreeDSecure.prototype.teardown = function() {
          return this._instance.teardown();
        };
        module2.exports = ThreeDSecure;
      }, { "./assign": 195, "braintree-web/three-d-secure": 140 }], 209: [function(require2, module2, exports2) {
        var browserDetection = require2("./browser-detection");
        function isHidden(element) {
          if (!element) {
            return false;
          }
          if (element.style.display === "none") {
            return true;
          }
          return isHidden(element.parentNode);
        }
        function onTransitionEnd(element, propertyName, callback) {
          if (browserDetection.isIe9() || isHidden(element)) {
            callback();
            return;
          }
          function transitionEventListener(event) {
            if (event.propertyName === propertyName) {
              element.removeEventListener("transitionend", transitionEventListener);
              callback();
            }
          }
          element.addEventListener("transitionend", transitionEventListener);
        }
        module2.exports = {
          onTransitionEnd
        };
      }, { "./browser-detection": 196 }], 210: [function(require2, module2, exports2) {
        function delay(time) {
          time = time || 0;
          return new Promise(function(resolve2) {
            window.setTimeout(resolve2, time);
          });
        }
        module2.exports = {
          delay
        };
      }, {}], 211: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u0627\u0644\u062F\u0641\u0639 \u0628\u0648\u0627\u0633\u0637\u0629 {{paymentSource}}",
          "chooseAnotherWayToPay": "\u0627\u062E\u062A\u0631 \u0637\u0631\u064A\u0642\u0629 \u062F\u0641\u0639 \u0623\u062E\u0631\u0649",
          "chooseAWayToPay": "\u0627\u062E\u062A\u0631 \u0637\u0631\u064A\u0642\u0629 \u0627\u0644\u062F\u0641\u0639",
          "otherWaysToPay": "\u0637\u0631\u0642 \u0623\u062E\u0631\u0649 \u0644\u0644\u062F\u0641\u0639",
          "edit": "\u062A\u062D\u0631\u064A\u0631",
          "doneEditing": "\u062A\u0645",
          "editPaymentMethods": "\u062A\u062D\u0631\u064A\u0631 \u0637\u0631\u0642 \u0627\u0644\u062F\u0641\u0639",
          "CreditCardDeleteConfirmationMessage": "\u0647\u0644 \u062A\u0631\u064A\u062F \u062D\u0630\u0641 \u0628\u0637\u0627\u0642\u0629 {{secondaryIdentifier}} \u0627\u0644\u062A\u064A \u062A\u0646\u062A\u0647\u064A \u0628\u0627\u0644\u0623\u0631\u0642\u0627\u0645 {{identifier}}\u061F",
          "PayPalAccountDeleteConfirmationMessage": "\u0647\u0644 \u062A\u0631\u064A\u062F \u062D\u0630\u0641 {{identifier}}\u0627\u0644\u062D\u0633\u0627\u0628 PayPal\u061F",
          "VenmoAccountDeleteConfirmationMessage": "\u0647\u0644 \u062A\u0631\u064A\u062F \u0641\u0639\u0644\u0627\u064B \u062D\u0630\u0641 \u062D\u0633\u0627\u0628 Venmo \u0627\u0644\u0630\u064A \u064A\u062D\u0645\u0644 \u0627\u0633\u0645 \u0627\u0644\u0645\u0633\u062A\u062E\u062F\u0645 {{identifier}}\u061F",
          "genericDeleteConfirmationMessage": "\u0647\u0644 \u062A\u0631\u064A\u062F \u0628\u0627\u0644\u0641\u0639\u0644 \u062D\u0630\u0641 \u0637\u0631\u064A\u0642\u0629 \u0627\u0644\u062F\u0641\u0639\u061F",
          "deleteCancelButton": "\u0625\u0644\u063A\u0627\u0621",
          "deleteConfirmationButton": "\u062D\u0630\u0641",
          "fieldEmptyForCvv": "\u064A\u0631\u062C\u0649 \u0625\u062F\u062E\u0627\u0644 \u0631\u0645\u0632 \u062D\u0645\u0627\u064A\u0629 \u0627\u0644\u0628\u0637\u0627\u0642\u0629.",
          "fieldEmptyForExpirationDate": "\u064A\u0631\u062C\u0649 \u0625\u062F\u062E\u0627\u0644 \u062A\u0627\u0631\u064A\u062E \u0627\u0646\u062A\u0647\u0627\u0621 \u0627\u0644\u0635\u0644\u0627\u062D\u064A\u0629.",
          "fieldEmptyForCardholderName": "\u064A\u0631\u062C\u0649 \u0625\u062F\u062E\u0627\u0644 \u0627\u0633\u0645 \u0635\u0627\u062D\u0628 \u0627\u0644\u0628\u0637\u0627\u0642\u0629.",
          "fieldTooLongForCardholderName": "\u064A\u062C\u0628 \u0623\u0646 \u064A\u0642\u0644 \u0627\u0633\u0645 \u0635\u0627\u062D\u0628 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u0639\u0646 256 \u062D\u0631\u0641\u0627\u064B.",
          "fieldEmptyForNumber": "\u064A\u0631\u062C\u0649 \u0625\u062F\u062E\u0627\u0644 \u0631\u0642\u0645.",
          "fieldEmptyForPostalCode": "\u064A\u0631\u062C\u0649 \u0625\u062F\u062E\u0627\u0644 \u0627\u0644\u0631\u0645\u0632 \u0627\u0644\u0628\u0631\u064A\u062F\u064A.",
          "fieldInvalidForCardholderName": "\u0627\u0633\u0645 \u062D\u0627\u0645\u0644 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D.",
          "fieldInvalidForCvv": "\u0631\u0645\u0632 \u0627\u0644\u062D\u0645\u0627\u064A\u0629 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D.",
          "fieldInvalidForExpirationDate": "\u062A\u0627\u0631\u064A\u062E \u0627\u0646\u062A\u0647\u0627\u0621 \u0627\u0644\u0635\u0644\u0627\u062D\u064A\u0629 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D.",
          "fieldInvalidForNumber": "\u0631\u0642\u0645 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D.",
          "fieldInvalidForPostalCode": "\u0627\u0644\u0631\u0645\u0632 \u0627\u0644\u0628\u0631\u064A\u062F\u064A \u063A\u064A\u0631 \u0635\u062D\u064A\u062D.",
          "noticeOfCollection": '\u0639\u0646\u062F\u0645\u0627 \u0623\u062F\u0641\u0639 \u0628\u0628\u0637\u0627\u0642\u062A\u064A\u060C \u0641\u0623\u0646\u0627 \u0623\u0648\u0627\u0641\u0642 \u0639\u0644\u0649 "\u0628\u064A\u0627\u0646 \u0627\u0644\u062E\u0635\u0648\u0635\u064A\u0629 \u0644\u062F\u0649 PayPal".',
          "genericError": "\u062D\u062F\u062B \u062E\u0637\u0623 \u0645\u0627 \u0645\u0646 \u062C\u0627\u0646\u0628\u0646\u0627.",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u0647\u0630\u0647 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u0627\u0644\u0627\u0626\u062A\u0645\u0627\u0646\u064A\u0629 \u0645\u062D\u0641\u0648\u0638\u0629 \u0643\u0637\u0631\u064A\u0642\u0629 \u062F\u0641\u0639 \u062D\u0627\u0644\u064A\u0627\u064B.",
          "hostedFieldsFailedTokenizationError": "\u064A\u0631\u062C\u0649 \u0645\u0631\u0627\u062C\u0639\u0629 \u0645\u0639\u0644\u0648\u0645\u0627\u062A\u0643 \u0648\u0625\u0639\u0627\u062F\u0629 \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629.",
          "hostedFieldsFieldsInvalidError": "\u064A\u0631\u062C\u0649 \u0645\u0631\u0627\u062C\u0639\u0629 \u0645\u0639\u0644\u0648\u0645\u0627\u062A\u0643 \u0648\u0625\u0639\u0627\u062F\u0629 \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629.",
          "hostedFieldsTokenizationNetworkErrorError": "\u062E\u0637\u0623 \u0641\u064A \u0627\u0644\u0634\u0628\u0643\u0629. \u064A\u0631\u062C\u0649 \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629 \u0645\u062C\u062F\u062F\u0627\u064B.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u0641\u0634\u0644\u062A \u0645\u0635\u0627\u062F\u0642\u0629 \u0628\u0637\u0627\u0642\u0629 \u0627\u0644\u0627\u0626\u062A\u0645\u0627\u0646. \u064A\u0631\u062C\u0649 \u0645\u0631\u0627\u062C\u0639\u0629 \u0645\u0639\u0644\u0648\u0645\u0627\u062A\u0643 \u0648\u0625\u0639\u0627\u062F\u0629 \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629.",
          "paypalButtonMustBeUsed": "\u0627\u0633\u062A\u062E\u062F\u0645 \u0632\u0631 PayPal \u0644\u0627\u0633\u062A\u0626\u0646\u0627\u0641 \u0627\u0644\u062F\u0641\u0639.",
          "venmoButtonMustBeUsed": "\u0627\u0633\u062A\u062E\u062F\u0650\u0645 \u0632\u0631 Venmo \u0644\u0645\u062A\u0627\u0628\u0639\u0629 \u0625\u062C\u0631\u0627\u0621 \u062F\u0641\u0639\u062A\u0643",
          "applePayButtonMustBeUsed": " \u0627\u0633\u062A\u062E\u062F\u0650\u0645 \u0632\u0631 Apple Pay \u0644\u0645\u062A\u0627\u0628\u0639\u0629 \u0639\u0645\u0644\u064A\u0629 \u0627\u0644\u062F\u0641\u0639 \u0627\u0644\u062A\u064A \u062A\u064F\u062C\u0631\u064A\u0647\u0627.",
          "paypalAccountTokenizationFailedError": "\u0648\u0642\u0639 \u062E\u0637\u0623 \u0623\u062B\u0646\u0627\u0621 \u0625\u0636\u0627\u0641\u0629 \u062D\u0633\u0627\u0628 PayPal. \u064A\u0631\u062C\u0649 \u0625\u0639\u0627\u062F\u0629 \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629.",
          "paypalFlowFailedError": "\u0648\u0642\u0639 \u062E\u0637\u0623 \u0623\u062B\u0646\u0627\u0621 \u0627\u0644\u0627\u062A\u0635\u0627\u0644 \u0628\u0640 PayPal. \u064A\u0631\u062C\u0649 \u0625\u0639\u0627\u062F\u0629 \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629.",
          "paypalTokenizationRequestActiveError": "\u062A\u0641\u0648\u064A\u0636 \u0627\u0644\u062F\u0641\u0639 \u0639\u0628\u0631 PayPal \u0642\u064A\u062F \u0627\u0644\u062A\u0646\u0641\u064A\u0630.",
          "venmoCanceledError": "\u0648\u0642\u0639 \u062E\u0637\u0623. \u062A\u0623\u0643\u062F \u0623\u0646 \u0623\u062D\u062F\u062B \u0625\u0635\u062F\u0627\u0631 \u0645\u0646 \u062A\u0637\u0628\u064A\u0642 Venmo \u0645\u062B\u0628\u062A \u0641\u064A \u062C\u0647\u0627\u0632\u0643 \u0648\u0623\u0646 \u0645\u062A\u0635\u0641\u062D\u0643 \u064A\u062F\u0639\u0645 \u0627\u0644\u062A\u0628\u062F\u064A\u0644 \u0625\u0644\u0649 Venmo.",
          "vaultManagerPaymentMethodDeletionError": "\u0641\u0634\u0644 \u062D\u0630\u0641 \u0637\u0631\u064A\u0642\u0629 \u0627\u0644\u062F\u0641\u0639. \u0623\u0639\u062F \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629.",
          "venmoAppFailedError": "\u062A\u0637\u0628\u064A\u0642 Venmo \u063A\u064A\u0631 \u0645\u0648\u062C\u0648\u062F \u0641\u064A \u062C\u0647\u0627\u0632\u0643.",
          "unsupportedCardTypeError": "\u0646\u0648\u0639 \u0627\u0644\u0628\u0637\u0627\u0642\u0629 \u063A\u064A\u0631 \u0645\u062F\u0639\u0648\u0645. \u064A\u0631\u062C\u0649 \u062A\u062C\u0631\u0628\u0629 \u0628\u0637\u0627\u0642\u0629 \u0623\u062E\u0631\u0649.",
          "applePayTokenizationError": "\u0648\u0642\u0639 \u062E\u0637\u0623 \u0641\u064A \u0627\u0644\u0634\u0628\u0643\u0629 \u0623\u062B\u0646\u0627\u0621 \u0645\u0639\u0627\u0644\u062C\u0629 \u0627\u0644\u062F\u0641\u0639 \u0639\u0628\u0631 Apple Pay. \u064A\u0631\u062C\u0649 \u0625\u0639\u0627\u062F\u0629 \u0627\u0644\u0645\u062D\u0627\u0648\u0644\u0629.",
          "applePayActiveCardError": "\u0625\u0636\u0627\u0641\u0629 \u0628\u0637\u0627\u0642\u0629 \u0645\u062F\u0639\u0648\u0645\u0629 \u0625\u0644\u0649 \u0645\u062D\u0641\u0638\u0629 Apple Pay.",
          "cardholderNameLabel": "\u0627\u0633\u0645 \u0635\u0627\u062D\u0628 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
          "cardNumberLabel": "\u0631\u0642\u0645 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
          "cvvLabel": "\u0631\u0645\u0632 CVV\u200F",
          "cvvThreeDigitLabelSubheading": "(3 \u0623\u0631\u0642\u0627\u0645)",
          "cvvFourDigitLabelSubheading": "(4 \u0623\u0631\u0642\u0627\u0645)",
          "cardholderNamePlaceholder": "\u0627\u0633\u0645 \u0635\u0627\u062D\u0628 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
          "expirationDateLabel": "\u062A\u0627\u0631\u064A\u062E \u0627\u0646\u062A\u0647\u0627\u0621 \u0627\u0644\u0635\u0644\u0627\u062D\u064A\u0629",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "\u0627\u0644\u0634\u0647\u0631/ \u0627\u0644\u0633\u0646\u0629",
          "postalCodeLabel": "\u0627\u0644\u0631\u0645\u0632 \u0627\u0644\u0628\u0631\u064A\u062F\u064A",
          "saveCardLabel": "\u062D\u0641\u0638 \u0627\u0644\u0628\u0637\u0627\u0642\u0629",
          "payWithCard": "\u0627\u0644\u062F\u0641\u0639 \u0628\u0628\u0637\u0627\u0642\u0629 \u0633\u062D\u0628 \u0623\u0648 \u0627\u0626\u062A\u0645\u0627\u0646",
          "endingIn": "\u062A\u0646\u062A\u0647\u064A \u0628\u062A\u0627\u0631\u064A\u062E {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo\u200F",
          "Card": "\u0627\u0644\u0628\u0637\u0627\u0642\u0629",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express\u200F",
          "Discover": "Discover\u200F",
          "Diners Club": "Diners Club\u200F",
          "Elo": "Elo\u200F",
          "Hiper": "Hiper\u200F",
          "Hipercard": "Hipercard\u200F",
          "MasterCard": "Mastercard\u200F",
          "Visa": "Visa\u200F",
          "JCB": "JCB\u200F",
          "Maestro": "Maestro\u200F",
          "UnionPay": "UnionPay\u200F"
        };
      }, {}], 212: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Forma \xFAhrady: {{paymentSource}}",
          "chooseAnotherWayToPay": "Vybrat jin\xFD zp\u016Fsob platby",
          "chooseAWayToPay": "Vybrat zp\u016Fsob platby",
          "otherWaysToPay": "Jin\xE9 zp\u016Fsoby platby",
          "edit": "Upravit",
          "doneEditing": "Hotovo",
          "editPaymentMethods": "Upravit zp\u016Fsoby platby",
          "CreditCardDeleteConfirmationMessage": "Chcete kartu {{secondaryIdentifier}} s koncov\xFDm \u010D\xEDslem {{identifier}}odstranit?",
          "PayPalAccountDeleteConfirmationMessage": "Chcete {{identifier}}\xFA\u010Dtu PayPal odstranit?",
          "VenmoAccountDeleteConfirmationMessage": "Opravdu chcete \xFA\u010Det Venmo s\xA0u\u017Eivatelsk\xFDm jm\xE9nem {{identifier}} odstranit?",
          "genericDeleteConfirmationMessage": "Opravdu chcete tento zp\u016Fsob platby odstranit?",
          "deleteCancelButton": "Zru\u0161it",
          "deleteConfirmationButton": "Odstranit",
          "fieldEmptyForCvv": "Vypl\u0148te k\xF3d CVV.",
          "fieldEmptyForExpirationDate": "Vypl\u0148te datum vypr\u0161en\xED platnosti.",
          "fieldEmptyForCardholderName": "Vypl\u0148te jm\xE9no dr\u017Eitele karty.",
          "fieldTooLongForCardholderName": "Jm\xE9no dr\u017Eitele karty mus\xED obsahovat m\xE9n\u011B ne\u017E 256\xA0znak\u016F.",
          "fieldEmptyForNumber": "Vypl\u0148te \u010D\xEDslo.",
          "fieldEmptyForPostalCode": "Vypl\u0148te po\u0161tovn\xED sm\u011Brovac\xED \u010D\xEDslo.",
          "fieldInvalidForCardholderName": "Toto jm\xE9no dr\u017Eitele karty nen\xED platn\xE9.",
          "fieldInvalidForCvv": "Tento bezpe\u010Dnostn\xED k\xF3d nen\xED platn\xFD.",
          "fieldInvalidForExpirationDate": "Toto datum vypr\u0161en\xED platnosti nen\xED platn\xE9.",
          "fieldInvalidForNumber": "Toto \u010D\xEDslo karty nen\xED platn\xE9.",
          "fieldInvalidForPostalCode": "Toto po\u0161tovn\xED sm\u011Brovac\xED \u010D\xEDslo nen\xED platn\xE9.",
          "noticeOfCollection": "Zaplacen\xEDm kartou vyjad\u0159uji souhlas s\xA0prohl\xE1\u0161en\xEDm o\xA0ochran\u011B osobn\xEDch \xFAdaj\u016F spole\u010Dnosti PayPal.",
          "genericError": "Do\u0161lo k\xA0chyb\u011B na na\u0161\xED stran\u011B.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Tato kreditn\xED karta je ji\u017E jako zp\u016Fsob platby ulo\u017Eena.",
          "hostedFieldsFailedTokenizationError": "Zkontrolujte zadan\xE9 informace a\xA0zkuste to znovu.",
          "hostedFieldsFieldsInvalidError": "Zkontrolujte zadan\xE9 informace a\xA0zkuste to znovu.",
          "hostedFieldsTokenizationNetworkErrorError": "Do\u0161lo k\xA0chyb\u011B s\xEDt\u011B. Zkuste to znovu.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Ov\u011B\u0159en\xED kreditn\xED karty se nezda\u0159ilo. Zkontrolujte zadan\xE9 informace a\xA0zkuste to znovu.",
          "paypalButtonMustBeUsed": "Chcete-li p\u0159ej\xEDt k\xA0platb\u011B, pou\u017Eijte tla\u010D\xEDtko PayPal.",
          "venmoButtonMustBeUsed": "Chcete-li pokra\u010Dovat v placen\xED, pou\u017Eijte tla\u010D\xEDtko Venmo.",
          "applePayButtonMustBeUsed": "Chcete-li p\u0159ej\xEDt k platb\u011B, pou\u017Eijte tla\u010D\xEDtko Apple Pay.",
          "paypalAccountTokenizationFailedError": "P\u0159i p\u0159id\xE1v\xE1n\xED \xFA\u010Dtu PayPal do\u0161lo k\xA0chyb\u011B. Zkuste to znovu.",
          "paypalFlowFailedError": "P\u0159i p\u0159ipojov\xE1n\xED ke slu\u017Eb\u011B PayPal do\u0161lo k\xA0chyb\u011B. Zkuste to znovu.",
          "paypalTokenizationRequestActiveError": "Autorizace platby p\u0159es PayPal ji\u017E prob\xEDh\xE1.",
          "venmoCanceledError": "Do\u0161lo k\xA0chyb\u011B. Zkontrolujte, zda m\xE1te v\xA0za\u0159\xEDzen\xED nainstalovanou nejnov\u011Bj\u0161\xED verzi aplikace Venmo a\xA0zda prohl\xED\u017Ee\u010D p\u0159echod na aplikaci Venmo podporuje.",
          "vaultManagerPaymentMethodDeletionError": "Zp\u016Fsob platby se nepoda\u0159ilo odstranit. Zkuste to znovu.",
          "venmoAppFailedError": "Aplikaci Venmo se ve va\u0161em za\u0159\xEDzen\xED nepoda\u0159ilo naj\xEDt.",
          "unsupportedCardTypeError": "Tento typ karty nen\xED podporov\xE1n. Vyzkou\u0161ejte jinou kartu.",
          "applePayTokenizationError": "P\u0159i zpracov\xE1n\xED platby p\u0159es Apple Pay do\u0161lo k\xA0chyb\u011B s\xEDt\u011B. Zkuste to znovu.",
          "applePayActiveCardError": "P\u0159idejte si podporovanou kartu do pen\u011B\u017Eenky Apple Pay.",
          "cardholderNameLabel": "Jm\xE9no dr\u017Eitele karty",
          "cardNumberLabel": "\u010C\xEDslo karty",
          "cvvLabel": "K\xF3d\xA0CVV",
          "cvvThreeDigitLabelSubheading": "(3\xA0\u010D\xEDslice)",
          "cvvFourDigitLabelSubheading": "(4\xA0\u010D\xEDslice)",
          "cardholderNamePlaceholder": "Jm\xE9no dr\u017Eitele karty",
          "expirationDateLabel": "Datum vypr\u0161en\xED platnosti",
          "expirationDateLabelSubheading": "(MM/RR)",
          "expirationDatePlaceholder": "MM/RR",
          "postalCodeLabel": "Po\u0161tovn\xED sm\u011Brovac\xED \u010D\xEDslo",
          "saveCardLabel": "Ulo\u017Eit kartu",
          "payWithCard": "Zaplatit kartou",
          "endingIn": "Koncov\xE9 \u010D\xEDslo {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Karta",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 213: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Betaling med {{paymentSource}}",
          "chooseAnotherWayToPay": "V\xE6lg en anden betalingsmetode",
          "chooseAWayToPay": "V\xE6lg, hvordan du vil betale",
          "otherWaysToPay": "Andre m\xE5der at betale p\xE5",
          "edit": "Rediger",
          "doneEditing": "Udf\xF8rt",
          "editPaymentMethods": "Rediger betalingsmetode",
          "CreditCardDeleteConfirmationMessage": "Vil du slette dit {{secondaryIdentifier}}-kort, der slutter p\xE5 {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Vil du slette PayPal-kontoen for {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Er du sikker p\xE5, at du vil slette Venmo-konto med brugernavnet {{identifier}}?",
          "genericDeleteConfirmationMessage": "Er du sikker p\xE5, at du vil slette denne betalingsmetode?",
          "deleteCancelButton": "Annuller",
          "deleteConfirmationButton": "Slet",
          "fieldEmptyForCvv": "Du skal indtaste kontrolcifrene.",
          "fieldEmptyForExpirationDate": "Du skal indtaste en udl\xF8bsdato.",
          "fieldEmptyForCardholderName": "Du skal indtaste kortholderens navn.",
          "fieldTooLongForCardholderName": "Kortholders navn skal v\xE6re mindre end 256 tegn.",
          "fieldEmptyForNumber": "Du skal indtaste et nummer.",
          "fieldEmptyForPostalCode": "Du skal indtaste et postnummer.",
          "fieldInvalidForCardholderName": "Kortindehaverens navn er ugyldigt.",
          "fieldInvalidForCvv": "Denne sikkerhedskode er ugyldig.",
          "fieldInvalidForExpirationDate": "Denne udl\xF8bsdato er ugyldig.",
          "fieldInvalidForNumber": "Dette kortnummer er ikke gyldigt.",
          "fieldInvalidForPostalCode": "Dette postnummer er ikke gyldigt.",
          "noticeOfCollection": "N\xE5r jeg betaler med mit kort, accepterer jeg PayPals erkl\xE6ring om personlige oplysninger.",
          "genericError": "Der opstod en fejl.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Dette betalingskort findes allerede som en gemt betalingsmetode.",
          "hostedFieldsFailedTokenizationError": "Tjek oplysningerne, og pr\xF8v igen.",
          "hostedFieldsFieldsInvalidError": "Tjek oplysningerne, og pr\xF8v igen.",
          "hostedFieldsTokenizationNetworkErrorError": "Netv\xE6rksfejl. Pr\xF8v igen.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Bekr\xE6ftelse af betalingskort mislykkedes. Tjek oplysningerne, og pr\xF8v igen.",
          "paypalButtonMustBeUsed": "Brug PayPal-knappen til at forts\xE6tte med din betaling.",
          "venmoButtonMustBeUsed": "Brug Venmo-knappen til at forts\xE6tte med din betaling.",
          "applePayButtonMustBeUsed": "Brug Apple Pay-knappen til at forts\xE6tte med din betaling.",
          "paypalAccountTokenizationFailedError": "Der opstod en fejl under tilf\xF8jelsen af PayPal-kontoen. Pr\xF8v igen.",
          "paypalFlowFailedError": "Det lykkedes ikke at oprette forbindelse til PayPal. Pr\xF8v igen.",
          "paypalTokenizationRequestActiveError": "PayPals betalingsautorisation er allerede i gang.",
          "venmoCanceledError": "Der opstod et problem. S\xF8rg for, at den nyeste version af Venmo-appen er installeret p\xE5 din enhed, og at din browser underst\xF8tter skift til Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Betalingsmetoden kunne ikke slettes. Pr\xF8v igen.",
          "venmoAppFailedError": "Venmo-appen blev ikke fundet p\xE5 din enhed.",
          "unsupportedCardTypeError": "Korttypen underst\xF8ttes ikke. Pr\xF8v et andet kort.",
          "applePayTokenizationError": "Der opstod en netv\xE6rksfejl under behandling af Apple Pay-betalingen. Pr\xF8v igen.",
          "applePayActiveCardError": "F\xF8j et underst\xF8ttet kort til din Apple Pay-e-pung.",
          "cardholderNameLabel": "Kortindehaverens navn",
          "cardNumberLabel": "Kortnummer",
          "cvvLabel": "Kontrolcifre",
          "cvvThreeDigitLabelSubheading": "(3 cifre)",
          "cvvFourDigitLabelSubheading": "(4 cifre)",
          "cardholderNamePlaceholder": "Kortindehaverens navn",
          "expirationDateLabel": "Udl\xF8bsdato",
          "expirationDateLabelSubheading": "(MM/\xC5\xC5)",
          "expirationDatePlaceholder": "MM/\xC5\xC5",
          "postalCodeLabel": "Postnummer",
          "saveCardLabel": "Gem kort",
          "payWithCard": "Betal med betalingskort",
          "endingIn": "Slutter p\xE5 {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Kort",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 214: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Zahlen mit {{paymentSource}}",
          "chooseAnotherWayToPay": "W\xE4hlen Sie eine andere Zahlungsquelle",
          "chooseAWayToPay": "W\xE4hlen Sie eine Zahlungsquelle",
          "otherWaysToPay": "Sonstige Zahlungsquellen",
          "edit": "\xC4ndern",
          "doneEditing": "Fertig",
          "editPaymentMethods": "Zahlungsquellen bearbeiten",
          "CreditCardDeleteConfirmationMessage": "{{secondaryIdentifier}}-Karte mit den Endziffern {{identifier}} l\xF6schen?",
          "PayPalAccountDeleteConfirmationMessage": "PayPal-Konto {{identifier}} l\xF6schen?",
          "VenmoAccountDeleteConfirmationMessage": "Wollen Sie das Venmo-Konto mit dem Benutzernamen {{identifier}} wirklich l\xF6schen?",
          "genericDeleteConfirmationMessage": "M\xF6chten Sie diese Zahlungsquelle wirklich l\xF6schen?",
          "deleteCancelButton": "Abbrechen",
          "deleteConfirmationButton": "L\xF6schen",
          "fieldEmptyForCvv": "Geben Sie die Kartenpr\xFCfnummer (CVV) ein.",
          "fieldEmptyForExpirationDate": "Geben Sie das Ablaufdatum ein.",
          "fieldEmptyForCardholderName": "Geben Sie den Namen des Karteninhabers ein.",
          "fieldTooLongForCardholderName": "Der Name des Karteninhabers darf nicht l\xE4nger als 256 Zeichen sein.",
          "fieldEmptyForNumber": "Geben Sie eine Nummer ein.",
          "fieldEmptyForPostalCode": "Geben Sie eine Postleitzahl ein.",
          "fieldInvalidForCardholderName": "Der Name des Karteninhabers ist nicht g\xFCltig.",
          "fieldInvalidForCvv": "Diese Kartenpr\xFCfnummer ist ung\xFCltig.",
          "fieldInvalidForExpirationDate": "Dieses Ablaufdatum ist ung\xFCltig.",
          "fieldInvalidForNumber": "Diese Kartennummer ist ung\xFCltig.",
          "fieldInvalidForPostalCode": "Diese Postleitzahl ist ung\xFCltig.",
          "noticeOfCollection": "Indem ich mit meiner Karte bezahle, stimme ich der PayPal-Datenschutzerkl\xE4rung zu.",
          "genericError": "Bei uns ist ein Fehler aufgetreten.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Diese Kreditkarte ist bereits als gespeicherte Zahlungsquelle vorhanden.",
          "hostedFieldsFailedTokenizationError": "Bitte pr\xFCfen Sie die Informationen und versuchen Sie es erneut.",
          "hostedFieldsFieldsInvalidError": "Bitte pr\xFCfen Sie die Informationen und versuchen Sie es erneut.",
          "hostedFieldsTokenizationNetworkErrorError": "Netzwerkfehler. Versuchen Sie es bitte erneut.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Die Kreditkartenverifizierung ist fehlgeschlagen. Bitte pr\xFCfen Sie die Informationen und versuchen Sie es erneut.",
          "paypalButtonMustBeUsed": "Verwenden Sie den PayPal-Button, um mit der Zahlung fortzufahren.",
          "venmoButtonMustBeUsed": "Verwenden Sie den Venmo-Button, um mit Ihrer Zahlung fortzufahren.",
          "applePayButtonMustBeUsed": "Verwenden Sie den Apple Pay-Button, um mit der Zahlung fortzufahren.",
          "paypalAccountTokenizationFailedError": "Beim Hinzuf\xFCgen des PayPal-Kontos ist ein Fehler aufgetreten. Versuchen Sie es bitte erneut.",
          "paypalFlowFailedError": "Bei der Verbindung mit PayPal ist ein Fehler aufgetreten. Versuchen Sie es bitte erneut.",
          "paypalTokenizationRequestActiveError": "Die PayPal-Zahlungsautorisierung wird bereits vorgenommen.",
          "venmoCanceledError": "Etwas ist schief gelaufen. Vergewissern Sie sich, dass Sie die neueste Version der Venmo-App auf Ihrem Ger\xE4t installiert haben und Ihr Browser den Wechsel zu Venmo unterst\xFCtzt.",
          "vaultManagerPaymentMethodDeletionError": "Die Zahlungsquelle konnte nicht gel\xF6scht werden. Versuchen Sie es erneut.",
          "venmoAppFailedError": "Die Venmo-App wurde nicht auf Ihrem Ger\xE4t gefunden.",
          "unsupportedCardTypeError": "Dieser Kartentyp wird nicht unterst\xFCtzt. Versuchen Sie es mit einer anderen Karte.",
          "applePayTokenizationError": "Bei der Verarbeitung der Apple Pay-Zahlung ist ein Netzwerkfehler aufgetreten. Versuchen Sie es bitte erneut.",
          "applePayActiveCardError": "F\xFCgen Sie Ihrem Apple Pay-Wallet eine unterst\xFCtzte Karte hinzu.",
          "cardholderNameLabel": "Name des Karteninhabers",
          "cardNumberLabel": "Kartennummer",
          "cvvLabel": "Kartenpr\xFCfnummer",
          "cvvThreeDigitLabelSubheading": "(3-stellig)",
          "cvvFourDigitLabelSubheading": "(4-stellig)",
          "cardholderNamePlaceholder": "Name des Karteninhabers",
          "expirationDateLabel": "G\xFCltig bis",
          "expirationDateLabelSubheading": "(MM/JJ)",
          "expirationDatePlaceholder": "MM/JJ",
          "postalCodeLabel": "Postleitzahl",
          "saveCardLabel": "Karte speichern",
          "payWithCard": "Mit Karte zahlen",
          "endingIn": "Mit den Endziffern {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Karte",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 215: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u03A0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE \u03BC\u03B5 {{paymentSource}}",
          "chooseAnotherWayToPay": "\u0395\u03C0\u03B9\u03BB\u03BF\u03B3\u03AE \u03B5\u03BD\u03CC\u03C2 \u03AC\u03BB\u03BB\u03BF\u03C5 \u03C4\u03C1\u03CC\u03C0\u03BF\u03C5 \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2",
          "chooseAWayToPay": "\u0395\u03C0\u03B9\u03BB\u03BF\u03B3\u03AE \u03C4\u03C1\u03CC\u03C0\u03BF\u03C5 \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2",
          "otherWaysToPay": "\u0386\u03BB\u03BB\u03BF\u03B9 \u03C4\u03C1\u03CC\u03C0\u03BF\u03B9 \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2",
          "edit": "\u0395\u03C0\u03B5\u03BE\u03B5\u03C1\u03B3\u03B1\u03C3\u03AF\u03B1",
          "doneEditing": "\u03A4\u03AD\u03BB\u03BF\u03C2",
          "editPaymentMethods": "\u0395\u03C0\u03B5\u03BE\u03B5\u03C1\u03B3\u03B1\u03C3\u03AF\u03B1 \u03BC\u03B5\u03B8\u03CC\u03B4\u03C9\u03BD \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2",
          "CreditCardDeleteConfirmationMessage": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03C4\u03B7\u03C2 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2 {{secondaryIdentifier}} \u03C0\u03BF\u03C5 \u03BB\u03AE\u03B3\u03B5\u03B9 \u03C3\u03B5 {{identifier}};",
          "PayPalAccountDeleteConfirmationMessage": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE {{identifier}}\u03BB\u03BF\u03B3\u03B1\u03C1\u03B9\u03B1\u03C3\u03BC\u03BF\u03CD PayPal;",
          "VenmoAccountDeleteConfirmationMessage": "\u0398\u03AD\u03BB\u03B5\u03C4\u03B5 \u03C3\u03AF\u03B3\u03BF\u03C5\u03C1\u03B1 \u03BD\u03B1 \u03B4\u03B9\u03B1\u03B3\u03C1\u03AC\u03C8\u03B5\u03C4\u03B5 \u03C4\u03BF\u03BD \u03BB\u03BF\u03B3\u03B1\u03C1\u03B9\u03B1\u03C3\u03BC\u03CC Venmo \u03BC\u03B5 \u03C4\u03BF \u03CC\u03BD\u03BF\u03BC\u03B1 \u03C7\u03C1\u03AE\u03C3\u03C4\u03B7 {{identifier}};",
          "genericDeleteConfirmationMessage": "\u0398\u03AD\u03BB\u03B5\u03C4\u03B5 \u03C3\u03AF\u03B3\u03BF\u03C5\u03C1\u03B1 \u03BD\u03B1 \u03B4\u03B9\u03B1\u03B3\u03C1\u03AC\u03C8\u03B5\u03C4\u03B5 \u03B1\u03C5\u03C4\u03AE\u03BD \u03C4\u03B7 \u03BC\u03AD\u03B8\u03BF\u03B4\u03BF \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2;",
          "deleteCancelButton": "\u0391\u03BA\u03CD\u03C1\u03C9\u03C3\u03B7",
          "deleteConfirmationButton": "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE",
          "fieldEmptyForCvv": "\u03A3\u03C5\u03BC\u03C0\u03BB\u03B7\u03C1\u03CE\u03C3\u03C4\u03B5 \u03AD\u03BD\u03B1\u03BD \u03BA\u03C9\u03B4\u03B9\u03BA\u03CC \u03B1\u03C3\u03C6\u03B1\u03BB\u03B5\u03AF\u03B1\u03C2 (CVV).",
          "fieldEmptyForExpirationDate": "\u03A3\u03C5\u03BC\u03C0\u03BB\u03B7\u03C1\u03CE\u03C3\u03C4\u03B5 \u03B7\u03BC\u03B5\u03C1\u03BF\u03BC\u03B7\u03BD\u03AF\u03B1 \u03BB\u03AE\u03BE\u03B7\u03C2.",
          "fieldEmptyForCardholderName": "\u03A3\u03C5\u03BC\u03C0\u03BB\u03B7\u03C1\u03CE\u03C3\u03C4\u03B5 \u03C4\u03BF \u03CC\u03BD\u03BF\u03BC\u03B1 \u03B5\u03BD\u03CC\u03C2 \u03BA\u03B1\u03C4\u03CC\u03C7\u03BF\u03C5 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2.",
          "fieldTooLongForCardholderName": "\u03A4\u03BF \u03CC\u03BD\u03BF\u03BC\u03B1 \u03C4\u03BF\u03C5 \u03BA\u03B1\u03C4\u03CC\u03C7\u03BF\u03C5 \u03C4\u03B7\u03C2 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2 \u03C0\u03C1\u03AD\u03C0\u03B5\u03B9 \u03BD\u03B1 \u03C0\u03B5\u03C1\u03B9\u03AD\u03C7\u03B5\u03B9 \u03BB\u03B9\u03B3\u03CC\u03C4\u03B5\u03C1\u03BF\u03C5\u03C2 \u03B1\u03C0\u03CC 256 \u03C7\u03B1\u03C1\u03B1\u03BA\u03C4\u03AE\u03C1\u03B5\u03C2.",
          "fieldEmptyForNumber": "\u03A3\u03C5\u03BC\u03C0\u03BB\u03B7\u03C1\u03CE\u03C3\u03C4\u03B5 \u03AD\u03BD\u03B1\u03BD \u03B1\u03C1\u03B9\u03B8\u03BC\u03CC.",
          "fieldEmptyForPostalCode": "\u03A3\u03C5\u03BC\u03C0\u03BB\u03B7\u03C1\u03CE\u03C3\u03C4\u03B5 \u03AD\u03BD\u03B1\u03BD \u03C4\u03B1\u03C7\u03C5\u03B4\u03C1\u03BF\u03BC\u03B9\u03BA\u03CC \u03BA\u03CE\u03B4\u03B9\u03BA\u03B1.",
          "fieldInvalidForCardholderName": "\u0391\u03C5\u03C4\u03CC \u03C4\u03BF \u03CC\u03BD\u03BF\u03BC\u03B1 \u03BA\u03B1\u03C4\u03CC\u03C7\u03BF\u03C5 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2 \u03B4\u03B5\u03BD \u03B5\u03AF\u03BD\u03B1\u03B9 \u03AD\u03B3\u03BA\u03C5\u03C1\u03BF.",
          "fieldInvalidForCvv": "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BF \u03BA\u03C9\u03B4\u03B9\u03BA\u03CC\u03C2 \u03B1\u03C3\u03C6\u03B1\u03BB\u03B5\u03AF\u03B1\u03C2 \u03B4\u03B5\u03BD \u03B5\u03AF\u03BD\u03B1\u03B9 \u03AD\u03B3\u03BA\u03C5\u03C1\u03BF\u03C2.",
          "fieldInvalidForExpirationDate": "\u0391\u03C5\u03C4\u03AE \u03B7 \u03B7\u03BC\u03B5\u03C1\u03BF\u03BC\u03B7\u03BD\u03AF\u03B1 \u03BB\u03AE\u03BE\u03B7\u03C2 \u03B4\u03B5\u03BD \u03B5\u03AF\u03BD\u03B1\u03B9 \u03AD\u03B3\u03BA\u03C5\u03C1\u03B7.",
          "fieldInvalidForNumber": "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BF \u03B1\u03C1\u03B9\u03B8\u03BC\u03CC\u03C2 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2 \u03B4\u03B5\u03BD \u03B5\u03AF\u03BD\u03B1\u03B9 \u03AD\u03B3\u03BA\u03C5\u03C1\u03BF\u03C2.",
          "fieldInvalidForPostalCode": "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BF \u03C4\u03B1\u03C7\u03C5\u03B4\u03C1\u03BF\u03BC\u03B9\u03BA\u03CC\u03C2 \u03BA\u03CE\u03B4\u03B9\u03BA\u03B1\u03C2 \u03B4\u03B5\u03BD \u03B5\u03AF\u03BD\u03B1\u03B9 \u03AD\u03B3\u03BA\u03C5\u03C1\u03BF\u03C2.",
          "noticeOfCollection": "\u03A0\u03BB\u03B7\u03C1\u03CE\u03BD\u03BF\u03BD\u03C4\u03B1\u03C2 \u03BC\u03B5 \u03C4\u03B7\u03BD \u03BA\u03AC\u03C1\u03C4\u03B1 \u03BC\u03BF\u03C5, \u03B1\u03C0\u03BF\u03B4\u03AD\u03C7\u03BF\u03BC\u03B1\u03B9 \u03C4\u03B7 \u0394\u03AE\u03BB\u03C9\u03C3\u03B7 \u03B1\u03C0\u03BF\u03C1\u03C1\u03AE\u03C4\u03BF\u03C5 \u03C4\u03B7\u03C2 PayPal.",
          "genericError": "\u03A0\u03C1\u03BF\u03AD\u03BA\u03C5\u03C8\u03B5 \u03C0\u03C1\u03CC\u03B2\u03BB\u03B7\u03BC\u03B1 \u03C3\u03C4\u03BF \u03C3\u03CD\u03C3\u03C4\u03B7\u03BC\u03AC \u03BC\u03B1\u03C2.",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u0391\u03C5\u03C4\u03AE \u03B7 \u03C0\u03B9\u03C3\u03C4\u03C9\u03C4\u03B9\u03BA\u03AE \u03BA\u03AC\u03C1\u03C4\u03B1 \u03C5\u03C0\u03AC\u03C1\u03C7\u03B5\u03B9 \u03AE\u03B4\u03B7 \u03C9\u03C2 \u03B1\u03C0\u03BF\u03B8\u03B7\u03BA\u03B5\u03C5\u03BC\u03AD\u03BD\u03B7 \u03BC\u03AD\u03B8\u03BF\u03B4\u03BF\u03C2 \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2.",
          "hostedFieldsFailedTokenizationError": "\u0395\u03BB\u03AD\u03B3\u03BE\u03C4\u03B5 \u03C4\u03B1 \u03C3\u03C4\u03BF\u03B9\u03C7\u03B5\u03AF\u03B1 \u03C3\u03B1\u03C2 \u03BA\u03B1\u03B9 \u03B4\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BE\u03B1\u03BD\u03AC.",
          "hostedFieldsFieldsInvalidError": "\u0395\u03BB\u03AD\u03B3\u03BE\u03C4\u03B5 \u03C4\u03B1 \u03C3\u03C4\u03BF\u03B9\u03C7\u03B5\u03AF\u03B1 \u03C3\u03B1\u03C2 \u03BA\u03B1\u03B9 \u03B4\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BE\u03B1\u03BD\u03AC.",
          "hostedFieldsTokenizationNetworkErrorError": "\u03A3\u03C6\u03AC\u03BB\u03BC\u03B1 \u03B4\u03B9\u03BA\u03C4\u03CD\u03BF\u03C5. \u0394\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BE\u03B1\u03BD\u03AC.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u0397 \u03B5\u03C0\u03B1\u03BB\u03AE\u03B8\u03B5\u03C5\u03C3\u03B7 \u03C4\u03B7\u03C2 \u03C0\u03B9\u03C3\u03C4\u03C9\u03C4\u03B9\u03BA\u03AE\u03C2 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2 \u03B1\u03C0\u03AD\u03C4\u03C5\u03C7\u03B5. \u0395\u03BB\u03AD\u03B3\u03BE\u03C4\u03B5 \u03C4\u03B1 \u03C3\u03C4\u03BF\u03B9\u03C7\u03B5\u03AF\u03B1 \u03C3\u03B1\u03C2 \u03BA\u03B1\u03B9 \u03B4\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BE\u03B1\u03BD\u03AC.",
          "paypalButtonMustBeUsed": "\u03A7\u03C1\u03B7\u03C3\u03B9\u03BC\u03BF\u03C0\u03BF\u03B9\u03AE\u03C3\u03C4\u03B5 \u03C4\u03BF \u03BA\u03BF\u03C5\u03BC\u03C0\u03AF PayPal \u03B3\u03B9\u03B1 \u03BD\u03B1 \u03C3\u03C5\u03BD\u03B5\u03C7\u03AF\u03C3\u03B5\u03C4\u03B5 \u03BC\u03B5 \u03C4\u03B7\u03BD \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE.",
          "venmoButtonMustBeUsed": "\u03A7\u03C1\u03B7\u03C3\u03B9\u03BC\u03BF\u03C0\u03BF\u03B9\u03AE\u03C3\u03C4\u03B5 \u03C4\u03BF \u03BA\u03BF\u03C5\u03BC\u03C0\u03AF Venmo \u03B3\u03B9\u03B1 \u03BD\u03B1 \u03C3\u03C5\u03BD\u03B5\u03C7\u03AF\u03C3\u03B5\u03C4\u03B5 \u03BC\u03B5 \u03C4\u03B7\u03BD \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE \u03C3\u03B1\u03C2.",
          "applePayButtonMustBeUsed": "\u03A7\u03C1\u03B7\u03C3\u03B9\u03BC\u03BF\u03C0\u03BF\u03B9\u03AE\u03C3\u03C4\u03B5 \u03C4\u03BF \u03BA\u03BF\u03C5\u03BC\u03C0\u03AF Apple Pay \u03B3\u03B9\u03B1 \u03BD\u03B1 \u03C3\u03C5\u03BD\u03B5\u03C7\u03AF\u03C3\u03B5\u03C4\u03B5 \u03BC\u03B5 \u03C4\u03B7\u03BD \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE.",
          "paypalAccountTokenizationFailedError": "\u03A0\u03C1\u03BF\u03AD\u03BA\u03C5\u03C8\u03B5 \u03BA\u03AC\u03C0\u03BF\u03B9\u03BF \u03C0\u03C1\u03CC\u03B2\u03BB\u03B7\u03BC\u03B1 \u03BC\u03B5 \u03C4\u03B7\u03BD \u03C0\u03C1\u03BF\u03C3\u03B8\u03AE\u03BA\u03B7 \u03C4\u03BF\u03C5 \u03BB\u03BF\u03B3\u03B1\u03C1\u03B9\u03B1\u03C3\u03BC\u03BF\u03CD PayPal. \u0394\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BE\u03B1\u03BD\u03AC.",
          "paypalFlowFailedError": "\u03A0\u03C1\u03BF\u03AD\u03BA\u03C5\u03C8\u03B5 \u03BA\u03AC\u03C0\u03BF\u03B9\u03BF \u03C0\u03C1\u03CC\u03B2\u03BB\u03B7\u03BC\u03B1 \u03BC\u03B5 \u03C4\u03B7 \u03C3\u03CD\u03BD\u03B4\u03B5\u03C3\u03B7 \u03C3\u03C4\u03B7\u03BD PayPal. \u0394\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BE\u03B1\u03BD\u03AC.",
          "paypalTokenizationRequestActiveError": "\u0397 \u03B5\u03BE\u03BF\u03C5\u03C3\u03B9\u03BF\u03B4\u03CC\u03C4\u03B7\u03C3\u03B7 \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2 \u03BC\u03AD\u03C3\u03C9 PayPal \u03B2\u03C1\u03AF\u03C3\u03BA\u03B5\u03C4\u03B1\u03B9 \u03AE\u03B4\u03B7 \u03C3\u03B5 \u03B5\u03BE\u03AD\u03BB\u03B9\u03BE\u03B7.",
          "venmoCanceledError": "\u03A0\u03C1\u03BF\u03AD\u03BA\u03C5\u03C8\u03B5 \u03C0\u03C1\u03CC\u03B2\u03BB\u03B7\u03BC\u03B1. \u0392\u03B5\u03B2\u03B1\u03B9\u03C9\u03B8\u03B5\u03AF\u03C4\u03B5 \u03CC\u03C4\u03B9 \u03AD\u03C7\u03B5\u03C4\u03B5 \u03C4\u03B7\u03BD \u03C0\u03B9\u03BF \u03C0\u03C1\u03CC\u03C3\u03C6\u03B1\u03C4\u03B7 \u03AD\u03BA\u03B4\u03BF\u03C3\u03B7 \u03C4\u03B7\u03C2 \u03B5\u03C6\u03B1\u03C1\u03BC\u03BF\u03B3\u03AE\u03C2 Venmo \u03B5\u03B3\u03BA\u03B1\u03C4\u03B5\u03C3\u03C4\u03B7\u03BC\u03AD\u03BD\u03B7 \u03C3\u03C4\u03B7 \u03C3\u03C5\u03C3\u03BA\u03B5\u03C5\u03AE \u03C3\u03B1\u03C2 \u03BA\u03B1\u03B9 \u03CC\u03C4\u03B9 \u03C4\u03BF \u03C0\u03C1\u03CC\u03B3\u03C1\u03B1\u03BC\u03BC\u03B1 \u03C0\u03B5\u03C1\u03B9\u03AE\u03B3\u03B7\u03C3\u03AE\u03C2 \u03C3\u03B1\u03C2 \u03C5\u03C0\u03BF\u03C3\u03C4\u03B7\u03C1\u03AF\u03B6\u03B5\u03B9 \u03C4\u03B7 \u03BC\u03B5\u03C4\u03AC\u03B2\u03B1\u03C3\u03B7 \u03C3\u03C4\u03B7 Venmo.",
          "vaultManagerPaymentMethodDeletionError": "\u0397 \u03B4\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE \u03C4\u03B7\u03C2 \u03BC\u03B5\u03B8\u03CC\u03B4\u03BF\u03C5 \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2 \u03B5\u03AF\u03BD\u03B1\u03B9 \u03B1\u03B4\u03CD\u03BD\u03B1\u03C4\u03B7, \u03B4\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BE\u03B1\u03BD\u03AC.",
          "venmoAppFailedError": "\u0397 \u03B5\u03C6\u03B1\u03C1\u03BC\u03BF\u03B3\u03AE Venmo \u03B4\u03B5\u03BD \u03B2\u03C1\u03AD\u03B8\u03B7\u03BA\u03B5 \u03C3\u03C4\u03B7 \u03C3\u03C5\u03C3\u03BA\u03B5\u03C5\u03AE \u03C3\u03B1\u03C2.",
          "unsupportedCardTypeError": "\u0391\u03C5\u03C4\u03CC\u03C2 \u03BF \u03C4\u03CD\u03C0\u03BF\u03C2 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2 \u03B4\u03B5\u03BD \u03C5\u03C0\u03BF\u03C3\u03C4\u03B7\u03C1\u03AF\u03B6\u03B5\u03C4\u03B1\u03B9. \u0394\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BC\u03B9\u03B1 \u03AC\u03BB\u03BB\u03B7 \u03BA\u03AC\u03C1\u03C4\u03B1.",
          "applePayTokenizationError": "\u03A0\u03C1\u03BF\u03AD\u03BA\u03C5\u03C8\u03B5 \u03C3\u03C6\u03AC\u03BB\u03BC\u03B1 \u03B4\u03B9\u03BA\u03C4\u03CD\u03BF\u03C5 \u03BA\u03B1\u03C4\u03AC \u03C4\u03B7\u03BD \u03B5\u03C0\u03B5\u03BE\u03B5\u03C1\u03B3\u03B1\u03C3\u03AF\u03B1 \u03C4\u03B7\u03C2 \u03C0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE\u03C2 \u03BC\u03AD\u03C3\u03C9 Apple Pay. \u0394\u03BF\u03BA\u03B9\u03BC\u03AC\u03C3\u03C4\u03B5 \u03BE\u03B1\u03BD\u03AC.",
          "applePayActiveCardError": "\u03A0\u03C1\u03BF\u03C3\u03B8\u03AD\u03C3\u03C4\u03B5 \u03BC\u03B9\u03B1 \u03C5\u03C0\u03BF\u03C3\u03C4\u03B7\u03C1\u03B9\u03B6\u03CC\u03BC\u03B5\u03BD\u03B7 \u03BA\u03AC\u03C1\u03C4\u03B1 \u03C3\u03C4\u03BF \u03C8\u03B7\u03C6\u03B9\u03B1\u03BA\u03CC \u03C0\u03BF\u03C1\u03C4\u03BF\u03C6\u03CC\u03BB\u03B9 Apple Pay.",
          "cardholderNameLabel": "\u038C\u03BD\u03BF\u03BC\u03B1 \u03BA\u03B1\u03C4\u03CC\u03C7\u03BF\u03C5 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2",
          "cardNumberLabel": "\u0391\u03C1\u03B9\u03B8\u03BC\u03CC\u03C2 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2",
          "cvvLabel": "\u039A\u03C9\u03B4\u03B9\u03BA\u03CC\u03C2 \u03B1\u03C3\u03C6\u03B1\u03BB\u03B5\u03AF\u03B1\u03C2 (CVV)",
          "cvvThreeDigitLabelSubheading": "(3 \u03C8\u03B7\u03C6\u03AF\u03B1)",
          "cvvFourDigitLabelSubheading": "(4 \u03C8\u03B7\u03C6\u03AF\u03B1)",
          "cardholderNamePlaceholder": "\u038C\u03BD\u03BF\u03BC\u03B1 \u03BA\u03B1\u03C4\u03CC\u03C7\u03BF\u03C5 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2",
          "expirationDateLabel": "\u0397\u03BC\u03B5\u03C1\u03BF\u03BC\u03B7\u03BD\u03AF\u03B1 \u03BB\u03AE\u03BE\u03B7\u03C2",
          "expirationDateLabelSubheading": "(\u039C\u039C/\u0395\u0395)",
          "expirationDatePlaceholder": "\u039C\u039C/\u0395\u0395",
          "postalCodeLabel": "\u03A4\u03B1\u03C7\u03C5\u03B4\u03C1\u03BF\u03BC\u03B9\u03BA\u03CC\u03C2 \u03BA\u03CE\u03B4\u03B9\u03BA\u03B1\u03C2",
          "saveCardLabel": "\u0391\u03C0\u03BF\u03B8\u03AE\u03BA\u03B5\u03C5\u03C3\u03B7 \u03BA\u03AC\u03C1\u03C4\u03B1\u03C2",
          "payWithCard": "\u03A0\u03BB\u03B7\u03C1\u03C9\u03BC\u03AE \u03BC\u03B5 \u03BA\u03AC\u03C1\u03C4\u03B1",
          "endingIn": "\u03A0\u03BF\u03C5 \u03BB\u03AE\u03B3\u03B5\u03B9 \u03C3\u03B5 {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u039A\u03AC\u03C1\u03C4\u03B1",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 216: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Paying with {{paymentSource}}",
          "chooseAnotherWayToPay": "Choose another way to pay",
          "chooseAWayToPay": "Choose a way to pay",
          "otherWaysToPay": "Other ways to pay",
          "edit": "Edit",
          "doneEditing": "Done",
          "editPaymentMethods": "Edit payment methods",
          "CreditCardDeleteConfirmationMessage": "Delete {{secondaryIdentifier}} card ending in {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Delete PayPal account {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Are you sure you want to delete Venmo account with username {{identifier}}?",
          "genericDeleteConfirmationMessage": "Are you sure you want to delete this payment method?",
          "deleteCancelButton": "Cancel",
          "deleteConfirmationButton": "Delete",
          "fieldEmptyForCvv": "Please enter a CVV.",
          "fieldEmptyForExpirationDate": "Please enter an expiry date.",
          "fieldEmptyForCardholderName": "Please enter a cardholder name.",
          "fieldTooLongForCardholderName": "Cardholder name must be less than 256 characters.",
          "fieldEmptyForNumber": "Please enter a number.",
          "fieldEmptyForPostalCode": "Please enter a postcode.",
          "fieldInvalidForCardholderName": "This cardholder name isn't valid.",
          "fieldInvalidForCvv": "This CVV isn't valid.",
          "fieldInvalidForExpirationDate": "This expiry date isn't valid.",
          "fieldInvalidForNumber": "This card number isn't valid.",
          "fieldInvalidForPostalCode": "This postcode isn't valid.",
          "noticeOfCollection": "By paying with my card, I agree to the PayPal Privacy Statement.",
          "genericError": "We're sorry, something seems to have gone wrong.",
          "hostedFieldsTokenizationFailOnDuplicateError": "This card already exists as a saved payment method.",
          "hostedFieldsFailedTokenizationError": "Please check your entries and try again.",
          "hostedFieldsFieldsInvalidError": "Please check your entries and try again.",
          "hostedFieldsTokenizationNetworkErrorError": "Network error. Please try again.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Card verification failed. Please check your entries and try again.",
          "paypalButtonMustBeUsed": "Use the PayPal button to continue with your payment.",
          "venmoButtonMustBeUsed": "Use the Venmo button to continue with your payment.",
          "applePayButtonMustBeUsed": "Use the Apple Pay button to continue with your payment.",
          "paypalAccountTokenizationFailedError": "Something went wrong adding the PayPal account. Please try again.",
          "paypalFlowFailedError": "Something went wrong connecting to PayPal. Please try again.",
          "paypalTokenizationRequestActiveError": "PayPal payment authorisation is already in progress.",
          "venmoCanceledError": "We're sorry, something seems to have gone wrong. Please make sure you have the most recent version of the Venmo app installed on your device and that your browser supports switching to Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Unable to delete payment method. Please try again.",
          "venmoAppFailedError": "The Venmo app couldn't be found on your device.",
          "unsupportedCardTypeError": "This card type isn't supported. Please try another card.",
          "applePayTokenizationError": "A network error occurred while processing the Apple Pay payment. Please try again.",
          "applePayActiveCardError": "Add a supported card to your Apple Pay wallet.",
          "cardholderNameLabel": "Cardholder name",
          "cardNumberLabel": "Card number",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 digits)",
          "cvvFourDigitLabelSubheading": "(4 digits)",
          "cardholderNamePlaceholder": "Cardholder name",
          "expirationDateLabel": "Expiry date",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "MM/YY",
          "postalCodeLabel": "Postcode",
          "saveCardLabel": "Save card",
          "payWithCard": "Pay with card",
          "endingIn": "Ending in {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Card",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 217: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Paying with {{paymentSource}}",
          "chooseAnotherWayToPay": "Choose another way to pay",
          "chooseAWayToPay": "Choose a way to pay",
          "otherWaysToPay": "Other ways to pay",
          "edit": "Edit",
          "doneEditing": "Done",
          "editPaymentMethods": "Edit funding sources",
          "CreditCardDeleteConfirmationMessage": "Delete {{secondaryIdentifier}} card ending in {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Delete PayPal account {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Are you sure you want to delete Venmo account with username {{identifier}}?",
          "genericDeleteConfirmationMessage": "Are you sure you want to delete this funding source?",
          "deleteCancelButton": "Cancel",
          "deleteConfirmationButton": "Delete",
          "fieldEmptyForCvv": "Please enter a security code.",
          "fieldEmptyForExpirationDate": "Please enter an expiry date.",
          "fieldEmptyForCardholderName": "Please enter a cardholder name.",
          "fieldTooLongForCardholderName": "Cardholder name must be less than 256 characters.",
          "fieldEmptyForNumber": "Please enter a number.",
          "fieldEmptyForPostalCode": "Please enter a postcode.",
          "fieldInvalidForCardholderName": "This cardholder name isn't valid.",
          "fieldInvalidForCvv": "This security code isn't valid.",
          "fieldInvalidForExpirationDate": "This expiry date isn't valid.",
          "fieldInvalidForNumber": "This card number isn't valid.",
          "fieldInvalidForPostalCode": "This postcode isn't valid.",
          "noticeOfCollection": "By paying with my card, I agree to the PayPal Privacy Statement.",
          "genericError": "Something went wrong on our end.",
          "hostedFieldsTokenizationFailOnDuplicateError": "This credit card already exists as a saved funding source.",
          "hostedFieldsFailedTokenizationError": "Please check your information and try again.",
          "hostedFieldsFieldsInvalidError": "Please check your information and try again.",
          "hostedFieldsTokenizationNetworkErrorError": "Network error. Please try again.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Credit card verification failed. Please check your information and try again.",
          "paypalButtonMustBeUsed": "Use the PayPal button to continue with your payment.",
          "venmoButtonMustBeUsed": "Use the Venmo button to continue with your payment.",
          "applePayButtonMustBeUsed": "Use the Apple Pay button to continue with your payment.",
          "paypalAccountTokenizationFailedError": "Something went wrong adding the PayPal account. Please try again.",
          "paypalFlowFailedError": "Something went wrong connecting to PayPal. Please try again.",
          "paypalTokenizationRequestActiveError": "PayPal payment authorisation is already in progress.",
          "venmoCanceledError": "Something went wrong. Ensure you have the most recent version of the Venmo app installed on your device and your browser supports switching to Venmo.",
          "vaultManagerPaymentMethodDeletionError": "We were unable to delete the funding source. Please try again.",
          "venmoAppFailedError": "The Venmo app couldn't be found on your device.",
          "unsupportedCardTypeError": "This card type isn't supported. Please try another card.",
          "applePayTokenizationError": "A network error occurred while processing the Apple Pay payment. Please try again.",
          "applePayActiveCardError": "Add a supported card to your Apple Pay wallet.",
          "cardholderNameLabel": "Cardholder name",
          "cardNumberLabel": "Card number",
          "cvvLabel": "Security code",
          "cvvThreeDigitLabelSubheading": "(3 digits)",
          "cvvFourDigitLabelSubheading": "(4 digits)",
          "cardholderNamePlaceholder": "Cardholder name",
          "expirationDateLabel": "Expiry date",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "MM/YY",
          "postalCodeLabel": "Postcode",
          "saveCardLabel": "Save card",
          "payWithCard": "Pay with card",
          "endingIn": "Ending in {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Card",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 218: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Paying with {{paymentSource}}",
          "chooseAnotherWayToPay": "Choose another way to pay",
          "chooseAWayToPay": "Choose a way to pay",
          "otherWaysToPay": "Other ways to pay",
          "edit": "Edit",
          "doneEditing": "Done",
          "editPaymentMethods": "Edit payment methods",
          "CreditCardDeleteConfirmationMessage": "Delete {{secondaryIdentifier}} card ending in {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Delete PayPal account {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Are you sure you want to delete Venmo account with username {{identifier}}?",
          "genericDeleteConfirmationMessage": "Are you sure you want to delete this payment method?",
          "deleteCancelButton": "Cancel",
          "deleteConfirmationButton": "Delete",
          "fieldEmptyForCvv": "Please enter a CVV.",
          "fieldEmptyForExpirationDate": "Please enter an expiry date.",
          "fieldEmptyForCardholderName": "Please enter a cardholder name.",
          "fieldTooLongForCardholderName": "Cardholder name must be less than 256 characters.",
          "fieldEmptyForNumber": "Please enter a number.",
          "fieldEmptyForPostalCode": "Please enter a PIN code.",
          "fieldInvalidForCardholderName": "This cardholder name isn't valid.",
          "fieldInvalidForCvv": "This CVV isn't valid.",
          "fieldInvalidForExpirationDate": "This expiry date isn't valid.",
          "fieldInvalidForNumber": "This card number isn't valid.",
          "fieldInvalidForPostalCode": "This PIN code isn't valid.",
          "noticeOfCollection": "By paying with my card, I agree to the PayPal Privacy Statement.",
          "genericError": "We're sorry, something seems to have gone wrong.",
          "hostedFieldsTokenizationFailOnDuplicateError": "This card already exists as a saved payment method.",
          "hostedFieldsFailedTokenizationError": "Please check your information and try again.",
          "hostedFieldsFieldsInvalidError": "Please check your information and try again.",
          "hostedFieldsTokenizationNetworkErrorError": "Network error. Please try again.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Card verification failed. Please check your information and try again.",
          "paypalButtonMustBeUsed": "Use the PayPal button to continue with your payment.",
          "venmoButtonMustBeUsed": "Use the Venmo button to continue with your payment.",
          "applePayButtonMustBeUsed": "Use the Apple Pay button to continue with your payment.",
          "paypalAccountTokenizationFailedError": "Something went wrong adding the PayPal account. Please try again.",
          "paypalFlowFailedError": "Something went wrong connecting to PayPal. Please try again.",
          "paypalTokenizationRequestActiveError": "PayPal payment authorisation is already in progress.",
          "venmoCanceledError": "We're sorry, something seems to have gone wrong. Ensure you have the most recent version of the Venmo app installed on your device and your browser supports switching to Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Unable to delete payment method. Please try again.",
          "venmoAppFailedError": "The Venmo app couldn't be found on your device.",
          "unsupportedCardTypeError": "This card type isn't supported. Please try another card.",
          "applePayTokenizationError": "A network error occurred while processing the Apple Pay payment. Please try again.",
          "applePayActiveCardError": "Add a supported card to your Apple Pay digital wallet.",
          "cardholderNameLabel": "Cardholder name",
          "cardNumberLabel": "Card number",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 digits)",
          "cvvFourDigitLabelSubheading": "(4 digits)",
          "cardholderNamePlaceholder": "Cardholder name",
          "expirationDateLabel": "Expiry date",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "MM/YY",
          "postalCodeLabel": "PIN code",
          "saveCardLabel": "Save card",
          "payWithCard": "Pay with card",
          "endingIn": "Ending in {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Card",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 219: [function(require2, module2, exports2) {
        module2.exports = {
          payingWith: "Paying with {{paymentSource}}",
          chooseAnotherWayToPay: "Choose another way to pay",
          chooseAWayToPay: "Choose a way to pay",
          otherWaysToPay: "Other ways to pay",
          edit: "Edit",
          doneEditing: "Done",
          editPaymentMethods: "Edit payment methods",
          CreditCardDeleteConfirmationMessage: "Delete {{secondaryIdentifier}} card ending in {{identifier}}?",
          PayPalAccountDeleteConfirmationMessage: "Delete PayPal account {{identifier}}?",
          VenmoAccountDeleteConfirmationMessage: "Are you sure you want to delete Venmo account with username {{identifier}}?",
          genericDeleteConfirmationMessage: "Are you sure you want to delete this payment method?",
          deleteCancelButton: "Cancel",
          deleteConfirmationButton: "Delete",
          fieldEmptyForCvv: "Please fill out a CVV.",
          fieldEmptyForExpirationDate: "Please fill out an expiration date.",
          fieldEmptyForCardholderName: "Please fill out a cardholder name.",
          fieldEmptyForNumber: "Please fill out a card number.",
          fieldEmptyForPostalCode: "Please fill out a postal code.",
          fieldInvalidForCardholderName: "This cardholder name is not valid.",
          fieldInvalidForCvv: "This security code is not valid.",
          fieldInvalidForExpirationDate: "This expiration date is not valid.",
          fieldInvalidForNumber: "This card number is not valid.",
          fieldInvalidForPostalCode: "This postal code is not valid.",
          fieldTooLongForCardholderName: "Cardholder name must be less than 256 characters.",
          noticeOfCollection: "By paying with my card, I agree to the PayPal Privacy Statement.",
          genericError: "Something went wrong on our end.",
          hostedFieldsTokenizationFailOnDuplicateError: "This credit card already exists as a saved payment method.",
          hostedFieldsFailedTokenizationError: "Please check your information and try again.",
          hostedFieldsTokenizationCvvVerificationFailedError: "Credit card verification failed. Please check your information and try again.",
          hostedFieldsTokenizationNetworkErrorError: "Network error. Please try again.",
          hostedFieldsFieldsInvalidError: "Please check your information and try again.",
          paypalButtonMustBeUsed: "Use the PayPal button to continue with your payment.",
          venmoButtonMustBeUsed: "Use the Venmo button to continue with your payment.",
          applePayButtonMustBeUsed: "Use the Apple Pay button to continue with your payment.",
          paypalAccountTokenizationFailedError: "Something went wrong adding the PayPal account. Please try again.",
          paypalFlowFailedError: "Something went wrong connecting to PayPal. Please try again.",
          paypalTokenizationRequestActiveError: "PayPal payment authorization is already in progress.",
          applePayTokenizationError: "A network error occurred while processing the Apple Pay payment. Please try again.",
          applePayActiveCardError: "Add a supported card to your Apple Pay wallet.",
          vaultManagerPaymentMethodDeletionError: "Unable to delete payment method, try again.",
          venmoCanceledError: "Something went wrong. Ensure you have the most recent version of the Venmo app installed on your device and your browser supports switching to Venmo.",
          venmoAppFailedError: "The Venmo app could not be found on your device.",
          unsupportedCardTypeError: "This card type is not supported. Please try another card.",
          cardholderNameLabel: "Cardholder Name",
          cardNumberLabel: "Card Number",
          cvvLabel: "CVV",
          cvvThreeDigitLabelSubheading: "(3 digits)",
          cvvFourDigitLabelSubheading: "(4 digits)",
          expirationDateLabel: "Expiration Date",
          expirationDateLabelSubheading: "(MM/YY)",
          cardholderNamePlaceholder: "Cardholder Name",
          expirationDatePlaceholder: "MM/YY",
          postalCodeLabel: "Postal Code",
          saveCardLabel: "Save card",
          payWithCard: "Pay with card",
          endingIn: "Ending in {{lastFourCardDigits}}",
          Card: "Card",
          PayPal: "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Apple Pay": "Apple Pay",
          "Google Pay": "Google Pay",
          "Venmo": "Venmo",
          "American Express": "American Express",
          Discover: "Discover",
          "Diners Club": "Diners Club",
          Elo: "Elo",
          Hiper: "Hiper",
          Hipercard: "Hipercard",
          MasterCard: "Mastercard",
          Visa: "Visa",
          JCB: "JCB",
          Maestro: "Maestro",
          UnionPay: "UnionPay"
        };
      }, {}], 220: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Pagar con\xA0{{paymentSource}}",
          "chooseAnotherWayToPay": "Seleccionar otra forma de pago",
          "chooseAWayToPay": "Seleccionar forma de pago",
          "otherWaysToPay": "Otras formas de pago",
          "edit": "Editar",
          "doneEditing": "Hecho",
          "editPaymentMethods": "Editar formas de pago",
          "CreditCardDeleteConfirmationMessage": "\xBFEliminar la tarjeta {{secondaryIdentifier}} terminada en {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "\xBFEliminar la cuenta PayPal {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "\xBFSeguro que deseas eliminar la cuenta de Venmo con el nombre de usuario {{identifier}}?",
          "genericDeleteConfirmationMessage": "\xBFSeguro que deseas eliminar esta forma de pago?",
          "deleteCancelButton": "Cancelar",
          "deleteConfirmationButton": "Eliminar",
          "fieldEmptyForCvv": "Introduce el CVV.",
          "fieldEmptyForExpirationDate": "Introduce una fecha de vencimiento.",
          "fieldEmptyForCardholderName": "Introduce el nombre del titular de la tarjeta.",
          "fieldTooLongForCardholderName": "El nombre del titular de la tarjeta debe tener menos de 256 caracteres.",
          "fieldEmptyForNumber": "Introduce un n\xFAmero.",
          "fieldEmptyForPostalCode": "Introduce un c\xF3digo postal.",
          "fieldInvalidForCardholderName": "El nombre del titular de la tarjeta no es v\xE1lido.",
          "fieldInvalidForCvv": "El c\xF3digo de seguridad no es v\xE1lido.",
          "fieldInvalidForExpirationDate": "La fecha de vencimiento no es v\xE1lida.",
          "fieldInvalidForNumber": "El n\xFAmero de tarjeta no es v\xE1lido.",
          "fieldInvalidForPostalCode": "El c\xF3digo postal no es v\xE1lido.",
          "noticeOfCollection": "Al pagar con mi tarjeta, acepto la Declaraci\xF3n de privacidad de PayPal.",
          "genericError": "Ha habido un problema.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Esta tarjeta de cr\xE9dito ya existe como forma de pago guardada.",
          "hostedFieldsFailedTokenizationError": "Comprueba la informaci\xF3n e int\xE9ntalo de nuevo.",
          "hostedFieldsFieldsInvalidError": "Comprueba la informaci\xF3n e int\xE9ntalo de nuevo.",
          "hostedFieldsTokenizationNetworkErrorError": "Error de red. Int\xE9ntalo de nuevo.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Error al verificar la tarjeta de cr\xE9dito. Comprueba la informaci\xF3n e int\xE9ntalo de nuevo.",
          "paypalButtonMustBeUsed": "Utiliza el bot\xF3n de PayPal para continuar con el pago.",
          "venmoButtonMustBeUsed": "Pulsa el bot\xF3n de Venmo para continuar con el pago.",
          "applePayButtonMustBeUsed": "Utiliza el bot\xF3n de Apple Pay para continuar con el pago.",
          "paypalAccountTokenizationFailedError": "Se ha producido un error al a\xF1adir la cuenta PayPal. Int\xE9ntalo de nuevo.",
          "paypalFlowFailedError": "Se ha producido un error al conectar con PayPal. Int\xE9ntalo de nuevo.",
          "paypalTokenizationRequestActiveError": "La autorizaci\xF3n del pago de PayPal ya est\xE1 en curso.",
          "venmoCanceledError": "Ha habido un error. Aseg\xFArate de tener la versi\xF3n m\xE1s reciente de la aplicaci\xF3n de Venmo instalada en el dispositivo y de que el navegador admita el cambio a Venmo.",
          "vaultManagerPaymentMethodDeletionError": "No se puede eliminar la forma de pago. Int\xE9ntalo de nuevo.",
          "venmoAppFailedError": "No se ha podido encontrar la aplicaci\xF3n de Venmo en tu dispositivo.",
          "unsupportedCardTypeError": "No se admite este tipo de tarjeta. Prueba con otra tarjeta.",
          "applePayTokenizationError": "Se ha producido un error de red al procesar el pago de Apple Pay. Int\xE9ntalo de nuevo.",
          "applePayActiveCardError": "A\xF1ade una tarjeta compatible a tu cartera de Apple Pay.",
          "cardholderNameLabel": "Nombre del titular de la tarjeta",
          "cardNumberLabel": "N\xFAmero de tarjeta",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3\xA0d\xEDgitos)",
          "cvvFourDigitLabelSubheading": "(4\xA0d\xEDgitos)",
          "cardholderNamePlaceholder": "Nombre del titular de la tarjeta",
          "expirationDateLabel": "Fecha de vencimiento",
          "expirationDateLabelSubheading": "(MM/AA)",
          "expirationDatePlaceholder": "MM/AA",
          "postalCodeLabel": "C\xF3digo postal",
          "saveCardLabel": "Guardar tarjeta",
          "payWithCard": "Pagar con tarjeta",
          "endingIn": "Terminada en {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Tarjeta",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 221: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Pagar con {{paymentSource}}",
          "chooseAnotherWayToPay": "Elija otra forma de pago",
          "chooseAWayToPay": "Seleccione una forma de pago",
          "otherWaysToPay": "Otras formas de pago",
          "edit": "Editar",
          "doneEditing": "Listo",
          "editPaymentMethods": "Editar m\xE9todos de pago",
          "CreditCardDeleteConfirmationMessage": "\xBFEliminar tarjeta {{secondaryIdentifier}} con terminaci\xF3n {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "\xBFDesea eliminar la cuenta de PayPal {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "\xBFSeguro que desea eliminar la cuenta de Venmo con el nombre de usuario {{identifier}}?",
          "genericDeleteConfirmationMessage": "\xBFSeguro que desea eliminar esta forma de pago?",
          "deleteCancelButton": "Cancelar",
          "deleteConfirmationButton": "Eliminar",
          "fieldEmptyForCvv": "Ingrese un CVV.",
          "fieldEmptyForExpirationDate": "Ingrese una fecha de vencimiento.",
          "fieldEmptyForCardholderName": "Ingrese un nombre de titular de tarjeta.",
          "fieldTooLongForCardholderName": "El nombre del titular de la tarjeta debe tener menos de 256 caracteres.",
          "fieldEmptyForNumber": "Ingrese un n\xFAmero.",
          "fieldEmptyForPostalCode": "Ingrese un c\xF3digo postal.",
          "fieldInvalidForCardholderName": "El nombre del titular de la tarjeta no es v\xE1lido.",
          "fieldInvalidForCvv": "Este c\xF3digo de seguridad no es v\xE1lido.",
          "fieldInvalidForExpirationDate": "Esta fecha de vencimiento no es v\xE1lida.",
          "fieldInvalidForNumber": "Este n\xFAmero de tarjeta no es v\xE1lido.",
          "fieldInvalidForPostalCode": "Este c\xF3digo postal no es v\xE1lido.",
          "noticeOfCollection": "Al pagar con mi tarjeta, acepto el Aviso de Privacidad de PayPal.",
          "genericError": "Se ha producido un error.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Esta tarjeta de cr\xE9dito ya existe como forma de pago guardada.",
          "hostedFieldsFailedTokenizationError": "Revise la informaci\xF3n e int\xE9ntelo de nuevo.",
          "hostedFieldsFieldsInvalidError": "Revise la informaci\xF3n e int\xE9ntelo de nuevo.",
          "hostedFieldsTokenizationNetworkErrorError": "Error de red. Int\xE9ntelo de nuevo.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "La verificaci\xF3n de la tarjeta de cr\xE9dito fall\xF3. Revise la informaci\xF3n e int\xE9ntelo de nuevo.",
          "paypalButtonMustBeUsed": "Utilice el bot\xF3n de PayPal para continuar con su pago.",
          "venmoButtonMustBeUsed": "Use el bot\xF3n Venmo para continuar con el pago.",
          "applePayButtonMustBeUsed": "Utilice el bot\xF3n de Apple Pay para continuar con su pago.",
          "paypalAccountTokenizationFailedError": "Se ha producido un error al agregar la cuenta de PayPal. Int\xE9ntelo de nuevo.",
          "paypalFlowFailedError": "Se ha producido un error al conectar con PayPal. Int\xE9ntelo de nuevo.",
          "paypalTokenizationRequestActiveError": "La autorizaci\xF3n de pago de PayPal ya est\xE1 en curso.",
          "venmoCanceledError": "Se ha producido un error. Aseg\xFArese de que tiene la versi\xF3n m\xE1s reciente de la aplicaci\xF3n de Venmo instalada en su dispositivo y que su navegador admita el sitio web Venmo.",
          "vaultManagerPaymentMethodDeletionError": "No se pudo eliminar la forma de pago, int\xE9ntelo de nuevo.",
          "venmoAppFailedError": "No se pudo encontrar la aplicaci\xF3n de Venmo en su dispositivo.",
          "unsupportedCardTypeError": "Este tipo de tarjeta no es compatible. Int\xE9ntelo con otra tarjeta.",
          "applePayTokenizationError": "Se ha producido un error de red al procesar el pago de Apple Pay. Int\xE9ntelo de nuevo.",
          "applePayActiveCardError": "Agregue una tarjeta compatible a su cartera de Apple Pay.",
          "cardholderNameLabel": "Nombre del titular de la tarjeta",
          "cardNumberLabel": "N\xFAmero de tarjeta",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 d\xEDgitos)",
          "cvvFourDigitLabelSubheading": "(4 d\xEDgitos)",
          "cardholderNamePlaceholder": "Nombre del titular de la tarjeta",
          "expirationDateLabel": "Fecha de vencimiento",
          "expirationDateLabelSubheading": "(MM/AA)",
          "expirationDatePlaceholder": "MM/AA",
          "postalCodeLabel": "C\xF3digo postal",
          "saveCardLabel": "Guardar tarjeta",
          "payWithCard": "Pagar con tarjeta",
          "endingIn": "Con terminaci\xF3n {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Tarjeta",
          "PayPal": "Paypal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 222: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Maksuv\xE4line: {{paymentSource}}",
          "chooseAnotherWayToPay": "Valitse toinen maksutapa",
          "chooseAWayToPay": "Valitse maksutapa",
          "otherWaysToPay": "Muita maksutapoja",
          "edit": "Muokkaa",
          "doneEditing": "Valmis",
          "editPaymentMethods": "Muokkaa maksutapoja",
          "CreditCardDeleteConfirmationMessage": "Haluatko poistaa {{secondaryIdentifier}}} -kortin, joka p\xE4\xE4ttyy {{identifier}}}?",
          "PayPalAccountDeleteConfirmationMessage": "Haluatko poistaa PayPal-tilin {{identifier}}}?",
          "VenmoAccountDeleteConfirmationMessage": "Haluatko varmasti poistaa Venmo-tilin, jonka k\xE4ytt\xE4j\xE4tunnus on {{identifier}}}?",
          "genericDeleteConfirmationMessage": "Haluatko varmasti poistaa t\xE4m\xE4n maksutavan?",
          "deleteCancelButton": "Peruuta",
          "deleteConfirmationButton": "Poista",
          "fieldEmptyForCvv": "Anna turvakoodi.",
          "fieldEmptyForExpirationDate": "Anna voimassaolon p\xE4\xE4ttymisp\xE4iv\xE4m\xE4\xE4r\xE4.",
          "fieldEmptyForCardholderName": "Anna kortinhaltijan nimi.",
          "fieldTooLongForCardholderName": "Kortinhaltijan nimen on oltava alle 256 merkki\xE4.",
          "fieldEmptyForNumber": "Anna numero.",
          "fieldEmptyForPostalCode": "Anna postinumero.",
          "fieldInvalidForCardholderName": "Kortinhaltijan nimi ei ole kelvollinen.",
          "fieldInvalidForCvv": "Turvakoodi ei ole kelvollinen.",
          "fieldInvalidForExpirationDate": "P\xE4\xE4ttymisp\xE4iv\xE4m\xE4\xE4r\xE4 ei ole kelvollinen.",
          "fieldInvalidForNumber": "Kortin numero ei ole kelvollinen.",
          "fieldInvalidForPostalCode": "Postinumero ei ole kelvollinen.",
          "noticeOfCollection": "Maksamalla kortillani hyv\xE4ksyn PayPal tietosuojaselosteen.",
          "genericError": "Jokin meni pieleen t\xE4ss\xE4 p\xE4\xE4ss\xE4.",
          "hostedFieldsTokenizationFailOnDuplicateError": "T\xE4m\xE4 luottokortti on jo tallennettu maksutavaksi.",
          "hostedFieldsFailedTokenizationError": "Tarkista tiedot ja yrit\xE4 uudelleen.",
          "hostedFieldsFieldsInvalidError": "Tarkista tiedot ja yrit\xE4 uudelleen.",
          "hostedFieldsTokenizationNetworkErrorError": "Verkkovirhe. Yrit\xE4 uudelleen.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Luottokortin varmennus ep\xE4onnistui. Tarkista tiedot ja yrit\xE4 uudelleen.",
          "paypalButtonMustBeUsed": "Jatka maksua PayPal-painikkeen avulla.",
          "venmoButtonMustBeUsed": "Jatka maksua Venmo-painikkeella.",
          "applePayButtonMustBeUsed": "Jatka maksua Apple Pay-painikkeen avulla.",
          "paypalAccountTokenizationFailedError": "Jotain meni pieleen PayPal-tili\xE4 lis\xE4tess\xE4. Yrit\xE4 uudelleen.",
          "paypalFlowFailedError": "Jotain meni pieleen muodostettaessa yhteytt\xE4 PayPaliin. Yrit\xE4 uudelleen.",
          "paypalTokenizationRequestActiveError": "PayPal-maksun valtuutus on jo meneill\xE4\xE4n.",
          "venmoCanceledError": "Jokin meni pieleen. Varmista, ett\xE4 laitteeseesi on asennettu Venmo-sovelluksen viimeisin versio, ja ett\xE4 selain tukee vaihtamista Venmoon.",
          "vaultManagerPaymentMethodDeletionError": "Maksutavan poistaminen ei onnistu, yrit\xE4 uudelleen.",
          "venmoAppFailedError": "Venmo-sovellusta ei l\xF6ytynyt laitteesta.",
          "unsupportedCardTypeError": "T\xE4t\xE4 korttityyppi\xE4 ei tueta. Kokeile toista korttia.",
          "applePayTokenizationError": "Tapahtui verkkovirhe Apple Pay -maksun k\xE4sittelyss\xE4. Yrit\xE4 uudelleen.",
          "applePayActiveCardError": "Lis\xE4\xE4 tuettu kortti Apple Pay -lompakkoon.",
          "cardholderNameLabel": "Kortinhaltijan nimi",
          "cardNumberLabel": "Kortin numero",
          "cvvLabel": "Kortin turvakoodi",
          "cvvThreeDigitLabelSubheading": "(kolme numeroa)",
          "cvvFourDigitLabelSubheading": "(nelj\xE4 numeroa)",
          "cardholderNamePlaceholder": "Kortinhaltijan nimi",
          "expirationDateLabel": "P\xE4\xE4ttymisp\xE4iv\xE4m\xE4\xE4r\xE4",
          "expirationDateLabelSubheading": "(KK/VV)",
          "expirationDatePlaceholder": "KK/VV",
          "postalCodeLabel": "Postinumero",
          "saveCardLabel": "Tallenna kortti",
          "payWithCard": "Maksa kortilla",
          "endingIn": "P\xE4\xE4ttyy {{lastFourCardDigits}}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Kortti",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 223: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Payer avec {{paymentSource}}",
          "chooseAnotherWayToPay": "Choisir un autre mode de paiement",
          "chooseAWayToPay": "Choisir un mode de paiement",
          "otherWaysToPay": "Autres modes de paiement",
          "edit": "Modifier",
          "doneEditing": "Termin\xE9",
          "editPaymentMethods": "Modifier les modes de paiement",
          "CreditCardDeleteConfirmationMessage": "Supprimer la carte {{secondaryIdentifier}} se terminant par {{identifier}}\xA0?",
          "PayPalAccountDeleteConfirmationMessage": "Supprimer le compte PayPal {{identifier}}\xA0?",
          "VenmoAccountDeleteConfirmationMessage": "Souhaitez-vous vraiment supprimer le compte Venmo dont le nom d'utilisateur est {{identifier}}\xA0?",
          "genericDeleteConfirmationMessage": "Voulez-vous vraiment supprimer ce mode paiement\xA0?",
          "deleteCancelButton": "Annuler",
          "deleteConfirmationButton": "Supprimer",
          "fieldEmptyForCvv": "Saisissez un CVV.",
          "fieldEmptyForExpirationDate": "Saisissez une date d'expiration.",
          "fieldEmptyForCardholderName": "Saisissez le nom du titulaire de la carte.",
          "fieldTooLongForCardholderName": "Le nom du titulaire de la carte doit contenir moins de 256\xA0caract\xE8res.",
          "fieldEmptyForNumber": "Saisissez un num\xE9ro.",
          "fieldEmptyForPostalCode": "Saisissez un code postal.",
          "fieldInvalidForCardholderName": "Le nom de ce titulaire de la carte n'est pas valide.",
          "fieldInvalidForCvv": "Ce cryptogramme visuel n'est pas valide.",
          "fieldInvalidForExpirationDate": "Cette date d'expiration n'est pas valide.",
          "fieldInvalidForNumber": "Ce num\xE9ro de carte n'est pas valide.",
          "fieldInvalidForPostalCode": "Ce code postal n'est pas valide.",
          "noticeOfCollection": "En payant avec ma carte, j\u2019accepte la Politique de confidentialit\xE9 de PayPal.",
          "genericError": "Une erreur s'est produite de notre c\xF4t\xE9.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Cette carte de cr\xE9dit est d\xE9j\xE0 enregistr\xE9e en tant que mode de paiement.",
          "hostedFieldsFailedTokenizationError": "Veuillez v\xE9rifier vos informations, puis r\xE9essayer.",
          "hostedFieldsFieldsInvalidError": "Veuillez v\xE9rifier vos informations, puis r\xE9essayer.",
          "hostedFieldsTokenizationNetworkErrorError": "Erreur de r\xE9seau. R\xE9essayez.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\xC9chec de v\xE9rification de la carte de cr\xE9dit. Veuillez v\xE9rifier vos informations, puis r\xE9essayer.",
          "paypalButtonMustBeUsed": "Utilisez le bouton PayPal pour poursuivre votre paiement.",
          "venmoButtonMustBeUsed": "Utilisez le bouton Venmo pour continuer votre paiement.",
          "applePayButtonMustBeUsed": "Utilisez le bouton Apple Pay pour poursuivre votre paiement.",
          "paypalAccountTokenizationFailedError": "Une erreur s'est produite lors de l'ajout du compte PayPal. Veuillez r\xE9essayer.",
          "paypalFlowFailedError": "Une erreur s'est produite lors de la connexion \xE0 PayPal. Veuillez r\xE9essayer.",
          "paypalTokenizationRequestActiveError": "L'autorisation de paiement PayPal est d\xE9j\xE0 en cours.",
          "venmoCanceledError": "Une erreur s'est produite. Assurez-vous que la version la plus r\xE9cente de l'application Venmo est install\xE9e sur votre appareil et que votre navigateur prend en charge la redirection vers Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Impossible de supprimer le mode de paiement. R\xE9essayez.",
          "venmoAppFailedError": "L'application Venmo n'est pas pr\xE9sente sur votre appareil.",
          "unsupportedCardTypeError": "Ce type de carte n'est pas pris en charge. Veuillez essayer une autre carte.",
          "applePayTokenizationError": "Une erreur de r\xE9seau s'est produite lors du traitement du paiement Apple Pay. Veuillez r\xE9essayer.",
          "applePayActiveCardError": "Ajoutez une carte prise en charge \xE0 votre portefeuille Apple Pay.",
          "cardholderNameLabel": "Nom du titulaire de la carte",
          "cardNumberLabel": "Num\xE9ro de carte",
          "cvvLabel": "Cryptogramme visuel",
          "cvvThreeDigitLabelSubheading": "(3\xA0chiffres)",
          "cvvFourDigitLabelSubheading": "(4\xA0chiffres)",
          "cardholderNamePlaceholder": "Nom du titulaire de la carte",
          "expirationDateLabel": "Date d'expiration",
          "expirationDateLabelSubheading": "(MM/AA)",
          "expirationDatePlaceholder": "MM/AA",
          "postalCodeLabel": "Code postal",
          "saveCardLabel": "Enregistrer la carte",
          "payWithCard": "Payer par carte",
          "endingIn": "Se terminant par {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Carte",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 224: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Payer avec\xA0: {{paymentSource}}",
          "chooseAnotherWayToPay": "Choisir un autre mode de paiement",
          "chooseAWayToPay": "Choisir un mode de paiement",
          "otherWaysToPay": "Autres modes de paiement",
          "edit": "Modifier",
          "doneEditing": "Termin\xE9",
          "editPaymentMethods": "Modifier les modes de paiement",
          "CreditCardDeleteConfirmationMessage": "Supprimer la carte {{secondaryIdentifier}} se terminant par {{identifier}}\xA0?",
          "PayPalAccountDeleteConfirmationMessage": "Supprimer le compte PayPal {{identifier}}\xA0?",
          "VenmoAccountDeleteConfirmationMessage": "Souhaitez-vous vraiment supprimer le compte Venmo associ\xE9 au nom d'utilisateur {{identifier}}\xA0?",
          "genericDeleteConfirmationMessage": "Souhaitez-vous vraiment supprimer ce mode de paiement\xA0?",
          "deleteCancelButton": "Annuler",
          "deleteConfirmationButton": "Supprimer",
          "fieldEmptyForCvv": "Renseignez un cryptogramme visuel.",
          "fieldEmptyForExpirationDate": "Renseignez une date d'expiration.",
          "fieldEmptyForCardholderName": "Renseignez le nom du titulaire de la carte.",
          "fieldTooLongForCardholderName": "Le nom du titulaire de la carte doit comporter moins de 256\xA0caract\xE8res.",
          "fieldEmptyForNumber": "Renseignez un num\xE9ro.",
          "fieldEmptyForPostalCode": "Renseignez un code postal.",
          "fieldInvalidForCardholderName": "Le nom de ce titulaire de la carte est incorrect.",
          "fieldInvalidForCvv": "Ce cryptogramme visuel est incorrect.",
          "fieldInvalidForExpirationDate": "Cette date d'expiration est incorrecte.",
          "fieldInvalidForNumber": "Ce num\xE9ro de carte est incorrect.",
          "fieldInvalidForPostalCode": "Ce code postal est incorrect.",
          "noticeOfCollection": "En payant avec ma carte, j'accepte la Politique de confidentialit\xE9 de PayPal.",
          "genericError": "Une erreur est survenue.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Cette carte bancaire existe d\xE9j\xE0 en tant que mode de paiement enregistr\xE9.",
          "hostedFieldsFailedTokenizationError": "V\xE9rifiez vos informations et r\xE9essayez.",
          "hostedFieldsFieldsInvalidError": "V\xE9rifiez vos informations et r\xE9essayez.",
          "hostedFieldsTokenizationNetworkErrorError": "Erreur r\xE9seau. R\xE9essayez.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\xC9chec de la v\xE9rification de carte bancaire. V\xE9rifiez vos informations et r\xE9essayez.",
          "paypalButtonMustBeUsed": "Utilisez le bouton PayPal pour poursuivre le paiement.",
          "venmoButtonMustBeUsed": "Utilisez le bouton Venmo pour poursuivre le paiement.",
          "applePayButtonMustBeUsed": "Utilisez le bouton Apple Pay pour poursuivre le paiement.",
          "paypalAccountTokenizationFailedError": "Une erreur est survenue lors de l'ajout du compte PayPal. R\xE9essayez.",
          "paypalFlowFailedError": "Une erreur est survenue lors de la connexion \xE0 PayPal. R\xE9essayez.",
          "paypalTokenizationRequestActiveError": "L'autorisation de paiement PayPal est d\xE9j\xE0 en cours.",
          "venmoCanceledError": "Une erreur est survenue. V\xE9rifiez que la derni\xE8re version de l'application Venmo est install\xE9e sur votre appareil et que votre navigateur prend en charge la redirection vers Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Impossible de supprimer le mode de paiement, r\xE9essayez.",
          "venmoAppFailedError": "Nous n'avons pas trouv\xE9 l'application Venmo sur votre appareil.",
          "unsupportedCardTypeError": "Ce type de carte n'est pas pris en charge. Essayez une autre carte.",
          "applePayTokenizationError": "Une erreur r\xE9seau est survenue lors du traitement du paiement Apple\xA0Pay. R\xE9essayez.",
          "applePayActiveCardError": "Enregistrez une carte prise en charge sur votre portefeuille Apple\xA0Pay.",
          "cardholderNameLabel": "Nom du titulaire de la carte",
          "cardNumberLabel": "Num\xE9ro de carte",
          "cvvLabel": "Crypto.",
          "cvvThreeDigitLabelSubheading": "(3\xA0chiffres)",
          "cvvFourDigitLabelSubheading": "(4\xA0chiffres)",
          "cardholderNamePlaceholder": "Nom du titulaire de la carte",
          "expirationDateLabel": "Date d'expiration",
          "expirationDateLabelSubheading": "(MM/AA)",
          "expirationDatePlaceholder": "MM/AA",
          "postalCodeLabel": "Code postal",
          "saveCardLabel": "Enregistrer la carte",
          "payWithCard": "Payer par carte",
          "endingIn": "Se terminant par {{lastFourCardDigits}}",
          "Apple Pay": "Apple\xA0Pay",
          "Venmo": "Venmo",
          "Card": "Carte",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal\xA0Credit",
          "Google Pay": "Google\xA0Pay",
          "American Express": "American\xA0Express",
          "Discover": "Discover",
          "Diners Club": "Diners\xA0Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 225: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Payer avec {{paymentSource}}",
          "chooseAnotherWayToPay": "Choisir un autre mode de paiement",
          "chooseAWayToPay": "Choisir un mode de paiement",
          "otherWaysToPay": "Autres modes de paiement",
          "edit": "Modifier",
          "doneEditing": "Termin\xE9",
          "editPaymentMethods": "Modifier les modes de paiement",
          "CreditCardDeleteConfirmationMessage": "Supprimer la carte {{secondaryIdentifier}}} se terminant par {{identifier}}}\xA0?",
          "PayPalAccountDeleteConfirmationMessage": "Supprimer le compte PayPal {{identifier}}}\xA0?",
          "VenmoAccountDeleteConfirmationMessage": "Souhaitez-vous vraiment supprimer le compte Venmo associ\xE9 au nom d'utilisateur {{identifier}}}\xA0?",
          "genericDeleteConfirmationMessage": "Souhaitez-vous vraiment supprimer ce mode de paiement\xA0?",
          "deleteCancelButton": "Annuler",
          "deleteConfirmationButton": "Supprimer",
          "fieldEmptyForCvv": "Renseignez un cryptogramme visuel.",
          "fieldEmptyForExpirationDate": "Renseignez une date d'expiration.",
          "fieldEmptyForCardholderName": "Renseignez le nom du titulaire de la carte.",
          "fieldTooLongForCardholderName": "Le nom du titulaire de la carte doit comporter moins de 256\xA0caract\xE8res.",
          "fieldEmptyForNumber": "Renseignez un num\xE9ro.",
          "fieldEmptyForPostalCode": "Renseignez un code postal.",
          "fieldInvalidForCardholderName": "Le nom de ce titulaire de la carte est incorrect.",
          "fieldInvalidForCvv": "Ce cryptogramme visuel est incorrect.",
          "fieldInvalidForExpirationDate": "Cette date d'expiration est incorrecte.",
          "fieldInvalidForNumber": "Ce num\xE9ro de carte est incorrect.",
          "fieldInvalidForPostalCode": "Ce code postal est incorrect.",
          "noticeOfCollection": "En payant avec ma carte, j'accepte la Politique de confidentialit\xE9 de PayPal.",
          "genericError": "Une erreur est survenue.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Cette carte bancaire existe d\xE9j\xE0 en tant que mode de paiement enregistr\xE9.",
          "hostedFieldsFailedTokenizationError": "V\xE9rifiez vos informations et r\xE9essayez.",
          "hostedFieldsFieldsInvalidError": "V\xE9rifiez vos informations et r\xE9essayez.",
          "hostedFieldsTokenizationNetworkErrorError": "Erreur r\xE9seau. R\xE9essayez.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\xC9chec de la v\xE9rification de carte bancaire. V\xE9rifiez vos informations et r\xE9essayez.",
          "paypalButtonMustBeUsed": "Utilisez le bouton PayPal pour poursuivre le paiement.",
          "venmoButtonMustBeUsed": "Utilisez le bouton Venmo pour poursuivre le paiement.",
          "applePayButtonMustBeUsed": "Utilisez le bouton Apple Pay pour poursuivre le paiement.",
          "paypalAccountTokenizationFailedError": "Une erreur est survenue lors de l'ajout du compte PayPal. R\xE9essayez.",
          "paypalFlowFailedError": "Une erreur est survenue lors de la connexion \xE0 PayPal. R\xE9essayez.",
          "paypalTokenizationRequestActiveError": "L'autorisation de paiement PayPal est d\xE9j\xE0 en cours.",
          "venmoCanceledError": "Une erreur est survenue. V\xE9rifiez que la derni\xE8re version de l'application Venmo est install\xE9e sur votre appareil et que votre navigateur prend en charge la redirection vers Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Impossible de supprimer le mode de paiement, r\xE9essayez.",
          "venmoAppFailedError": "Nous n'avons pas trouv\xE9 l'application Venmo sur votre appareil.",
          "unsupportedCardTypeError": "Ce type de carte n'est pas pris en charge. Essayez une autre carte.",
          "applePayTokenizationError": "Une erreur r\xE9seau est survenue lors du traitement du paiement Apple\xA0Pay. R\xE9essayez.",
          "applePayActiveCardError": "Enregistrez une carte prise en charge sur votre portefeuille Apple\xA0Pay.",
          "cardholderNameLabel": "Nom du titulaire de la carte",
          "cardNumberLabel": "Num\xE9ro de carte",
          "cvvLabel": "Crypto.",
          "cvvThreeDigitLabelSubheading": "(3\xA0chiffres)",
          "cvvFourDigitLabelSubheading": "(4\xA0chiffres)",
          "cardholderNamePlaceholder": "Nom du titulaire de la carte",
          "expirationDateLabel": "Date d'expiration",
          "expirationDateLabelSubheading": "(MM/AA)",
          "expirationDatePlaceholder": "MM/AA",
          "postalCodeLabel": "Code postal",
          "saveCardLabel": "Enregistrer la carte",
          "payWithCard": "Payer par carte",
          "endingIn": "Se termine le {{lastFourCardDigits}}",
          "Apple Pay": "Apple\xA0Pay",
          "Venmo": "Venmo",
          "Card": "Carte",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal\xA0Credit",
          "Google Pay": "Google\xA0Pay",
          "American Express": "American\xA0Express",
          "Discover": "Discover",
          "Diners Club": "Diners\xA0Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 226: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u05EA\u05E9\u05DC\u05D5\u05DD \u05D1\u05D0\u05DE\u05E6\u05E2\u05D5\u05EA {{paymentSource}}",
          "chooseAnotherWayToPay": "\u05E2\u05DC\u05D9\u05DA \u05DC\u05D1\u05D7\u05D5\u05E8 \u05E9\u05D9\u05D8\u05EA \u05EA\u05E9\u05DC\u05D5\u05DD \u05D0\u05D7\u05E8\u05EA",
          "chooseAWayToPay": "\u05DB\u05D9\u05E6\u05D3 \u05D1\u05E8\u05E6\u05D5\u05E0\u05DA \u05DC\u05E9\u05DC\u05DD?",
          "otherWaysToPay": "\u05E9\u05D9\u05D8\u05D5\u05EA \u05EA\u05E9\u05DC\u05D5\u05DD \u05D0\u05D7\u05E8\u05D5\u05EA",
          "edit": "\u05E2\u05E8\u05D9\u05DB\u05D4",
          "doneEditing": "\u05D1\u05D5\u05E6\u05E2",
          "editPaymentMethods": "\u05E2\u05E8\u05D9\u05DB\u05EA \u05E9\u05D9\u05D8\u05D5\u05EA \u05EA\u05E9\u05DC\u05D5\u05DD",
          "CreditCardDeleteConfirmationMessage": "\u05DC\u05DE\u05D7\u05D5\u05E7 {{secondaryIdentifier}} \u05D4\u05DB\u05E8\u05D8\u05D9\u05E1 \u05D4\u05DE\u05E1\u05EA\u05D9\u05D9\u05DD {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "\u05DC\u05DE\u05D7\u05D5\u05E7 PayPal \u05D4\u05D7\u05E9\u05D1\u05D5\u05DF {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "\u05D4\u05D0\u05DD \u05D0\u05EA\u05D4 \u05D1\u05D8\u05D5\u05D7 \u05E9\u05D1\u05E8\u05E6\u05D5\u05E0\u05DA \u05DC\u05DE\u05D7\u05D5\u05E7 \u05D0\u05EA \u05D7\u05E9\u05D1\u05D5\u05DF Venmo \u05D4\u05E8\u05E9\u05D5\u05DD \u05EA\u05D7\u05EA \u05E9\u05DD \u05D4\u05DE\u05E9\u05EA\u05DE\u05E9 {{identifier}}?",
          "genericDeleteConfirmationMessage": "\u05D4\u05D0\u05DD \u05D0\u05EA\u05D4 \u05D1\u05D8\u05D5\u05D7 \u05E9\u05D1\u05E8\u05E6\u05D5\u05E0\u05DA \u05DC\u05DE\u05D7\u05D5\u05E7 \u05E9\u05D9\u05D8\u05EA \u05EA\u05E9\u05DC\u05D5\u05DD \u05D6\u05D5?",
          "deleteCancelButton": "\u05D1\u05D9\u05D8\u05D5\u05DC",
          "deleteConfirmationButton": "\u05DE\u05D7\u05D9\u05E7\u05D4",
          "fieldEmptyForCvv": "\u05E2\u05DC\u05D9\u05DA \u05DC\u05DE\u05DC\u05D0 \u05D0\u05EA \u05DE\u05E1\u05E4\u05E8 \u05D4\u05D0\u05D1\u05D8\u05D7\u05D4 \u05E9\u05DC \u05DB\u05E8\u05D8\u05D9\u05E1 \u05D4\u05D0\u05E9\u05E8\u05D0\u05D9.",
          "fieldEmptyForExpirationDate": "\u05E2\u05DC\u05D9\u05DA \u05DC\u05DE\u05DC\u05D0 \u05D0\u05EA \u05EA\u05D0\u05E8\u05D9\u05DA \u05E4\u05E7\u05D9\u05E2\u05EA \u05D4\u05EA\u05D5\u05E7\u05E3.",
          "fieldEmptyForCardholderName": "\u05E2\u05DC\u05D9\u05DA \u05DC\u05DE\u05DC\u05D0 \u05D0\u05EA \u05E9\u05DD \u05D1\u05E2\u05DC \u05D4\u05DB\u05E8\u05D8\u05D9\u05E1.",
          "fieldTooLongForCardholderName": "\u05E9\u05DD \u05D1\u05E2\u05DC \u05D4\u05DB\u05E8\u05D8\u05D9\u05E1 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC 256 \u05EA\u05D5\u05D5\u05D9\u05DD \u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8.",
          "fieldEmptyForNumber": "\u05E2\u05DC\u05D9\u05DA \u05DC\u05DE\u05DC\u05D0 \u05D0\u05EA \u05D4\u05DE\u05E1\u05E4\u05E8.",
          "fieldEmptyForPostalCode": "\u05E2\u05DC\u05D9\u05DA \u05DC\u05DE\u05DC\u05D0 \u05D0\u05EA \u05D4\u05DE\u05D9\u05E7\u05D5\u05D3.",
          "fieldInvalidForCardholderName": "\u05E9\u05DD \u05D1\u05E2\u05DC \u05D4\u05DB\u05E8\u05D8\u05D9\u05E1 \u05D0\u05D9\u05E0\u05D5 \u05D7\u05D5\u05E7\u05D9.",
          "fieldInvalidForCvv": "\u05E7\u05D5\u05D3 \u05D0\u05D1\u05D8\u05D7\u05D4 \u05D0\u05D9\u05E0\u05D5 \u05D7\u05D5\u05E7\u05D9.",
          "fieldInvalidForExpirationDate": "\u05EA\u05D0\u05E8\u05D9\u05DA \u05E4\u05E7\u05D9\u05E2\u05EA \u05D4\u05EA\u05D5\u05E7\u05E3 \u05D0\u05D9\u05E0\u05D5 \u05D7\u05D5\u05E7\u05D9.",
          "fieldInvalidForNumber": "\u05DE\u05E1\u05E4\u05E8 \u05DB\u05E8\u05D8\u05D9\u05E1 \u05D4\u05D0\u05E9\u05E8\u05D0\u05D9 \u05D0\u05D9\u05E0\u05D5 \u05D7\u05D5\u05E7\u05D9.",
          "fieldInvalidForPostalCode": "\u05D4\u05DE\u05D9\u05E7\u05D5\u05D3 \u05D0\u05D9\u05E0\u05D5 \u05D7\u05D5\u05E7\u05D9.",
          "noticeOfCollection": "\u05D1\u05DB\u05DA \u05E9\u05D0\u05E0\u05D9 \u05DE\u05E9\u05DC\u05DD/\u05EA \u05D1\u05D0\u05DE\u05E6\u05E2\u05D5\u05EA \u05DB\u05E8\u05D8\u05D9\u05E1 \u05D4\u05D0\u05E9\u05E8\u05D0\u05D9 \u05E9\u05DC\u05D9, \u05D0\u05E0\u05D9 \u05DE\u05E1\u05DB\u05D9\u05DD/\u05D4 \u05DC\u05D4\u05E6\u05D4\u05E8\u05EA \u05D4\u05E4\u05E8\u05D8\u05D9\u05D5\u05EA \u05E9\u05DC PayPal.",
          "genericError": "\u05E0\u05E8\u05D0\u05D4 \u05E9\u05DE\u05E9\u05D4\u05D5 \u05D4\u05E9\u05EA\u05D1\u05E9 \u05D1\u05E6\u05D3 \u05E9\u05DC\u05E0\u05D5.",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u05DB\u05E8\u05D8\u05D9\u05E1 \u05D0\u05E9\u05E8\u05D0\u05D9 \u05D6\u05D4 \u05DB\u05D1\u05E8 \u05E9\u05DE\u05D5\u05E8 \u05DB\u05E9\u05D9\u05D8\u05EA \u05EA\u05E9\u05DC\u05D5\u05DD.",
          "hostedFieldsFailedTokenizationError": "\u05E2\u05DC\u05D9\u05DA \u05DC\u05D1\u05D3\u05D5\u05E7 \u05D0\u05EA \u05D4\u05E4\u05E8\u05D8\u05D9\u05DD \u05E9\u05DC\u05DA \u05D5\u05DC\u05E0\u05E1\u05D5\u05EA \u05E9\u05D5\u05D1.",
          "hostedFieldsFieldsInvalidError": "\u05E2\u05DC\u05D9\u05DA \u05DC\u05D1\u05D3\u05D5\u05E7 \u05D0\u05EA \u05D4\u05E4\u05E8\u05D8\u05D9\u05DD \u05E9\u05DC\u05DA \u05D5\u05DC\u05E0\u05E1\u05D5\u05EA \u05E9\u05D5\u05D1.",
          "hostedFieldsTokenizationNetworkErrorError": "\u05E9\u05D2\u05D9\u05D0\u05EA \u05E8\u05E9\u05EA. \u05E2\u05DC\u05D9\u05DA \u05DC\u05E0\u05E1\u05D5\u05EA \u05E9\u05D5\u05D1.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u05D0\u05D9\u05DE\u05D5\u05EA \u05DB\u05E8\u05D8\u05D9\u05E1 \u05D4\u05D0\u05E9\u05E8\u05D0\u05D9 \u05E0\u05DB\u05E9\u05DC. \u05E2\u05DC\u05D9\u05DA \u05DC\u05D1\u05D3\u05D5\u05E7 \u05D0\u05EA \u05D4\u05E4\u05E8\u05D8\u05D9\u05DD \u05E9\u05DC\u05DA \u05D5\u05DC\u05E0\u05E1\u05D5\u05EA \u05E9\u05D5\u05D1.",
          "paypalButtonMustBeUsed": "\u05DC\u05D4\u05E9\u05EA\u05DE\u05E9 \u05D1\u05DC\u05D7\u05E6\u05DF PayPal \u05DB\u05D3\u05D9 \u05DC\u05D4\u05DE\u05E9\u05D9\u05DA \u05D1\u05D1\u05D9\u05E6\u05D5\u05E2 \u05D4\u05EA\u05E9\u05DC\u05D5\u05DD \u05E9\u05DC\u05DA.",
          "venmoButtonMustBeUsed": "\u05D4\u05E9\u05EA\u05DE\u05E9\u05D5 \u05D1\u05DC\u05D7\u05E6\u05DF Venmo \u05DB\u05D3\u05D9 \u05DC\u05D4\u05DE\u05E9\u05D9\u05DA \u05D1\u05EA\u05E9\u05DC\u05D5\u05DD \u05E9\u05DC\u05DB\u05DD.",
          "applePayButtonMustBeUsed": "\u05D4\u05E9\u05EA\u05DE\u05E9\u05D5 \u05D1\u05DC\u05D7\u05E6\u05DF Apple Pay \u05DB\u05D3\u05D9 \u05DC\u05D4\u05DE\u05E9\u05D9\u05DA \u05D1\u05D1\u05D9\u05E6\u05D5\u05E2 \u05D4\u05EA\u05E9\u05DC\u05D5\u05DD \u05E9\u05DC\u05DB\u05DD.",
          "paypalAccountTokenizationFailedError": "\u05DE\u05E9\u05D4\u05D5 \u05D4\u05E9\u05EA\u05D1\u05E9 \u05D1\u05E2\u05EA \u05D4\u05D5\u05E1\u05E4\u05EA \u05D7\u05E9\u05D1\u05D5\u05DF PayPal. \u05E2\u05DC\u05D9\u05DA \u05DC\u05E0\u05E1\u05D5\u05EA \u05E9\u05D5\u05D1.",
          "paypalFlowFailedError": "\u05DE\u05E9\u05D4\u05D5 \u05D4\u05E9\u05EA\u05D1\u05E9 \u05D1\u05D4\u05EA\u05D7\u05D1\u05E8\u05D5\u05EA \u05DC-PayPal. \u05E2\u05DC\u05D9\u05DA \u05DC\u05E0\u05E1\u05D5\u05EA \u05E9\u05D5\u05D1.",
          "paypalTokenizationRequestActiveError": "\u05D0\u05D9\u05E9\u05D5\u05E8 \u05D4\u05EA\u05E9\u05DC\u05D5\u05DD \u05E9\u05DC PayPal \u05DB\u05D1\u05E8 \u05DE\u05EA\u05D1\u05E6\u05E2.",
          "venmoCanceledError": "\u05E0\u05E8\u05D0\u05D4 \u05E9\u05DE\u05E9\u05D4\u05D5 \u05D4\u05E9\u05EA\u05D1\u05E9. \u05E2\u05DC\u05D9\u05DA \u05DC\u05D5\u05D5\u05D3\u05D0 \u05E9\u05D4\u05D2\u05E8\u05E1\u05D4 \u05D4\u05E2\u05D3\u05DB\u05E0\u05D9\u05EA \u05D1\u05D9\u05D5\u05EA\u05E8 \u05E9\u05DC \u05D0\u05E4\u05DC\u05D9\u05E7\u05E6\u05D9\u05D9\u05EA Venmo \u05DE\u05D5\u05EA\u05E7\u05E0\u05EA \u05D1\u05DE\u05DB\u05E9\u05D9\u05E8 \u05E9\u05DC\u05DA, \u05D5\u05E9\u05D4\u05D3\u05E4\u05D3\u05E4\u05DF \u05E9\u05DC\u05DA \u05EA\u05D5\u05DE\u05DA \u05D1\u05DE\u05E2\u05D1\u05E8 \u05DC-Venmo.",
          "vaultManagerPaymentMethodDeletionError": "\u05DC\u05D0 \u05D4\u05E6\u05DC\u05D7\u05E0\u05D5 \u05DC\u05DE\u05D7\u05D5\u05E7 \u05D0\u05EA \u05E9\u05D9\u05D8\u05EA \u05D4\u05EA\u05E9\u05DC\u05D5\u05DD, \u05E2\u05DC\u05D9\u05DA \u05DC\u05E0\u05E1\u05D5\u05EA \u05E9\u05D5\u05D1.",
          "venmoAppFailedError": "\u05DC\u05D0 \u05DE\u05E6\u05D0\u05E0\u05D5 \u05DC\u05DE\u05E6\u05D5\u05D0 \u05D0\u05EA \u05D0\u05E4\u05DC\u05D9\u05E7\u05E6\u05D9\u05D9\u05EA Venmo \u05D1\u05DE\u05DB\u05E9\u05D9\u05E8 \u05E9\u05DC\u05DA.",
          "unsupportedCardTypeError": "\u05E1\u05D5\u05D2 \u05DB\u05E8\u05D8\u05D9\u05E1 \u05D6\u05D4 \u05D0\u05D9\u05E0\u05D5 \u05E0\u05EA\u05DE\u05DA. \u05E2\u05DC\u05D9\u05DA \u05DC\u05E0\u05E1\u05D5\u05EA \u05DB\u05E8\u05D8\u05D9\u05E1 \u05D0\u05D7\u05E8.",
          "applePayTokenizationError": "\u05D0\u05D9\u05E8\u05E2\u05D4 \u05E9\u05D2\u05D9\u05D0\u05EA \u05E8\u05E9\u05EA \u05D1\u05E2\u05EA \u05E2\u05D9\u05D1\u05D5\u05D3 \u05EA\u05E9\u05DC\u05D5\u05DD \u05D4\u05EA\u05E9\u05DC\u05D5\u05DE\u05D9\u05DD \u05E9\u05DC Apple Pay. \u05E2\u05DC\u05D9\u05DA \u05DC\u05E0\u05E1\u05D5\u05EA \u05E9\u05D5\u05D1.",
          "applePayActiveCardError": "\u05D4\u05D5\u05E1\u05E4\u05EA \u05DB\u05E8\u05D8\u05D9\u05E1 \u05E0\u05EA\u05DE\u05DA \u05DC\u05D0\u05E8\u05E0\u05E7 Apple Pay \u05E9\u05DC\u05DA.",
          "cardholderNameLabel": "\u05E9\u05DD \u05D1\u05E2\u05DC \u05D4\u05DB\u05E8\u05D8\u05D9\u05E1",
          "cardNumberLabel": "\u05DE\u05E1\u05E4\u05E8 \u05DB\u05E8\u05D8\u05D9\u05E1",
          "cvvLabel": "\u05E7\u05D5\u05D3 \u05D0\u05D1\u05D8\u05D7\u05EA \u05DB\u05E8\u05D8\u05D9\u05E1 (CVV)",
          "cvvThreeDigitLabelSubheading": "(3 \u05E1\u05E4\u05E8\u05D5\u05EA)",
          "cvvFourDigitLabelSubheading": "(4 \u05E1\u05E4\u05E8\u05D5\u05EA)",
          "cardholderNamePlaceholder": "\u05E9\u05DD \u05D1\u05E2\u05DC \u05D4\u05DB\u05E8\u05D8\u05D9\u05E1",
          "expirationDateLabel": "\u05EA\u05D0\u05E8\u05D9\u05DA \u05E4\u05E7\u05D9\u05E2\u05EA \u05EA\u05D5\u05E7\u05E3",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "MM/YY\u200F",
          "postalCodeLabel": "\u05DE\u05D9\u05E7\u05D5\u05D3",
          "saveCardLabel": "\u05E9\u05DE\u05D9\u05E8\u05EA \u05DB\u05E8\u05D8\u05D9\u05E1 \u05D0\u05E9\u05E8\u05D0\u05D9",
          "payWithCard": "\u05DC\u05E9\u05DC\u05DD \u05D1\u05D0\u05DE\u05E6\u05E2\u05D5\u05EA \u05DB\u05E8\u05D8\u05D9\u05E1 \u05D0\u05E9\u05E8\u05D0\u05D9",
          "endingIn": "\u05DE\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1\u05EA\u05D0\u05E8\u05D9\u05DA {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u05DB\u05E8\u05D8\u05D9\u05E1",
          "PayPal": "PayPal\u200F",
          "PayPal Credit": "PayPal Credit\u200F",
          "Google Pay": "Google Pay",
          "American Express": "\u05D0\u05DE\u05E8\u05D9\u05E7\u05DF \u05D0\u05E7\u05E1\u05E4\u05E8\u05E1",
          "Discover": "Discover\u200F",
          "Diners Club": "\u05D3\u05D9\u05D9\u05E0\u05E8\u05E1 \u05E7\u05DC\u05D0\u05D1",
          "Elo": "Elo\u200F",
          "Hiper": "Hiper\u200F",
          "Hipercard": "HiperCard\u200F",
          "MasterCard": "\u05DE\u05D0\u05E1\u05D8\u05E8\u05E7\u05D0\u05E8\u05D3",
          "Visa": "Visa",
          "JCB": "JCB\u200F",
          "Maestro": "Maestro\u200F",
          "UnionPay": "UnionPay\u200F"
        };
      }, {}], 227: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Fizet\xE9s ezzel: {{paymentSource}}",
          "chooseAnotherWayToPay": "V\xE1lasszon m\xE1sik fizet\xE9si m\xF3dot",
          "chooseAWayToPay": "V\xE1lasszon fizet\xE9si m\xF3dot",
          "otherWaysToPay": "Egy\xE9b fizet\xE9si m\xF3dok",
          "edit": "Szerkeszt\xE9s",
          "doneEditing": "K\xE9sz",
          "editPaymentMethods": "Fizet\xE9si m\xF3dok szerkeszt\xE9se",
          "CreditCardDeleteConfirmationMessage": "T\xF6rli a(z) {{identifier}}} v\xE9g\u0171 {{secondaryIdentifier}}} k\xE1rty\xE1t?",
          "PayPalAccountDeleteConfirmationMessage": "T\xF6rli a(z) {{identifier}} PayPal-sz\xE1ml\xE1t?",
          "VenmoAccountDeleteConfirmationMessage": "Biztosan t\xF6rli a(z) {{identifier}} felhaszn\xE1l\xF3n\xE9vhez tartoz\xF3 Venmo-sz\xE1ml\xE1t?",
          "genericDeleteConfirmationMessage": "Biztosan t\xF6rli ezt a fizet\xE9si m\xF3dot?",
          "deleteCancelButton": "M\xE9gse",
          "deleteConfirmationButton": "T\xF6rl\xE9s",
          "fieldEmptyForCvv": "K\xE9rj\xFCk, t\xF6ltse ki a CVV-sz\xE1mot.",
          "fieldEmptyForExpirationDate": "T\xF6ltse ki a lej\xE1rati d\xE1tumot.",
          "fieldEmptyForCardholderName": "T\xF6ltse ki a k\xE1rtyabirtokos nev\xE9t.",
          "fieldTooLongForCardholderName": "A k\xE1rtyatulajdonos neve nem lehet hosszabb mint 256 karakter.",
          "fieldEmptyForNumber": "T\xF6ltse ki a sz\xE1mot.",
          "fieldEmptyForPostalCode": "T\xF6ltse ki az ir\xE1ny\xEDt\xF3sz\xE1mot.",
          "fieldInvalidForCardholderName": "Ez a k\xE1rtyabirtokos neve nem \xE9rv\xE9nyes.",
          "fieldInvalidForCvv": "Ez a biztons\xE1gi k\xF3d nem \xE9rv\xE9nyes.",
          "fieldInvalidForExpirationDate": "Ez a lej\xE1rati d\xE1tum \xE9rv\xE9nytelen.",
          "fieldInvalidForNumber": "Ez a k\xE1rtyasz\xE1m nem \xE9rv\xE9nyes.",
          "fieldInvalidForPostalCode": "Ez az ir\xE1ny\xEDt\xF3sz\xE1m nem \xE9rv\xE9nyes.",
          "noticeOfCollection": "A k\xE1rty\xE1mmal t\xF6rt\xE9n\u0151 fizet\xE9s r\xE9v\xE9n elfogadom a PayPal Adatv\xE9delmi nyilatkozat\xE1t.",
          "genericError": "Hiba t\xF6rt\xE9nt a mi oldalunkon.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Ez a hitelk\xE1rtya m\xE1r szerepel mentett fizet\xE9si m\xF3dk\xE9nt.",
          "hostedFieldsFailedTokenizationError": "Ellen\u0151rizze az adatait, majd pr\xF3b\xE1lja \xFAjra.",
          "hostedFieldsFieldsInvalidError": "Ellen\u0151rizze az adatait, majd pr\xF3b\xE1lja \xFAjra.",
          "hostedFieldsTokenizationNetworkErrorError": "H\xE1l\xF3zati hiba. Pr\xF3b\xE1lja \xFAjra.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "A hitelk\xE1rtya hiteles\xEDt\xE9se sikertelen. Ellen\u0151rizze az adatait, majd pr\xF3b\xE1lja \xFAjra.",
          "paypalButtonMustBeUsed": "A fizet\xE9s folytat\xE1s\xE1hoz haszn\xE1lja a PayPal-gombot.",
          "venmoButtonMustBeUsed": "Haszn\xE1lja a Venmo-gombot a fizet\xE9s folytat\xE1s\xE1hoz.",
          "applePayButtonMustBeUsed": "A fizet\xE9s folytat\xE1s\xE1hoz haszn\xE1lja az Apple Pay-gombot.",
          "paypalAccountTokenizationFailedError": "Hiba t\xF6rt\xE9nt a PayPal-sz\xE1mla hozz\xE1ad\xE1sa k\xF6zben. Pr\xF3b\xE1lja \xFAjra.",
          "paypalFlowFailedError": "Hiba t\xF6rt\xE9nt a PayPalhoz val\xF3 kapcsol\xF3d\xE1s k\xF6zben. Pr\xF3b\xE1lja \xFAjra.",
          "paypalTokenizationRequestActiveError": "A PayPal-fizet\xE9s enged\xE9lyez\xE9se m\xE1r folyamatban van.",
          "venmoCanceledError": "Hiba t\xF6rt\xE9nt. Ellen\u0151rizze, hogy eszk\xF6z\xE9re a Venmo-alkalmaz\xE1s legfrissebb verzi\xF3ja van-e telep\xEDtve, \xE9s hogy a b\xF6ng\xE9sz\u0151je t\xE1mogatja-e a Venmo-ra t\xF6rt\xE9n\u0151 \xE1tv\xE1lt\xE1st.",
          "vaultManagerPaymentMethodDeletionError": "Nem siker\xFClt t\xF6r\xF6lni a fizet\xE9si m\xF3dot, pr\xF3b\xE1lja \xFAjra.",
          "venmoAppFailedError": "A Venmo alkalmaz\xE1st nem tal\xE1lja a rendszer az eszk\xF6z\xF6n.",
          "unsupportedCardTypeError": "Ez a k\xE1rtyat\xEDpus nem t\xE1mogatott. Pr\xF3b\xE1ljon meg egy m\xE1sik k\xE1rty\xE1t.",
          "applePayTokenizationError": "H\xE1l\xF3zati hiba t\xF6rt\xE9nt az Apple Pay-kifizet\xE9s k\xF6zben. Pr\xF3b\xE1lja \xFAjra.",
          "applePayActiveCardError": "Adjon egy t\xE1mogatott k\xE1rty\xE1t az Apple Pay p\xE9nzt\xE1rc\xE1hoz.",
          "cardholderNameLabel": "K\xE1rtyabirtokos neve",
          "cardNumberLabel": "K\xE1rtyasz\xE1m",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 sz\xE1mjegy)",
          "cvvFourDigitLabelSubheading": "(4 sz\xE1mjegy)",
          "cardholderNamePlaceholder": "K\xE1rtyabirtokos neve",
          "expirationDateLabel": "Lej\xE1rati d\xE1tum",
          "expirationDateLabelSubheading": "(HH/\xC9\xC9)",
          "expirationDatePlaceholder": "HH/\xC9\xC9",
          "postalCodeLabel": "Ir\xE1ny\xEDt\xF3sz\xE1m",
          "saveCardLabel": "K\xE1rtya ment\xE9se",
          "payWithCard": "Fizet\xE9s bankk\xE1rty\xE1val vagy hitelk\xE1rty\xE1val",
          "endingIn": "{{lastFourCardDigits}}} v\xE9g\u0171",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "K\xE1rtya",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 228: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Membayar dengan {{paymentSource}}",
          "chooseAnotherWayToPay": "Pilih metode pembayaran lain",
          "chooseAWayToPay": "Pilih cara pembayaran",
          "otherWaysToPay": "Cara lain untuk membayar",
          "edit": "Edit",
          "doneEditing": "Selesai",
          "editPaymentMethods": "Edit metode pembayaran",
          "CreditCardDeleteConfirmationMessage": "Hapus kartu {{secondaryIdentifier}} yang berakhiran dengan {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Hapus rekening PayPal {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Yakin ingin menghapus rekening Venmo dengan nama pengguna {{identifier}}?",
          "genericDeleteConfirmationMessage": "Yakin ingin menghapus metode pembayaran ini?",
          "deleteCancelButton": "Batalkan",
          "deleteConfirmationButton": "Hapus",
          "fieldEmptyForCvv": "Mohon mengisi CVV.",
          "fieldEmptyForExpirationDate": "Silakan mengisi tanggal kedaluwarsa.",
          "fieldEmptyForCardholderName": "Silakan mengisi nama pemilik kartu.",
          "fieldTooLongForCardholderName": "Nama pemilik kartu harus kurang dari 256 karakter.",
          "fieldEmptyForNumber": "Mohon mengisi angkanya.",
          "fieldEmptyForPostalCode": "Mohon mengisi kode pos.",
          "fieldInvalidForCardholderName": "Nama pemilik kartu ini tidak valid.",
          "fieldInvalidForCvv": "Kode keamanan ini tidak valid.",
          "fieldInvalidForExpirationDate": "Tanggal kedaluwarsa ini tidak valid.",
          "fieldInvalidForNumber": "Nomor kartu ini tidak valid.",
          "fieldInvalidForPostalCode": "Kode pos ini tidak valid.",
          "noticeOfCollection": "Dengan membayar menggunakan kartu, saya menyetujui Pernyataan Privasi PayPal.",
          "genericError": "Ada yang salah pada sistem kami.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Kartu kredit ini telah ada sebelumnya sebagai metode pembayaran tersimpan.",
          "hostedFieldsFailedTokenizationError": "Mohon periksa informasi Anda dan coba lagi.",
          "hostedFieldsFieldsInvalidError": "Mohon periksa informasi Anda dan coba lagi.",
          "hostedFieldsTokenizationNetworkErrorError": "Kesalahan jaringan. Mohon coba lagi.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Verifikasi kartu kredit gagal. Mohon periksa informasi Anda dan coba lagi.",
          "paypalButtonMustBeUsed": "Gunakan tombol PayPal untuk melanjutkan pembayaran.",
          "venmoButtonMustBeUsed": "Gunakan tombol Venmo untuk melanjutkan pembayaran Anda.",
          "applePayButtonMustBeUsed": "Gunakan tombol Apple Pay untuk melanjutkan pembayaran.",
          "paypalAccountTokenizationFailedError": "Terjadi kesalahan saat menambahkan rekening PayPal. Mohon coba lagi.",
          "paypalFlowFailedError": "Terjadi kesalahan ketika menghubungkan ke PayPal. Mohon coba lagi.",
          "paypalTokenizationRequestActiveError": "Otorisasi pembayaran PayPal sedang diproses.",
          "venmoCanceledError": "Terjadi kesalahan. Pastikan Anda memiliki aplikasi Venmo versi terbaru di perangkat dan peramban Anda mendukung peralihan ke Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Tidak dapat menghapus metode pembayaran, coba lagi.",
          "venmoAppFailedError": "Aplikasi Venmo tidak dapat ditemukan di perangkat Anda.",
          "unsupportedCardTypeError": "Jenis kartu ini tidak didukung. Mohon coba kartu lainnya.",
          "applePayTokenizationError": "Terjadi kesalahan pada jaringan saat memproses pembayaran Apple Pay. Mohon coba lagi.",
          "applePayActiveCardError": "Tambahkan kartu yang didukung oleh wallet Apple Pay Anda.",
          "cardholderNameLabel": "Nama Pemilik Kartu",
          "cardNumberLabel": "Nomor Kartu",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 angka)",
          "cvvFourDigitLabelSubheading": "(4 angka)",
          "cardholderNamePlaceholder": "Nama Pemilik Kartu",
          "expirationDateLabel": "Tanggal Kedaluwarsa",
          "expirationDateLabelSubheading": "(BB/TT)",
          "expirationDatePlaceholder": "BB/TT",
          "postalCodeLabel": "Kode Pos",
          "saveCardLabel": "Simpan kartu",
          "payWithCard": "Bayar dengan kartu",
          "endingIn": "Berakhiran dengan {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Kartu",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Jelajahi",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 229: [function(require2, module2, exports2) {
        var assign2 = require2("../lib/assign").assign;
        var fiveCharacterLocales = {
          ar_EG: require2("./ar_EG"),
          cs_CZ: require2("./cs_CZ"),
          da_DK: require2("./da_DK"),
          de_DE: require2("./de_DE"),
          el_GR: require2("./el_GR"),
          en_AU: require2("./en_AU"),
          en_GB: require2("./en_GB"),
          en_IN: require2("./en_IN"),
          en_US: require2("./en_US"),
          es_ES: require2("./es_ES"),
          es_XC: require2("./es_XC"),
          fi_FI: require2("./fi_FI"),
          fr_CA: require2("./fr_CA"),
          fr_FR: require2("./fr_FR"),
          fr_XC: require2("./fr_XC"),
          he_IL: require2("./he_IL"),
          hu_HU: require2("./hu_HU"),
          id_ID: require2("./id_ID"),
          it_IT: require2("./it_IT"),
          ja_JP: require2("./ja_JP"),
          ko_KR: require2("./ko_KR"),
          nl_NL: require2("./nl_NL"),
          no_NO: require2("./no_NO"),
          pl_PL: require2("./pl_PL"),
          pt_BR: require2("./pt_BR"),
          pt_PT: require2("./pt_PT"),
          ru_RU: require2("./ru_RU"),
          sk_SK: require2("./sk_SK"),
          sv_SE: require2("./sv_SE"),
          th_TH: require2("./th_TH"),
          zh_CN: require2("./zh_CN"),
          zh_HK: require2("./zh_HK"),
          zh_TW: require2("./zh_TW"),
          zh_XC: require2("./zh_XC")
        };
        var twoCharacterLocaleAliases = {
          ar: fiveCharacterLocales.ar_EG,
          cs: fiveCharacterLocales.cs_CZ,
          da: fiveCharacterLocales.da_DK,
          de: fiveCharacterLocales.de_DE,
          el: fiveCharacterLocales.el_GR,
          en: fiveCharacterLocales.en_US,
          es: fiveCharacterLocales.es_ES,
          fi: fiveCharacterLocales.fi_FI,
          fr: fiveCharacterLocales.fr_FR,
          id: fiveCharacterLocales.id_ID,
          it: fiveCharacterLocales.it_IT,
          hu: fiveCharacterLocales.hu_HU,
          ja: fiveCharacterLocales.ja_JP,
          ko: fiveCharacterLocales.ko_KR,
          nl: fiveCharacterLocales.nl_NL,
          no: fiveCharacterLocales.no_NO,
          pl: fiveCharacterLocales.pl_PL,
          pt: fiveCharacterLocales.pt_PT,
          ru: fiveCharacterLocales.ru_RU,
          sk: fiveCharacterLocales.sk_SK,
          sv: fiveCharacterLocales.sv_SE,
          th: fiveCharacterLocales.th_TH,
          zh: fiveCharacterLocales.zh_CN
        };
        module2.exports = {
          twoCharacterLocaleAliases,
          fiveCharacterLocales,
          translations: assign2({}, twoCharacterLocaleAliases, fiveCharacterLocales)
        };
      }, { "../lib/assign": 195, "./ar_EG": 211, "./cs_CZ": 212, "./da_DK": 213, "./de_DE": 214, "./el_GR": 215, "./en_AU": 216, "./en_GB": 217, "./en_IN": 218, "./en_US": 219, "./es_ES": 220, "./es_XC": 221, "./fi_FI": 222, "./fr_CA": 223, "./fr_FR": 224, "./fr_XC": 225, "./he_IL": 226, "./hu_HU": 227, "./id_ID": 228, "./it_IT": 230, "./ja_JP": 231, "./ko_KR": 232, "./nl_NL": 233, "./no_NO": 234, "./pl_PL": 235, "./pt_BR": 236, "./pt_PT": 237, "./ru_RU": 238, "./sk_SK": 239, "./sv_SE": 240, "./th_TH": 241, "./zh_CN": 242, "./zh_HK": 243, "./zh_TW": 244, "./zh_XC": 245 }], 230: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Metodo di pagamento: {{paymentSource}}",
          "chooseAnotherWayToPay": "Scegli un altro metodo di pagamento",
          "chooseAWayToPay": "Scegli un metodo di pagamento",
          "otherWaysToPay": "Altri metodi di pagamento",
          "edit": "Modifica",
          "doneEditing": "Fine",
          "editPaymentMethods": "Modifica metodi di pagamento",
          "CreditCardDeleteConfirmationMessage": "Eliminare la carta {{secondaryIdentifier}} le cui ultime cifre sono {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Eliminare il conto PayPal {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Vuoi davvero eliminare il conto Venmo con il nome utente {{identifier}}?",
          "genericDeleteConfirmationMessage": "Vuoi davvero eliminare questo metodo di pagamento?",
          "deleteCancelButton": "Annulla",
          "deleteConfirmationButton": "Rimuovi",
          "fieldEmptyForCvv": "Compila un CVV.",
          "fieldEmptyForExpirationDate": "Compila una data di scadenza.",
          "fieldEmptyForCardholderName": "Compila un nome del titolare.",
          "fieldTooLongForCardholderName": "Il nome del titolare della carta non pu\xF2 contenere pi\xF9 di 256 caratteri.",
          "fieldEmptyForNumber": "Compila un numero.",
          "fieldEmptyForPostalCode": "Compila un CAP.",
          "fieldInvalidForCardholderName": "Il nome del titolare non \xE8 valido.",
          "fieldInvalidForCvv": "Il codice di sicurezza non \xE8 valido.",
          "fieldInvalidForExpirationDate": "La data di scadenza non \xE8 valida.",
          "fieldInvalidForNumber": "Il numero di carta non \xE8 valido.",
          "fieldInvalidForPostalCode": "Il CAP non \xE8 valido.",
          "noticeOfCollection": "Pagando con la carta, accetto la Dichiarazione sulla privacy di PayPal.",
          "genericError": "Si \xE8 verificato un errore nei nostri sistemi.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Questa carta di credito esiste gi\xE0 come metodo di pagamento salvato.",
          "hostedFieldsFailedTokenizationError": "Controlla i tuoi dati e riprova.",
          "hostedFieldsFieldsInvalidError": "Controlla i tuoi dati e riprova.",
          "hostedFieldsTokenizationNetworkErrorError": "Errore di rete. Riprova.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Verifica della carta di credito non riuscita. Controlla i tuoi dati e riprova.",
          "paypalButtonMustBeUsed": "Usa il pulsante PayPal per continuare con il pagamento.",
          "venmoButtonMustBeUsed": "Usa il pulsante Venmo per continuare il pagamento.",
          "applePayButtonMustBeUsed": "Usa il pulsante Apple Pay per continuare con il pagamento.",
          "paypalAccountTokenizationFailedError": "Si \xE8 verificato un errore durante l'aggiunta del conto PayPal. Riprova.",
          "paypalFlowFailedError": "Si \xE8 verificato un errore durante la connessione a PayPal. Riprova.",
          "paypalTokenizationRequestActiveError": "Autorizzazione di pagamento PayPal gi\xE0 in corso.",
          "venmoCanceledError": "Si \xE8 verificato un errore. Assicurati di avere installato la versione pi\xF9 recente dell'app Venmo sul tuo dispositivo e che il tuo browser supporti il passaggio a Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Impossibile eliminare il metodo di pagamento, riprova.",
          "venmoAppFailedError": "Impossibile trovare l'app Venmo sul tuo dispositivo.",
          "unsupportedCardTypeError": "Questo tipo di carta non \xE8 supportato. Prova con un'altra carta.",
          "applePayTokenizationError": "Si \xE8 verificato un errore di rete durante l'elaborazione del pagamento Apple Pay. Riprova.",
          "applePayActiveCardError": "Aggiungi una carta supportata al tuo wallet Apple Pay.",
          "cardholderNameLabel": "Nome del titolare",
          "cardNumberLabel": "Numero di carta",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 cifre)",
          "cvvFourDigitLabelSubheading": "(4 cifre)",
          "cardholderNamePlaceholder": "Nome del titolare",
          "expirationDateLabel": "Data di scadenza",
          "expirationDateLabelSubheading": "(MM/AA)",
          "expirationDatePlaceholder": "MM/AA",
          "postalCodeLabel": "CAP",
          "saveCardLabel": "Salva carta",
          "payWithCard": "Paga con una carta",
          "endingIn": "Le ultime cifre sono {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Carta",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 231: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "{{paymentSource}}\u3067\u306E\u304A\u652F\u6255\u3044",
          "chooseAnotherWayToPay": "\u5225\u306E\u652F\u6255\u65B9\u6CD5\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044",
          "chooseAWayToPay": "\u652F\u6255\u65B9\u6CD5\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044",
          "otherWaysToPay": "\u305D\u306E\u4ED6\u306E\u652F\u6255\u65B9\u6CD5",
          "edit": "\u7DE8\u96C6",
          "doneEditing": "\u5B8C\u4E86",
          "editPaymentMethods": "\u652F\u6255\u65B9\u6CD5\u306E\u7DE8\u96C6",
          "CreditCardDeleteConfirmationMessage": "{{secondaryIdentifier}}\u30AB\u30FC\u30C9(\u672B\u5C3E\u756A\u53F7: {{identifier}})\u3092\u524A\u9664\u3057\u307E\u3059\u304B?",
          "PayPalAccountDeleteConfirmationMessage": "PayPal\u30A2\u30AB\u30A6\u30F3\u30C8{{identifier}}\u3092\u524A\u9664\u3057\u307E\u3059\u304B?",
          "VenmoAccountDeleteConfirmationMessage": "\u30E6\u30FC\u30B6\u30FC\u540D{{identifier}}\u306EVenmo\u30A2\u30AB\u30A6\u30F3\u30C8\u3092\u524A\u9664\u3057\u3066\u3088\u308D\u3057\u3044\u3067\u3059\u304B?",
          "genericDeleteConfirmationMessage": "\u3053\u306E\u652F\u6255\u65B9\u6CD5\u3092\u524A\u9664\u3057\u307E\u3059\u304B?",
          "deleteCancelButton": "\u30AD\u30E3\u30F3\u30BB\u30EB",
          "deleteConfirmationButton": "\u524A\u9664",
          "fieldEmptyForCvv": "CVV\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "fieldEmptyForExpirationDate": "\u6709\u52B9\u671F\u9650\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "fieldEmptyForCardholderName": "\u30AB\u30FC\u30C9\u4FDD\u6709\u8005\u306E\u540D\u524D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "fieldTooLongForCardholderName": "\u30AB\u30FC\u30C9\u4FDD\u6709\u8005\u306E\u540D\u524D\u306F256\u6587\u5B57\u672A\u6E80\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "fieldEmptyForNumber": "\u756A\u53F7\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "fieldEmptyForPostalCode": "\u90F5\u4FBF\u756A\u53F7\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "fieldInvalidForCardholderName": "\u3053\u306E\u30AB\u30FC\u30C9\u4FDD\u6709\u8005\u306E\u540D\u524D\u306F\u7121\u52B9\u3067\u3059\u3002",
          "fieldInvalidForCvv": "\u3053\u306E\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u30B3\u30FC\u30C9\u306F\u7121\u52B9\u3067\u3059\u3002",
          "fieldInvalidForExpirationDate": "\u3053\u306E\u6709\u52B9\u671F\u9650\u306F\u7121\u52B9\u3067\u3059\u3002",
          "fieldInvalidForNumber": "\u3053\u306E\u30AB\u30FC\u30C9\u756A\u53F7\u306F\u7121\u52B9\u3067\u3059\u3002",
          "fieldInvalidForPostalCode": "\u3053\u306E\u90F5\u4FBF\u756A\u53F7\u306F\u7121\u52B9\u3067\u3059\u3002",
          "noticeOfCollection": "\u30AB\u30FC\u30C9\u3067\u652F\u6255\u3046\u3053\u3068\u306B\u3088\u308A\u3001PayPal\u30D7\u30E9\u30A4\u30D0\u30B7\u30FC\u30B9\u30C6\u30FC\u30C8\u30E1\u30F3\u30C8\u306B\u540C\u610F\u3057\u305F\u3082\u306E\u3068\u307F\u306A\u3055\u308C\u307E\u3059\u3002",
          "genericError": "\u5F0A\u793E\u5074\u3067\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u3053\u306E\u30AF\u30EC\u30B8\u30C3\u30C8\u30AB\u30FC\u30C9\u306F\u3001\u4FDD\u5B58\u6E08\u307F\u306E\u652F\u6255\u65B9\u6CD5\u3068\u3057\u3066\u3059\u3067\u306B\u5B58\u5728\u3057\u307E\u3059\u3002",
          "hostedFieldsFailedTokenizationError": "\u60C5\u5831\u3092\u78BA\u8A8D\u3057\u3066\u3082\u3046\u4E00\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044\u3002",
          "hostedFieldsFieldsInvalidError": "\u60C5\u5831\u3092\u78BA\u8A8D\u3057\u3066\u3082\u3046\u4E00\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044\u3002",
          "hostedFieldsTokenizationNetworkErrorError": "\u30CD\u30C3\u30C8\u30EF\u30FC\u30AF\u30A8\u30E9\u30FC\u3067\u3059\u3002\u518D\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044\u3002",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u30AF\u30EC\u30B8\u30C3\u30C8\u30AB\u30FC\u30C9\u306E\u8A8D\u8A3C\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002\u60C5\u5831\u3092\u78BA\u8A8D\u3057\u3066\u3082\u3046\u4E00\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044\u3002",
          "paypalButtonMustBeUsed": "\u652F\u6255\u3044\u3092\u7D9A\u884C\u3059\u308B\u306B\u306F\u3001PayPal\u30DC\u30BF\u30F3\u3092\u4F7F\u7528\u3057\u307E\u3059\u3002",
          "venmoButtonMustBeUsed": "\u304A\u652F\u6255\u3044\u3092\u7D9A\u884C\u3059\u308B\u306B\u306F\u3001Venmo\u30DC\u30BF\u30F3\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "applePayButtonMustBeUsed": "Apple Pay\u30DC\u30BF\u30F3\u3092\u4F7F\u7528\u3057\u3066\u304A\u652F\u6255\u3044\u3092\u7D9A\u884C\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "paypalAccountTokenizationFailedError": "PayPal\u30A2\u30AB\u30A6\u30F3\u30C8\u306E\u8FFD\u52A0\u4E2D\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u518D\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044\u3002",
          "paypalFlowFailedError": "PayPal\u3078\u306E\u63A5\u7D9A\u306B\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u518D\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044\u3002",
          "paypalTokenizationRequestActiveError": "PayPal\u306E\u652F\u6255\u3044\u627F\u8A8D\u306F\u3059\u3067\u306B\u51E6\u7406\u4E2D\u3067\u3059\u3002",
          "venmoCanceledError": "\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u304A\u4F7F\u3044\u306E\u7AEF\u672B\u306BVenmo\u30A2\u30D7\u30EA\u306E\u6700\u65B0\u30D0\u30FC\u30B8\u30E7\u30F3\u304C\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u3055\u308C\u3066\u304A\u308A\u3001\u304A\u4F7F\u3044\u306E\u30D6\u30E9\u30A6\u30B6\u304CVenmo\u3078\u306E\u5207\u308A\u66FF\u3048\u3092\u30B5\u30DD\u30FC\u30C8\u3057\u3066\u3044\u308B\u3053\u3068\u3092\u3054\u78BA\u8A8D\u304F\u3060\u3055\u3044\u3002",
          "vaultManagerPaymentMethodDeletionError": "\u652F\u6255\u65B9\u6CD5\u3092\u524A\u9664\u3067\u304D\u306A\u3044\u5834\u5408\u306F\u3001\u3082\u3046\u4E00\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044\u3002",
          "venmoAppFailedError": "\u304A\u5BA2\u3055\u307E\u306E\u7AEF\u672B\u3067Venmo\u30A2\u30D7\u30EA\u3092\u898B\u3064\u3051\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002",
          "unsupportedCardTypeError": "\u3053\u306E\u30AB\u30FC\u30C9\u306E\u30BF\u30A4\u30D7\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002\u5225\u306E\u30AB\u30FC\u30C9\u3092\u3054\u4F7F\u7528\u304F\u3060\u3055\u3044\u3002",
          "applePayTokenizationError": "Apple Pay\u306E\u652F\u6255\u3044\u306E\u51E6\u7406\u4E2D\u306B\u30CD\u30C3\u30C8\u30EF\u30FC\u30AF\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u518D\u5EA6\u304A\u8A66\u3057\u304F\u3060\u3055\u3044\u3002",
          "applePayActiveCardError": "Apple Pay\u30A6\u30A9\u30EC\u30C3\u30C8\u306B\u5BFE\u5FDC\u3057\u3066\u3044\u308B\u30AB\u30FC\u30C9\u3092\u8FFD\u52A0\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          "cardholderNameLabel": "\u30AB\u30FC\u30C9\u4FDD\u6709\u8005\u306E\u540D\u524D",
          "cardNumberLabel": "\u30AB\u30FC\u30C9\u756A\u53F7",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3\u6841)",
          "cvvFourDigitLabelSubheading": "(4\u6841)",
          "cardholderNamePlaceholder": "\u30AB\u30FC\u30C9\u4FDD\u6709\u8005\u306E\u540D\u524D",
          "expirationDateLabel": "\u6709\u52B9\u671F\u9650",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "MM/YY",
          "postalCodeLabel": "\u90F5\u4FBF\u756A\u53F7",
          "saveCardLabel": "\u30AB\u30FC\u30C9\u3092\u4FDD\u5B58",
          "payWithCard": "\u30AB\u30FC\u30C9\u3067\u652F\u6255\u3046",
          "endingIn": "\u672B\u5C3E\u756A\u53F7: {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u30AB\u30FC\u30C9",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "\u9280\u806F(UnionPay)"
        };
      }, {}], 232: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\uACB0\uC81C\uC218\uB2E8: {{paymentSource}}",
          "chooseAnotherWayToPay": "\uB2E4\uB978 \uACB0\uC81C\uC218\uB2E8\uC744 \uC120\uD0DD\uD574 \uC8FC\uC138\uC694.",
          "chooseAWayToPay": "\uACB0\uC81C\uC218\uB2E8 \uC120\uD0DD",
          "otherWaysToPay": "\uB2E4\uB978 \uACB0\uC81C\uC218\uB2E8",
          "edit": "\uD3B8\uC9D1",
          "doneEditing": "\uC644\uB8CC",
          "editPaymentMethods": "\uACB0\uC81C\uC218\uB2E8 \uD3B8\uC9D1",
          "CreditCardDeleteConfirmationMessage": "{{identifier}}(\uC73C)\uB85C \uB05D\uB098\uB294 {{secondaryIdentifier}} \uCE74\uB4DC\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
          "PayPalAccountDeleteConfirmationMessage": "PayPal \uACC4\uC815 {{identifier}}\uC744(\uB97C) \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
          "VenmoAccountDeleteConfirmationMessage": "\uC0AC\uC6A9\uC790 \uC774\uB984 {{identifier}}\uC758 Venmo \uACC4\uC815\uC744 \uC815\uB9D0 \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
          "genericDeleteConfirmationMessage": "\uC774 \uACB0\uC81C\uC218\uB2E8\uC744 \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?",
          "deleteCancelButton": "\uCDE8\uC18C",
          "deleteConfirmationButton": "\uC0AD\uC81C",
          "fieldEmptyForCvv": "CVV\uB97C \uC785\uB825\uD558\uC138\uC694.",
          "fieldEmptyForExpirationDate": "\uB9CC\uB8CC\uC77C\uC744 \uC785\uB825\uD558\uC138\uC694.",
          "fieldEmptyForCardholderName": "\uCE74\uB4DC \uC18C\uC720\uC790 \uC774\uB984\uC744 \uC785\uB825\uD558\uC138\uC694.",
          "fieldTooLongForCardholderName": "\uCE74\uB4DC \uC18C\uC720\uC790 \uC774\uB984\uC740 256\uC790 \uBBF8\uB9CC\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4.",
          "fieldEmptyForNumber": "\uBC88\uD638\uB97C \uC785\uB825\uD558\uC138\uC694.",
          "fieldEmptyForPostalCode": "\uC6B0\uD3B8\uBC88\uD638\uB97C \uC785\uB825\uD558\uC138\uC694.",
          "fieldInvalidForCardholderName": "\uC774 \uCE74\uB4DC \uC18C\uC720\uC790 \uC774\uB984\uC740 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
          "fieldInvalidForCvv": "\uC774 \uBCF4\uC548 \uCF54\uB4DC\uB294 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
          "fieldInvalidForExpirationDate": "\uC774 \uB9CC\uB8CC\uC77C\uC740 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
          "fieldInvalidForNumber": "\uC774 \uCE74\uB4DC \uBC88\uD638\uB294 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
          "fieldInvalidForPostalCode": "\uC774 \uC6B0\uD3B8\uBC88\uD638\uB294 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.",
          "noticeOfCollection": "\uC790\uC2E0\uC758 \uCE74\uB4DC\uB85C \uACB0\uC81C\uD568\uC73C\uB85C\uC368 \uC0AC\uC6A9\uC790\uB294 PayPal \uAC1C\uC778\uC815\uBCF4 \uCDE8\uAE09\uBC29\uCE68\uC5D0 \uB3D9\uC758\uD569\uB2C8\uB2E4.",
          "genericError": "\uC800\uD76C \uCABD\uC5D0 \uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
          "hostedFieldsTokenizationFailOnDuplicateError": "\uC774 \uC2E0\uC6A9\uCE74\uB4DC\uB294 \uC774\uBBF8 \uC800\uC7A5\uB41C \uACB0\uC81C\uC218\uB2E8\uC73C\uB85C \uC124\uC815\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.",
          "hostedFieldsFailedTokenizationError": "\uC815\uBCF4\uB97C \uD655\uC778\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "hostedFieldsFieldsInvalidError": "\uC815\uBCF4\uB97C \uD655\uC778\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "hostedFieldsTokenizationNetworkErrorError": "\uB124\uD2B8\uC6CC\uD06C \uC624\uB958\uC785\uB2C8\uB2E4. \uB2E4\uC2DC \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\uC2E0\uC6A9\uCE74\uB4DC \uC778\uC99D\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. \uC815\uBCF4\uB97C \uD655\uC778\uD558\uACE0 \uB2E4\uC2DC \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "paypalButtonMustBeUsed": "PayPal \uBC84\uD2BC\uC744 \uC0AC\uC6A9\uD558\uC5EC \uACB0\uC81C\uB97C \uACC4\uC18D \uC9C4\uD589\uD558\uC138\uC694.",
          "venmoButtonMustBeUsed": "\uACB0\uC81C\uB97C \uACC4\uC18D\uD558\uB824\uBA74 Venmo \uBC84\uD2BC\uC744 \uC0AC\uC6A9\uD558\uC138\uC694.",
          "applePayButtonMustBeUsed": "Apple Pay \uBC84\uD2BC\uC744 \uC0AC\uC6A9\uD558\uC5EC \uACB0\uC81C\uB97C \uACC4\uC18D \uC9C4\uD589\uD558\uC138\uC694.",
          "paypalAccountTokenizationFailedError": "PayPal \uACC4\uC815\uC744 \uCD94\uAC00\uD558\uB294 \uC911\uC5D0 \uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. \uB2E4\uC2DC \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "paypalFlowFailedError": "PayPal\uC5D0 \uC5F0\uACB0\uD558\uB294 \uB370 \uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. \uB2E4\uC2DC \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "paypalTokenizationRequestActiveError": "PayPal \uACB0\uC81C \uC2B9\uC778\uC774 \uC774\uBBF8 \uC9C4\uD589 \uC911\uC785\uB2C8\uB2E4.",
          "venmoCanceledError": "\uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. \uAE30\uAE30\uC5D0 \uCD5C\uC2E0 \uBC84\uC804\uC758 Venmo \uC571\uC774 \uC124\uCE58\uB418\uC5B4 \uC788\uACE0 \uBE0C\uB77C\uC6B0\uC800\uAC00 Venmo\uB85C\uC758 \uC804\uD658\uC744 \uC9C0\uC6D0\uD558\uB294\uC9C0 \uD655\uC778\uD558\uC138\uC694.",
          "vaultManagerPaymentMethodDeletionError": "\uACB0\uC81C\uC218\uB2E8\uC744 \uC0AD\uC81C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uB2E4\uC2DC \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "venmoAppFailedError": "\uAE30\uAE30\uC5D0\uC11C Venmo \uC571\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
          "unsupportedCardTypeError": "\uC774 \uCE74\uB4DC \uC720\uD615\uC740 \uC9C0\uC6D0\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4. \uB2E4\uB978 \uCE74\uB4DC\uB85C \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "applePayTokenizationError": "Apple Pay \uACB0\uC81C\uB97C \uCC98\uB9AC\uD558\uB294 \uB3D9\uC548 \uB124\uD2B8\uC6CC\uD06C \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. \uB2E4\uC2DC \uC2DC\uB3C4\uD574 \uC8FC\uC138\uC694.",
          "applePayActiveCardError": "Apple Pay \uC804\uC790\uC9C0\uAC11\uC5D0 \uC9C0\uC6D0\uB418\uB294 \uCE74\uB4DC\uB97C \uCD94\uAC00\uD558\uC138\uC694.",
          "cardholderNameLabel": "\uCE74\uB4DC \uC18C\uC720\uC790 \uC774\uB984",
          "cardNumberLabel": "\uCE74\uB4DC \uBC88\uD638",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3\uC790\uB9AC)",
          "cvvFourDigitLabelSubheading": "(4\uC790\uB9AC)",
          "cardholderNamePlaceholder": "\uCE74\uB4DC \uC18C\uC720\uC790 \uC774\uB984",
          "expirationDateLabel": "\uB9CC\uB8CC\uC77C",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "MM/YY",
          "postalCodeLabel": "\uC6B0\uD3B8\uBC88\uD638",
          "saveCardLabel": "\uCE74\uB4DC \uC800\uC7A5",
          "payWithCard": "\uCE74\uB4DC\uB85C \uACB0\uC81C",
          "endingIn": "\uB2E4\uC74C\uC73C\uB85C \uB05D\uB0A8: {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\uCE74\uB4DC",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 233: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Betalen met {{paymentSource}}",
          "chooseAnotherWayToPay": "Kies een andere betaalmethode",
          "chooseAWayToPay": "Kies een betaalmethode",
          "otherWaysToPay": "Andere betaalmethoden",
          "edit": "Bewerken",
          "doneEditing": "Klaar",
          "editPaymentMethods": "Betaalmethoden bewerken",
          "CreditCardDeleteConfirmationMessage": "{{secondaryIdentifier}}-kaart eindigend op {{identifier}} verwijderen?",
          "PayPalAccountDeleteConfirmationMessage": "PayPal-rekening {{identifier}} verwijderen?",
          "VenmoAccountDeleteConfirmationMessage": "Weet je zeker dat je de Venmo-rekening met gebruikersnaam {{identifier}} wilt verwijderen?",
          "genericDeleteConfirmationMessage": "Weet je zeker dat je deze betaalmethode wilt verwijderen?",
          "deleteCancelButton": "Annuleren",
          "deleteConfirmationButton": "Verwijderen",
          "fieldEmptyForCvv": "Vul een CVV in.",
          "fieldEmptyForExpirationDate": "Vul een vervaldatum in.",
          "fieldEmptyForCardholderName": "Vul de naam van de kaarthouder in.",
          "fieldTooLongForCardholderName": "Naam kaarthouder moet minder dan 256 tekens bevatten.",
          "fieldEmptyForNumber": "Vul een nummer in.",
          "fieldEmptyForPostalCode": "Vul een postcode in.",
          "fieldInvalidForCardholderName": "Naam kaarthouder is ongeldig.",
          "fieldInvalidForCvv": "Deze beveiligingscode is ongeldig.",
          "fieldInvalidForExpirationDate": "Deze vervaldatum is ongeldig.",
          "fieldInvalidForNumber": "Dit kaartnummer is ongeldig.",
          "fieldInvalidForPostalCode": "Deze postcode is ongeldig.",
          "noticeOfCollection": "Door met mijn kaart te betalen, ga ik akkoord met de PayPal Privacyverklaring.",
          "genericError": "Er is aan onze kant iets fout gegaan.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Deze creditcard bestaat al als opgeslagen betaalmethode.",
          "hostedFieldsFailedTokenizationError": "Controleer je gegevens en probeer het opnieuw.",
          "hostedFieldsFieldsInvalidError": "Controleer je gegevens en probeer het opnieuw.",
          "hostedFieldsTokenizationNetworkErrorError": "Netwerkfout. Probeer het opnieuw.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Verificatie van creditcard is mislukt. Controleer je gegevens en probeer het opnieuw.",
          "paypalButtonMustBeUsed": "Gebruik de PayPal-knop om door te gaan met je betaling.",
          "venmoButtonMustBeUsed": "Gebruik de Venmo-knop om door te gaan met je betaling.",
          "applePayButtonMustBeUsed": "Gebruik de knop Apple Pay om door te gaan met je betaling.",
          "paypalAccountTokenizationFailedError": "Er is iets fout gegaan bij het toevoegen van de PayPal-rekening. Probeer het opnieuw.",
          "paypalFlowFailedError": "Er is iets fout gegaan bij het verbinden met PayPal. Probeer het opnieuw.",
          "paypalTokenizationRequestActiveError": "PayPal-betaalautorisatie is al in voortgang.",
          "venmoCanceledError": "Er is iets fout gegaan. Zorg ervoor dat je de recentste versie van de Venmo-app op je apparaat ge\xEFnstalleerd hebt en dat je browser ondersteuning biedt voor overschakelen naar Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Kan betaalmethode niet verwijderen. Probeer het opnieuw.",
          "venmoAppFailedError": "De Venmo-app is niet gevonden op je apparaat.",
          "unsupportedCardTypeError": "Dit kaarttype wordt niet ondersteund. Gebruik een andere kaart.",
          "applePayTokenizationError": "Er is een netwerkfout opgetreden bij het verwerken van de Apple Pay-betaling. Probeer het opnieuw.",
          "applePayActiveCardError": "Voeg een ondersteunde kaart toe aan je Apple Pay-wallet.",
          "cardholderNameLabel": "Naam kaarthouder",
          "cardNumberLabel": "Kaartnummer",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 cijfers)",
          "cvvFourDigitLabelSubheading": "(4 cijfers)",
          "cardholderNamePlaceholder": "Naam kaarthouder",
          "expirationDateLabel": "Vervaldatum",
          "expirationDateLabelSubheading": "(mm/jj)",
          "expirationDatePlaceholder": "mm/jj",
          "postalCodeLabel": "Postcode",
          "saveCardLabel": "Kaart opslaan",
          "payWithCard": "Betalen met kaart",
          "endingIn": "Eindigend op {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Kaart",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 234: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Betaler med {{paymentSource}}",
          "chooseAnotherWayToPay": "Velg en annen betalingsm\xE5te",
          "chooseAWayToPay": "Velg betalingsm\xE5te",
          "otherWaysToPay": "Andre betalingsm\xE5ter",
          "edit": "Endre",
          "doneEditing": "Ferdig",
          "editPaymentMethods": "Rediger betalingsmetode",
          "CreditCardDeleteConfirmationMessage": "Vil du slette {{secondaryIdentifier}}-kortet som slutter p\xE5 {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Vil du slette PayPal-konto {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Er du sikker p\xE5 at du vil slette Venmo-kontoen med brukernavnet {{identifier}}?",
          "genericDeleteConfirmationMessage": "Er du sikker p\xE5 at du vil slette denne betalingsmetoden?",
          "deleteCancelButton": "Avbryt",
          "deleteConfirmationButton": "Slett",
          "fieldEmptyForCvv": "Fyll ut sikkerhetskode (CVV).",
          "fieldEmptyForExpirationDate": "Fyll ut utl\xF8psdato.",
          "fieldEmptyForCardholderName": "Fyll ut kortinnehavers navn.",
          "fieldTooLongForCardholderName": "Kortinnehaverens m\xE5 ha mindre enn 256 tegn.",
          "fieldEmptyForNumber": "Fyll ut nummer.",
          "fieldEmptyForPostalCode": "Fyll ut postnummer.",
          "fieldInvalidForCardholderName": "Denne kortinnehaverens navn er ikke gyldig.",
          "fieldInvalidForCvv": "Denne sikkerhetskoden er ikke gyldig.",
          "fieldInvalidForExpirationDate": "Denne utl\xF8psdatoen er ikke gyldig.",
          "fieldInvalidForNumber": "Dette kortnummeret er ikke gyldig.",
          "fieldInvalidForPostalCode": "Dette postnummeret er ikke gyldig.",
          "noticeOfCollection": "Ved \xE5 betale med kortet godtar jeg PayPals personvernerkl\xE6ring.",
          "genericError": "Noe gikk galt hos oss.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Dette betalingskortet finnes allerede som en lagret betalingsmetode.",
          "hostedFieldsFailedTokenizationError": "Kontroller informasjonen, og pr\xF8v p\xE5 nytt.",
          "hostedFieldsFieldsInvalidError": "Kontroller informasjonen, og pr\xF8v p\xE5 nytt.",
          "hostedFieldsTokenizationNetworkErrorError": "Nettverksfeil. Pr\xF8v p\xE5 nytt.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Kontroll av betalingskort mislyktes. Kontroller informasjonen, og pr\xF8v p\xE5 nytt.",
          "paypalButtonMustBeUsed": "Bruk PayPal-knappen for \xE5 fortsette med betalingen.",
          "venmoButtonMustBeUsed": "Bruk Venmo-knappen for \xE5 fortsette med betalingen.",
          "applePayButtonMustBeUsed": "Bruk Apple Pay-knappen for \xE5 fortsette med betalingen.",
          "paypalAccountTokenizationFailedError": "Kan ikke legge til PayPal-kontoen. Pr\xF8v p\xE5 nytt.",
          "paypalFlowFailedError": "Kan ikke koble til PayPal. Pr\xF8v p\xE5 nytt.",
          "paypalTokenizationRequestActiveError": "PayPals prosess for betalingsgodkjenning har allerede startet.",
          "venmoCanceledError": "Noe gikk galt. Kontroller at den nyeste versjonen av Venmo-appen er installert p\xE5 enheten din, og at nettleseren din st\xF8tter bruk av Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Kan ikke slette betalingsmetoden. Pr\xF8v p\xE5 nytt.",
          "venmoAppFailedError": "Finner ikke Venmo-appen p\xE5 enheten.",
          "unsupportedCardTypeError": "Denne korttypen st\xF8ttes ikke. Pr\xF8v et annet kort.",
          "applePayTokenizationError": "Nettverksfeil under behandling av Apple Pay-betalingen. Pr\xF8v p\xE5 nytt.",
          "applePayActiveCardError": "Legg til et st\xF8ttet kort i e-lommeboken for Apple Pay.",
          "cardholderNameLabel": "Kortinnehavers navn",
          "cardNumberLabel": "Kortnummer",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 sifre)",
          "cvvFourDigitLabelSubheading": "(4 sifre)",
          "cardholderNamePlaceholder": "Kortinnehavers navn",
          "expirationDateLabel": "Utl\xF8psdato",
          "expirationDateLabelSubheading": "(MM/\xC5\xC5)",
          "expirationDatePlaceholder": "MM/\xC5\xC5",
          "postalCodeLabel": "Postnummer",
          "saveCardLabel": "Lagre kort",
          "payWithCard": "Betal med kort",
          "endingIn": "Slutter p\xE5 {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Kort",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 235: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u0179r\xF3d\u0142o finansowania p\u0142atno\u015Bci: {{paymentSource}}",
          "chooseAnotherWayToPay": "Wybierz inny spos\xF3b p\u0142atno\u015Bci.",
          "chooseAWayToPay": "Wybierz spos\xF3b p\u0142atno\u015Bci",
          "otherWaysToPay": "Inne sposoby p\u0142atno\u015Bci",
          "edit": "Edytuj",
          "doneEditing": "Gotowe",
          "editPaymentMethods": "Edytuj formy p\u0142atno\u015Bci",
          "CreditCardDeleteConfirmationMessage": "Usun\u0105\u0107 kart\u0119 {{secondaryIdentifier}} o numerze zako\u0144czonym cyframi {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Usun\u0105\u0107 {{identifier}}konta PayPal?",
          "VenmoAccountDeleteConfirmationMessage": "Czy na pewno chcesz usun\u0105\u0107 konto Venmo o nazwie u\u017Cytkownika {{identifier}}?",
          "genericDeleteConfirmationMessage": "Na pewno chcesz usun\u0105\u0107 t\u0119 form\u0119 p\u0142atno\u015Bci?",
          "deleteCancelButton": "Anuluj",
          "deleteConfirmationButton": "Usu\u0144",
          "fieldEmptyForCvv": "Wpisz kod CVV.",
          "fieldEmptyForExpirationDate": "Wpisz dat\u0119 wa\u017Cno\u015Bci.",
          "fieldEmptyForCardholderName": "Podaj imi\u0119 i nazwisko posiadacza karty.",
          "fieldTooLongForCardholderName": "Imi\u0119 i nazwisko posiadacza karty musi mie\u0107 mniej ni\u017C 256 znak\xF3w.",
          "fieldEmptyForNumber": "Podaj numer.",
          "fieldEmptyForPostalCode": "Podaj kod pocztowy.",
          "fieldInvalidForCardholderName": "To imi\u0119 i nazwisko posiadacza karty jest nieprawid\u0142owe.",
          "fieldInvalidForCvv": "Ten kod bezpiecze\u0144stwa jest nieprawid\u0142owy.",
          "fieldInvalidForExpirationDate": "Ta data wa\u017Cno\u015Bci jest nieprawid\u0142owa.",
          "fieldInvalidForNumber": "Numer karty jest nieprawid\u0142owy.",
          "fieldInvalidForPostalCode": "Kod pocztowy jest nieprawid\u0142owy.",
          "noticeOfCollection": "Dokonuj\u0105c p\u0142atno\u015Bci kart\u0105, akceptuj\u0119 Informacje dotycz\u0105ce zasad ochrony danych firmy PayPal.",
          "genericError": "Wyst\u0105pi\u0142 b\u0142\u0105d po naszej stronie.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Ta karta kredytowa istnieje jako zapisana forma p\u0142atno\u015Bci.",
          "hostedFieldsFailedTokenizationError": "Sprawd\u017A swoje informacje i spr\xF3buj ponownie.",
          "hostedFieldsFieldsInvalidError": "Sprawd\u017A swoje informacje i spr\xF3buj ponownie.",
          "hostedFieldsTokenizationNetworkErrorError": "B\u0142\u0105d sieci. Spr\xF3buj ponownie.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Weryfikacja karty kredytowej nie powiod\u0142a si\u0119. Sprawd\u017A swoje informacje i spr\xF3buj ponownie.",
          "paypalButtonMustBeUsed": "Aby kontynuowa\u0107 p\u0142atno\u015B\u0107, u\u017Cyj przycisku PayPal.",
          "venmoButtonMustBeUsed": "U\u017Cyj przycisku Venmo, aby kontynuowa\u0107 p\u0142atno\u015B\u0107",
          "applePayButtonMustBeUsed": "Aby kontynuowa\u0107 p\u0142atno\u015B\u0107, u\u017Cyj przycisku Apple Pay.",
          "paypalAccountTokenizationFailedError": "Co\u015B posz\u0142o nie tak przy dodawaniu konta PayPal. Spr\xF3buj ponownie.",
          "paypalFlowFailedError": "Wyst\u0105pi\u0142 problem przy nawi\u0105zywaniu po\u0142\u0105czenia z PayPal. Spr\xF3buj ponownie.",
          "paypalTokenizationRequestActiveError": "Autoryzacja p\u0142atno\u015Bci PayPal jest w trakcie realizacji.",
          "venmoCanceledError": "Co\u015B posz\u0142o nie tak. Upewnij si\u0119, \u017Ce na Twoim urz\u0105dzeniu jest zainstalowana najnowsza wersja aplikacji Venmo, a Twoja przegl\u0105darka obs\u0142uguje prze\u0142\u0105czanie na Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Nie mo\u017Cna usun\u0105\u0107 formy p\u0142atno\u015Bci, spr\xF3buj ponownie.",
          "venmoAppFailedError": "Aplikacja Venmo nie zosta\u0142a odnaleziona na Twoim urz\u0105dzeniu.",
          "unsupportedCardTypeError": "Ten typ karty nie jest obs\u0142ugiwany. Spr\xF3buj u\u017Cy\u0107 innej karty.",
          "applePayTokenizationError": "Wyst\u0105pi\u0142 b\u0142\u0105d sieciowy podczas przetwarzania p\u0142atno\u015Bci Apple Pay. Spr\xF3buj ponownie.",
          "applePayActiveCardError": "Dodaj obs\u0142ugiwan\u0105 kart\u0119 do portfela Apple Pay.",
          "cardholderNameLabel": "Imi\u0119 i nazwisko posiadacza karty",
          "cardNumberLabel": "Numer karty",
          "cvvLabel": "Kod CVV/CVC2",
          "cvvThreeDigitLabelSubheading": "(3 cyfry)",
          "cvvFourDigitLabelSubheading": "(4 cyfry)",
          "cardholderNamePlaceholder": "Imi\u0119 i nazwisko posiadacza karty",
          "expirationDateLabel": "Data wa\u017Cno\u015Bci",
          "expirationDateLabelSubheading": "(MM/RR)",
          "expirationDatePlaceholder": "MM/RR",
          "postalCodeLabel": "Kod pocztowy",
          "saveCardLabel": "Zapisz kart\u0119",
          "payWithCard": "Zap\u0142a\u0107 kart\u0105",
          "endingIn": "Numer zako\u0144czonym cyframi {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Karta",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 236: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Pagando com {{paymentSource}}",
          "chooseAnotherWayToPay": "Escolha outro meio de pagamento",
          "chooseAWayToPay": "Escolha um meio de pagamento",
          "otherWaysToPay": "Outras formas de pagar",
          "edit": "Editar",
          "doneEditing": "Conclu\xEDdo",
          "editPaymentMethods": "Editar meios de pagamento",
          "CreditCardDeleteConfirmationMessage": "Excluir cart\xE3o {{secondaryIdentifier}} de final {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Excluir conta do PayPal {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Tem certeza de que deseja excluir a conta do Venmo com nome de usu\xE1rio {{identifier}}?",
          "genericDeleteConfirmationMessage": "Tem certeza que deseja excluir este meio de pagamento?",
          "deleteCancelButton": "Cancelar",
          "deleteConfirmationButton": "Excluir",
          "fieldEmptyForCvv": "Preencha um CVV.",
          "fieldEmptyForExpirationDate": "Preencha uma data de vencimento.",
          "fieldEmptyForCardholderName": "Preencha um nome para o titular do cart\xE3o.",
          "fieldTooLongForCardholderName": "O nome do titular do cart\xE3o deve ter menos de 256 caracteres.",
          "fieldEmptyForNumber": "Preencha um n\xFAmero.",
          "fieldEmptyForPostalCode": "Preencha um c\xF3digo postal.",
          "fieldInvalidForCardholderName": "O nome do titular do cart\xE3o \xE9 inv\xE1lido.",
          "fieldInvalidForCvv": "Este c\xF3digo de seguran\xE7a \xE9 inv\xE1lido.",
          "fieldInvalidForExpirationDate": "Esta data de vencimento \xE9 inv\xE1lida.",
          "fieldInvalidForNumber": "O n\xFAmero do cart\xE3o \xE9 inv\xE1lido.",
          "fieldInvalidForPostalCode": "Este c\xF3digo postal \xE9 inv\xE1lido.",
          "noticeOfCollection": "Ao pagar com o meu cart\xE3o, aceito a Declara\xE7\xE3o de Privacidade da PayPal.",
          "genericError": "Ocorreu um erro.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Este cart\xE3o de cr\xE9dito j\xE1 existe como um meio de pagamento salvo.",
          "hostedFieldsFailedTokenizationError": "Verifique as informa\xE7\xF5es e tente novamente.",
          "hostedFieldsFieldsInvalidError": "Verifique as informa\xE7\xF5es e tente novamente.",
          "hostedFieldsTokenizationNetworkErrorError": "Erro de rede. Tente novamente.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Falha na verifica\xE7\xE3o do cart\xE3o de cr\xE9dito. Verifique as informa\xE7\xF5es e tente novamente.",
          "paypalButtonMustBeUsed": "Use o bot\xE3o do PayPal para prosseguir com o pagamento.",
          "venmoButtonMustBeUsed": "Utilize o bot\xE3o Venmo para continuar o seu pagamento.",
          "applePayButtonMustBeUsed": "Use o bot\xE3o Apple Pay para prosseguir com o pagamento.",
          "paypalAccountTokenizationFailedError": "Ocorreu um erro ao adicionar a conta do PayPal. Tente novamente.",
          "paypalFlowFailedError": "Ocorreu um erro na conex\xE3o com o PayPal. Tente novamente.",
          "paypalTokenizationRequestActiveError": "A autoriza\xE7\xE3o de pagamento do PayPal j\xE1 est\xE1 em andamento.",
          "venmoCanceledError": "Ocorreu um erro. Certifique-se de que voc\xEA tenha a vers\xE3o mais recente do aplicativo Venmo instalada no seu dispositivo, e que seu navegador aceite a mudan\xE7a para o Venmo.",
          "vaultManagerPaymentMethodDeletionError": "N\xE3o \xE9 poss\xEDvel excluir o meio de pagamento, tente novamente.",
          "venmoAppFailedError": "O aplicativo Venmo n\xE3o foi encontrado no seu dispositivo.",
          "unsupportedCardTypeError": "Este tipo de cart\xE3o n\xE3o \xE9 aceito. Tente outro cart\xE3o.",
          "applePayTokenizationError": "Ocorreu um erro de rede ao processar o pagamento do Apple Pay. Tente novamente.",
          "applePayActiveCardError": "Adicione um cart\xE3o compat\xEDvel \xE0 sua carteira Apple Pay.",
          "cardholderNameLabel": "Nome do titular do cart\xE3o",
          "cardNumberLabel": "N\xFAmero do cart\xE3o",
          "cvvLabel": "CSC",
          "cvvThreeDigitLabelSubheading": "(3 d\xEDgitos)",
          "cvvFourDigitLabelSubheading": "(4 d\xEDgitos)",
          "cardholderNamePlaceholder": "Nome do titular do cart\xE3o",
          "expirationDateLabel": "Data de vencimento",
          "expirationDateLabelSubheading": "(MM/AA)",
          "expirationDatePlaceholder": "MM/AA",
          "postalCodeLabel": "CEP",
          "saveCardLabel": "Salvar cart\xE3o",
          "payWithCard": "Pague com seu cart\xE3o de cr\xE9dito",
          "endingIn": "De final {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Cart\xE3o",
          "PayPal": "PayPal",
          "PayPal Credit": "Cr\xE9dito do PayPal",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Descobrir",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 237: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Pagamento com {{paymentSource}}",
          "chooseAnotherWayToPay": "Escolher outra forma de pagamento",
          "chooseAWayToPay": "Escolher forma de pagamento",
          "otherWaysToPay": "Outras formas de pagamento",
          "edit": "Editar",
          "doneEditing": "Conclu\xEDdo",
          "editPaymentMethods": "Editar meios de pagamento",
          "CreditCardDeleteConfirmationMessage": "Eliminar cart\xE3o {{secondaryIdentifier}} terminado em {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Eliminar conta PayPal {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "Quer mesmo eliminar a conta Venmo com o nome de utilizador {{identifier}}?",
          "genericDeleteConfirmationMessage": "Quer mesmo eliminar este meio de pagamento?",
          "deleteCancelButton": "Cancelar",
          "deleteConfirmationButton": "Eliminar",
          "fieldEmptyForCvv": "Introduza um CVV.",
          "fieldEmptyForExpirationDate": "Introduza uma data de validade.",
          "fieldEmptyForCardholderName": "Introduza um nome do titular do cart\xE3o.",
          "fieldTooLongForCardholderName": "O Nome do titular do cart\xE3o deve ter menos de 256\xA0carateres.",
          "fieldEmptyForNumber": "Introduza um n\xFAmero.",
          "fieldEmptyForPostalCode": "Introduza um c\xF3digo postal.",
          "fieldInvalidForCardholderName": "Este nome do titular do cart\xE3o n\xE3o \xE9 v\xE1lido.",
          "fieldInvalidForCvv": "Este c\xF3digo de seguran\xE7a n\xE3o \xE9 v\xE1lido.",
          "fieldInvalidForExpirationDate": "Esta data de validade n\xE3o \xE9 v\xE1lida.",
          "fieldInvalidForNumber": "Este n\xFAmero de cart\xE3o n\xE3o \xE9 v\xE1lido.",
          "fieldInvalidForPostalCode": "Este c\xF3digo postal n\xE3o \xE9 v\xE1lido.",
          "noticeOfCollection": "Ao pagar com o meu cart\xE3o, aceito a Declara\xE7\xE3o de Privacidade da PayPal.",
          "genericError": "Tudo indica que houve um problema.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Este cart\xE3o de cr\xE9dito j\xE1 existe como meio de pagamento guardado.",
          "hostedFieldsFailedTokenizationError": "Verifique as suas informa\xE7\xF5es e tente novamente.",
          "hostedFieldsFieldsInvalidError": "Verifique as suas informa\xE7\xF5es e tente novamente.",
          "hostedFieldsTokenizationNetworkErrorError": "Erro de rede. Tente novamente.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "A verifica\xE7\xE3o do cart\xE3o de cr\xE9dito falhou. Verifique as suas informa\xE7\xF5es e tente novamente.",
          "paypalButtonMustBeUsed": "Use o bot\xE3o PayPal para continuar o seu pagamento.",
          "venmoButtonMustBeUsed": "Utilize o bot\xE3o Venmo para continuar o seu pagamento.",
          "applePayButtonMustBeUsed": "Utilize o bot\xE3o Apple Pay para continuar o seu pagamento.",
          "paypalAccountTokenizationFailedError": "Ocorreu um erro ao adicionar a conta PayPal. Tente novamente.",
          "paypalFlowFailedError": "Ocorreu um erro ao ligar ao PayPal. Tente novamente.",
          "paypalTokenizationRequestActiveError": "A autoriza\xE7\xE3o de pagamento com PayPal j\xE1 est\xE1 em curso.",
          "venmoCanceledError": "Ocorreu um erro. Certifique-se de que tem a vers\xE3o mais recente da aplica\xE7\xE3o Venmo instalada no seu dispositivo e que o seu navegador suporta a mudan\xE7a para Venmo.",
          "vaultManagerPaymentMethodDeletionError": "N\xE3o \xE9 poss\xEDvel eliminar o meio de pagamento; tente novamente.",
          "venmoAppFailedError": "A aplica\xE7\xE3o Venmo n\xE3o foi encontrada no seu dispositivo.",
          "unsupportedCardTypeError": "Este tipo de cart\xE3o n\xE3o \xE9 suportado. Tente com outro cart\xE3o.",
          "applePayTokenizationError": "Ocorreu um erro de rede ao processar o pagamento com Apple Pay. Tente novamente.",
          "applePayActiveCardError": "Adicione um cart\xE3o suportado \xE0 sua carteira Apple Pay.",
          "cardholderNameLabel": "Nome do titular do cart\xE3o",
          "cardNumberLabel": "N\xFAmero do cart\xE3o",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3\xA0d\xEDgitos)",
          "cvvFourDigitLabelSubheading": "(4\xA0d\xEDgitos)",
          "cardholderNamePlaceholder": "Nome do titular do cart\xE3o",
          "expirationDateLabel": "Data de validade",
          "expirationDateLabelSubheading": "(MM/AA)",
          "expirationDatePlaceholder": "MM/AA",
          "postalCodeLabel": "C\xF3digo postal",
          "saveCardLabel": "Guardar cart\xE3o",
          "payWithCard": "Pagar com cart\xE3o",
          "endingIn": "Termina em {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Cart\xE3o",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 238: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u041E\u043F\u043B\u0430\u0442\u0430 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E {{paymentSource}}",
          "chooseAnotherWayToPay": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0440\u0443\u0433\u043E\u0439 \u0441\u043F\u043E\u0441\u043E\u0431 \u043E\u043F\u043B\u0430\u0442\u044B",
          "chooseAWayToPay": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u043F\u043E\u0441\u043E\u0431 \u043E\u043F\u043B\u0430\u0442\u044B",
          "otherWaysToPay": "\u0414\u0440\u0443\u0433\u0438\u0435 \u0441\u043F\u043E\u0441\u043E\u0431\u044B \u043E\u043F\u043B\u0430\u0442\u044B",
          "edit": "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C",
          "doneEditing": "\u0413\u043E\u0442\u043E\u0432\u043E",
          "editPaymentMethods": "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u0441\u043F\u043E\u0441\u043E\u0431\u044B \u043E\u043F\u043B\u0430\u0442\u044B",
          "CreditCardDeleteConfirmationMessage": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u0443 {{secondaryIdentifier}} \u0441 \u043D\u043E\u043C\u0435\u0440\u043E\u043C, \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u044E\u0449\u0438\u043C\u0441\u044F \u043D\u0430 {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0447\u0435\u0442 PayPal {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "\u0412\u044B \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u0447\u0435\u0442 Venmo \u0441 \u0438\u043C\u0435\u043D\u0435\u043C \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F {{identifier}}?",
          "genericDeleteConfirmationMessage": "\u0412\u044B \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u044D\u0442\u043E\u0442 \u0441\u043F\u043E\u0441\u043E\u0431 \u043E\u043F\u043B\u0430\u0442\u044B?",
          "deleteCancelButton": "\u041E\u0442\u043C\u0435\u043D\u0430",
          "deleteConfirmationButton": "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
          "fieldEmptyForCvv": "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u043A\u043E\u0434 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438.",
          "fieldEmptyForExpirationDate": "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u0434\u0430\u0442\u0443 \u043E\u043A\u043E\u043D\u0447\u0430\u043D\u0438\u044F \u0441\u0440\u043E\u043A\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F.",
          "fieldEmptyForCardholderName": "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u0438\u043C\u044F \u0432\u043B\u0430\u0434\u0435\u043B\u044C\u0446\u0430 \u043A\u0430\u0440\u0442\u044B.",
          "fieldTooLongForCardholderName": "\u0418\u043C\u044F \u0432\u043B\u0430\u0434\u0435\u043B\u044C\u0446\u0430 \u043A\u0430\u0440\u0442\u044B \u0434\u043E\u043B\u0436\u043D\u043E \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043D\u0435 \u0431\u043E\u043B\u0435\u0435 256 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432.",
          "fieldEmptyForNumber": "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u043D\u043E\u043C\u0435\u0440.",
          "fieldEmptyForPostalCode": "\u0423\u043A\u0430\u0436\u0438\u0442\u0435 \u043F\u043E\u0447\u0442\u043E\u0432\u044B\u0439 \u0438\u043D\u0434\u0435\u043A\u0441.",
          "fieldInvalidForCardholderName": "\u041D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0438\u043C\u044F \u0432\u043B\u0430\u0434\u0435\u043B\u044C\u0446\u0430 \u043A\u0430\u0440\u0442\u044B.",
          "fieldInvalidForCvv": "\u041D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u044B\u0439 \u043A\u043E\u0434 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438.",
          "fieldInvalidForExpirationDate": "\u041D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u0430\u044F \u0434\u0430\u0442\u0430 \u0438\u0441\u0442\u0435\u0447\u0435\u043D\u0438\u044F \u0441\u0440\u043E\u043A\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F.",
          "fieldInvalidForNumber": "\u041D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u044B\u0439 \u043D\u043E\u043C\u0435\u0440 \u043A\u0430\u0440\u0442\u044B.",
          "fieldInvalidForPostalCode": "\u041D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u044B\u0439 \u043F\u043E\u0447\u0442\u043E\u0432\u044B\u0439 \u0438\u043D\u0434\u0435\u043A\u0441.",
          "noticeOfCollection": "\u0412\u044B\u043F\u043E\u043B\u043D\u044F\u044F \u043E\u043F\u043B\u0430\u0442\u0443 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u043A\u0430\u0440\u0442\u044B, \u044F \u0441\u043E\u0433\u043B\u0430\u0448\u0430\u044E\u0441\u044C \u0441 \u0443\u0441\u043B\u043E\u0432\u0438\u044F\u043C\u0438 \u041F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u044F \u043E \u043A\u043E\u043D\u0444\u0438\u0434\u0435\u043D\u0446\u0438\u0430\u043B\u044C\u043D\u043E\u0441\u0442\u0438 PayPal.",
          "genericError": "\u0412\u043E\u0437\u043D\u0438\u043A\u043B\u0430 \u043F\u0440\u043E\u0431\u043B\u0435\u043C\u0430 \u0441 \u043D\u0430\u0448\u0435\u0439 \u0441\u0442\u043E\u0440\u043E\u043D\u044B.",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u0414\u0430\u043D\u043D\u0430\u044F \u043A\u0440\u0435\u0434\u0438\u0442\u043D\u0430\u044F \u043A\u0430\u0440\u0442\u0430 \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043A\u0430\u043A \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u043D\u044B\u0439 \u0441\u043F\u043E\u0441\u043E\u0431 \u043E\u043F\u043B\u0430\u0442\u044B.",
          "hostedFieldsFailedTokenizationError": "\u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0432\u0432\u043E\u0434\u0430 \u0434\u0430\u043D\u043D\u044B\u0445 \u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.",
          "hostedFieldsFieldsInvalidError": "\u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0432\u0432\u043E\u0434\u0430 \u0434\u0430\u043D\u043D\u044B\u0445 \u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.",
          "hostedFieldsTokenizationNetworkErrorError": "\u0421\u0431\u043E\u0439 \u0441\u0435\u0442\u0438. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u0421\u0431\u043E\u0439 \u043F\u0440\u0438 \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0435 \u043A\u0440\u0435\u0434\u0438\u0442\u043D\u043E\u0439 \u043A\u0430\u0440\u0442\u044B. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0432\u0432\u043E\u0434\u0430 \u0434\u0430\u043D\u043D\u044B\u0445 \u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.",
          "paypalButtonMustBeUsed": "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u043A\u043D\u043E\u043F\u043A\u0443 PayPal, \u0447\u0442\u043E\u0431\u044B \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C \u043E\u043F\u043B\u0430\u0442\u0443.",
          "venmoButtonMustBeUsed": "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u043A\u043D\u043E\u043F\u043A\u0443 Venmo, \u0447\u0442\u043E\u0431\u044B \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C \u043E\u043F\u043B\u0430\u0442\u0443.",
          "applePayButtonMustBeUsed": "\u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u043A\u043D\u043E\u043F\u043A\u0443 Apple Pay, \u0447\u0442\u043E\u0431\u044B \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C \u043E\u043F\u043B\u0430\u0442\u0443.",
          "paypalAccountTokenizationFailedError": "\u0412\u043E\u0437\u043D\u0438\u043A\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0438\u0438 \u0441\u0447\u0435\u0442\u0430 PayPal. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.",
          "paypalFlowFailedError": "\u0412\u043E\u0437\u043D\u0438\u043A\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0438 \u043A PayPal. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.",
          "paypalTokenizationRequestActiveError": "\u0410\u0432\u0442\u043E\u0440\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u043B\u0430\u0442\u0435\u0436\u0430 \u0447\u0435\u0440\u0435\u0437 PayPal \u0443\u0436\u0435 \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u0442\u0441\u044F.",
          "venmoCanceledError": "\u0412\u043E\u0437\u043D\u0438\u043A\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430. \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E \u043D\u0430 \u0432\u0430\u0448\u0435\u043C \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430 \u0441\u0430\u043C\u0430\u044F \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u044F\u044F \u0432\u0435\u0440\u0441\u0438\u044F \u043F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u044F Venmo \u0438 \u0431\u0440\u0430\u0443\u0437\u0435\u0440 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442 \u043F\u0435\u0440\u0435\u0445\u043E\u0434 \u043D\u0430 Venmo.",
          "vaultManagerPaymentMethodDeletionError": "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0441\u043F\u043E\u0441\u043E\u0431 \u043E\u043F\u043B\u0430\u0442\u044B, \u043F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.",
          "venmoAppFailedError": "\u041F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435 Venmo \u043D\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044F \u043E\u0431\u043D\u0430\u0440\u0443\u0436\u0438\u0442\u044C \u043D\u0430 \u0432\u0430\u0448\u0435\u043C \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432\u0435.",
          "unsupportedCardTypeError": "\u0414\u0430\u043D\u043D\u044B\u0439 \u0442\u0438\u043F \u043A\u0430\u0440\u0442\u044B \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0432\u043E\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0434\u0440\u0443\u0433\u043E\u0439 \u043A\u0430\u0440\u0442\u043E\u0439.",
          "applePayTokenizationError": "\u0412\u043E\u0437\u043D\u0438\u043A\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0442\u0438 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u043F\u043B\u0430\u0442\u0435\u0436\u0430 Apple Pay. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443.",
          "applePayActiveCardError": "\u0414\u043E\u0431\u0430\u0432\u044C\u0442\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043C\u0443\u044E \u043A\u0430\u0440\u0442\u0443 \u0432 \u0432\u0430\u0448 \u0441\u0447\u0435\u0442 Apple Pay.",
          "cardholderNameLabel": "\u0418\u043C\u044F \u0432\u043B\u0430\u0434\u0435\u043B\u044C\u0446\u0430 \u043A\u0430\u0440\u0442\u044B",
          "cardNumberLabel": "\u041D\u043E\u043C\u0435\u0440 \u043A\u0430\u0440\u0442\u044B",
          "cvvLabel": "\u041A\u043E\u0434 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438 \u043A\u0430\u0440\u0442\u044B CVV",
          "cvvThreeDigitLabelSubheading": "(3 \u0446\u0438\u0444\u0440\u044B)",
          "cvvFourDigitLabelSubheading": "(4 \u0446\u0438\u0444\u0440\u044B)",
          "cardholderNamePlaceholder": "\u0418\u043C\u044F \u0432\u043B\u0430\u0434\u0435\u043B\u044C\u0446\u0430 \u043A\u0430\u0440\u0442\u044B",
          "expirationDateLabel": "\u0414\u0430\u0442\u0430 \u043E\u043A\u043E\u043D\u0447\u0430\u043D\u0438\u044F \u0441\u0440\u043E\u043A\u0430 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F",
          "expirationDateLabelSubheading": "(\u041C\u041C/\u0413\u0413)",
          "expirationDatePlaceholder": "\u041C\u041C/\u0413\u0413",
          "postalCodeLabel": "\u0418\u043D\u0434\u0435\u043A\u0441",
          "saveCardLabel": "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043A\u0430\u0440\u0442\u0443",
          "payWithCard": "\u041E\u043F\u043B\u0430\u0442\u0438\u0442\u044C \u0431\u0430\u043D\u043A\u043E\u0432\u0441\u043A\u043E\u0439 \u043A\u0430\u0440\u0442\u043E\u0439",
          "endingIn": "\u0417\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u043D\u0430 {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u041A\u0430\u0440\u0442\u0430",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "\u041F\u043E\u043B\u0435\u0437\u043D\u043E\u0435",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 239: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Sp\xF4sob platby: {{paymentSource}}",
          "chooseAnotherWayToPay": "Vyberte in\xFD sp\xF4sob platby",
          "chooseAWayToPay": "Zvo\u013Ete sp\xF4sob platby",
          "otherWaysToPay": "In\xE9 sp\xF4soby platby",
          "edit": "Upravi\u0165",
          "doneEditing": "Hotovo",
          "editPaymentMethods": "Upravi\u0165 sp\xF4soby platby",
          "CreditCardDeleteConfirmationMessage": "Chcete odstr\xE1ni\u0165 kartu {{secondaryIdentifier}} kon\u010Diacu sa na {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Chcete odstr\xE1ni\u0165 {{identifier}}\xFA\u010Dtu PayPal?",
          "VenmoAccountDeleteConfirmationMessage": "Naozaj chcete odstr\xE1ni\u0165 \xFA\u010Det Venmo s\xA0menom pou\u017E\xEDvate\u013Ea {{identifier}}?",
          "genericDeleteConfirmationMessage": "Ste si ist\xED, \u017Ee chcete tento sp\xF4sob platby odstr\xE1ni\u0165?",
          "deleteCancelButton": "Zru\u0161i\u0165",
          "deleteConfirmationButton": "Odstr\xE1ni\u0165",
          "fieldEmptyForCvv": "Vypl\u0148te k\xF3d CVV.",
          "fieldEmptyForExpirationDate": "Zadajte d\xE1tum skon\u010Denia platnosti.",
          "fieldEmptyForCardholderName": "Zadajte meno majite\u013Ea karty.",
          "fieldTooLongForCardholderName": "Meno majite\u013Ea karty mus\xED obsahova\u0165 menej ako 256\xA0znakov.",
          "fieldEmptyForNumber": "Zadajte \u010D\xEDslo.",
          "fieldEmptyForPostalCode": "Zadajte PS\u010C.",
          "fieldInvalidForCardholderName": "Toto meno majite\u013Ea karty je neplatn\xE9.",
          "fieldInvalidForCvv": "Tento bezpe\u010Dnostn\xFD k\xF3d je neplatn\xFD.",
          "fieldInvalidForExpirationDate": "Tento d\xE1tum skon\u010Denia platnosti je neplatn\xFD.",
          "fieldInvalidForNumber": "Toto \u010D\xEDslo karty je neplatn\xE9.",
          "fieldInvalidForPostalCode": "Toto PS\u010C je neplatn\xE9.",
          "noticeOfCollection": "Zaplaten\xEDm kartou vyjadrujem s\xFAhlas s\xA0Vyhl\xE1sen\xEDm spolo\u010Dnosti PayPal o\xA0ochrane osobn\xFDch \xFAdajov.",
          "genericError": "Vyskytla sa chyba na na\u0161ej strane.",
          "hostedFieldsTokenizationFailOnDuplicateError": "T\xE1to kreditn\xE1 karta u\u017E existuje ako ulo\u017Een\xFD sp\xF4sob platby.",
          "hostedFieldsFailedTokenizationError": "Skontrolujte \xFAdaje a\xA0sk\xFAste to znova.",
          "hostedFieldsFieldsInvalidError": "Skontrolujte \xFAdaje a\xA0sk\xFAste to znova.",
          "hostedFieldsTokenizationNetworkErrorError": "Chyba v\xA0sieti. Sk\xFAste to znova.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Overenie kreditnej karty nebolo \xFAspe\u0161n\xE9. Skontrolujte \xFAdaje a\xA0sk\xFAste to znova.",
          "paypalButtonMustBeUsed": "Ak chcete pokra\u010Dova\u0165 v\xA0platbe, pou\u017Eite tla\u010Didlo PayPal.",
          "venmoButtonMustBeUsed": "Ak chcete pokra\u010Dova\u0165 v platbe, pou\u017Eite tla\u010Didlo Venmo.",
          "applePayButtonMustBeUsed": "Ak chcete pokra\u010Dova\u0165 v platbe, pou\u017Eite tla\u010Didlo Apple Pay.",
          "paypalAccountTokenizationFailedError": "Vyskytla sa chyba pri prid\xE1van\xED \xFA\u010Dtu PayPal. Sk\xFAste to znova.",
          "paypalFlowFailedError": "Vyskytla sa chyba pri prip\xE1jan\xED do \xFA\u010Dtu PayPal. Sk\xFAste to znova.",
          "paypalTokenizationRequestActiveError": "Autoriz\xE1cia platby PayPal u\u017E prebieha.",
          "venmoCanceledError": "Vyskytla sa chyba. Skontrolujte, \u010Di m\xE1te v\xA0zariaden\xED nain\u0161talovan\xFA najnov\u0161iu verziu aplik\xE1cie Venmo a\xA0\u010Di prehliada\u010D podporuje prechod na aplik\xE1ciu Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Nebolo mo\u017En\xE9 odstr\xE1ni\u0165 sp\xF4sob platby, sk\xFAste to znova.",
          "venmoAppFailedError": "Aplik\xE1ciu Venmo sa vo va\u0161om zariaden\xED nepodarilo n\xE1js\u0165.",
          "unsupportedCardTypeError": "Tento typ karty nie je podporovan\xFD. Pros\xEDm sk\xFAste in\xFA kartu.",
          "applePayTokenizationError": "Po\u010Das sprac\xFAvania platby cez Apple Pay do\u0161lo k\xA0chybe siete. Sk\xFAste to znova.",
          "applePayActiveCardError": "Pridajte si podporovan\xFA kartu do pe\u0148a\u017Eenky Apple Pay.",
          "cardholderNameLabel": "Meno majite\u013Ea karty",
          "cardNumberLabel": "\u010C\xEDslo karty",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3\xA0\u010D\xEDslice)",
          "cvvFourDigitLabelSubheading": "(4\xA0\u010D\xEDslice)",
          "cardholderNamePlaceholder": "Meno majite\u013Ea karty",
          "expirationDateLabel": "D\xE1tum skon\u010Denia platnosti",
          "expirationDateLabelSubheading": "(MM/RR)",
          "expirationDatePlaceholder": "MM/RR",
          "postalCodeLabel": "PS\u010C",
          "saveCardLabel": "Ulo\u017Ei\u0165 kartu",
          "payWithCard": "Zaplati\u0165 kartou",
          "endingIn": "Kon\u010D\xED {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Karta",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 240: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "Betalar med {{paymentSource}}",
          "chooseAnotherWayToPay": "V\xE4lj ett annat s\xE4tt att betala",
          "chooseAWayToPay": "V\xE4lj ett s\xE4tt att betala",
          "otherWaysToPay": "Andra s\xE4tt att betala",
          "edit": "\xC4ndra",
          "doneEditing": "Klart",
          "editPaymentMethods": "\xC4ndra betalningsmetoder",
          "CreditCardDeleteConfirmationMessage": "Ta bort {{secondaryIdentifier}}-kortet som slutar p\xE5 {{identifier}}?",
          "PayPalAccountDeleteConfirmationMessage": "Ta bort PayPal-konto {{identifier}}?",
          "VenmoAccountDeleteConfirmationMessage": "\xC4r du s\xE4ker p\xE5 att du vill ta bort Venmo-kontot med anv\xE4ndarnamnet {{identifier}}?",
          "genericDeleteConfirmationMessage": "\xC4r du s\xE4ker p\xE5 att du vill ta bort den h\xE4r betalningsmetoden?",
          "deleteCancelButton": "Avbryt",
          "deleteConfirmationButton": "Ta bort",
          "fieldEmptyForCvv": "Fyll i ett CVV.",
          "fieldEmptyForExpirationDate": "Fyll i ett utg\xE5ngsdatum.",
          "fieldEmptyForCardholderName": "Fyll i kortinnehavarens namn.",
          "fieldTooLongForCardholderName": "Namnet p\xE5 kortinnehavaren m\xE5ste vara kortare \xE4n 256 tecken.",
          "fieldEmptyForNumber": "Fyll i ett nummer.",
          "fieldEmptyForPostalCode": "Fyll i ett postnummer.",
          "fieldInvalidForCardholderName": "Namnet p\xE5 kortinnehavaren \xE4r ogiltigt.",
          "fieldInvalidForCvv": "Den h\xE4r s\xE4kerhetskoden \xE4r inte giltig.",
          "fieldInvalidForExpirationDate": "Utg\xE5ngsdatumet \xE4r ogiltigt.",
          "fieldInvalidForNumber": "Det h\xE4r kortnumret \xE4r ogiltigt.",
          "fieldInvalidForPostalCode": "Postnumret \xE4r ogiltigt.",
          "noticeOfCollection": "Genom att betala med mitt kort godk\xE4nner jag PayPals sekretessmeddelande.",
          "genericError": "Ett fel uppstod.",
          "hostedFieldsTokenizationFailOnDuplicateError": "Det h\xE4r kreditkortet finns redan som en sparad betalningsmetod.",
          "hostedFieldsFailedTokenizationError": "Kontrollera uppgifterna och f\xF6rs\xF6k igen.",
          "hostedFieldsFieldsInvalidError": "Kontrollera uppgifterna och f\xF6rs\xF6k igen.",
          "hostedFieldsTokenizationNetworkErrorError": "N\xE4tverksfel. F\xF6rs\xF6k igen.",
          "hostedFieldsTokenizationCvvVerificationFailedError": "Verifiering av kreditkortet misslyckades. Kontrollera uppgifterna och f\xF6rs\xF6k igen.",
          "paypalButtonMustBeUsed": "Anv\xE4nd PayPal-knappen f\xF6r att forts\xE4tta med din betalning.",
          "venmoButtonMustBeUsed": "Anv\xE4nd Venmo-knappen f\xF6r att forts\xE4tta med din betalning.",
          "applePayButtonMustBeUsed": "Anv\xE4nd PayPal-knappen f\xF6r att forts\xE4tta med din betalning.",
          "paypalAccountTokenizationFailedError": "N\xE5got gick fel n\xE4r du lade till PayPal-kontot. F\xF6rs\xF6k igen.",
          "paypalFlowFailedError": "N\xE5got gick fel med att ansluta till PayPal. F\xF6rs\xF6k igen.",
          "paypalTokenizationRequestActiveError": "Godk\xE4nnande av PayPal-betalning p\xE5g\xE5r redan.",
          "venmoCanceledError": "N\xE5got gick fel. Se till att du har den senaste versionen av Venmo-appen installerad p\xE5 din enhet och att din webbl\xE4sare st\xF6der byte till Venmo.",
          "vaultManagerPaymentMethodDeletionError": "Kan inte ta bort betalningsmetoden, f\xF6rs\xF6k igen.",
          "venmoAppFailedError": "Det gick inte att hitta Venmo-appen p\xE5 din enhet.",
          "unsupportedCardTypeError": "Den h\xE4r korttypen st\xF6ds inte. Prova med ett annat kort.",
          "applePayTokenizationError": "Ett n\xE4tverksfel uppstod n\xE4r Apple Pay-betalningen behandlades. F\xF6rs\xF6k igen.",
          "applePayActiveCardError": "L\xE4gg till ett kort som st\xF6ds i din Apple Pay e-pl\xE5nbok.",
          "cardholderNameLabel": "Kortinnehavarens namn",
          "cardNumberLabel": "Kortnummer",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 siffror)",
          "cvvFourDigitLabelSubheading": "(4 siffror)",
          "cardholderNamePlaceholder": "Kortinnehavarens namn",
          "expirationDateLabel": "Utg\xE5ngsdatum",
          "expirationDateLabelSubheading": "(MM/\xC5\xC5)",
          "expirationDatePlaceholder": "MM/\xC5\xC5",
          "postalCodeLabel": "Postnummer",
          "saveCardLabel": "Spara kort",
          "payWithCard": "Betala med kort",
          "endingIn": "Slutar p\xE5 {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "Kort",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 241: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E14\u0E49\u0E27\u0E22 {{paymentSource}}",
          "chooseAnotherWayToPay": "\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E27\u0E34\u0E18\u0E35\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E2D\u0E37\u0E48\u0E19",
          "chooseAWayToPay": "\u0E42\u0E1B\u0E23\u0E14\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E27\u0E34\u0E18\u0E35\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19",
          "otherWaysToPay": "\u0E27\u0E34\u0E18\u0E35\u0E2D\u0E37\u0E48\u0E19\u0E43\u0E19\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19",
          "edit": "\u0E41\u0E01\u0E49\u0E44\u0E02",
          "doneEditing": "\u0E40\u0E2A\u0E23\u0E47\u0E08\u0E41\u0E25\u0E49\u0E27",
          "editPaymentMethods": "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E27\u0E34\u0E18\u0E35\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19",
          "CreditCardDeleteConfirmationMessage": "\u0E25\u0E1A\u0E1A\u0E31\u0E15\u0E23 {{secondaryIdentifier}} \u0E17\u0E35\u0E48\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 {{identifier}} \u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48",
          "PayPalAccountDeleteConfirmationMessage": "\u0E04\u0E38\u0E13\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E25\u0E1A\u0E1A\u0E31\u0E0D\u0E0A\u0E35 PayPal {{identifier}} \u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48",
          "VenmoAccountDeleteConfirmationMessage": "\u0E04\u0E38\u0E13\u0E41\u0E19\u0E48\u0E43\u0E08\u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48\u0E27\u0E48\u0E32\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E25\u0E1A\u0E1A\u0E31\u0E0D\u0E0A\u0E35 Venmo \u0E17\u0E35\u0E48\u0E21\u0E35\u0E0A\u0E37\u0E48\u0E2D\u0E1C\u0E39\u0E49\u0E43\u0E0A\u0E49 {{identifier}}",
          "genericDeleteConfirmationMessage": "\u0E04\u0E38\u0E13\u0E41\u0E19\u0E48\u0E43\u0E08\u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48\u0E27\u0E48\u0E32\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E25\u0E1A\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E19\u0E35\u0E49\u0E2D\u0E2D\u0E01",
          "deleteCancelButton": "\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01",
          "deleteConfirmationButton": "\u0E25\u0E1A",
          "fieldEmptyForCvv": "\u0E42\u0E1B\u0E23\u0E14\u0E01\u0E23\u0E2D\u0E01\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E43\u0E19\u0E1A\u0E31\u0E15\u0E23 CVV",
          "fieldEmptyForExpirationDate": "\u0E42\u0E1B\u0E23\u0E14\u0E01\u0E23\u0E2D\u0E01\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E21\u0E14\u0E2D\u0E32\u0E22\u0E38",
          "fieldEmptyForCardholderName": "\u0E42\u0E1B\u0E23\u0E14\u0E01\u0E23\u0E2D\u0E01\u0E0A\u0E37\u0E48\u0E2D\u0E1C\u0E39\u0E49\u0E16\u0E37\u0E2D\u0E1A\u0E31\u0E15\u0E23",
          "fieldTooLongForCardholderName": "\u0E0A\u0E37\u0E48\u0E2D\u0E1C\u0E39\u0E49\u0E16\u0E37\u0E2D\u0E1A\u0E31\u0E15\u0E23\u0E15\u0E49\u0E2D\u0E07\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19 256 \u0E2D\u0E31\u0E01\u0E02\u0E23\u0E30",
          "fieldEmptyForNumber": "\u0E42\u0E1B\u0E23\u0E14\u0E01\u0E23\u0E2D\u0E01\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E25\u0E02",
          "fieldEmptyForPostalCode": "\u0E42\u0E1B\u0E23\u0E14\u0E01\u0E23\u0E2D\u0E01\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E43\u0E19\u0E23\u0E2B\u0E31\u0E2A\u0E44\u0E1B\u0E23\u0E29\u0E13\u0E35\u0E22\u0E4C",
          "fieldInvalidForCardholderName": "\u0E0A\u0E37\u0E48\u0E2D\u0E1C\u0E39\u0E49\u0E16\u0E37\u0E2D\u0E1A\u0E31\u0E15\u0E23\u0E19\u0E35\u0E49\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07",
          "fieldInvalidForCvv": "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E27\u0E32\u0E21\u0E1B\u0E25\u0E2D\u0E14\u0E20\u0E31\u0E22\u0E19\u0E35\u0E49\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07",
          "fieldInvalidForExpirationDate": "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E21\u0E14\u0E2D\u0E32\u0E22\u0E38\u0E19\u0E35\u0E49\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07",
          "fieldInvalidForNumber": "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E25\u0E02\u0E1A\u0E31\u0E15\u0E23\u0E19\u0E35\u0E49\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07",
          "fieldInvalidForPostalCode": "\u0E23\u0E2B\u0E31\u0E2A\u0E44\u0E1B\u0E23\u0E29\u0E13\u0E35\u0E22\u0E4C\u0E19\u0E35\u0E49\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07",
          "noticeOfCollection": "\u0E01\u0E32\u0E23\u0E0A\u0E4D\u0E32\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E14\u0E49\u0E27\u0E22\u0E1A\u0E31\u0E15\u0E23\u0E19\u0E35\u0E49\u0E16\u0E37\u0E2D\u0E27\u0E48\u0E32\u0E02\u0E49\u0E32\u0E1E\u0E40\u0E08\u0E49\u0E32\u0E22\u0E2D\u0E21\u0E23\u0E31\u0E1A\u0E19\u0E42\u0E22\u0E1A\u0E32\u0E22\u0E04\u0E27\u0E32\u0E21\u0E40\u0E1B\u0E47\u0E19\u0E2A\u0E48\u0E27\u0E19\u0E15\u0E31\u0E27\u0E02\u0E2D\u0E07 PayPal",
          "genericError": "\u0E40\u0E01\u0E34\u0E14\u0E02\u0E49\u0E2D\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E02\u0E36\u0E49\u0E19\u0E43\u0E19\u0E23\u0E30\u0E1A\u0E1A\u0E02\u0E2D\u0E07\u0E40\u0E23\u0E32",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u0E1A\u0E31\u0E15\u0E23\u0E40\u0E04\u0E23\u0E14\u0E34\u0E15\u0E19\u0E35\u0E49\u0E40\u0E1B\u0E47\u0E19\u0E27\u0E34\u0E18\u0E35\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E17\u0E35\u0E48\u0E1A\u0E31\u0E19\u0E17\u0E36\u0E01\u0E44\u0E27\u0E49\u0E41\u0E25\u0E49\u0E27",
          "hostedFieldsFailedTokenizationError": "\u0E42\u0E1B\u0E23\u0E14\u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E02\u0E2D\u0E07\u0E04\u0E38\u0E13 \u0E41\u0E25\u0E49\u0E27\u0E25\u0E2D\u0E07\u0E43\u0E2B\u0E21\u0E48\u0E2D\u0E35\u0E01\u0E04\u0E23\u0E31\u0E49\u0E07",
          "hostedFieldsFieldsInvalidError": "\u0E42\u0E1B\u0E23\u0E14\u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E02\u0E2D\u0E07\u0E04\u0E38\u0E13 \u0E41\u0E25\u0E49\u0E27\u0E25\u0E2D\u0E07\u0E43\u0E2B\u0E21\u0E48\u0E2D\u0E35\u0E01\u0E04\u0E23\u0E31\u0E49\u0E07",
          "hostedFieldsTokenizationNetworkErrorError": "\u0E02\u0E49\u0E2D\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E02\u0E2D\u0E07\u0E40\u0E04\u0E23\u0E37\u0E2D\u0E02\u0E48\u0E32\u0E22 \u0E42\u0E1B\u0E23\u0E14\u0E25\u0E2D\u0E07\u0E2D\u0E35\u0E01\u0E04\u0E23\u0E31\u0E49\u0E07",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u0E01\u0E32\u0E23\u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E1A\u0E31\u0E15\u0E23\u0E40\u0E04\u0E23\u0E14\u0E34\u0E15\u0E44\u0E21\u0E48\u0E2A\u0E33\u0E40\u0E23\u0E47\u0E08 \u0E42\u0E1B\u0E23\u0E14\u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E02\u0E2D\u0E07\u0E04\u0E38\u0E13 \u0E41\u0E25\u0E49\u0E27\u0E25\u0E2D\u0E07\u0E43\u0E2B\u0E21\u0E48\u0E2D\u0E35\u0E01\u0E04\u0E23\u0E31\u0E49\u0E07",
          "paypalButtonMustBeUsed": "\u0E43\u0E0A\u0E49\u0E1B\u0E38\u0E48\u0E21 PayPal \u0E40\u0E1E\u0E37\u0E48\u0E2D\u0E14\u0E33\u0E40\u0E19\u0E34\u0E19\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E15\u0E48\u0E2D\u0E44\u0E1B",
          "venmoButtonMustBeUsed": "\u0E43\u0E0A\u0E49\u0E1B\u0E38\u0E48\u0E21 Venmo \u0E40\u0E1E\u0E37\u0E48\u0E2D\u0E14\u0E4D\u0E32\u0E40\u0E19\u0E34\u0E19\u0E01\u0E32\u0E23\u0E0A\u0E4D\u0E32\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E15\u0E48\u0E2D\u0E44\u0E1B",
          "applePayButtonMustBeUsed": "\u0E43\u0E0A\u0E49\u0E1B\u0E38\u0E48\u0E21 Apple Pay \u0E40\u0E1E\u0E37\u0E48\u0E2D\u0E14\u0E33\u0E40\u0E19\u0E34\u0E19\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E15\u0E48\u0E2D\u0E44\u0E1B.",
          "paypalAccountTokenizationFailedError": "\u0E40\u0E01\u0E34\u0E14\u0E02\u0E49\u0E2D\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E1A\u0E32\u0E07\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E43\u0E19\u0E01\u0E32\u0E23\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E1A\u0E31\u0E0D\u0E0A\u0E35 PayPal \u0E42\u0E1B\u0E23\u0E14\u0E25\u0E2D\u0E07\u0E2D\u0E35\u0E01\u0E04\u0E23\u0E31\u0E49\u0E07",
          "paypalFlowFailedError": "\u0E40\u0E01\u0E34\u0E14\u0E02\u0E49\u0E2D\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E43\u0E19\u0E01\u0E32\u0E23\u0E40\u0E0A\u0E37\u0E48\u0E2D\u0E21\u0E15\u0E48\u0E2D\u0E01\u0E31\u0E1A PayPal \u0E42\u0E1B\u0E23\u0E14\u0E25\u0E2D\u0E07\u0E2D\u0E35\u0E01\u0E04\u0E23\u0E31\u0E49\u0E07",
          "paypalTokenizationRequestActiveError": "\u0E01\u0E32\u0E23\u0E2D\u0E19\u0E38\u0E21\u0E31\u0E15\u0E34\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19 PayPal \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E14\u0E33\u0E40\u0E19\u0E34\u0E19\u0E01\u0E32\u0E23\u0E41\u0E25\u0E49\u0E27",
          "venmoCanceledError": "\u0E40\u0E01\u0E34\u0E14\u0E02\u0E49\u0E2D\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E1A\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E01\u0E32\u0E23 \u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E43\u0E2B\u0E49\u0E41\u0E19\u0E48\u0E43\u0E08\u0E27\u0E48\u0E32\u0E04\u0E38\u0E13\u0E21\u0E35\u0E41\u0E2D\u0E1B\u0E1E\u0E25\u0E34\u0E40\u0E04\u0E0A\u0E31\u0E19 Venmo \u0E40\u0E27\u0E2D\u0E23\u0E4C\u0E0A\u0E31\u0E19\u0E25\u0E48\u0E32\u0E2A\u0E38\u0E14\u0E17\u0E35\u0E48\u0E15\u0E34\u0E14\u0E15\u0E31\u0E49\u0E07\u0E44\u0E27\u0E49\u0E43\u0E19\u0E2D\u0E38\u0E1B\u0E01\u0E23\u0E13\u0E4C\u0E02\u0E2D\u0E07\u0E04\u0E38\u0E13\u0E41\u0E25\u0E30\u0E40\u0E1A\u0E23\u0E32\u0E27\u0E4C\u0E40\u0E0B\u0E2D\u0E23\u0E4C\u0E02\u0E2D\u0E07\u0E04\u0E38\u0E13\u0E23\u0E2D\u0E07\u0E23\u0E31\u0E1A\u0E01\u0E32\u0E23\u0E40\u0E1B\u0E25\u0E35\u0E48\u0E22\u0E19\u0E40\u0E1B\u0E47\u0E19 Venmo",
          "vaultManagerPaymentMethodDeletionError": "\u0E44\u0E21\u0E48\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E25\u0E1A\u0E27\u0E34\u0E18\u0E35\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E44\u0E14\u0E49\u0E42\u0E1B\u0E23\u0E14\u0E25\u0E2D\u0E07\u0E2D\u0E35\u0E01\u0E04\u0E23\u0E31\u0E49\u0E07",
          "venmoAppFailedError": "\u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E41\u0E2D\u0E1B Venmo \u0E43\u0E19\u0E2D\u0E38\u0E1B\u0E01\u0E23\u0E13\u0E4C\u0E02\u0E2D\u0E07\u0E04\u0E38\u0E13",
          "unsupportedCardTypeError": "\u0E44\u0E21\u0E48\u0E23\u0E2D\u0E07\u0E23\u0E31\u0E1A\u0E1A\u0E31\u0E15\u0E23\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E19\u0E35\u0E49 \u0E42\u0E1B\u0E23\u0E14\u0E25\u0E2D\u0E07\u0E43\u0E0A\u0E49\u0E1A\u0E31\u0E15\u0E23\u0E43\u0E1A\u0E2D\u0E37\u0E48\u0E19",
          "applePayTokenizationError": "\u0E40\u0E01\u0E34\u0E14\u0E02\u0E49\u0E2D\u0E1C\u0E34\u0E14\u0E1E\u0E25\u0E32\u0E14\u0E43\u0E19\u0E40\u0E04\u0E23\u0E37\u0E2D\u0E02\u0E48\u0E32\u0E22\u0E02\u0E13\u0E30\u0E1B\u0E23\u0E30\u0E21\u0E27\u0E25\u0E1C\u0E25\u0E01\u0E32\u0E23\u0E0A\u0E33\u0E23\u0E30\u0E40\u0E07\u0E34\u0E19\u0E02\u0E2D\u0E07 Apple Pay \u0E42\u0E1B\u0E23\u0E14\u0E25\u0E2D\u0E07\u0E2D\u0E35\u0E01\u0E04\u0E23\u0E31\u0E49\u0E07",
          "applePayActiveCardError": "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E1A\u0E31\u0E15\u0E23\u0E17\u0E35\u0E48\u0E23\u0E2D\u0E07\u0E23\u0E31\u0E1A\u0E44\u0E1B\u0E22\u0E31\u0E07\u0E01\u0E23\u0E30\u0E40\u0E1B\u0E4B\u0E32\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C Apple Pay \u0E02\u0E2D\u0E07\u0E04\u0E38\u0E13",
          "cardholderNameLabel": "\u0E0A\u0E37\u0E48\u0E2D\u0E02\u0E2D\u0E07\u0E1C\u0E39\u0E49\u0E16\u0E37\u0E2D\u0E1A\u0E31\u0E15\u0E23",
          "cardNumberLabel": "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E25\u0E02\u0E1A\u0E31\u0E15\u0E23",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "(3 \u0E2B\u0E25\u0E31\u0E01)",
          "cvvFourDigitLabelSubheading": "(4 \u0E2B\u0E25\u0E31\u0E01)",
          "cardholderNamePlaceholder": "\u0E0A\u0E37\u0E48\u0E2D\u0E02\u0E2D\u0E07\u0E1C\u0E39\u0E49\u0E16\u0E37\u0E2D\u0E1A\u0E31\u0E15\u0E23",
          "expirationDateLabel": "\u0E27\u0E31\u0E19\u0E2B\u0E21\u0E14\u0E2D\u0E32\u0E22\u0E38",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "MM/YY",
          "postalCodeLabel": "\u0E23\u0E2B\u0E31\u0E2A\u0E44\u0E1B\u0E23\u0E29\u0E13\u0E35\u0E22\u0E4C",
          "saveCardLabel": "\u0E1A\u0E31\u0E19\u0E17\u0E36\u0E01\u0E1A\u0E31\u0E15\u0E23",
          "payWithCard": "\u0E0A\u0E33\u0E23\u0E30\u0E14\u0E49\u0E27\u0E22\u0E1A\u0E31\u0E15\u0E23\u0E40\u0E14\u0E1A\u0E34\u0E15\u0E2B\u0E23\u0E37\u0E2D\u0E1A\u0E31\u0E15\u0E23\u0E40\u0E04\u0E23\u0E14\u0E34\u0E15",
          "endingIn": "\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u0E1A\u0E31\u0E15\u0E23",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 242: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u4F7F\u7528{{paymentSource}}\u4ED8\u6B3E",
          "chooseAnotherWayToPay": "\u8BF7\u9009\u62E9\u5176\u5B83\u4ED8\u6B3E\u65B9\u5F0F\u3002",
          "chooseAWayToPay": "\u9009\u62E9\u4ED8\u6B3E\u65B9\u5F0F",
          "otherWaysToPay": "\u5176\u4ED6\u4ED8\u6B3E\u65B9\u5F0F",
          "edit": "\u7F16\u8F91",
          "doneEditing": "\u5B8C\u6210",
          "editPaymentMethods": "\u7F16\u8F91\u4ED8\u6B3E\u65B9\u5F0F",
          "CreditCardDeleteConfirmationMessage": "\u5220\u9664\u5C3E\u53F7\u4E3A{{identifier}}\u7684{{secondaryIdentifier}}\u5361\uFF1F",
          "PayPalAccountDeleteConfirmationMessage": "\u5220\u9664PayPal\u8D26\u6237{{identifier}}\uFF1F",
          "VenmoAccountDeleteConfirmationMessage": "\u60A8\u786E\u5B9A\u8981\u5220\u9664\u7528\u6237\u540D\u4E3A{{identifier}}\u7684Venmo\u8D26\u6237\u5417\uFF1F",
          "genericDeleteConfirmationMessage": "\u786E\u5B9A\u8981\u5220\u9664\u6B64\u4ED8\u6B3E\u65B9\u5F0F\u5417\uFF1F",
          "deleteCancelButton": "\u53D6\u6D88",
          "deleteConfirmationButton": "\u5220\u9664",
          "fieldEmptyForCvv": "\u8BF7\u586B\u5199CVV\u3002",
          "fieldEmptyForExpirationDate": "\u8BF7\u586B\u5199\u6709\u6548\u671F\u9650\u3002",
          "fieldEmptyForCardholderName": "\u8BF7\u586B\u5199\u6301\u5361\u4EBA\u59D3\u540D\u3002",
          "fieldTooLongForCardholderName": "\u6301\u5361\u4EBA\u59D3\u540D\u5FC5\u987B\u5C11\u4E8E256\u4E2A\u5B57\u7B26\u3002",
          "fieldEmptyForNumber": "\u8BF7\u586B\u5199\u4E00\u4E2A\u53F7\u7801\u3002",
          "fieldEmptyForPostalCode": "\u8BF7\u586B\u5199\u90AE\u653F\u7F16\u7801\u3002",
          "fieldInvalidForCardholderName": "\u6B64\u6301\u5361\u4EBA\u59D3\u540D\u65E0\u6548\u3002",
          "fieldInvalidForCvv": "\u6B64\u5B89\u5168\u7801\u65E0\u6548\u3002",
          "fieldInvalidForExpirationDate": "\u6B64\u6709\u6548\u671F\u9650\u65E0\u6548\u3002",
          "fieldInvalidForNumber": "\u6B64\u5361\u53F7\u65E0\u6548\u3002",
          "fieldInvalidForPostalCode": "\u6B64\u90AE\u653F\u7F16\u7801\u65E0\u6548\u3002",
          "noticeOfCollection": "\u4F7F\u7528\u6211\u7684\u5361\u4ED8\u6B3E\u5373\u8868\u793A\u6211\u540C\u610FPayPal\u9690\u79C1\u58F0\u660E\u3002",
          "genericError": "\u6211\u4EEC\u9047\u5230\u4E86\u4E00\u4E9B\u95EE\u9898\u3002",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u6B64\u4FE1\u7528\u5361\u5DF2\u5B58\u5728\u4E8E\u5DF2\u4FDD\u5B58\u7684\u4ED8\u6B3E\u65B9\u5F0F\u3002",
          "hostedFieldsFailedTokenizationError": "\u8BF7\u68C0\u67E5\u60A8\u7684\u4FE1\u606F\uFF0C\u7136\u540E\u91CD\u8BD5\u3002",
          "hostedFieldsFieldsInvalidError": "\u8BF7\u68C0\u67E5\u60A8\u7684\u4FE1\u606F\uFF0C\u7136\u540E\u91CD\u8BD5\u3002",
          "hostedFieldsTokenizationNetworkErrorError": "\u7F51\u7EDC\u9519\u8BEF\u3002\u8BF7\u91CD\u8BD5\u3002",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u4FE1\u7528\u5361\u9A8C\u8BC1\u5931\u8D25\u3002\u8BF7\u68C0\u67E5\u60A8\u7684\u4FE1\u606F\uFF0C\u7136\u540E\u91CD\u8BD5\u3002",
          "paypalButtonMustBeUsed": "\u4F7F\u7528PayPal\u6309\u94AE\u7EE7\u7EED\u4ED8\u6B3E\u3002",
          "venmoButtonMustBeUsed": "\u4F7F\u7528Venmo\u6309\u94AE\u7EE7\u7EED\u4ED8\u6B3E\u3002",
          "applePayButtonMustBeUsed": "\u4F7F\u7528Apple Pay\u6309\u94AE\u4EE5\u4FBF\u7EE7\u7EED\u8FDB\u884C\u60A8\u7684\u4ED8\u6B3E\u3002",
          "paypalAccountTokenizationFailedError": "\u6DFB\u52A0PayPal\u8D26\u6237\u65F6\u9047\u5230\u4E86\u4E00\u4E9B\u95EE\u9898\u3002\u8BF7\u91CD\u8BD5\u3002",
          "paypalFlowFailedError": "\u8FDE\u63A5\u5230PayPal\u9047\u5230\u4E86\u4E00\u4E9B\u95EE\u9898\u3002\u8BF7\u91CD\u8BD5\u3002",
          "paypalTokenizationRequestActiveError": "PayPal\u4ED8\u6B3E\u6388\u6743\u5DF2\u5728\u5904\u7406\u4E2D\u3002",
          "venmoCanceledError": "\u9047\u5230\u4E86\u4E00\u4E9B\u95EE\u9898\u3002\u8BF7\u786E\u4FDD\u60A8\u7684\u8BBE\u5907\u4E0A\u5B89\u88C5\u4E86\u6700\u65B0\u7248\u672C\u7684Venmo\u5E94\u7528\uFF0C\u5E76\u4E14\u60A8\u7684\u6D4F\u89C8\u5668\u652F\u6301\u5207\u6362\u5230Venmo\u3002",
          "vaultManagerPaymentMethodDeletionError": "\u65E0\u6CD5\u5220\u9664\u4ED8\u6B3E\u65B9\u5F0F\uFF0C\u8BF7\u91CD\u8BD5\u3002",
          "venmoAppFailedError": "\u5728\u60A8\u7684\u8BBE\u5907\u4E0A\u627E\u4E0D\u5230Venmo\u5E94\u7528\u7A0B\u5E8F\u3002",
          "unsupportedCardTypeError": "\u4E0D\u652F\u6301\u8BE5\u5361\u7C7B\u578B\u3002\u8BF7\u5C1D\u8BD5\u5176\u4ED6\u5361\u3002",
          "applePayTokenizationError": "\u5904\u7406Apple Pay\u4ED8\u6B3E\u65F6\u53D1\u751F\u4E86\u7F51\u7EDC\u9519\u8BEF\u3002\u8BF7\u91CD\u8BD5\u3002",
          "applePayActiveCardError": "\u5728\u60A8\u7684Apple Pay\u94B1\u5305\u4E2D\u6DFB\u52A0\u4E00\u5F20\u53D7\u652F\u6301\u7684\u5361\u3002",
          "cardholderNameLabel": "\u6301\u5361\u4EBA\u59D3\u540D",
          "cardNumberLabel": "\u5361\u53F7",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "\uFF083\u4F4D\u6570\uFF09",
          "cvvFourDigitLabelSubheading": "\uFF084\u4F4D\u6570\uFF09",
          "cardholderNamePlaceholder": "\u6301\u5361\u4EBA\u59D3\u540D",
          "expirationDateLabel": "\u6709\u6548\u671F\u9650",
          "expirationDateLabelSubheading": "\uFF08\u6708/\u5E74\uFF09",
          "expirationDatePlaceholder": "\u6708/\u5E74",
          "postalCodeLabel": "\u90AE\u653F\u7F16\u7801",
          "saveCardLabel": "\u4FDD\u5B58\u6B64\u5361",
          "payWithCard": "\u4F7F\u7528\u5361\u652F\u4ED8",
          "endingIn": "\u5C3E\u53F7\u4E3A{{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u5361",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "\u53D1\u73B0",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "\u94F6\u8054"
        };
      }, {}], 243: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u4ED8\u6B3E\u65B9\u5F0F\u70BA {{paymentSource}}",
          "chooseAnotherWayToPay": "\u8ACB\u9078\u64C7\u5176\u4ED6\u4ED8\u6B3E\u65B9\u5F0F",
          "chooseAWayToPay": "\u9078\u64C7\u4ED8\u6B3E\u65B9\u5F0F",
          "otherWaysToPay": "\u5176\u4ED6\u4ED8\u6B3E\u65B9\u5F0F",
          "edit": "\u7DE8\u8F2F",
          "doneEditing": "\u5B8C\u6210",
          "editPaymentMethods": "\u7DE8\u8F2F\u4ED8\u6B3E\u65B9\u5F0F",
          "CreditCardDeleteConfirmationMessage": "\u522A\u9664\u6700\u5F8C\u6578\u5B57\u70BA {{identifier}} \u7684 {{secondaryIdentifier}} \u5361\u55CE\uFF1F",
          "PayPalAccountDeleteConfirmationMessage": "\u522A\u9664 {{identifier}} PayPal \u5E33\u6236\u55CE\uFF1F",
          "VenmoAccountDeleteConfirmationMessage": "\u78BA\u5B9A\u8981\u522A\u9664\u7528\u6236\u540D\u7A31\u70BA {{identifier}} \u7684 Venmo \u5E33\u6236\u55CE\uFF1F",
          "genericDeleteConfirmationMessage": "\u78BA\u5B9A\u8981\u522A\u9664\u6B64\u4ED8\u6B3E\u65B9\u5F0F\u55CE\uFF1F",
          "deleteCancelButton": "\u53D6\u6D88",
          "deleteConfirmationButton": "\u522A\u9664",
          "fieldEmptyForCvv": "\u8ACB\u586B\u5BEB\u4FE1\u7528\u5361\u8A8D\u8B49\u78BC\uFF08CVV\uFF09\u3002",
          "fieldEmptyForExpirationDate": "\u8ACB\u586B\u5BEB\u5230\u671F\u65E5\u3002",
          "fieldEmptyForCardholderName": "\u8ACB\u586B\u5BEB\u6301\u5361\u4EBA\u59D3\u540D\u3002",
          "fieldTooLongForCardholderName": "\u6301\u5361\u4EBA\u59D3\u540D\u5FC5\u9808\u5C11\u65BC 256 \u500B\u5B57\u5143\u3002",
          "fieldEmptyForNumber": "\u8ACB\u586B\u5BEB\u6578\u5B57\u3002",
          "fieldEmptyForPostalCode": "\u8ACB\u586B\u5BEB\u90F5\u905E\u5340\u865F\u3002",
          "fieldInvalidForCardholderName": "\u6301\u5361\u4EBA\u59D3\u540D\u7121\u6548\u3002",
          "fieldInvalidForCvv": "\u6B64\u5B89\u5168\u4EE3\u78BC\u7121\u6548\u3002",
          "fieldInvalidForExpirationDate": "\u6B64\u5230\u671F\u65E5\u7121\u6548\u3002",
          "fieldInvalidForNumber": "\u6B64\u5361\u865F\u7121\u6548\u3002",
          "fieldInvalidForPostalCode": "\u90F5\u905E\u5340\u865F\u7121\u6548\u3002",
          "noticeOfCollection": "\u4E00\u7D93\u4F7F\u7528\u4FE1\u7528\u5361\u4ED8\u6B3E\uFF0C\u5373\u8868\u793A\u6211\u540C\u610F PayPal \u7684\u300A\u79C1\u96B1\u6B0A\u8072\u660E\u300B\u3002",
          "genericError": "\u7CFB\u7D71\u767C\u751F\u932F\u8AA4\u3002",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u6B64\u4FE1\u7528\u5361\u70BA\u5DF2\u5132\u5B58\u7684\u4ED8\u6B3E\u65B9\u5F0F\u3002",
          "hostedFieldsFailedTokenizationError": "\u8ACB\u6AA2\u67E5\u4F60\u7684\u8CC7\u6599\uFF0C\u7136\u5F8C\u91CD\u8A66\u3002",
          "hostedFieldsFieldsInvalidError": "\u8ACB\u6AA2\u67E5\u4F60\u7684\u8CC7\u6599\uFF0C\u7136\u5F8C\u91CD\u8A66\u3002",
          "hostedFieldsTokenizationNetworkErrorError": "\u7DB2\u7D61\u932F\u8AA4\u3002\u8ACB\u518D\u8A66\u4E00\u6B21\u3002",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u4FE1\u7528\u5361\u8A8D\u8B49\u5931\u6557\u3002\u8ACB\u6AA2\u67E5\u4F60\u7684\u8CC7\u6599\uFF0C\u7136\u5F8C\u91CD\u8A66\u3002",
          "paypalButtonMustBeUsed": "\u4F7F\u7528\u300CPayPal \u6309\u9215\u300D\u7E7C\u7E8C\u4ED8\u6B3E\u3002",
          "venmoButtonMustBeUsed": "\u4F7F\u7528 Venmo \u6309\u9215\u4EE5\u7E7C\u7E8C\u4ED8\u6B3E\u3002",
          "applePayButtonMustBeUsed": "\u4F7F\u7528 Apple Pay \u6309\u9215\u7E7C\u7E8C\u4ED8\u6B3E\u3002",
          "paypalAccountTokenizationFailedError": "\u65B0\u589E PayPal \u5E33\u6236\u51FA\u73FE\u554F\u984C\uFF0C\u8ACB\u518D\u8A66\u4E00\u6B21\u3002",
          "paypalFlowFailedError": "\u9023\u63A5\u81F3 PayPal \u51FA\u73FE\u554F\u984C\uFF0C\u8ACB\u518D\u8A66\u4E00\u6B21\u3002",
          "paypalTokenizationRequestActiveError": "\u6B63\u5728\u8655\u7406 PayPal \u6388\u6B0A\u4ED8\u6B3E\u3002",
          "venmoCanceledError": "\u7CFB\u7D71\u51FA\u73FE\u932F\u8AA4\uFF0C\u8ACB\u78BA\u4FDD\u88DD\u7F6E\u5DF2\u5B89\u88DD\u6700\u65B0\u7248\u672C\u7684 Venmo \u61C9\u7528\u7A0B\u5F0F\uFF0C\u53CA\u700F\u89BD\u5668\u652F\u63F4\u5207\u63DB\u81F3 Venmo\u3002",
          "vaultManagerPaymentMethodDeletionError": "\u7121\u6CD5\u522A\u9664\u4ED8\u6B3E\u65B9\u5F0F\uFF0C\u8ACB\u518D\u8A66\u4E00\u6B21\u3002",
          "venmoAppFailedError": "\u7121\u6CD5\u5728\u88DD\u7F6E\u4E0A\u627E\u5230 Venmo \u61C9\u7528\u7A0B\u5F0F\u3002",
          "unsupportedCardTypeError": "\u4E0D\u652F\u63F4\u6B64\u5361\u985E\u578B\u3002\u8ACB\u6539\u7528\u5176\u4ED6\u4FE1\u7528\u5361\u3002",
          "applePayTokenizationError": "\u8655\u7406 Apple Pay \u4ED8\u6B3E\u6642\u7DB2\u8DEF\u767C\u751F\u932F\u8AA4\u3002\u8ACB\u518D\u8A66\u4E00\u6B21\u3002",
          "applePayActiveCardError": "\u65B0\u589E\u53EF\u7528\u7684\u4FE1\u7528\u5361\u5230 Apple Pay \u9322\u5305\u3002",
          "cardholderNameLabel": "\u6301\u5361\u4EBA\u59D3\u540D",
          "cardNumberLabel": "\u5361\u865F",
          "cvvLabel": "CVV",
          "cvvThreeDigitLabelSubheading": "\uFF083 \u4F4D\u6578\uFF09",
          "cvvFourDigitLabelSubheading": "\uFF084 \u4F4D\u6578\uFF09",
          "cardholderNamePlaceholder": "\u6301\u5361\u4EBA\u59D3\u540D",
          "expirationDateLabel": "\u5230\u671F\u65E5",
          "expirationDateLabelSubheading": "(MM/YY)",
          "expirationDatePlaceholder": "MM/YY",
          "postalCodeLabel": "\u90F5\u905E\u5340\u865F",
          "saveCardLabel": "\u5132\u5B58\u5361",
          "payWithCard": "\u4F7F\u7528\u6263\u5E33\u5361\u6216\u4FE1\u7528\u5361\u4ED8\u6B3E",
          "endingIn": "\u6700\u5F8C\u6578\u5B57\u70BA {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u4FE1\u7528\u5361",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "Discover",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "UnionPay"
        };
      }, {}], 244: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u4F7F\u7528 {{paymentSource}} \u4ED8\u6B3E",
          "chooseAnotherWayToPay": "\u9078\u64C7\u5176\u4ED6\u4ED8\u6B3E\u65B9\u5F0F",
          "chooseAWayToPay": "\u9078\u64C7\u4ED8\u6B3E\u65B9\u5F0F",
          "otherWaysToPay": "\u5176\u4ED6\u4ED8\u6B3E\u65B9\u5F0F",
          "edit": "\u7DE8\u8F2F",
          "doneEditing": "\u5B8C\u6210",
          "editPaymentMethods": "\u7DE8\u8F2F\u4ED8\u6B3E\u65B9\u5F0F",
          "CreditCardDeleteConfirmationMessage": "\u522A\u9664\u672B\u78BC\u70BA {{identifier}} \u7684 {{secondaryIdentifier}} \u5361\u7247\uFF1F",
          "PayPalAccountDeleteConfirmationMessage": "\u522A\u9664 {{identifier}} \u7684 PayPal \u5E33\u6236\uFF1F",
          "VenmoAccountDeleteConfirmationMessage": "\u78BA\u5B9A\u8981\u522A\u9664\u7528\u6236\u540D\u7A31\u70BA {{identifier}} \u7684 Venmo \u5E33\u6236\uFF1F",
          "genericDeleteConfirmationMessage": "\u78BA\u5B9A\u8981\u522A\u9664\u6B64\u4ED8\u6B3E\u65B9\u5F0F\uFF1F",
          "deleteCancelButton": "\u53D6\u6D88",
          "deleteConfirmationButton": "\u522A\u9664",
          "fieldEmptyForCvv": "\u586B\u5BEB\u4FE1\u7528\u5361\u9A57\u8B49\u78BC\u3002",
          "fieldEmptyForExpirationDate": "\u586B\u5BEB\u5230\u671F\u65E5\u3002",
          "fieldEmptyForCardholderName": "\u586B\u5BEB\u6301\u5361\u4EBA\u59D3\u540D\u3002",
          "fieldTooLongForCardholderName": "\u6301\u5361\u4EBA\u59D3\u540D\u5FC5\u9808\u5C11\u65BC 256 \u500B\u5B57\u5143\u3002",
          "fieldEmptyForNumber": "\u586B\u5BEB\u6578\u5B57\u3002",
          "fieldEmptyForPostalCode": "\u586B\u5BEB\u90F5\u905E\u5340\u865F\u3002",
          "fieldInvalidForCardholderName": "\u6B64\u6301\u5361\u4EBA\u59D3\u540D\u7121\u6548\u3002",
          "fieldInvalidForCvv": "\u6B64\u5B89\u5168\u4EE3\u78BC\u7121\u6548\u3002",
          "fieldInvalidForExpirationDate": "\u6B64\u5230\u671F\u65E5\u7121\u6548\u3002",
          "fieldInvalidForNumber": "\u6B64\u5361\u865F\u7121\u6548\u3002",
          "fieldInvalidForPostalCode": "\u6B64\u90F5\u905E\u5340\u865F\u7121\u6548\u3002",
          "noticeOfCollection": "\u4F7F\u7528\u6211\u7684\u5361\u7247\u4ED8\u6B3E\uFF0C\u5373\u8868\u793A\u6211\u540C\u610F\u300CPayPal \u96B1\u79C1\u6B0A\u8072\u660E\u300D\u3002",
          "genericError": "\u6211\u5011\u7684\u7CFB\u7D71\u767C\u751F\u554F\u984C\u3002",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u6B64\u4FE1\u7528\u5361\u5DF2\u7D93\u662F\u5132\u5B58\u7684\u4ED8\u6B3E\u65B9\u5F0F\u3002",
          "hostedFieldsFailedTokenizationError": "\u8ACB\u6AA2\u67E5\u4F60\u7684\u8CC7\u6599\u4E26\u91CD\u8A66\u3002",
          "hostedFieldsFieldsInvalidError": "\u8ACB\u6AA2\u67E5\u4F60\u7684\u8CC7\u6599\u4E26\u91CD\u8A66\u3002",
          "hostedFieldsTokenizationNetworkErrorError": "\u7DB2\u8DEF\u932F\u8AA4\u3002\u8ACB\u91CD\u8A66\u3002",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u4FE1\u7528\u5361\u8A8D\u8B49\u5931\u6557\u3002\u8ACB\u6AA2\u67E5\u4F60\u7684\u8CC7\u6599\u4E26\u91CD\u8A66\u3002",
          "paypalButtonMustBeUsed": "\u4F7F\u7528 PayPal \u6309\u9215\u7E7C\u7E8C\u4ED8\u6B3E\u3002",
          "venmoButtonMustBeUsed": "\u4F7F\u7528 Venmo \u6309\u9215\u7E7C\u7E8C\u4ED8\u6B3E\u3002",
          "applePayButtonMustBeUsed": "\u4F7F\u7528 PayPal \u6309\u9215\u7E7C\u7E8C\u4ED8\u6B3E\u3002",
          "paypalAccountTokenizationFailedError": "\u65B0\u589E PayPal \u5E33\u6236\u6642\u767C\u751F\u932F\u8AA4\u3002\u8ACB\u91CD\u8A66\u3002",
          "paypalFlowFailedError": "\u9023\u7D50\u81F3 PayPal \u6642\u767C\u751F\u932F\u8AA4\u3002\u8ACB\u91CD\u8A66\u3002",
          "paypalTokenizationRequestActiveError": "PayPal \u4ED8\u6B3E\u6388\u6B0A\u5DF2\u5728\u9032\u884C\u4E2D\u3002",
          "venmoCanceledError": "\u7CFB\u7D71\u767C\u751F\u932F\u8AA4\u3002\u78BA\u4FDD\u4F60\u5728\u88DD\u7F6E\u4E0A\u5B89\u88DD\u4E86\u6700\u65B0\u7248\u672C\u7684 Venmo \u61C9\u7528\u7A0B\u5F0F\uFF0C\u4E14\u700F\u89BD\u5668\u652F\u63F4\u8F49\u63DB\u81F3 Venmo\u3002",
          "vaultManagerPaymentMethodDeletionError": "\u7121\u6CD5\u522A\u9664\u4ED8\u6B3E\u65B9\u5F0F\uFF0C\u8ACB\u91CD\u8A66\u3002",
          "venmoAppFailedError": "\u4F60\u7684\u88DD\u7F6E\u4E0A\u627E\u4E0D\u5230 Venmo \u61C9\u7528\u7A0B\u5F0F\u3002",
          "unsupportedCardTypeError": "\u4E0D\u652F\u63F4\u6B64\u5361\u7247\u985E\u578B\uFF0C\u8ACB\u6539\u7528\u5176\u4ED6\u5361\u7247\u3002",
          "applePayTokenizationError": "\u8655\u7406 Apple Pay \u4ED8\u6B3E\u6642\u767C\u751F\u7DB2\u8DEF\u9023\u7DDA\u932F\u8AA4\u3002\u8ACB\u91CD\u8A66\u3002",
          "applePayActiveCardError": "\u5C07\u652F\u63F4\u5361\u7247\u65B0\u589E\u81F3\u4F60\u7684 Apple Pay \u9322\u5305\u3002",
          "cardholderNameLabel": "\u6301\u5361\u4EBA\u59D3\u540D",
          "cardNumberLabel": "\u5361\u865F",
          "cvvLabel": "\u4FE1\u7528\u5361\u9A57\u8B49\u78BC",
          "cvvThreeDigitLabelSubheading": "\uFF083 \u4F4D\u6578\uFF09",
          "cvvFourDigitLabelSubheading": "\uFF084 \u4F4D\u6578\uFF09",
          "cardholderNamePlaceholder": "\u6301\u5361\u4EBA\u59D3\u540D",
          "expirationDateLabel": "\u5230\u671F\u65E5",
          "expirationDateLabelSubheading": "\uFF08\u6708 / \u5E74\uFF09",
          "expirationDatePlaceholder": "\u6708 / \u5E74",
          "postalCodeLabel": "\u90F5\u905E\u5340\u865F",
          "saveCardLabel": "\u5132\u5B58\u5361\u7247",
          "payWithCard": "\u4F7F\u7528\u5361\u7247\u4ED8\u6B3E",
          "endingIn": "\u672B\u78BC\u70BA {{lastFourCardDigits}}",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u5361\u7247",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "\u7F8E\u570B\u904B\u901A",
          "Discover": "\u767C\u73FE\u5361",
          "Diners Club": "\u5927\u4F86\u5361",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "\u9280\u806F"
        };
      }, {}], 245: [function(require2, module2, exports2) {
        module2.exports = {
          "payingWith": "\u4F7F\u7528{{paymentSource}}\u4ED8\u6B3E",
          "chooseAnotherWayToPay": "\u9009\u62E9\u5176\u4ED6\u4ED8\u6B3E\u65B9\u5F0F",
          "chooseAWayToPay": "\u9009\u62E9\u4ED8\u6B3E\u65B9\u5F0F",
          "otherWaysToPay": "\u5176\u4ED6\u4ED8\u6B3E\u65B9\u5F0F",
          "edit": "\u7F16\u8F91",
          "doneEditing": "\u5B8C\u6210",
          "editPaymentMethods": "\u7F16\u8F91\u4ED8\u6B3E\u65B9\u5F0F",
          "CreditCardDeleteConfirmationMessage": "\u5220\u9664\u4EE5{{identifier}}}\u7ED3\u5C3E\u7684{{secondaryIdentifier}}}\u5361\uFF1F",
          "PayPalAccountDeleteConfirmationMessage": "\u5220\u9664PayPal\u8D26\u6237{{identifier}}}\uFF1F",
          "VenmoAccountDeleteConfirmationMessage": "\u786E\u5B9A\u8981\u5220\u9664\u7528\u6237\u540D\u4E3A{{identifier}}}\u7684Venmo\u8D26\u6237\u5417\uFF1F",
          "genericDeleteConfirmationMessage": "\u786E\u5B9A\u8981\u5220\u9664\u6B64\u4ED8\u6B3E\u65B9\u5F0F\u5417\uFF1F",
          "deleteCancelButton": "\u53D6\u6D88",
          "deleteConfirmationButton": "\u5220\u9664",
          "fieldEmptyForCvv": "\u8BF7\u586B\u5199\u5361\u6821\u9A8C\u503C\u3002",
          "fieldEmptyForExpirationDate": "\u8BF7\u586B\u5199\u6709\u6548\u671F\u9650\u3002",
          "fieldEmptyForCardholderName": "\u8BF7\u586B\u5199\u6301\u5361\u4EBA\u59D3\u540D\u3002",
          "fieldTooLongForCardholderName": "\u6301\u5361\u4EBA\u59D3\u540D\u5FC5\u987B\u5C11\u4E8E256\u4E2A\u5B57\u7B26\u3002",
          "fieldEmptyForNumber": "\u8BF7\u586B\u5199\u53F7\u7801\u3002",
          "fieldEmptyForPostalCode": "\u8BF7\u586B\u5199\u90AE\u653F\u7F16\u7801\u3002",
          "fieldInvalidForCardholderName": "\u6B64\u6301\u5361\u4EBA\u59D3\u540D\u65E0\u6548\u3002",
          "fieldInvalidForCvv": "\u6B64\u9A8C\u8BC1\u7801\u65E0\u6548\u3002",
          "fieldInvalidForExpirationDate": "\u6B64\u6709\u6548\u671F\u9650\u65E0\u6548\u3002",
          "fieldInvalidForNumber": "\u6B64\u5361\u53F7\u65E0\u6548\u3002",
          "fieldInvalidForPostalCode": "\u6B64\u90AE\u653F\u7F16\u7801\u65E0\u6548\u3002",
          "noticeOfCollection": "\u4F7F\u7528\u6211\u7684\u5361\u4ED8\u6B3E\u5373\u8868\u793A\u6211\u540C\u610FPayPal\u9690\u79C1\u58F0\u660E\u3002",
          "genericError": "\u6211\u4EEC\u9047\u5230\u4E86\u4E00\u4E9B\u95EE\u9898\u3002",
          "hostedFieldsTokenizationFailOnDuplicateError": "\u6B64\u4FE1\u7528\u5361\u5DF2\u5B58\u5728\u4E8E\u5DF2\u4FDD\u5B58\u7684\u4ED8\u6B3E\u65B9\u5F0F\u4E2D\u3002",
          "hostedFieldsFailedTokenizationError": "\u8BF7\u68C0\u67E5\u60A8\u7684\u4FE1\u606F\uFF0C\u7136\u540E\u91CD\u8BD5\u3002",
          "hostedFieldsFieldsInvalidError": "\u8BF7\u68C0\u67E5\u60A8\u7684\u4FE1\u606F\uFF0C\u7136\u540E\u91CD\u8BD5\u3002",
          "hostedFieldsTokenizationNetworkErrorError": "\u7F51\u7EDC\u9519\u8BEF\u3002\u8BF7\u91CD\u8BD5\u3002",
          "hostedFieldsTokenizationCvvVerificationFailedError": "\u4FE1\u7528\u5361\u8BA4\u8BC1\u5931\u8D25\u3002\u8BF7\u68C0\u67E5\u60A8\u7684\u4FE1\u606F\uFF0C\u7136\u540E\u91CD\u8BD5\u3002",
          "paypalButtonMustBeUsed": "\u4F7F\u7528PayPal\u6309\u94AE\u4EE5\u4FBF\u7EE7\u7EED\u8FDB\u884C\u60A8\u7684\u4ED8\u6B3E\u3002",
          "venmoButtonMustBeUsed": "\u4F7F\u7528Venmo\u6309\u94AE\u7EE7\u7EED\u4ED8\u6B3E\u3002",
          "applePayButtonMustBeUsed": "\u4F7F\u7528Apple Pay\u6309\u94AE\u4EE5\u4FBF\u7EE7\u7EED\u8FDB\u884C\u60A8\u7684\u4ED8\u6B3E\u3002",
          "paypalAccountTokenizationFailedError": "\u6DFB\u52A0PayPal\u8D26\u6237\u65F6\u9047\u5230\u4E86\u95EE\u9898\u3002\u8BF7\u91CD\u8BD5\u3002",
          "paypalFlowFailedError": "\u8FDE\u63A5\u5230PayPal\u65F6\u9047\u5230\u4E86\u95EE\u9898\u3002\u8BF7\u91CD\u8BD5\u3002",
          "paypalTokenizationRequestActiveError": "PayPal\u4ED8\u6B3E\u6388\u6743\u6B63\u5728\u5904\u7406\u4E2D\u3002",
          "venmoCanceledError": "\u9047\u5230\u4E86\u4E00\u4E9B\u95EE\u9898\u3002\u8BF7\u786E\u4FDD\u60A8\u7684\u8BBE\u5907\u4E0A\u5B89\u88C5\u4E86\u6700\u65B0\u7248\u672C\u7684Venmo\u5E94\u7528\uFF0C\u5E76\u4E14\u60A8\u7684\u6D4F\u89C8\u5668\u652F\u6301\u5207\u6362\u5230Venmo\u3002",
          "vaultManagerPaymentMethodDeletionError": "\u65E0\u6CD5\u5220\u9664\u4ED8\u6B3E\u65B9\u5F0F\uFF0C\u8BF7\u91CD\u8BD5\u3002",
          "venmoAppFailedError": "\u672A\u80FD\u5728\u60A8\u7684\u8BBE\u5907\u4E0A\u627E\u5230Venmo\u5E94\u7528\u3002",
          "unsupportedCardTypeError": "\u4E0D\u652F\u6301\u8BE5\u5361\u7C7B\u578B\u3002\u8BF7\u5C1D\u8BD5\u5176\u5B83\u5361\u3002",
          "applePayTokenizationError": "\u5904\u7406Apple Pay\u4ED8\u6B3E\u65F6\u51FA\u73B0\u4E86\u7F51\u7EDC\u9519\u8BEF\u3002\u8BF7\u91CD\u8BD5\u3002",
          "applePayActiveCardError": "\u5728\u60A8\u7684Apple Pay\u94B1\u5305\u4E2D\u6DFB\u52A0\u4E00\u5F20\u53D7\u652F\u6301\u7684\u5361\u3002",
          "cardholderNameLabel": "\u6301\u5361\u4EBA\u59D3\u540D",
          "cardNumberLabel": "\u5361\u53F7",
          "cvvLabel": "\u5361\u6821\u9A8C\u503C",
          "cvvThreeDigitLabelSubheading": "\uFF083\u4F4D\u6570\uFF09",
          "cvvFourDigitLabelSubheading": "\uFF084\u4F4D\u6570\uFF09",
          "cardholderNamePlaceholder": "\u6301\u5361\u4EBA\u59D3\u540D",
          "expirationDateLabel": "\u6709\u6548\u671F\u9650",
          "expirationDateLabelSubheading": "\uFF08\u6708/\u5E74\uFF09",
          "expirationDatePlaceholder": "\u6708/\u5E74",
          "postalCodeLabel": "\u90AE\u653F\u7F16\u7801",
          "saveCardLabel": "\u4FDD\u5B58\u5361",
          "payWithCard": "\u4F7F\u7528\u5361\u652F\u4ED8",
          "endingIn": "\u4EE5{{lastFourCardDigits}}}\u7ED3\u5C3E",
          "Apple Pay": "Apple Pay",
          "Venmo": "Venmo",
          "Card": "\u5361",
          "PayPal": "PayPal",
          "PayPal Credit": "PayPal Credit",
          "Google Pay": "Google Pay",
          "American Express": "American Express",
          "Discover": "\u53D1\u73B0",
          "Diners Club": "Diners Club",
          "Elo": "Elo",
          "Hiper": "Hiper",
          "Hipercard": "Hipercard",
          "MasterCard": "Mastercard",
          "Visa": "Visa",
          "JCB": "JCB",
          "Maestro": "Maestro",
          "UnionPay": "\u94F6\u8054"
        };
      }, {}], 246: [function(require2, module2, exports2) {
        var assign2 = require2("../lib/assign").assign;
        var DropinError = require2("../lib/dropin-error");
        var errors = require2("../constants").errors;
        function BaseView(options) {
          options = options || {};
          assign2(this, options);
        }
        BaseView.prototype.getElementById = function(id) {
          if (!this.element) {
            return null;
          }
          return this.element.querySelector('[data-braintree-id="' + id + '"]');
        };
        BaseView.prototype.requestPaymentMethod = function() {
          return Promise.reject(new DropinError(errors.NO_PAYMENT_METHOD_ERROR));
        };
        BaseView.prototype.getPaymentMethod = function() {
          return this.activeMethodView && this.activeMethodView.paymentMethod;
        };
        BaseView.prototype.onSelection = function() {
        };
        BaseView.prototype.teardown = function() {
          return Promise.resolve();
        };
        BaseView.prototype.preventUserAction = function() {
          if (this.element) {
            this.element.classList.add("braintree-sheet--loading");
          }
          this.model.preventUserAction();
        };
        BaseView.prototype.allowUserAction = function() {
          if (this.element) {
            this.element.classList.remove("braintree-sheet--loading");
          }
          this.model.allowUserAction();
        };
        module2.exports = BaseView;
      }, { "../constants": 189, "../lib/assign": 195, "../lib/dropin-error": 199 }], 247: [function(require2, module2, exports2) {
        var BaseView = require2("./base-view");
        var addSelectionEventHandler = require2("../lib/add-selection-event-handler");
        var paymentMethodTypes = require2("../constants").paymentMethodTypes;
        function DeleteConfirmationView() {
          BaseView.apply(this, arguments);
          this._initialize();
        }
        DeleteConfirmationView.prototype = Object.create(BaseView.prototype);
        DeleteConfirmationView.prototype.constructor = DeleteConfirmationView;
        DeleteConfirmationView.ID = DeleteConfirmationView.prototype.ID = "delete-confirmation";
        DeleteConfirmationView.prototype._initialize = function() {
          this._yesButton = this.getElementById("delete-confirmation__yes");
          this._noButton = this.getElementById("delete-confirmation__no");
          this._messageBox = this.getElementById("delete-confirmation__message");
          addSelectionEventHandler(this._yesButton, function() {
            this.model.deleteVaultedPaymentMethod();
          }.bind(this));
          addSelectionEventHandler(this._noButton, function() {
            this.model.cancelDeleteVaultedPaymentMethod();
          }.bind(this));
        };
        DeleteConfirmationView.prototype.applyPaymentMethod = function(paymentMethod) {
          var identifier, secondaryIdentifier;
          var messageText = this.strings[paymentMethod.type + "DeleteConfirmationMessage"];
          if (messageText) {
            switch (paymentMethod.type) {
              case paymentMethodTypes.card:
                identifier = paymentMethod.details.lastFour;
                secondaryIdentifier = paymentMethod.details.cardType;
                secondaryIdentifier = this.strings[secondaryIdentifier] || secondaryIdentifier;
                break;
              case paymentMethodTypes.paypal:
                identifier = paymentMethod.details.email;
                break;
              case paymentMethodTypes.venmo:
                identifier = paymentMethod.details.username;
                break;
            }
            messageText = messageText.replace("{{identifier}}", identifier);
            if (secondaryIdentifier) {
              messageText = messageText.replace("{{secondaryIdentifier}}", secondaryIdentifier);
            }
          } else {
            messageText = this.strings.genericDeleteConfirmationMessage;
          }
          this._messageBox.innerText = messageText;
        };
        DeleteConfirmationView.prototype.onSelection = function() {
          window.requestAnimationFrame(function() {
            this._yesButton.focus();
          }.bind(this));
        };
        module2.exports = DeleteConfirmationView;
      }, { "../constants": 189, "../lib/add-selection-event-handler": 193, "./base-view": 246 }], 248: [function(require2, module2, exports2) {
        var analytics = require2("../lib/analytics");
        var analyticsKinds = require2("../constants").analyticsKinds;
        var BaseView = require2("./base-view");
        var sheetViews = require2("./payment-sheet-views");
        var PaymentMethodsView = require2("./payment-methods-view");
        var PaymentOptionsView = require2("./payment-options-view");
        var DeleteConfirmationView = require2("./delete-confirmation-view");
        var addSelectionEventHandler = require2("../lib/add-selection-event-handler");
        var wait = require2("../lib/wait");
        var supportsFlexbox = require2("../lib/supports-flexbox");
        var CHANGE_ACTIVE_PAYMENT_METHOD_TIMEOUT = require2("../constants").CHANGE_ACTIVE_PAYMENT_METHOD_TIMEOUT;
        var DEVELOPER_MISCONFIGURATION_MESSAGE = require2("../constants").errors.DEVELOPER_MISCONFIGURATION_MESSAGE;
        function MainView() {
          BaseView.apply(this, arguments);
          this.dependenciesInitializing = 0;
          this._initialize();
        }
        MainView.prototype = Object.create(BaseView.prototype);
        MainView.prototype.constructor = MainView;
        MainView.prototype._initialize = function() {
          var paymentOptionsView;
          this._hasMultiplePaymentOptions = this.model.supportedPaymentOptions.length > 1;
          this._views = {};
          this.sheetContainer = this.getElementById("sheet-container");
          this.sheetErrorText = this.getElementById("sheet-error-text");
          this.toggle = this.getElementById("toggle");
          this.disableWrapper = this.getElementById("disable-wrapper");
          this.lowerContainer = this.getElementById("lower-container");
          this.loadingContainer = this.getElementById("loading-container");
          this.dropinContainer = this.element.querySelector(".braintree-dropin");
          this.supportsFlexbox = supportsFlexbox();
          this.model.on("asyncDependenciesReady", this.hideLoadingIndicator.bind(this));
          this.model.on("errorOccurred", this.showSheetError.bind(this));
          this.model.on("errorCleared", this.hideSheetError.bind(this));
          this.model.on("preventUserAction", this.preventUserAction.bind(this));
          this.model.on("allowUserAction", this.allowUserAction.bind(this));
          this.paymentSheetViewIDs = Object.keys(sheetViews).reduce(function(ids, sheetViewKey) {
            var PaymentSheetView, paymentSheetView;
            if (this.model.supportedPaymentOptions.indexOf(sheetViewKey) !== -1) {
              PaymentSheetView = sheetViews[sheetViewKey];
              paymentSheetView = new PaymentSheetView({
                element: this.getElementById(PaymentSheetView.ID),
                mainView: this,
                model: this.model,
                client: this.client,
                strings: this.strings
              });
              paymentSheetView.initialize();
              this.addView(paymentSheetView);
              ids.push(paymentSheetView.ID);
            }
            return ids;
          }.bind(this), []);
          this.paymentMethodsViews = new PaymentMethodsView({
            element: this.element,
            model: this.model,
            client: this.client,
            strings: this.strings
          });
          this.addView(this.paymentMethodsViews);
          this.deleteConfirmationView = new DeleteConfirmationView({
            element: this.getElementById("delete-confirmation"),
            model: this.model,
            strings: this.strings
          });
          this.addView(this.deleteConfirmationView);
          addSelectionEventHandler(this.toggle, this.toggleAdditionalOptions.bind(this));
          this.model.on("changeActivePaymentMethod", function() {
            wait.delay(CHANGE_ACTIVE_PAYMENT_METHOD_TIMEOUT).then(function() {
              var id = PaymentMethodsView.ID;
              if (!this.model.hasPaymentMethods()) {
                id = this.model.getInitialViewId();
              }
              this.setPrimaryView(id);
            }.bind(this));
          }.bind(this));
          this.model.on("changeActiveView", this._onChangeActiveView.bind(this));
          this.model.on("removeActivePaymentMethod", function() {
            var activePaymentView = this.getView(this.model.getActivePaymentViewId());
            if (activePaymentView && typeof activePaymentView.removeActivePaymentMethod === "function") {
              activePaymentView.removeActivePaymentMethod();
            }
          }.bind(this));
          this.model.on("enableEditMode", this.enableEditMode.bind(this));
          this.model.on("disableEditMode", this.disableEditMode.bind(this));
          this.model.on("confirmPaymentMethodDeletion", this.openConfirmPaymentMethodDeletionDialog.bind(this));
          this.model.on("cancelVaultedPaymentMethodDeletion", this.cancelVaultedPaymentMethodDeletion.bind(this));
          this.model.on("startVaultedPaymentMethodDeletion", this.startVaultedPaymentMethodDeletion.bind(this));
          this.model.on("finishVaultedPaymentMethodDeletion", this.finishVaultedPaymentMethodDeletion.bind(this));
          if (this._hasMultiplePaymentOptions) {
            paymentOptionsView = new PaymentOptionsView({
              client: this.client,
              element: this.getElementById(PaymentOptionsView.ID),
              mainView: this,
              model: this.model,
              strings: this.strings
            });
            this.addView(paymentOptionsView);
          }
          this._sendToDefaultView();
        };
        MainView.prototype._onChangeActiveView = function(data2) {
          var id = data2.newViewId;
          var activePaymentView = this.getView(id);
          if (id === PaymentMethodsView.ID) {
            this.paymentMethodsViews.container.classList.add("braintree-methods--active");
            this.sheetContainer.classList.remove("braintree-sheet--active");
          } else {
            wait.delay(0).then(function() {
              this.sheetContainer.classList.add("braintree-sheet--active");
            }.bind(this));
            this.paymentMethodsViews.container.classList.remove("braintree-methods--active");
            if (!this.getView(id).getPaymentMethod()) {
              this.model.setPaymentMethodRequestable({
                isRequestable: false
              });
            }
          }
          activePaymentView.onSelection();
        };
        MainView.prototype.addView = function(view) {
          this._views[view.ID] = view;
        };
        MainView.prototype.getView = function(id) {
          return this._views[id];
        };
        MainView.prototype.setPrimaryView = function(id, secondaryViewId) {
          var paymentMethod;
          wait.delay(0).then(function() {
            this.element.className = prefixShowClass(id);
            if (secondaryViewId) {
              this.element.classList.add(prefixShowClass(secondaryViewId));
            }
          }.bind(this));
          this.primaryView = this.getView(id);
          this.model.changeActiveView(id);
          if (this.paymentSheetViewIDs.indexOf(id) !== -1) {
            if (this.model.getPaymentMethods().length > 0 || this.getView(PaymentOptionsView.ID)) {
              this.showToggle();
            } else {
              this.hideToggle();
            }
          } else if (id === PaymentMethodsView.ID) {
            this.showToggle();
            this.getElementById("lower-container").appendChild(this.getElementById("options"));
          } else if (id === PaymentOptionsView.ID) {
            this.hideToggle();
          }
          if (!this.supportsFlexbox) {
            this.element.setAttribute("data-braintree-no-flexbox", true);
          }
          paymentMethod = this.primaryView.getPaymentMethod();
          this.model.setPaymentMethodRequestable({
            isRequestable: Boolean(paymentMethod && !this.model.isInEditMode()),
            type: paymentMethod && paymentMethod.type,
            selectedPaymentMethod: paymentMethod
          });
          this.model.clearError();
        };
        MainView.prototype.requestPaymentMethod = function() {
          var activePaymentView = this.getView(this.model.getActivePaymentViewId());
          return activePaymentView.requestPaymentMethod().then(function(payload) {
            analytics.sendEvent(this.client, "request-payment-method." + analyticsKinds[payload.type]);
            return payload;
          }.bind(this)).catch(function(err) {
            analytics.sendEvent(this.client, "request-payment-method.error");
            return Promise.reject(err);
          }.bind(this));
        };
        MainView.prototype.hideLoadingIndicator = function() {
          this.dropinContainer.classList.remove("braintree-loading");
          this.dropinContainer.classList.add("braintree-loaded");
          this.loadingContainer.classList.add("braintree-hidden");
        };
        MainView.prototype.showLoadingIndicator = function() {
          this.dropinContainer.classList.add("braintree-loading");
          this.dropinContainer.classList.remove("braintree-loaded");
          this.loadingContainer.classList.remove("braintree-hidden");
        };
        MainView.prototype.toggleAdditionalOptions = function() {
          var sheetViewID;
          var isPaymentSheetView = this.paymentSheetViewIDs.indexOf(this.primaryView.ID) !== -1;
          this.hideToggle();
          if (!this._hasMultiplePaymentOptions) {
            sheetViewID = this.paymentSheetViewIDs[0];
            this.element.classList.add(prefixShowClass(sheetViewID));
            this.model.changeActiveView(sheetViewID);
          } else if (isPaymentSheetView) {
            if (this.model.getPaymentMethods().length === 0) {
              this.setPrimaryView(PaymentOptionsView.ID);
            } else {
              this.setPrimaryView(PaymentMethodsView.ID, PaymentOptionsView.ID);
              this.hideToggle();
            }
          } else {
            this.element.classList.add(prefixShowClass(PaymentOptionsView.ID));
          }
        };
        MainView.prototype.showToggle = function() {
          if (this.model.isInEditMode()) {
            return;
          }
          this.toggle.classList.remove("braintree-hidden");
          this.lowerContainer.classList.add("braintree-hidden");
        };
        MainView.prototype.hideToggle = function() {
          this.toggle.classList.add("braintree-hidden");
          this.lowerContainer.classList.remove("braintree-hidden");
        };
        MainView.prototype.showSheetError = function(error) {
          var errorMessage;
          var genericErrorMessage = this.strings.genericError;
          if (this.strings.hasOwnProperty(error)) {
            errorMessage = this.strings[error];
          } else if (error && typeof error.code === "string") {
            errorMessage = this.strings[snakeCaseToCamelCase(error.code) + "Error"] || genericErrorMessage;
          } else if (error === "developerError") {
            errorMessage = DEVELOPER_MISCONFIGURATION_MESSAGE;
          } else {
            errorMessage = genericErrorMessage;
          }
          this.dropinContainer.classList.add("braintree-sheet--has-error");
          this.sheetErrorText.innerHTML = errorMessage;
        };
        MainView.prototype.hideSheetError = function() {
          this.dropinContainer.classList.remove("braintree-sheet--has-error");
        };
        MainView.prototype.getOptionsElements = function() {
          return this._views.options.elements;
        };
        MainView.prototype.preventUserAction = function() {
          this.disableWrapper.classList.remove("braintree-hidden");
        };
        MainView.prototype.allowUserAction = function() {
          this.disableWrapper.classList.add("braintree-hidden");
        };
        MainView.prototype.teardown = function() {
          var error;
          var viewNames = Object.keys(this._views);
          var teardownPromises = viewNames.map(function(view) {
            return this._views[view].teardown().catch(function(err) {
              error = err;
            });
          }.bind(this));
          return Promise.all(teardownPromises).then(function() {
            if (error) {
              return Promise.reject(error);
            }
            return Promise.resolve();
          });
        };
        MainView.prototype.enableEditMode = function() {
          this.setPrimaryView(this.paymentMethodsViews.ID);
          this.paymentMethodsViews.enableEditMode();
          this.hideToggle();
          this.model.setPaymentMethodRequestable({
            isRequestable: false
          });
        };
        MainView.prototype.disableEditMode = function() {
          var paymentMethod;
          this.hideSheetError();
          this.paymentMethodsViews.disableEditMode();
          this.showToggle();
          paymentMethod = this.primaryView.getPaymentMethod();
          this.model.setPaymentMethodRequestable({
            isRequestable: Boolean(paymentMethod),
            type: paymentMethod && paymentMethod.type,
            selectedPaymentMethod: paymentMethod
          });
        };
        MainView.prototype.openConfirmPaymentMethodDeletionDialog = function(paymentMethod) {
          this.deleteConfirmationView.applyPaymentMethod(paymentMethod);
          this.setPrimaryView(this.deleteConfirmationView.ID);
        };
        MainView.prototype.cancelVaultedPaymentMethodDeletion = function() {
          this.setPrimaryView(this.paymentMethodsViews.ID);
        };
        MainView.prototype.startVaultedPaymentMethodDeletion = function() {
          this.element.className = "";
          this.showLoadingIndicator();
        };
        MainView.prototype.finishVaultedPaymentMethodDeletion = function(error) {
          var self2 = this;
          this.paymentMethodsViews.refreshPaymentMethods();
          if (error && this.model.getPaymentMethods().length > 0) {
            this.model.enableEditMode();
            this.showSheetError("vaultManagerPaymentMethodDeletionError");
          } else {
            this._sendToDefaultView();
          }
          return new Promise(function(resolve2) {
            wait.delay(500).then(function() {
              self2.hideLoadingIndicator();
              resolve2();
            });
          });
        };
        MainView.prototype._sendToDefaultView = function() {
          var paymentMethods2 = this.model.getPaymentMethods();
          var preselectVaultedPaymentMethod = this.model.merchantConfiguration.preselectVaultedPaymentMethod !== false;
          if (paymentMethods2.length > 0) {
            if (preselectVaultedPaymentMethod) {
              analytics.sendEvent(this.client, "vaulted-card.preselect");
              this.model.changeActivePaymentMethod(paymentMethods2[0]);
            } else {
              this.setPrimaryView(this.paymentMethodsViews.ID);
            }
          } else if (this._hasMultiplePaymentOptions) {
            this.setPrimaryView(PaymentOptionsView.ID);
          } else {
            this.setPrimaryView(this.paymentSheetViewIDs[0]);
          }
        };
        function snakeCaseToCamelCase(s) {
          return s.toLowerCase().replace(/(\_\w)/g, function(m) {
            return m[1].toUpperCase();
          });
        }
        function prefixShowClass(classname) {
          return "braintree-show-" + classname;
        }
        module2.exports = MainView;
      }, { "../constants": 189, "../lib/add-selection-event-handler": 193, "../lib/analytics": 194, "../lib/supports-flexbox": 207, "../lib/wait": 210, "./base-view": 246, "./delete-confirmation-view": 247, "./payment-methods-view": 250, "./payment-options-view": 251, "./payment-sheet-views": 256 }], 249: [function(require2, module2, exports2) {
        var analytics = require2("../lib/analytics");
        var BaseView = require2("./base-view");
        var constants = require2("../constants");
        var addSelectionEventHandler = require2("../lib/add-selection-event-handler");
        var paymentMethodHTML = '<div class="braintree-method__icon-container braintree-method__delete-container">\n  <div class="braintree-method__icon braintree-method__delete">\n    <svg width="48" height="29">\n      <use xlink:href="#iconX"></use>\n    </svg>\n  </div>\n</div>\n\n<div class="braintree-method__logo">\n  <svg width="40" height="24" class="@CLASSNAME">\n    <use xlink:href="#@ICON"></use>\n  </svg>\n</div>\n\n<div class="braintree-method__label">@TITLE<br><div class="braintree-method__label--small">@SUBTITLE</div></div>\n\n<div class="braintree-method__icon-container braintree-method__check-container">\n  <div class="braintree-method__icon braintree-method__check">\n    <svg height="100%" width="100%">\n      <use xlink:href="#iconCheck"></use>\n    </svg>\n  </div>\n</div>\n';
        function PaymentMethodView() {
          BaseView.apply(this, arguments);
          this._initialize();
        }
        PaymentMethodView.prototype = Object.create(BaseView.prototype);
        PaymentMethodView.prototype.constructor = PaymentMethodView;
        PaymentMethodView.prototype._initialize = function() {
          var endingInText;
          var html2 = paymentMethodHTML;
          var paymentMethodCardTypes = constants.paymentMethodCardTypes;
          var paymentMethodTypes = constants.paymentMethodTypes;
          this.element = document.createElement("div");
          this.element.className = "braintree-method";
          this.element.setAttribute("tabindex", "0");
          this.element.setAttribute("role", "button");
          addSelectionEventHandler(this.element, function() {
            if (this.model.isInEditMode()) {
              this._selectDelete();
            } else {
              this._choosePaymentMethod();
            }
          }.bind(this));
          switch (this.paymentMethod.type) {
            case paymentMethodTypes.applePay:
              html2 = html2.replace(/@ICON/g, "logoApplePay").replace(/@CLASSNAME/g, "").replace(/@TITLE/g, this.strings["Apple Pay"]).replace(/@SUBTITLE/g, "");
              break;
            case paymentMethodTypes.card:
              endingInText = this.strings.endingIn.replace("{{lastFourCardDigits}}", this.paymentMethod.details.lastFour);
              html2 = html2.replace(/@ICON/g, "icon-" + paymentMethodCardTypes[this.paymentMethod.details.cardType]).replace(/@CLASSNAME/g, " braintree-icon--bordered").replace(/@TITLE/g, endingInText).replace(/@SUBTITLE/g, this.strings[this.paymentMethod.details.cardType]);
              break;
            case paymentMethodTypes.googlePay:
              html2 = html2.replace(/@ICON/g, "logoGooglePay").replace(/@CLASSNAME/g, "").replace(/@TITLE/g, this.strings["Google Pay"]).replace(/@SUBTITLE/g, "");
              break;
            case paymentMethodTypes.paypal:
              html2 = html2.replace(/@ICON/g, "logoPayPal").replace(/@CLASSNAME/g, "").replace(/@TITLE/g, this.paymentMethod.details.email).replace(/@SUBTITLE/g, this.strings.PayPal);
              break;
            case paymentMethodTypes.venmo:
              html2 = html2.replace(/@ICON/g, "logoVenmo").replace(/@CLASSNAME/g, "").replace(/@TITLE/g, this.paymentMethod.details.username).replace(/@SUBTITLE/g, this.strings.Venmo);
              break;
          }
          this.element.innerHTML = html2;
          this.checkMark = this.element.querySelector(".braintree-method__check-container");
        };
        PaymentMethodView.prototype.setActive = function(isActive) {
          setTimeout(function() {
            this.element.classList.toggle("braintree-method--active", isActive);
          }.bind(this), 0);
        };
        PaymentMethodView.prototype.enableEditMode = function() {
          this.checkMark.classList.add("braintree-hidden");
          if (this.paymentMethod.hasSubscription) {
            this.element.classList.add("braintree-method--disabled");
          }
        };
        PaymentMethodView.prototype.disableEditMode = function() {
          this.checkMark.classList.remove("braintree-hidden");
          this.element.classList.remove("braintree-method--disabled");
        };
        PaymentMethodView.prototype.teardown = function() {
          if (this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
          }
        };
        PaymentMethodView.prototype._choosePaymentMethod = function() {
          if (this.paymentMethod.vaulted) {
            analytics.sendEvent(this.client, "vaulted-" + constants.analyticsKinds[this.paymentMethod.type] + ".select");
          }
          this.model.changeActivePaymentMethod(this.paymentMethod);
        };
        PaymentMethodView.prototype._selectDelete = function() {
          this.model.confirmPaymentMethodDeletion(this.paymentMethod);
        };
        module2.exports = PaymentMethodView;
      }, { "../constants": 189, "../lib/add-selection-event-handler": 193, "../lib/analytics": 194, "./base-view": 246 }], 250: [function(require2, module2, exports2) {
        var BaseView = require2("./base-view");
        var PaymentMethodView = require2("./payment-method-view");
        var DropinError = require2("../lib/dropin-error");
        var errors = require2("../constants").errors;
        var addSelectionEventHandler = require2("../lib/add-selection-event-handler");
        var PAYMENT_METHOD_TYPE_TO_TRANSLATION_STRING = {
          CreditCard: "Card",
          PayPalAccount: "PayPal",
          ApplePayCard: "Apple Pay",
          AndroidPayCard: "Google Pay",
          VenmoAccount: "Venmo"
        };
        function PaymentMethodsView() {
          BaseView.apply(this, arguments);
          this._initialize();
        }
        PaymentMethodsView.prototype = Object.create(BaseView.prototype);
        PaymentMethodsView.prototype.constructor = PaymentMethodsView;
        PaymentMethodsView.ID = PaymentMethodsView.prototype.ID = "methods";
        PaymentMethodsView.prototype._initialize = function() {
          this.views = [];
          this.container = this.getElementById("methods-container");
          this._headingLabel = this.getElementById("methods-label");
          this._editButton = this.getElementById("methods-edit");
          this.model.on("addPaymentMethod", this._addPaymentMethod.bind(this));
          this.model.on("changeActivePaymentMethod", this._changeActivePaymentMethodView.bind(this));
          this.model.on("refreshPaymentMethods", this.refreshPaymentMethods.bind(this));
          this.refreshPaymentMethods();
          if (this.model.merchantConfiguration.vaultManager) {
            this.model.on("removePaymentMethod", this._removePaymentMethod.bind(this));
            addSelectionEventHandler(this._editButton, function() {
              if (this.model.isInEditMode()) {
                this.model.disableEditMode();
              } else {
                this.model.enableEditMode();
              }
            }.bind(this));
            this._editButton.classList.remove("braintree-hidden");
          }
        };
        PaymentMethodsView.prototype.removeActivePaymentMethod = function() {
          if (!this.activeMethodView) {
            return;
          }
          this.activeMethodView.setActive(false);
          this.activeMethodView = null;
          this._headingLabel.classList.add("braintree-no-payment-method-selected");
        };
        PaymentMethodsView.prototype._getPaymentMethodString = function() {
          var stringKey, paymentMethodTypeString;
          if (!this.activeMethodView) {
            return "";
          }
          stringKey = PAYMENT_METHOD_TYPE_TO_TRANSLATION_STRING[this.activeMethodView.paymentMethod.type];
          paymentMethodTypeString = this.strings[stringKey];
          return this.strings.payingWith.replace("{{paymentSource}}", paymentMethodTypeString);
        };
        PaymentMethodsView.prototype.enableEditMode = function() {
          this.container.classList.add("braintree-methods--edit");
          this._editButton.innerHTML = this.strings.deleteCancelButton;
          this._headingLabel.innerHTML = this.strings.editPaymentMethods;
          this.views.forEach(function(view) {
            view.enableEditMode();
          });
        };
        PaymentMethodsView.prototype.disableEditMode = function() {
          this.container.classList.remove("braintree-methods--edit");
          this._editButton.innerHTML = this.strings.edit;
          this._headingLabel.innerHTML = this._getPaymentMethodString();
          this.views.forEach(function(view) {
            view.disableEditMode();
          });
        };
        PaymentMethodsView.prototype._addPaymentMethod = function(paymentMethod) {
          var paymentMethodView = new PaymentMethodView({
            model: this.model,
            paymentMethod,
            client: this.client,
            strings: this.strings
          });
          if (this.model.isGuestCheckout && this.container.firstChild) {
            this.views[0].teardown();
            this.views.pop();
          }
          if (this.container.firstChild) {
            this.container.insertBefore(paymentMethodView.element, this.container.firstChild);
          } else {
            this.container.appendChild(paymentMethodView.element);
          }
          this.views.push(paymentMethodView);
        };
        PaymentMethodsView.prototype._removePaymentMethod = function(paymentMethod) {
          var i;
          for (i = 0; i < this.views.length; i++) {
            if (this.views[i].paymentMethod === paymentMethod) {
              this.views[i].teardown();
              this._headingLabel.innerHTML = "&nbsp;";
              this.views.splice(i, 1);
              break;
            }
          }
        };
        PaymentMethodsView.prototype._changeActivePaymentMethodView = function(paymentMethod) {
          var i;
          var previousActiveMethodView = this.activeMethodView;
          for (i = 0; i < this.views.length; i++) {
            if (this.views[i].paymentMethod === paymentMethod) {
              this.activeMethodView = this.views[i];
              this._headingLabel.innerHTML = this._getPaymentMethodString();
              break;
            }
          }
          if (previousActiveMethodView) {
            previousActiveMethodView.setActive(false);
          }
          this.activeMethodView.setActive(true);
          this._headingLabel.classList.remove("braintree-no-payment-method-selected");
        };
        PaymentMethodsView.prototype.requestPaymentMethod = function() {
          if (!this.activeMethodView || this.model.isInEditMode()) {
            return Promise.reject(new DropinError(errors.NO_PAYMENT_METHOD_ERROR));
          }
          return Promise.resolve(this.activeMethodView.paymentMethod);
        };
        PaymentMethodsView.prototype.refreshPaymentMethods = function() {
          var i;
          var paymentMethods2 = this.model.getPaymentMethods();
          this.views.forEach(function(view) {
            view.teardown();
          });
          this.views = [];
          for (i = paymentMethods2.length - 1; i >= 0; i--) {
            this._addPaymentMethod(paymentMethods2[i]);
          }
        };
        module2.exports = PaymentMethodsView;
      }, { "../constants": 189, "../lib/add-selection-event-handler": 193, "../lib/dropin-error": 199, "./base-view": 246, "./payment-method-view": 249 }], 251: [function(require2, module2, exports2) {
        var analytics = require2("../lib/analytics");
        var addSelectionEventHandler = require2("../lib/add-selection-event-handler");
        var BaseView = require2("./base-view");
        var paymentOptionIDs = require2("../constants").paymentOptionIDs;
        var paymentMethodOptionHTML = '<div class="braintree-option__logo">\n  <svg width="48" height="29" class="@CLASSNAME">\n    <use xlink:href="#@ICON"></use>\n  </svg>\n</div>\n\n<div class="braintree-option__label" aria-label="@OPTION_LABEL">\n  @OPTION_TITLE\n  <div class="braintree-option__disabled-message"></div>\n</div>\n';
        function PaymentOptionsView() {
          BaseView.apply(this, arguments);
          this._initialize();
        }
        PaymentOptionsView.prototype = Object.create(BaseView.prototype);
        PaymentOptionsView.prototype.constructor = PaymentOptionsView;
        PaymentOptionsView.ID = PaymentOptionsView.prototype.ID = "options";
        PaymentOptionsView.prototype._initialize = function() {
          this.container = this.getElementById("payment-options-container");
          this.elements = {};
          this.model.supportedPaymentOptions.forEach(function(paymentOptionID) {
            this._addPaymentOption(paymentOptionID);
          }.bind(this));
        };
        PaymentOptionsView.prototype._addPaymentOption = function(paymentOptionID) {
          var paymentSource;
          var div = document.createElement("div");
          var html2 = paymentMethodOptionHTML;
          var clickHandler = function clickHandler2() {
            this.mainView.setPrimaryView(paymentOptionID);
            this.model.selectPaymentOption(paymentOptionID);
            analytics.sendEvent(this.client, "selected." + paymentOptionIDs[paymentOptionID]);
          }.bind(this);
          div.className = "braintree-option braintree-option__" + paymentOptionID;
          div.setAttribute("tabindex", "0");
          div.setAttribute("role", "button");
          switch (paymentOptionID) {
            case paymentOptionIDs.applePay:
              paymentSource = this.strings["Apple Pay"];
              html2 = html2.replace(/@ICON/g, "logoApplePay");
              break;
            case paymentOptionIDs.card:
              paymentSource = this.strings.Card;
              html2 = html2.replace(/@ICON/g, "iconCardFront");
              html2 = html2.replace(/@CLASSNAME/g, "braintree-icon--bordered");
              break;
            case paymentOptionIDs.googlePay:
              paymentSource = this.strings["Google Pay"];
              html2 = html2.replace(/@ICON/g, "logoGooglePay");
              break;
            case paymentOptionIDs.paypal:
              paymentSource = this.strings.PayPal;
              html2 = html2.replace(/@ICON/g, "logoPayPal");
              break;
            case paymentOptionIDs.paypalCredit:
              paymentSource = this.strings["PayPal Credit"];
              html2 = html2.replace(/@ICON/g, "logoPayPalCredit");
              break;
            case paymentOptionIDs.venmo:
              paymentSource = this.strings.Venmo;
              html2 = html2.replace(/@ICON/g, "logoVenmo");
              break;
          }
          html2 = html2.replace(/@OPTION_LABEL/g, this._generateOptionLabel(paymentSource));
          html2 = html2.replace(/@OPTION_TITLE/g, paymentSource);
          html2 = html2.replace(/@CLASSNAME/g, "");
          div.innerHTML = html2;
          addSelectionEventHandler(div, clickHandler);
          this.container.appendChild(div);
          this.elements[paymentOptionID] = {
            div,
            clickHandler
          };
        };
        PaymentOptionsView.prototype._generateOptionLabel = function(paymentSourceString) {
          return this.strings.payingWith.replace("{{paymentSource}}", paymentSourceString);
        };
        module2.exports = PaymentOptionsView;
      }, { "../constants": 189, "../lib/add-selection-event-handler": 193, "../lib/analytics": 194, "./base-view": 246 }], 252: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            var assign2 = require2("../../lib/assign").assign;
            var BaseView = require2("../base-view");
            var btApplePay = require2("braintree-web/apple-pay");
            var DropinError = require2("../../lib/dropin-error");
            var isHTTPS = require2("../../lib/is-https");
            var paymentOptionIDs = require2("../../constants").paymentOptionIDs;
            var DEFAULT_APPLE_PAY_SESSION_VERSION = 2;
            function ApplePayView() {
              BaseView.apply(this, arguments);
            }
            ApplePayView.prototype = Object.create(BaseView.prototype);
            ApplePayView.prototype.constructor = ApplePayView;
            ApplePayView.ID = ApplePayView.prototype.ID = paymentOptionIDs.applePay;
            ApplePayView.prototype.initialize = function() {
              var self2 = this;
              self2.applePayConfiguration = assign2({}, self2.model.merchantConfiguration.applePay);
              self2.applePaySessionVersion = self2.applePayConfiguration.applePaySessionVersion || DEFAULT_APPLE_PAY_SESSION_VERSION;
              delete self2.applePayConfiguration.applePaySessionVersion;
              return btApplePay.create({ client: this.client }).then(function(applePayInstance) {
                self2.buttonDiv = self2.getElementById("apple-pay-button");
                self2.applePayInstance = applePayInstance;
                self2.buttonDiv.onclick = self2._showPaymentSheet.bind(self2);
                self2.buttonDiv.style["-apple-pay-button-style"] = self2.model.merchantConfiguration.applePay.buttonStyle || "black";
                self2.model.asyncDependencyReady(ApplePayView.ID);
              }).catch(function(err) {
                self2.model.asyncDependencyFailed({
                  view: self2.ID,
                  error: new DropinError(err)
                });
              });
            };
            ApplePayView.prototype.requestPaymentMethod = function() {
              this.model.reportError("applePayButtonMustBeUsed");
              return BaseView.prototype.requestPaymentMethod.call(this);
            };
            ApplePayView.prototype._showPaymentSheet = function() {
              var self2 = this;
              var request3, session;
              if (this._sessionInProgress) {
                return false;
              }
              this._sessionInProgress = true;
              request3 = this.applePayInstance.createPaymentRequest(this.applePayConfiguration.paymentRequest);
              session = new global2.ApplePaySession(self2.applePaySessionVersion, request3);
              session.onvalidatemerchant = function(event) {
                self2.applePayInstance.performValidation({
                  validationURL: event.validationURL,
                  displayName: self2.applePayConfiguration.displayName
                }).then(function(validationData) {
                  session.completeMerchantValidation(validationData);
                }).catch(function(validationErr) {
                  self2.model.reportError(validationErr);
                  self2._sessionInProgress = false;
                  session.abort();
                });
              };
              session.onpaymentauthorized = function(event) {
                self2.applePayInstance.tokenize({
                  token: event.payment.token
                }).then(function(payload) {
                  self2._sessionInProgress = false;
                  session.completePayment(global2.ApplePaySession.STATUS_SUCCESS);
                  payload.rawPaymentData = event.payment;
                  self2.model.addPaymentMethod(payload);
                }).catch(function(tokenizeErr) {
                  self2.model.reportError(tokenizeErr);
                  self2._sessionInProgress = false;
                  session.completePayment(global2.ApplePaySession.STATUS_FAILURE);
                });
              };
              session.oncancel = function() {
                self2._sessionInProgress = false;
              };
              session.begin();
              return false;
            };
            ApplePayView.prototype.updateConfiguration = function(key, value) {
              this.applePayConfiguration[key] = value;
            };
            ApplePayView.isEnabled = function(options) {
              var gatewayConfiguration = options.client.getConfiguration().gatewayConfiguration;
              var applePayEnabled = gatewayConfiguration.applePayWeb && Boolean(options.merchantConfiguration.applePay);
              var applePaySessionVersion = options.merchantConfiguration.applePay && options.merchantConfiguration.applePay.applePaySessionVersion;
              var applePayBrowserSupported;
              applePaySessionVersion = applePaySessionVersion || DEFAULT_APPLE_PAY_SESSION_VERSION;
              if (!applePayEnabled) {
                return Promise.resolve(false);
              }
              applePayBrowserSupported = global2.ApplePaySession && isHTTPS.isHTTPS();
              if (!applePayBrowserSupported) {
                return Promise.resolve(false);
              }
              if (!global2.ApplePaySession.supportsVersion(applePaySessionVersion)) {
                return Promise.resolve(false);
              }
              return Promise.resolve(Boolean(global2.ApplePaySession.canMakePayments()));
            };
            module2.exports = ApplePayView;
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../../constants": 189, "../../lib/assign": 195, "../../lib/dropin-error": 199, "../../lib/is-https": 202, "../base-view": 246, "braintree-web/apple-pay": 50 }], 253: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            var analytics = require2("../../lib/analytics");
            var assign2 = require2("../../lib/assign").assign;
            var browserDetection = require2("../../lib/browser-detection");
            var BaseView = require2("../base-view");
            var btPaypal = require2("braintree-web/paypal-checkout");
            var DropinError = require2("../../lib/dropin-error");
            var constants = require2("../../constants");
            var assets = require2("@braintree/asset-loader");
            var translations = require2("../../translations").fiveCharacterLocales;
            var ASYNC_DEPENDENCY_TIMEOUT = 3e4;
            var READ_ONLY_CONFIGURATION_OPTIONS = ["offerCredit", "locale"];
            var DEFAULT_CHECKOUTJS_LOG_LEVEL = "warn";
            var paypalScriptLoadInProgressPromise;
            function BasePayPalView() {
              BaseView.apply(this, arguments);
            }
            BasePayPalView.prototype = Object.create(BaseView.prototype);
            BasePayPalView.prototype.initialize = function() {
              var asyncDependencyTimeoutHandler;
              var isCredit = Boolean(this._isPayPalCredit);
              var setupComplete = false;
              var self2 = this;
              var paypalType = isCredit ? "paypalCredit" : "paypal";
              var paypalConfiguration = this.model.merchantConfiguration[paypalType];
              var dropinWrapperId = "#braintree--dropin__" + this.model.componentID;
              this.paypalConfiguration = assign2({}, paypalConfiguration);
              asyncDependencyTimeoutHandler = setTimeout(function() {
                self2.model.asyncDependencyFailed({
                  view: self2.ID,
                  error: new DropinError("There was an error connecting to PayPal.")
                });
              }, ASYNC_DEPENDENCY_TIMEOUT);
              return btPaypal.create({ client: this.client }).then(function(paypalInstance) {
                var checkoutJSConfiguration;
                var buttonSelector = '[data-braintree-id="paypal-button"]';
                var environment = self2.client.getConfiguration().gatewayConfiguration.environment === "production" ? "production" : "sandbox";
                var locale = self2.model.merchantConfiguration.locale;
                self2.paypalInstance = paypalInstance;
                self2.paypalConfiguration.offerCredit = Boolean(isCredit);
                checkoutJSConfiguration = {
                  env: environment,
                  style: self2.paypalConfiguration.buttonStyle || {},
                  commit: self2.paypalConfiguration.commit,
                  payment: function() {
                    return paypalInstance.createPayment(self2.paypalConfiguration).catch(reportError);
                  },
                  onAuthorize: function(data2) {
                    var shouldNotVault = self2.paypalConfiguration.vault && self2.paypalConfiguration.vault.vaultPayPal === false;
                    if (shouldNotVault) {
                      data2.vault = false;
                    }
                    return paypalInstance.tokenizePayment(data2).then(function(tokenizePayload) {
                      if (!shouldNotVault && self2.paypalConfiguration.flow === "vault" && !self2.model.isGuestCheckout) {
                        tokenizePayload.vaulted = true;
                      }
                      self2.model.addPaymentMethod(tokenizePayload);
                    }).catch(reportError);
                  },
                  onError: reportError
                };
                if (locale && locale in translations) {
                  self2.paypalConfiguration.locale = locale;
                  checkoutJSConfiguration.locale = locale;
                }
                checkoutJSConfiguration.funding = {
                  disallowed: []
                };
                Object.keys(global2.paypal.FUNDING).forEach(function(key) {
                  if (key === "PAYPAL" || key === "CREDIT") {
                    return;
                  }
                  checkoutJSConfiguration.funding.disallowed.push(global2.paypal.FUNDING[key]);
                });
                if (isCredit) {
                  buttonSelector = '[data-braintree-id="paypal-credit-button"]';
                  checkoutJSConfiguration.style.label = "credit";
                } else {
                  checkoutJSConfiguration.funding.disallowed.push(global2.paypal.FUNDING.CREDIT);
                }
                buttonSelector = dropinWrapperId + " " + buttonSelector;
                return global2.paypal.Button.render(checkoutJSConfiguration, buttonSelector).then(function() {
                  self2.model.asyncDependencyReady(paypalType);
                  setupComplete = true;
                  clearTimeout(asyncDependencyTimeoutHandler);
                });
              }).catch(reportError);
              function reportError(err) {
                if (setupComplete) {
                  self2.model.reportError(err);
                } else {
                  self2.model.asyncDependencyFailed({
                    view: self2.ID,
                    error: err
                  });
                  clearTimeout(asyncDependencyTimeoutHandler);
                }
              }
            };
            BasePayPalView.prototype.requestPaymentMethod = function() {
              this.model.reportError("paypalButtonMustBeUsed");
              return BaseView.prototype.requestPaymentMethod.call(this);
            };
            BasePayPalView.prototype.updateConfiguration = function(key, value) {
              if (READ_ONLY_CONFIGURATION_OPTIONS.indexOf(key) === -1) {
                this.paypalConfiguration[key] = value;
              }
            };
            BasePayPalView.isEnabled = function(options) {
              var gatewayConfiguration = options.client.getConfiguration().gatewayConfiguration;
              var merchantPayPalConfig = options.merchantConfiguration.paypal || options.merchantConfiguration.paypalCredit;
              if (!gatewayConfiguration.paypalEnabled) {
                return Promise.resolve(false);
              }
              if (browserDetection.isIe9() || browserDetection.isIe10()) {
                analytics.sendEvent(options.client, options.viewID + ".checkout.js-browser-not-supported");
                return Promise.resolve(false);
              }
              if (global2.paypal && global2.paypal.Button) {
                return Promise.resolve(true);
              }
              if (paypalScriptLoadInProgressPromise) {
                return paypalScriptLoadInProgressPromise;
              }
              paypalScriptLoadInProgressPromise = assets.loadScript({
                src: constants.CHECKOUT_JS_SOURCE,
                id: constants.PAYPAL_CHECKOUT_SCRIPT_ID,
                dataAttributes: {
                  "log-level": merchantPayPalConfig.logLevel || DEFAULT_CHECKOUTJS_LOG_LEVEL
                }
              }).then(function() {
                return Promise.resolve(true);
              }).catch(function() {
                return Promise.resolve(false);
              }).then(function(result) {
                paypalScriptLoadInProgressPromise = null;
                return Promise.resolve(result);
              });
              return paypalScriptLoadInProgressPromise;
            };
            module2.exports = BasePayPalView;
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../../constants": 189, "../../lib/analytics": 194, "../../lib/assign": 195, "../../lib/browser-detection": 196, "../../lib/dropin-error": 199, "../../translations": 229, "../base-view": 246, "@braintree/asset-loader": 1, "braintree-web/paypal-checkout": 129 }], 254: [function(require2, module2, exports2) {
        var assign2 = require2("../../lib/assign").assign;
        var BaseView = require2("../base-view");
        var constants = require2("../../constants");
        var DropinError = require2("../../lib/dropin-error");
        var hostedFields = require2("braintree-web/hosted-fields");
        var isUtf8 = require2("../../lib/is-utf-8");
        var transitionHelper = require2("../../lib/transition-helper");
        var cardIconHTML = '<div data-braintree-id="visa-card-icon" class="braintree-sheet__card-icon">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-visa"></use>\n    </svg>\n</div>\n<div data-braintree-id="master-card-card-icon" class="braintree-sheet__card-icon">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-master-card"></use>\n    </svg>\n</div>\n<div data-braintree-id="unionpay-card-icon" class="braintree-sheet__card-icon">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-unionpay"></use>\n    </svg>\n</div>\n<div data-braintree-id="american-express-card-icon" class="braintree-sheet__card-icon">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-american-express"></use>\n    </svg>\n</div>\n<div data-braintree-id="jcb-card-icon" class="braintree-sheet__card-icon">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-jcb"></use>\n    </svg>\n</div>\n<!--Elo, Hiper, and Hipercard currently use the generic icon.\nThe  braintree-hidden class should be removed here once we get icons for these cards-->\n<div data-braintree-id="elo-card-icon" class="braintree-sheet__card-icon braintree-hidden">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-elo"></use>\n    </svg>\n</div>\n<div data-braintree-id="hiper-card-icon" class="braintree-sheet__card-icon braintree-hidden">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-hiper"></use>\n    </svg>\n</div>\n<div data-braintree-id="hipercard-card-icon" class="braintree-sheet__card-icon braintree-hidden">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-hipercard"></use>\n    </svg>\n</div>\n<!-- Remove braintree-hidden class when supportedCardType accurately indicates Diners Club support -->\n<div data-braintree-id="diners-club-card-icon" class="braintree-sheet__card-icon braintree-hidden">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-diners-club"></use>\n    </svg>\n</div>\n<div data-braintree-id="discover-card-icon" class="braintree-sheet__card-icon">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-discover"></use>\n    </svg>\n</div>\n<div data-braintree-id="maestro-card-icon" class="braintree-sheet__card-icon">\n    <svg width="40" height="24">\n        <use xlink:href="#icon-maestro"></use>\n    </svg>\n</div>\n';
        var PASSTHROUGH_EVENTS = [
          "empty",
          "inputSubmitRequest",
          "binAvailable"
        ];
        var HOSTED_FIELDS = [
          "number",
          "expirationDate",
          "cvv",
          "postalCode",
          "cardholderName"
        ];
        function CardView() {
          BaseView.apply(this, arguments);
        }
        CardView.prototype = Object.create(BaseView.prototype);
        CardView.prototype.constructor = CardView;
        CardView.ID = CardView.prototype.ID = constants.paymentOptionIDs.card;
        CardView.prototype.initialize = function() {
          var cvvFieldGroup, postalCodeFieldGroup, hfOptions;
          var cardholderNameGroup = this.getElementById("cardholder-name-field-group");
          if (this.model.merchantConfiguration.card && this.model.merchantConfiguration.card !== true) {
            this.merchantConfiguration = this.model.merchantConfiguration.card;
          } else {
            this.merchantConfiguration = {};
          }
          this.merchantConfiguration.vault = this.merchantConfiguration.vault || {};
          this.hasCardholderName = Boolean(this.merchantConfiguration.cardholderName);
          this.cardholderNameRequired = this.hasCardholderName && this.merchantConfiguration.cardholderName.required === true;
          hfOptions = this._generateHostedFieldsOptions();
          this._renderCardIcons();
          this._hideUnsupportedCardIcons();
          this.hasCVV = hfOptions.fields.cvv;
          this.saveCardInput = this.getElementById("save-card-input");
          this.cardNumberIcon = this.getElementById("card-number-icon");
          this.cardNumberIconSvg = this.getElementById("card-number-icon-svg");
          this.cvvIcon = this.getElementById("cvv-icon");
          this.cvvIconSvg = this.getElementById("cvv-icon-svg");
          this.cvvLabelDescriptor = this.getElementById("cvv-label-descriptor");
          this.fieldErrors = {};
          if (!this.hasCardholderName) {
            cardholderNameGroup.parentNode.removeChild(cardholderNameGroup);
            HOSTED_FIELDS = HOSTED_FIELDS.filter(function(field) {
              return field !== "cardholderName";
            });
          }
          if (!this.hasCVV) {
            cvvFieldGroup = this.getElementById("cvv-field-group");
            cvvFieldGroup.parentNode.removeChild(cvvFieldGroup);
            HOSTED_FIELDS = HOSTED_FIELDS.filter(function(field) {
              return field !== "cvv";
            });
          }
          if (!hfOptions.fields.postalCode) {
            postalCodeFieldGroup = this.getElementById("postal-code-field-group");
            postalCodeFieldGroup.parentNode.removeChild(postalCodeFieldGroup);
            HOSTED_FIELDS = HOSTED_FIELDS.filter(function(field) {
              return field !== "postalCode";
            });
          }
          if (!this.model.isGuestCheckout && this.merchantConfiguration.vault.allowVaultCardOverride === true) {
            this.getElementById("save-card-field-group").classList.remove("braintree-hidden");
          }
          if (this.merchantConfiguration.vault.vaultCard === false) {
            this.saveCardInput.checked = false;
          }
          return hostedFields.create(hfOptions).then(function(hostedFieldsInstance) {
            this.hostedFieldsInstance = hostedFieldsInstance;
            this.hostedFieldsInstance.on("blur", this._onBlurEvent.bind(this));
            this.hostedFieldsInstance.on("cardTypeChange", this._onCardTypeChangeEvent.bind(this));
            this.hostedFieldsInstance.on("focus", this._onFocusEvent.bind(this));
            this.hostedFieldsInstance.on("notEmpty", this._onNotEmptyEvent.bind(this));
            this.hostedFieldsInstance.on("validityChange", this._onValidityChangeEvent.bind(this));
            HOSTED_FIELDS.forEach(function(hostedField) {
              this.hostedFieldsInstance.setAttribute({
                field: hostedField,
                attribute: "aria-required",
                value: true
              });
            }.bind(this));
            PASSTHROUGH_EVENTS.forEach(function(eventName) {
              this.hostedFieldsInstance.on(eventName, function(event) {
                this.model._emit("card:" + eventName, event);
              }.bind(this));
            }.bind(this));
            this.model.asyncDependencyReady(CardView.ID);
          }.bind(this)).catch(function(err) {
            this.model.asyncDependencyFailed({
              view: this.ID,
              error: err
            });
          }.bind(this));
        };
        CardView.prototype._sendRequestableEvent = function() {
          if (!this._isTokenizing) {
            this.model.setPaymentMethodRequestable({
              isRequestable: this._validateForm(),
              type: constants.paymentMethodTypes.card
            });
          }
        };
        CardView.prototype._renderCardIcons = function() {
          var overrides = this.merchantConfiguration.overrides;
          var cardIcons = this.getElementById("card-view-icons");
          var supportedCardBrands = overrides && overrides.fields && overrides.fields.number && overrides.fields.number.supportedCardBrands;
          cardIcons.innerHTML = cardIconHTML;
          if (supportedCardBrands) {
            Object.keys(supportedCardBrands).forEach(function(cardBrand) {
              var value = supportedCardBrands[cardBrand];
              var selector, iconDiv;
              if (value === false) {
                selector = 'div[data-braintree-id="' + constants.cardTypeIcons[cardBrand] + '-card-icon"]';
                iconDiv = document.querySelector(selector);
                hideCardIcon(iconDiv);
              }
            });
          }
        };
        CardView.prototype._generateHostedFieldsOptions = function() {
          var challenges = this.client.getConfiguration().gatewayConfiguration.challenges;
          var hasCVVChallenge = challenges.indexOf("cvv") !== -1;
          var hasPostalCodeChallenge = challenges.indexOf("postal_code") !== -1;
          var overrides = this.merchantConfiguration.overrides;
          var options = {
            client: this.client,
            fields: {
              cardholderName: {
                container: this._getFieldContainer("cardholder-name"),
                placeholder: this.strings.cardholderNamePlaceholder
              },
              number: {
                container: this._getFieldContainer("number"),
                placeholder: generateCardNumberPlaceholder()
              },
              expirationDate: {
                container: this._getFieldContainer("expiration"),
                placeholder: this.strings.expirationDatePlaceholder
              },
              cvv: {
                container: this._getFieldContainer("cvv"),
                placeholder: addBullets(3)
              },
              postalCode: {
                container: this._getFieldContainer("postal-code")
              }
            },
            styles: {
              input: {
                "font-size": "16px",
                "font-family": '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif',
                color: "#000"
              },
              ":focus": {
                color: "black"
              },
              "::-webkit-input-placeholder": {
                color: "#6a6a6a"
              },
              ":-moz-placeholder": {
                color: "#6a6a6a"
              },
              "::-moz-placeholder": {
                color: "#6a6a6a"
              },
              ":-ms-input-placeholder ": {
                color: "#6a6a6a"
              },
              "input::-ms-clear": {
                color: "transparent"
              }
            }
          };
          if (!this.hasCardholderName) {
            delete options.fields.cardholderName;
          }
          if (!hasCVVChallenge) {
            delete options.fields.cvv;
          }
          if (!hasPostalCodeChallenge) {
            delete options.fields.postalCode;
          }
          if (!overrides) {
            return options;
          }
          if (overrides.fields) {
            if (overrides.fields.cvv && typeof overrides.fields.cvv.placeholder !== "undefined") {
              this._hasCustomCVVPlaceholder = true;
            }
            Object.keys(overrides.fields).forEach(function(field) {
              if ((field === "cvv" || field === "postalCode") && overrides.fields[field] === null) {
                delete options.fields[field];
                return;
              }
              if (!options.fields[field]) {
                return;
              }
              assign2(options.fields[field], overrides.fields[field], {
                selector: options.fields[field].selector
              });
            });
          }
          if (overrides.styles) {
            Object.keys(overrides.styles).forEach(function(style) {
              if (overrides.styles[style] === null) {
                delete options.styles[style];
                return;
              } else if (typeof overrides.styles[style] === "string") {
                options.styles[style] = overrides.styles[style];
                return;
              }
              normalizeStyles(overrides.styles[style]);
              options.styles[style] = options.styles[style] || {};
              assign2(options.styles[style], overrides.styles[style]);
            });
          }
          return options;
        };
        CardView.prototype._validateForm = function(showFieldErrors) {
          var card, cardType, cardTypeSupported, state;
          var isValid = true;
          var supportedCardTypes = this.client.getConfiguration().gatewayConfiguration.creditCards.supportedCardTypes;
          if (!this.hostedFieldsInstance) {
            return false;
          }
          state = this.hostedFieldsInstance.getState();
          Object.keys(state.fields).forEach(function(key) {
            var field = state.fields[key];
            if (!showFieldErrors && !isValid) {
              return;
            }
            if (field.isEmpty) {
              if (!this.cardholderNameRequired && key === "cardholderName") {
                isValid = true;
              } else {
                isValid = false;
                if (showFieldErrors) {
                  this.showFieldError(key, this.strings["fieldEmptyFor" + capitalize2(key)]);
                }
              }
            } else if (!field.isValid) {
              isValid = false;
              if (showFieldErrors) {
                this.showFieldError(key, this.strings["fieldInvalidFor" + capitalize2(key)]);
              }
            }
          }.bind(this));
          if (state.fields.number.isValid) {
            card = state.cards[0];
            cardType = card && constants.configurationCardTypes[card.type];
            cardTypeSupported = cardType && supportedCardTypes.indexOf(cardType) !== -1;
            if (!cardTypeSupported) {
              isValid = false;
              if (showFieldErrors) {
                this.showFieldError("number", this.strings.unsupportedCardTypeError);
              }
            }
          }
          return isValid;
        };
        CardView.prototype.getPaymentMethod = function() {
          var formIsValid = this._validateForm();
          if (formIsValid) {
            return {
              type: constants.paymentMethodTypes.card
            };
          }
        };
        CardView.prototype.tokenize = function() {
          var transitionCallback;
          var self2 = this;
          var state = self2.hostedFieldsInstance.getState();
          var tokenizeOptions = {
            vault: this._shouldVault()
          };
          this.model.clearError();
          if (!this._validateForm(true)) {
            self2.model.reportError("hostedFieldsFieldsInvalidError");
            self2.allowUserAction();
            return Promise.reject(new DropinError(constants.errors.NO_PAYMENT_METHOD_ERROR));
          }
          if (!this.cardholderNameRequired && state.fields.cardholderName && state.fields.cardholderName.isEmpty) {
            tokenizeOptions.fieldsToTokenize = Object.keys(state.fields).filter(function(field) {
              return field !== "cardholderName";
            });
          }
          self2._isTokenizing = true;
          return self2.hostedFieldsInstance.tokenize(tokenizeOptions).then(function(payload) {
            var retainCardFields = self2.merchantConfiguration.clearFieldsAfterTokenization === false;
            if (!retainCardFields) {
              Object.keys(state.fields).forEach(function(field) {
                self2.hostedFieldsInstance.clear(field);
              });
            }
            if (self2._shouldVault()) {
              payload.vaulted = true;
            }
            return new Promise(function(resolve2) {
              transitionCallback = function() {
                setTimeout(function() {
                  self2.model.addPaymentMethod(payload);
                  resolve2(payload);
                  self2.element.classList.remove("braintree-sheet--tokenized");
                }, 0);
              };
              transitionHelper.onTransitionEnd(self2.element, "max-height", transitionCallback);
              setTimeout(function() {
                self2.allowUserAction();
                self2._isTokenizing = false;
              }, constants.CHANGE_ACTIVE_PAYMENT_METHOD_TIMEOUT);
              self2.element.classList.add("braintree-sheet--tokenized");
            });
          }).catch(function(err) {
            self2._isTokenizing = false;
            self2.model.reportError(err);
            self2.allowUserAction();
            return Promise.reject(new DropinError({
              message: constants.errors.NO_PAYMENT_METHOD_ERROR,
              braintreeWebError: err
            }));
          });
        };
        CardView.prototype.showFieldError = function(field, errorMessage) {
          var fieldError;
          var fieldGroup = this.getElementById(camelCaseToKebabCase(field) + "-field-group");
          var input = fieldGroup.querySelector("input");
          if (!this.fieldErrors.hasOwnProperty(field)) {
            this.fieldErrors[field] = this.getElementById(camelCaseToKebabCase(field) + "-field-error");
          }
          fieldGroup.classList.add("braintree-form__field-group--has-error");
          fieldError = this.fieldErrors[field];
          fieldError.innerHTML = errorMessage;
          if (input) {
            input.setAttribute("aria-invalid", true);
          } else {
            this.hostedFieldsInstance.setAttribute({
              field,
              attribute: "aria-invalid",
              value: true
            });
            this.hostedFieldsInstance.setMessage({
              field,
              message: errorMessage
            });
          }
        };
        CardView.prototype.hideFieldError = function(field) {
          var fieldGroup = this.getElementById(camelCaseToKebabCase(field) + "-field-group");
          var input = fieldGroup.querySelector("input");
          if (!this.fieldErrors.hasOwnProperty(field)) {
            this.fieldErrors[field] = this.getElementById(camelCaseToKebabCase(field) + "-field-error");
          }
          fieldGroup.classList.remove("braintree-form__field-group--has-error");
          if (input) {
            input.removeAttribute("aria-invalid");
          } else {
            this.hostedFieldsInstance.removeAttribute({
              field,
              attribute: "aria-invalid"
            });
            this.hostedFieldsInstance.setMessage({
              field,
              message: ""
            });
          }
        };
        CardView.prototype.teardown = function() {
          return this.hostedFieldsInstance.teardown();
        };
        CardView.prototype._shouldVault = function() {
          return !this.model.isGuestCheckout && this.saveCardInput.checked;
        };
        CardView.prototype._getFieldContainer = function(field) {
          if (field === "expiration") {
            field = "expiration-date";
          }
          return this.getElementById(field + "-field-group").querySelector(".braintree-form__hosted-field");
        };
        CardView.prototype._onBlurEvent = function(event) {
          var field = event.fields[event.emittedBy];
          var fieldGroup = this.getElementById(camelCaseToKebabCase(event.emittedBy) + "-field-group");
          fieldGroup.classList.remove("braintree-form__field-group--is-focused");
          if (field.isPotentiallyValid) {
            this.hideFieldError(event.emittedBy);
          }
          if (this._shouldApplyFieldEmptyError(event.emittedBy, field)) {
            this.showFieldError(event.emittedBy, this.strings["fieldEmptyFor" + capitalize2(event.emittedBy)]);
          } else if (!field.isEmpty && !field.isValid) {
            this.showFieldError(event.emittedBy, this.strings["fieldInvalidFor" + capitalize2(event.emittedBy)]);
          } else if (event.emittedBy === "number" && !this._isCardTypeSupported(event.cards[0])) {
            this.showFieldError("number", this.strings.unsupportedCardTypeError);
          }
          this.model._emit("card:blur", event);
          setTimeout(function() {
            if (this._shouldApplyFieldEmptyError(event.emittedBy, field)) {
              this.showFieldError(event.emittedBy, this.strings["fieldEmptyFor" + capitalize2(event.emittedBy)]);
            }
          }.bind(this), 150);
        };
        CardView.prototype._onCardTypeChangeEvent = function(event) {
          var cardType;
          var cardNumberHrefLink = "#iconCardFront";
          var cvvHrefLink = "#iconCVVBack";
          var cvvDescriptor = this.strings.cvvThreeDigitLabelSubheading;
          var cvvPlaceholder = addBullets(3);
          var numberFieldGroup = this.getElementById("number-field-group");
          if (event.cards.length === 1) {
            cardType = event.cards[0].type;
            cardNumberHrefLink = "#icon-" + cardType;
            if (cardType === "american-express") {
              cvvHrefLink = "#iconCVVFront";
              cvvDescriptor = this.strings.cvvFourDigitLabelSubheading;
              cvvPlaceholder = addBullets(4);
            }
            numberFieldGroup.classList.add("braintree-form__field-group--card-type-known");
          } else {
            numberFieldGroup.classList.remove("braintree-form__field-group--card-type-known");
          }
          if (event.emittedBy === "number" && this._isCardTypeSupported(event.cards[0])) {
            this.hideFieldError(event.emittedBy);
          }
          this.cardNumberIconSvg.setAttribute("xlink:href", cardNumberHrefLink);
          if (this.hasCVV) {
            this.cvvIconSvg.setAttribute("xlink:href", cvvHrefLink);
            this.cvvLabelDescriptor.innerHTML = cvvDescriptor;
            if (!this._hasCustomCVVPlaceholder) {
              this.hostedFieldsInstance.setAttribute({
                field: "cvv",
                attribute: "placeholder",
                value: cvvPlaceholder
              });
            }
          }
          this.model._emit("card:cardTypeChange", event);
        };
        CardView.prototype._onFocusEvent = function(event) {
          var fieldGroup = this.getElementById(camelCaseToKebabCase(event.emittedBy) + "-field-group");
          fieldGroup.classList.add("braintree-form__field-group--is-focused");
          this.model._emit("card:focus", event);
        };
        CardView.prototype._onNotEmptyEvent = function(event) {
          this.hideFieldError(event.emittedBy);
          this.model._emit("card:notEmpty", event);
        };
        CardView.prototype._onValidityChangeEvent = function(event) {
          var isValid;
          var field = event.fields[event.emittedBy];
          if (event.emittedBy === "number" && event.cards[0]) {
            isValid = field.isValid && this._isCardTypeSupported(event.cards[0]);
          } else {
            isValid = field.isValid;
          }
          field.container.classList.toggle("braintree-form__field--valid", isValid);
          if (field.isPotentiallyValid) {
            this.hideFieldError(event.emittedBy);
          }
          this._sendRequestableEvent();
          this.model._emit("card:validityChange", event);
        };
        CardView.prototype.requestPaymentMethod = function() {
          this.preventUserAction();
          return this.tokenize();
        };
        CardView.prototype.onSelection = function() {
          if (!this.hostedFieldsInstance) {
            return;
          }
          setTimeout(function() {
            if (this.hasCardholderName) {
              this.hostedFieldsInstance.focus("cardholderName");
            } else {
              this.hostedFieldsInstance.focus("number");
            }
          }.bind(this), 50);
          this._sendRequestableEvent();
        };
        CardView.prototype._hideUnsupportedCardIcons = function() {
          var supportedCardTypes = this.client.getConfiguration().gatewayConfiguration.creditCards.supportedCardTypes;
          Object.keys(constants.configurationCardTypes).forEach(function(paymentMethodCardType) {
            var cardIcon;
            var configurationCardType = constants.configurationCardTypes[paymentMethodCardType];
            if (supportedCardTypes.indexOf(configurationCardType) === -1) {
              cardIcon = this.getElementById(paymentMethodCardType + "-card-icon");
              cardIcon.classList.add("braintree-hidden");
            }
          }.bind(this));
        };
        CardView.prototype._isCardTypeSupported = function(card) {
          var cardType = card && card.type;
          var configurationCardType = constants.configurationCardTypes[cardType];
          var supportedCardTypes = this.client.getConfiguration().gatewayConfiguration.creditCards.supportedCardTypes;
          return supportedCardTypes.indexOf(configurationCardType) !== -1;
        };
        CardView.isEnabled = function(options) {
          var gatewayConfiguration = options.client.getConfiguration().gatewayConfiguration;
          var disabledByMerchant = options.merchantConfiguration.card === false;
          return Promise.resolve(!disabledByMerchant && gatewayConfiguration.creditCards.supportedCardTypes.length > 0);
        };
        CardView.prototype._shouldApplyFieldEmptyError = function(fieldId, field) {
          if (!field.isEmpty) {
            return false;
          }
          if (fieldId === "cardholderName" && !this.cardholderNameRequired) {
            return false;
          }
          return isCardViewElement();
        };
        function hideCardIcon(icon) {
          if (icon) {
            icon.classList.add("braintree-hidden");
          }
        }
        function isCardViewElement() {
          var activeId = document.activeElement && document.activeElement.id;
          var isHostedFieldsElement = document.activeElement instanceof HTMLIFrameElement && activeId.indexOf("braintree-hosted-field") !== -1;
          return isHostedFieldsElement;
        }
        function camelCaseToKebabCase(string) {
          return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
        }
        function capitalize2(string) {
          return string[0].toUpperCase() + string.substr(1);
        }
        function normalizeStyles(styles) {
          Object.keys(styles).forEach(function(style) {
            var transformedKeyName = camelCaseToKebabCase(style);
            styles[transformedKeyName] = styles[style];
          });
        }
        function addBullets(number2) {
          var bulletCharacter = isUtf8() ? "\u2022" : "*";
          return Array(number2 + 1).join(bulletCharacter);
        }
        function generateCardNumberPlaceholder() {
          var four = addBullets(4);
          return [four, four, four, four].join(" ");
        }
        module2.exports = CardView;
      }, { "../../constants": 189, "../../lib/assign": 195, "../../lib/dropin-error": 199, "../../lib/is-utf-8": 203, "../../lib/transition-helper": 209, "../base-view": 246, "braintree-web/hosted-fields": 78 }], 255: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            var assign2 = require2("../../lib/assign").assign;
            var BaseView = require2("../base-view");
            var btGooglePay = require2("braintree-web/google-payment");
            var DropinError = require2("../../lib/dropin-error");
            var constants = require2("../../constants");
            var assets = require2("@braintree/asset-loader");
            var analytics = require2("../../lib/analytics");
            function GooglePayView() {
              BaseView.apply(this, arguments);
            }
            GooglePayView.prototype = Object.create(BaseView.prototype);
            GooglePayView.prototype.constructor = GooglePayView;
            GooglePayView.ID = GooglePayView.prototype.ID = constants.paymentOptionIDs.googlePay;
            GooglePayView.prototype.initialize = function() {
              var self2 = this;
              var buttonOptions, googlePayVersion, merchantId;
              self2.googlePayConfiguration = assign2({}, self2.model.merchantConfiguration.googlePay);
              googlePayVersion = self2.googlePayConfiguration.googlePayVersion;
              merchantId = self2.googlePayConfiguration.merchantId;
              buttonOptions = assign2({
                buttonType: "short"
              }, self2.googlePayConfiguration.button, {
                onClick: function(event) {
                  event.preventDefault();
                  self2.preventUserAction();
                  self2.tokenize().then(function() {
                    self2.allowUserAction();
                  });
                }
              });
              delete self2.googlePayConfiguration.googlePayVersion;
              delete self2.googlePayConfiguration.merchantId;
              delete self2.googlePayConfiguration.button;
              return btGooglePay.create({
                client: self2.client,
                googlePayVersion,
                googleMerchantId: merchantId
              }).then(function(googlePayInstance) {
                self2.googlePayInstance = googlePayInstance;
                self2.paymentsClient = createPaymentsClient(self2.client);
              }).then(function() {
                var buttonContainer = self2.getElementById("google-pay-button");
                buttonContainer.appendChild(self2.paymentsClient.createButton(buttonOptions));
                self2.model.asyncDependencyReady(GooglePayView.ID);
              }).catch(function(err) {
                self2.model.asyncDependencyFailed({
                  view: self2.ID,
                  error: new DropinError(err)
                });
              });
            };
            GooglePayView.prototype.tokenize = function() {
              var self2 = this;
              var paymentDataRequest = self2.googlePayInstance.createPaymentDataRequest(self2.googlePayConfiguration);
              var rawPaymentData;
              return self2.paymentsClient.loadPaymentData(paymentDataRequest).then(function(paymentData) {
                rawPaymentData = paymentData;
                return self2.googlePayInstance.parseResponse(paymentData);
              }).then(function(tokenizePayload) {
                tokenizePayload.rawPaymentData = rawPaymentData;
                self2.model.addPaymentMethod(tokenizePayload);
              }).catch(function(err) {
                var reportedError = err;
                if (err.statusCode === "DEVELOPER_ERROR") {
                  console.error(err);
                  reportedError = "developerError";
                } else if (err.statusCode === "CANCELED") {
                  analytics.sendEvent(self2.client, "googlepay.loadPaymentData.canceled");
                  return;
                } else if (err.statusCode) {
                  analytics.sendEvent(self2.client, "googlepay.loadPaymentData.failed");
                }
                self2.model.reportError(reportedError);
              });
            };
            GooglePayView.prototype.updateConfiguration = function(key, value) {
              this.googlePayConfiguration[key] = value;
            };
            GooglePayView.isEnabled = function(options) {
              var gatewayConfiguration = options.client.getConfiguration().gatewayConfiguration;
              if (!(gatewayConfiguration.androidPay && Boolean(options.merchantConfiguration.googlePay))) {
                return Promise.resolve(false);
              }
              return Promise.resolve().then(function() {
                if (!(global2.google && global2.google.payments && global2.google.payments.api && global2.google.payments.api.PaymentsClient)) {
                  return assets.loadScript({
                    id: constants.GOOGLE_PAYMENT_SCRIPT_ID,
                    src: constants.GOOGLE_PAYMENT_SOURCE
                  });
                }
                return Promise.resolve();
              }).then(function() {
                var paymentsClient = createPaymentsClient(options.client);
                return paymentsClient.isReadyToPay({
                  allowedPaymentMethods: ["CARD", "TOKENIZED_CARD"]
                });
              }).then(function(response) {
                return Boolean(response.result);
              });
            };
            function createPaymentsClient(client) {
              return new global2.google.payments.api.PaymentsClient({
                environment: client.getConfiguration().gatewayConfiguration.environment === "production" ? "PRODUCTION" : "TEST"
              });
            }
            module2.exports = GooglePayView;
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../../constants": 189, "../../lib/analytics": 194, "../../lib/assign": 195, "../../lib/dropin-error": 199, "../base-view": 246, "@braintree/asset-loader": 1, "braintree-web/google-payment": 71 }], 256: [function(require2, module2, exports2) {
        var paymentOptionIDs = require2("../../constants").paymentOptionIDs;
        var result = {};
        result[paymentOptionIDs.applePay] = require2("./apple-pay-view");
        result[paymentOptionIDs.card] = require2("./card-view");
        result[paymentOptionIDs.googlePay] = require2("./google-pay-view");
        result[paymentOptionIDs.paypal] = require2("./paypal-view");
        result[paymentOptionIDs.paypalCredit] = require2("./paypal-credit-view");
        result[paymentOptionIDs.venmo] = require2("./venmo-view");
        module2.exports = result;
      }, { "../../constants": 189, "./apple-pay-view": 252, "./card-view": 254, "./google-pay-view": 255, "./paypal-credit-view": 257, "./paypal-view": 258, "./venmo-view": 259 }], 257: [function(require2, module2, exports2) {
        var assign2 = require2("../../lib/assign").assign;
        var paymentOptionIDs = require2("../../constants").paymentOptionIDs;
        var BasePayPalView = require2("./base-paypal-view");
        function PayPalCreditView() {
          BasePayPalView.apply(this, arguments);
          this._isPayPalCredit = true;
        }
        PayPalCreditView.prototype = Object.create(BasePayPalView.prototype);
        PayPalCreditView.prototype.constructor = PayPalCreditView;
        PayPalCreditView.ID = PayPalCreditView.prototype.ID = paymentOptionIDs.paypalCredit;
        PayPalCreditView.isEnabled = function(options) {
          if (!options.merchantConfiguration.paypalCredit) {
            return Promise.resolve(false);
          }
          return BasePayPalView.isEnabled(assign2({
            viewID: PayPalCreditView.ID
          }, options));
        };
        module2.exports = PayPalCreditView;
      }, { "../../constants": 189, "../../lib/assign": 195, "./base-paypal-view": 253 }], 258: [function(require2, module2, exports2) {
        var assign2 = require2("../../lib/assign").assign;
        var paymentOptionIDs = require2("../../constants").paymentOptionIDs;
        var BasePayPalView = require2("./base-paypal-view");
        function PayPalView() {
          BasePayPalView.apply(this, arguments);
        }
        PayPalView.prototype = Object.create(BasePayPalView.prototype);
        PayPalView.prototype.constructor = PayPalView;
        PayPalView.ID = PayPalView.prototype.ID = paymentOptionIDs.paypal;
        PayPalView.isEnabled = function(options) {
          if (!options.merchantConfiguration.paypal) {
            return Promise.resolve(false);
          }
          return BasePayPalView.isEnabled(assign2({
            viewID: PayPalView.ID
          }, options));
        };
        module2.exports = PayPalView;
      }, { "../../constants": 189, "../../lib/assign": 195, "./base-paypal-view": 253 }], 259: [function(require2, module2, exports2) {
        var assign2 = require2("../../lib/assign").assign;
        var BaseView = require2("../base-view");
        var btVenmo = require2("braintree-web/venmo");
        var DropinError = require2("../../lib/dropin-error");
        var paymentOptionIDs = require2("../../constants").paymentOptionIDs;
        function VenmoView() {
          BaseView.apply(this, arguments);
        }
        VenmoView.prototype = Object.create(BaseView.prototype);
        VenmoView.prototype.constructor = VenmoView;
        VenmoView.ID = VenmoView.prototype.ID = paymentOptionIDs.venmo;
        VenmoView.prototype.initialize = function() {
          var self2 = this;
          var venmoConfiguration = assign2({}, self2.model.merchantConfiguration.venmo, { client: this.client });
          return btVenmo.create(venmoConfiguration).then(function(venmoInstance) {
            self2.venmoInstance = venmoInstance;
            if (!self2.venmoInstance.hasTokenizationResult()) {
              return Promise.resolve();
            }
            return self2.venmoInstance.tokenize().then(function(payload) {
              self2.model.reportAppSwitchPayload(payload);
            }).catch(function(err) {
              if (self2._isIgnorableError(err)) {
                return;
              }
              self2.model.reportAppSwitchError(paymentOptionIDs.venmo, err);
            });
          }).then(function() {
            var button = self2.getElementById("venmo-button");
            button.addEventListener("click", function(event) {
              event.preventDefault();
              self2.preventUserAction();
              return self2.venmoInstance.tokenize().then(function(payload) {
                self2.model.addPaymentMethod(payload);
              }).catch(function(tokenizeErr) {
                if (self2._isIgnorableError(tokenizeErr)) {
                  return;
                }
                self2.model.reportError(tokenizeErr);
              }).then(function() {
                self2.allowUserAction();
              });
            });
            self2.model.asyncDependencyReady(VenmoView.ID);
          }).catch(function(err) {
            self2.model.asyncDependencyFailed({
              view: self2.ID,
              error: new DropinError(err)
            });
          });
        };
        VenmoView.prototype.requestPaymentMethod = function() {
          this.model.reportError("venmoButtonMustBeUsed");
          return BaseView.prototype.requestPaymentMethod.call(this);
        };
        VenmoView.prototype._isIgnorableError = function(error) {
          return error.code === "VENMO_APP_CANCELED" || error.code === "VENMO_DESKTOP_CANCELED";
        };
        VenmoView.isEnabled = function(options) {
          var gatewayConfiguration = options.client.getConfiguration().gatewayConfiguration;
          var venmoEnabled = gatewayConfiguration.payWithVenmo && Boolean(options.merchantConfiguration.venmo);
          if (!venmoEnabled) {
            return Promise.resolve(false);
          }
          return Promise.resolve(btVenmo.isBrowserSupported(options.merchantConfiguration.venmo));
        };
        module2.exports = VenmoView;
      }, { "../../constants": 189, "../../lib/assign": 195, "../../lib/dropin-error": 199, "../base-view": 246, "braintree-web/venmo": 150 }] }, {}, [192])(192);
    });
  })(dropin);
  var braintreeWebDropIn = /* @__PURE__ */ getDefaultExportFromCjs(dropin.exports);
  const _sfc_main$8 = {
    name: "BraintreeNewMethods",
    components: {
      Agreements,
      CheckboxComponent,
      ErrorMessage,
      MyButton,
      PrivacyPolicy,
      Recaptcha
    },
    data() {
      return {
        instance: null,
        storeMethod: false,
        additionalComponents: "",
        paymentOptionPriority: [],
        map: {},
        selectedMethod: null
      };
    },
    computed: {
      ...mapWritableState(useBraintreeStore, ["showMagentoPayments"]),
      ...mapState(useBraintreeStore, [
        "vaultActive",
        "clientToken",
        "threeDSEnabled",
        "threeDSThresholdAmount",
        "alwaysRequestThreeDS",
        "google",
        "paypal",
        "vaultedMethods",
        "errorMessage"
      ]),
      ...mapState(useConfigStore, ["currencyCode", "websiteName"]),
      ...mapState(useCartStore, ["cart", "cartGrandTotal"]),
      ...mapState(useCustomerStore, ["customer", "isLoggedIn"]),
      ...mapState(usePaymentStore, [
        "availableMethods",
        "paymentEmitter",
        "isPaymentMethodAvailable",
        "getPaymentMethodTitle",
        "getPaymentPriority"
      ]),
      ...mapState(useRecaptchaStore, ["isRecaptchaVisible"])
    },
    async created() {
      await this.getInitialConfig();
      await this.createClientToken();
      const total = (this.cartGrandTotal / 100).toString();
      this.map = {
        braintree: "card",
        braintree_applepay: "applePay",
        braintree_googlepay: "googlePay",
        braintree_venmo: "venmo",
        braintree_paypal: "paypal"
      };
      const braintreeMethods = this.availableMethods.filter(({ code: code2 }) => code2.startsWith("braintree"));
      this.paymentOptionPriority = braintreeMethods.map(({ code: code2 }) => this.map[code2]).filter(Boolean);
      if (this.paymentOptionPriority.includes("paypal") && this.paypal.creditActive) {
        const paypalIndex = this.paymentOptionPriority.indexOf("paypal");
        this.paymentOptionPriority.splice(paypalIndex + 1, 0, "paypalCredit");
        this.map.braintree_paypal_credit = "paypalCredit";
      }
      const options = {
        authorization: this.clientToken,
        container: "#braintree-drop-in",
        threeDSecure: false,
        paymentOptionPriority: this.paymentOptionPriority,
        translations: {
          Card: this.getPaymentMethodTitle("braintree"),
          PayPal: this.getPaymentMethodTitle("braintree_paypal")
        }
      };
      if (this.isPaymentMethodAvailable("braintree")) {
        options.card = {
          vault: {
            allowVaultCardOverride: true,
            vault: this.isLoggedIn
          }
        };
      }
      if (this.isPaymentMethodAvailable("braintree_applepay")) {
        options.applePay = {
          displayName: this.websiteName,
          paymentRequest: {
            total: {
              label: this.websiteName,
              amount: total
            }
          }
        };
      }
      if (this.isPaymentMethodAvailable("braintree_googlepay")) {
        options.googlePay = {
          merchantId: this.google.merchantId,
          googlePayVersion: 2,
          transactionInfo: {
            currencyCode: this.currencyCode,
            totalPriceStatus: "FINAL",
            totalPrice: total
          },
          allowedPaymentMethods: [{
            type: "CARD",
            parameters: {
              allowedAuthMethods: ["PAN_ONLY", "CRYPTOGRAM_3DS"],
              allowedCardNetworks: this.google.cCTypes,
              billingAddressRequired: true,
              billingAddressParameters: {
                format: "FULL",
                phoneNumberRequired: true
              }
            }
          }],
          button: {
            buttonColor: this.google.buttonColor
          }
        };
      }
      if (this.isPaymentMethodAvailable("braintree_paypal")) {
        options.paypal = {
          flow: "checkout",
          amount: total,
          currency: this.currencyCode,
          commit: true,
          lineItems: this.getPayPalLineItems(),
          buttonStyle: {
            color: this.paypal.buttonColor,
            label: this.paypal.buttonLabel,
            shape: this.paypal.buttonShape,
            size: "responsive"
          }
        };
        if (this.paypal.creditActive) {
          options.paypalCredit = {
            flow: "checkout",
            amount: total,
            currency: this.currencyCode,
            buttonStyle: {
              color: this.paypal.creditColor !== "gold" ? this.paypal.creditColor : "black",
              label: this.paypal.creditLabel,
              shape: this.paypal.creditShape,
              size: "responsive"
            },
            commit: true
          };
        }
      }
      if (this.isPaymentMethodAvailable("braintree_venmo")) {
        options.venmo = {
          allowDesktop: true
        };
      }
      if (this.threeDSEnabled) {
        options.threeDSecure = {
          amount: this.cartGrandTotal / 100
        };
      }
      braintreeWebDropIn.create(options, this.afterBraintreeInit);
    },
    unmounted() {
      this.removeEventListeners();
    },
    methods: {
      ...mapActions(useAgreementStore, ["validateAgreements"]),
      ...mapActions(useBraintreeStore, [
        "createClientToken",
        "unselectVaultedMethods",
        "setClientInstance",
        "setThreeDSInstance",
        "setErrorMessage",
        "clearErrorMessage",
        "escapeNonAsciiCharacters",
        "getPayPalLineItems"
      ]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useRecaptchaStore, ["validateToken"]),
      startPayment() {
        this.paymentEmitter.emit("braintreePaymentStart");
        this.requestPaymentMethod().then(this.getPaymentData).then(createPayment$1).then(() => refreshCustomerData(["cart"])).then(this.redirectToSuccess).catch((paymentError) => {
          var _a, _b;
          this.clearSelectedPaymentMethod();
          this.setToCurrentViewId();
          if (paymentError.name !== "DropinError") {
            this.setErrorMessage(((_b = (_a = paymentError == null ? void 0 : paymentError.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message) || paymentError.message);
          }
          this.paymentEmitter.emit("braintreePaymentError");
        });
      },
      requestPaymentMethod() {
        return new Promise((resolve2, reject) => {
          this.setErrorMessage("");
          const agreementsValid = this.validateAgreements();
          const recaptchaValid = this.validateToken("placeOrder");
          if (!agreementsValid || !recaptchaValid) {
            const error = new Error();
            error.name = "DropinError";
            reject(error);
            return;
          }
          if (!this.instance) {
            reject(new Error("Unable to initialise payment components."));
          }
          const billingAddress = this.cart.billing_address;
          const firstName = this.escapeNonAsciiCharacters(billingAddress.firstname);
          const lastName = this.escapeNonAsciiCharacters(billingAddress.lastname);
          const formattedBillingAddress = {
            givenName: firstName,
            surname: lastName,
            phoneNumber: billingAddress.telephone,
            streetAddress: billingAddress.street[0],
            extendedAddress: billingAddress.street[1],
            locality: billingAddress.city,
            region: billingAddress.region_code,
            postalCode: billingAddress.postcode,
            countryCodeAlpha2: billingAddress.country_code
          };
          const price = this.cartGrandTotal / 100;
          const threshold = this.threeDSThresholdAmount;
          const challengeRequested = this.alwaysRequestThreeDS || price >= threshold;
          this.instance.requestPaymentMethod({
            threeDSecure: {
              amount: parseFloat(price).toFixed(2),
              email: this.customer.email,
              billingAddress: formattedBillingAddress,
              challengeRequested
            }
          }, (error, payload) => {
            if (error) {
              reject(error);
            } else if (payload.liabilityShifted || !payload.liabilityShifted && !payload.liabilityShiftPossible || payload.type !== "CreditCard" && payload.type !== "AndroidPayCard") {
              this.showLoader();
              resolve2(payload);
            } else {
              reject(new Error("There was an error completing validation, please try again."));
            }
          });
        });
      },
      getPaymentData(payload) {
        return {
          email: this.customer.email,
          paymentMethod: {
            method: this.getBraintreeMethod(payload.type),
            additional_data: {
              payment_method_nonce: payload.nonce,
              is_active_payment_token_enabler: this.storeMethod
            },
            extension_attributes: getPaymentExtensionAttributes()
          }
        };
      },
      getBraintreeMethod(type) {
        switch (type) {
          case "AndroidPayCard":
            return "braintree_googlepay";
          case "PayPalAccount":
            return "braintree_paypal";
          default:
            return "braintree";
        }
      },
      afterBraintreeInit(event, instance) {
        this.showMagentoPayments = true;
        this.setClientInstance(instance._client);
        if (instance._threeDSecure) {
          this.setThreeDSInstance(instance._threeDSecure._instance);
        }
        this.instance = instance;
        this.attachEventListeners(instance);
        this.movePaymentContainers();
        [this.selectedMethod] = this.paymentOptionPriority;
        this.paymentEmitter.emit("braintreeInitComplete");
        this.modifyTokenize();
      },
      attachEventListeners(instance) {
        instance.on("changeActiveView", ({ newViewId, previousViewId }) => {
          this.removeActiveClass();
          this.clearErrorMessage();
          if (newViewId === "methods") {
            this.paymentEmitter.emit("changePaymentMethodDisplay", { visible: false });
            previousViewId !== "card" && this.startPayment();
          } else if (newViewId !== "options") {
            this.addActiveClass(newViewId);
            const id = newViewId === "card" ? "braintree" : `braintree_${newViewId}`;
            this.paymentEmitter.emit("paymentMethodSelected", { id });
            this.selectedMethod = newViewId;
            if (newViewId === "card") {
              this.additionalComponents = ".braintree-form__flexible-fields";
            } else if (newViewId === "paypal") {
              this.additionalComponents = 'div[data-braintree-id="paypal-button"]';
            } else if (newViewId === "googlePay") {
              this.additionalComponents = 'div[data-braintree-id="google-pay-button"]';
            } else if (newViewId === "applePay") {
              this.additionalComponents = ".braintree-applePay .braintree-sheet__content";
            } else if (newViewId === "venmo") {
              this.additionalComponents = ".braintree-venmo .braintree-sheet__content";
            }
          }
        });
        instance.on("3ds:customer-canceled", () => {
          const optionsContainer = this.$refs.braintreeContainer.querySelector(".braintree-options");
          if (optionsContainer) {
            this.clearSelectedPaymentMethod();
          }
        });
        this.paymentEmitter.on("paymentMethodSelected", this.clearSelectedMethod);
        this.paymentEmitter.on("changePaymentMethodDisplay", this.changePaymentMethodDisplay);
        this.paymentEmitter.on("braintreeStoredPaymentCardSelected", this.clearSelectedPaymentMethod);
        this.paymentEmitter.on("braintreePaymentStart", this.showLoader);
        this.paymentEmitter.on("braintreePaymentError", this.hideLoader);
      },
      removeEventListeners() {
        this.paymentEmitter.off("paymentMethodSelected", this.clearSelectedMethod);
        this.paymentEmitter.off("changePaymentMethodDisplay", this.changePaymentMethodDisplay);
        this.paymentEmitter.off("braintreeStoredPaymentCardSelected", this.clearSelectedPaymentMethod);
        this.paymentEmitter.off("braintreePaymentStart", this.showLoader);
        this.paymentEmitter.off("braintreePaymentError", this.hideLoader);
      },
      clearSelectedMethod({ id }) {
        this.unselectVaultedMethods();
        if (!id.startsWith("braintree") || id === "braintree-lpm" || id === "braintree-vaulted" || id === "braintree-ach") {
          this.clearSelectedPaymentMethod();
        }
        this.storeMethod = false;
      },
      changePaymentMethodDisplay({ visible }) {
        const sheets = this.$refs.braintreeContainer.querySelectorAll(".braintree-sheet__container .braintree-sheet");
        sheets.forEach((option) => {
          option.classList.toggle("braintree-hidden", !visible);
        });
      },
      movePaymentContainers() {
        const sheets = this.$refs.braintreeContainer.querySelectorAll(".braintree-sheet__container .braintree-sheet");
        sheets.forEach((sheet) => {
          const { braintreeId } = sheet.dataset;
          const matchingContainer = this.$refs.braintreeContainer.querySelector(`.braintree-option__${braintreeId}`);
          if (matchingContainer) {
            const index = Object.values(this.map).findIndex((method) => method === braintreeId);
            const priority = this.getPaymentPriority(Object.keys(this.map)[index]);
            const setBraintreeMethodPosition = (position) => {
              sheet.style.setProperty("--braintree-method-position", position);
              sheet.prepend(matchingContainer);
            };
            if (priority !== -1) {
              setBraintreeMethodPosition(priority + 1);
            } else if (braintreeId === "paypalCredit") {
              const paypalIndex = Object.values(this.map).findIndex((method) => method === "paypal");
              const paypalPriority = this.getPaymentPriority(Object.keys(this.map)[paypalIndex]);
              setBraintreeMethodPosition(paypalPriority + 2);
            }
            if (braintreeId === "card") {
              const icons = sheet.querySelector(".braintree-sheet__icons");
              matchingContainer.append(icons);
            }
          }
        });
      },
      modifyTokenize() {
        const originalGooglePay = this.instance._mainView._views.googlePay.tokenize.bind(toRaw(this.instance._mainView._views.googlePay));
        this.instance._mainView._views.googlePay.tokenize = () => {
          this.setErrorMessage("");
          const agreementsValid = this.validateAgreements();
          const recaptchaValid = this.validateToken("placeOrder");
          if (!agreementsValid || !recaptchaValid) {
            return Promise.resolve();
          }
          return originalGooglePay();
        };
        const originalVenmo = this.instance._mainView._views.venmo.venmoInstance.tokenize.bind(this.instance._mainView._views.venmo.venmoInstance);
        this.instance._mainView._views.venmo.venmoInstance.tokenize = () => {
          this.setErrorMessage("");
          const agreementsValid = this.validateAgreements();
          const recaptchaValid = this.validateToken("placeOrder");
          if (!agreementsValid || !recaptchaValid) {
            return Promise.resolve();
          }
          return originalVenmo();
        };
        const originalPayPal = this.instance._mainView._views.paypal.paypalInstance.createPayment.bind(this.instance._mainView._views.paypal.paypalInstance);
        this.instance._mainView._views.paypal.paypalInstance.createPayment = (configuration) => {
          this.setErrorMessage("");
          const agreementsValid = this.validateAgreements();
          const recaptchaValid = this.validateToken("placeOrder");
          if (!agreementsValid || !recaptchaValid) {
            return Promise.reject();
          }
          return originalPayPal(configuration);
        };
      },
      addActiveClass(type) {
        const classSearch = type === "card" ? ".braintree-option__card" : `.braintree-option__${type}`;
        const option = this.$refs.braintreeContainer.querySelector(classSearch);
        if (option) {
          option.classList.add("braintree-option__selected");
        }
      },
      removeActiveClass() {
        const options = this.$refs.braintreeContainer.querySelectorAll(".braintree-option");
        options.forEach((option) => {
          option.classList.remove("braintree-option__selected");
        });
      },
      clearSelectedPaymentMethod() {
        this.instance.clearSelectedPaymentMethod();
        this.paymentEmitter.emit("changePaymentMethodDisplay", { visible: true });
      },
      setToCurrentViewId() {
        this.instance._mainView.setPrimaryView(this.selectedMethod);
      },
      redirectToSuccess() {
        window.location.href = getSuccessPageUrl();
      },
      showLoader() {
        this.instance._mainView.showLoadingIndicator();
      },
      hideLoader() {
        this.instance._mainView.hideLoadingIndicator();
      }
    }
  };
  const _hoisted_1$6 = {
    id: "braintree-drop-in",
    ref: "braintreeContainer",
    class: "braintree-drop-in"
  };
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_CheckboxComponent = resolveComponent("CheckboxComponent");
    const _component_Agreements = resolveComponent("Agreements");
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_PrivacyPolicy = resolveComponent("PrivacyPolicy");
    const _component_MyButton = resolveComponent("MyButton");
    return openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$6, null, 512),
      $data.additionalComponents !== "" ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: $data.additionalComponents
      }, [
        _ctx.errorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
          key: 0,
          message: _ctx.errorMessage,
          attached: false,
          margin: false
        }, null, 8, ["message"])) : createCommentVNode("", true),
        _ctx.isLoggedIn && ($data.selectedMethod === "card" && _ctx.vaultActive || $data.selectedMethod === "googlepay" && _ctx.googlepay.vaultActive || $data.selectedMethod === "paypal" && _ctx.paypal.vaultActive) ? (openBlock(), createBlock(_component_CheckboxComponent, {
          key: 1,
          id: "braintree-store-method",
          class: "braintree-store-method",
          checked: $data.storeMethod,
          "change-handler": ({ currentTarget }) => $data.storeMethod = currentTarget.checked,
          text: _ctx.$t("braintree.storePayment")
        }, null, 8, ["checked", "change-handler", "text"])) : createCommentVNode("", true),
        createVNode(_component_Agreements, { id: "braintreeNew" }),
        _ctx.isRecaptchaVisible("placeOrder") ? (openBlock(), createBlock(_component_Recaptcha, {
          key: 2,
          id: "placeOrder",
          location: "braintreeNewMethods"
        })) : createCommentVNode("", true),
        createVNode(_component_PrivacyPolicy),
        $data.selectedMethod === "braintree" ? (openBlock(), createBlock(_component_MyButton, {
          key: 3,
          label: "Pay",
          primary: "",
          onClick: _cache[0] || (_cache[0] = ($event) => $options.startPayment())
        })) : createCommentVNode("", true)
      ], 8, ["to"])) : createCommentVNode("", true)
    ], 64);
  }
  var BraintreeNewMethods = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
  const _sfc_main$7 = {
    name: "BraintreeDropIn",
    components: {
      BraintreeAch,
      BraintreeLpm,
      BraintreeNewMethods
    },
    data() {
      return {
        paymentStepText: "",
        storedStepText: "",
        paymentStepTextStoredId: "bluefinch-checkout-paymentstep-text-stored",
        paymentStepTextNewId: "bluefinch-checkout-paymentstep-text-new",
        paymentStepTextGuestId: "bluefinch-checkout-paymentstep-text-guest"
      };
    },
    computed: {
      ...mapState(useCustomerStore, ["isLoggedIn"]),
      ...mapState(usePaymentStore, [
        "isPaymentMethodAvailable"
      ])
    }
  };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_BraintreeNewMethods = resolveComponent("BraintreeNewMethods");
    const _component_BraintreeLpm = resolveComponent("BraintreeLpm");
    const _component_BraintreeAch = resolveComponent("BraintreeAch");
    return openBlock(), createElementBlock(Fragment, null, [
      createVNode(_component_BraintreeNewMethods),
      _ctx.isPaymentMethodAvailable("braintree_local_payment") ? (openBlock(), createBlock(_component_BraintreeLpm, { key: 0 })) : createCommentVNode("", true),
      _ctx.isPaymentMethodAvailable("braintree_ach_direct_debit") ? (openBlock(), createBlock(_component_BraintreeAch, { key: 1 })) : createCommentVNode("", true)
    ], 64);
  }
  var BraintreeDropIn = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
  const _sfc_main$6 = {
    name: "SavedShippingMethod",
    components: {
      TextField,
      Shipping,
      Price,
      Edit
    },
    data() {
      return {
        shippingStepCompletedText: "",
        shippingStepCompletedTextId: "bluefinch-checkout-shippingstepcompleted-text"
      };
    },
    async created() {
      var _a;
      this.shippingStepCompletedText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a[this.shippingStepCompletedTextId]) || this.$t("shippingStep.stepCompleteTitle");
      document.addEventListener(this.shippingStepCompletedTextId, this.setShippingStepText);
    },
    unmounted() {
      document.removeEventListener(this.shippingStepCompletedTextId, this.setShippingStepText);
    },
    computed: {
      ...mapState(useCartStore, ["cart"]),
      ...mapState(useShippingMethodsStore, ["selectedMethod"])
    },
    methods: {
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useStepsStore, ["goToShipping"]),
      setShippingStepText(event) {
        var _a;
        this.shippingStepCompletedText = ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) || this.$t("shippingStep.stepCompleteTitle");
      },
      setDetailsStepActive() {
      }
    }
  };
  const _hoisted_1$5 = { class: "saved-shipping" };
  const _hoisted_2$4 = {
    class: "saved-shipping-link",
    "aria-label": "proceed-to-shipping-link"
  };
  const _hoisted_3$4 = { class: "saved-shipping__title" };
  const _hoisted_4$2 = { class: "order-total" };
  const _hoisted_5$2 = { class: "total__row" };
  const _hoisted_6$2 = { class: "saved-shipping__icon" };
  const _hoisted_7$2 = { class: "saved-shipping__icon-image" };
  const _hoisted_8$2 = { class: "title" };
  const _hoisted_9$1 = { class: "shipping-method-title" };
  const _hoisted_10$1 = { class: "proceed-to-shipping" };
  const _hoisted_11 = ["aria-label"];
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    var _a, _b, _c, _d, _e, _f, _g;
    const _component_Shipping = resolveComponent("Shipping");
    const _component_TextField = resolveComponent("TextField");
    const _component_Price = resolveComponent("Price");
    const _component_Edit = resolveComponent("Edit");
    return openBlock(), createElementBlock("div", _hoisted_1$5, [
      createBaseVNode("div", _hoisted_2$4, [
        createBaseVNode("div", _hoisted_3$4, [
          createBaseVNode("div", _hoisted_4$2, [
            createBaseVNode("div", _hoisted_5$2, [
              createBaseVNode("div", _hoisted_6$2, [
                createBaseVNode("div", _hoisted_7$2, [
                  createVNode(_component_Shipping)
                ]),
                createBaseVNode("div", _hoisted_8$2, [
                  createVNode(_component_TextField, { text: $data.shippingStepCompletedText }, null, 8, ["text"])
                ])
              ]),
              createBaseVNode("div", _hoisted_9$1, [
                createVNode(_component_TextField, {
                  text: `${(_c = (_b = (_a = _ctx.cart.shipping_addresses) == null ? void 0 : _a[0]) == null ? void 0 : _b.selected_shipping_method) == null ? void 0 : _c.method_title}, `
                }, null, 8, ["text"]),
                createVNode(_component_Price, {
                  class: "shipping-method-value",
                  value: (_g = (_f = (_e = (_d = _ctx.cart.shipping_addresses) == null ? void 0 : _d[0]) == null ? void 0 : _e.selected_shipping_method) == null ? void 0 : _f.amount) == null ? void 0 : _g.value
                }, null, 8, ["value"])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_10$1, [
          createBaseVNode("button", {
            class: "button--blank edit-shipping-button",
            "aria-label": _ctx.$t("yourDetailsSection.editShippingButtonLabel")
          }, [
            createVNode(_component_TextField, {
              class: "edit-button-title",
              text: _ctx.$t("yourDetailsSection.editButton")
            }, null, 8, ["text"]),
            createVNode(_component_Edit)
          ], 8, _hoisted_11)
        ])
      ])
    ]);
  }
  var SavedShippingMethod = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-2c0acdba"]]);
  const _sfc_main$5 = {
    name: "Rewards",
    components: {
      MyButton
    },
    computed: {
      ...mapState(useCartStore, ["cart"]),
      ...mapState(useCustomerStore, ["customer"])
    },
    methods: {
      ...mapActions(useCartStore, ["useRewardPoints", "removeRewardPoints"]),
      getFormattedPrice() {
        return formatPrice(this.customer.reward_points.balance.money.value);
      }
    }
  };
  const _hoisted_1$4 = {
    key: 0,
    class: "reward-points"
  };
  const _hoisted_2$3 = { class: "reward-points-available" };
  const _hoisted_3$3 = {
    key: 1,
    class: "reward-points"
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    var _a, _b, _c, _d, _e, _f;
    const _component_MyButton = resolveComponent("MyButton");
    return ((_b = (_a = _ctx.customer.reward_points) == null ? void 0 : _a.balance) == null ? void 0 : _b.points) && !((_c = _ctx.cart.applied_reward_points) == null ? void 0 : _c.points) ? (openBlock(), createElementBlock("div", _hoisted_1$4, [
      createBaseVNode("div", null, [
        createBaseVNode("span", null, toDisplayString$1(_ctx.$t("rewards.youHave")), 1),
        createBaseVNode("span", _hoisted_2$3, toDisplayString$1(_ctx.$t("rewards.rewardPoints", {
          points: _ctx.customer.reward_points.balance.points
        })), 1),
        createBaseVNode("span", null, toDisplayString$1(_ctx.$t("rewards.available")), 1),
        createBaseVNode("span", null, "(" + toDisplayString$1($options.getFormattedPrice()) + ")", 1)
      ]),
      createVNode(_component_MyButton, {
        label: _ctx.$t("rewards.applyButton"),
        secondary: "",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.useRewardPoints())
      }, null, 8, ["label"])
    ])) : ((_e = (_d = _ctx.customer.reward_points) == null ? void 0 : _d.balance) == null ? void 0 : _e.points) && ((_f = _ctx.cart.applied_reward_points) == null ? void 0 : _f.points) ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
      createBaseVNode("span", null, toDisplayString$1(_ctx.$t("rewards.applied")), 1),
      createVNode(_component_MyButton, {
        label: _ctx.$t("rewards.removeButton"),
        secondary: "",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.removeRewardPoints())
      }, null, 8, ["label"])
    ])) : createCommentVNode("", true);
  }
  var Rewards = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-3354a99b"]]);
  const _sfc_main$4 = {
    name: "StoreCredit",
    components: {
      MyButton
    },
    computed: {
      ...mapState(useCartStore, ["cart"]),
      ...mapState(useCustomerStore, ["customer"])
    },
    methods: {
      ...mapActions(useCartStore, ["useStoreCredit", "removeStoreCredit"]),
      getFormattedPrice() {
        return formatPrice(this.customer.store_credit.current_balance.value);
      }
    }
  };
  const _hoisted_1$3 = {
    key: 0,
    class: "store-credit"
  };
  const _hoisted_2$2 = { class: "store-credit-available" };
  const _hoisted_3$2 = {
    key: 1,
    class: "store-credit"
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    var _a, _b, _c, _d, _e, _f, _g;
    const _component_MyButton = resolveComponent("MyButton");
    return ((_c = (_b = (_a = _ctx.customer) == null ? void 0 : _a.store_credit) == null ? void 0 : _b.current_balance) == null ? void 0 : _c.value) && !((_e = (_d = _ctx.cart.applied_store_credit) == null ? void 0 : _d.applied_balance) == null ? void 0 : _e.value) ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
      createBaseVNode("div", null, [
        createBaseVNode("span", _hoisted_2$2, toDisplayString$1(_ctx.$t("storeCredit.applyStoreCredit", {
          value: $options.getFormattedPrice()
        })), 1)
      ]),
      createVNode(_component_MyButton, {
        label: _ctx.$t("storeCredit.applyButton"),
        secondary: "",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.useStoreCredit())
      }, null, 8, ["label"])
    ])) : ((_g = (_f = _ctx.cart.applied_store_credit) == null ? void 0 : _f.applied_balance) == null ? void 0 : _g.value) ? (openBlock(), createElementBlock("div", _hoisted_3$2, [
      createBaseVNode("span", null, toDisplayString$1(_ctx.$t("storeCredit.removeStoreCredit")), 1),
      createVNode(_component_MyButton, {
        label: _ctx.$t("storeCredit.removeButton"),
        secondary: "",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.removeStoreCredit())
      }, null, 8, ["label"])
    ])) : createCommentVNode("", true);
  }
  var StoreCredit = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-72e0444f"]]);
  var paymentComplete = () => {
    const gtmStore = useGtmStore();
    gtmStore.trackGtmEvent({
      event: "paymentComplete"
    });
  };
  var createPayment = (paymentMethod) => {
    const { maskedId } = useCartStore();
    const { tokens } = useRecaptchaStore();
    const request3 = `
    mutation PlaceOrder($cartId: String!, $paymentMethod: PaymentMethodInput!) {
      ${getNewsletterMutation()}

      setPayment: setPaymentMethodOnCart(input: {
        cart_id: $cartId
        payment_method: $paymentMethod
      }) {
        cart {
          id
        }
      }

      placeOrder: placeOrder(input: {
        cart_id: $cartId
      }) {
        order {
          order_number
        }
      }
    }`;
    const variables = {
      cartId: maskedId,
      paymentMethod
    };
    const customHeaders = {};
    if (tokens.placeOrder) {
      customHeaders["X-ReCaptcha"] = tokens.placeOrder;
    }
    return refreshCustomerData().then(() => graphQlRequest(request3, variables, customHeaders)).then((response) => {
      if (response.errors) {
        throw new Error(response.errors[0].message);
      }
      paymentComplete();
      return response.data.placeOrder.order.order_number;
    });
  };
  const _sfc_main$3 = {
    name: "FreePayment",
    components: {
      Agreements,
      ErrorMessage,
      MyButton,
      PrivacyPolicy,
      RadioButton,
      Recaptcha
    },
    props: {
      paymentType: String,
      title: String
    },
    data() {
      return {
        buttonDisabled: false,
        isMethodSelected: false,
        paymentVisible: true
      };
    },
    computed: {
      ...mapState(usePaymentStore, ["paymentEmitter", "isPaymentMethodAvailable"]),
      ...mapState(useCustomerStore, [
        "customer"
      ]),
      ...mapState(useRecaptchaStore, ["isRecaptchaVisible"])
    },
    created() {
      this.paymentEmitter.on("paymentMethodSelected", ({ id }) => {
        if (id !== this.paymentType) {
          this.isMethodSelected = false;
        }
      });
      this.paymentEmitter.on("changePaymentMethodDisplay", ({ visible }) => {
        this.paymentVisible = visible;
      });
    },
    methods: {
      ...mapActions(useAgreementStore, ["validateAgreements"]),
      ...mapActions(useRecaptchaStore, ["validateToken"]),
      async selectPaymentMethod() {
        this.isMethodSelected = true;
        this.paymentEmitter.emit("paymentMethodSelected", {
          id: this.paymentType,
          type: this.paymentType
        });
      },
      createPayment() {
        const paymentMethod = {
          code: this.paymentType
        };
        this.buttonDisabled = true;
        const agreementsValid = this.validateAgreements();
        const recaptchaValid = this.validateToken("placeOrder");
        if (!agreementsValid || !recaptchaValid) {
          return;
        }
        createPayment(paymentMethod).then(() => refreshCustomerData(["cart"])).then(this.redirectToSuccess).catch((error) => {
          if (error.message) {
            this.errorMessage = error.message;
          }
          this.buttonDisabled = false;
        });
      },
      redirectToSuccess() {
        window.location.href = getSuccessPageUrl();
      }
    }
  };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_RadioButton = resolveComponent("RadioButton");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_Agreements = resolveComponent("Agreements");
    const _component_PrivacyPolicy = resolveComponent("PrivacyPolicy");
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_MyButton = resolveComponent("MyButton");
    return $data.paymentVisible ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["free-payment", { active: $data.isMethodSelected }])
    }, [
      createVNode(_component_RadioButton, {
        text: $props.title,
        checked: $data.isMethodSelected,
        class: "free-payment-radio",
        onClick: $options.selectPaymentMethod,
        onKeydown: $options.selectPaymentMethod
      }, null, 8, ["text", "checked", "onClick", "onKeydown"]),
      _ctx.errorMessage && $data.isMethodSelected ? (openBlock(), createBlock(_component_ErrorMessage, {
        key: 0,
        message: _ctx.errorMessage,
        attached: false
      }, null, 8, ["message"])) : createCommentVNode("", true),
      $data.isMethodSelected ? (openBlock(), createBlock(_component_Agreements, {
        key: 1,
        id: "freeMoPayment"
      })) : createCommentVNode("", true),
      $data.isMethodSelected ? (openBlock(), createBlock(_component_PrivacyPolicy, { key: 2 })) : createCommentVNode("", true),
      $data.isMethodSelected && _ctx.isRecaptchaVisible("placeOrder") ? (openBlock(), createBlock(_component_Recaptcha, {
        key: 3,
        id: "placeOrder",
        location: "freeMoCheckPayment"
      })) : createCommentVNode("", true),
      $data.isMethodSelected ? (openBlock(), createBlock(_component_MyButton, {
        key: 4,
        class: "free-payment-button",
        label: _ctx.$t("paymentStep.payNow"),
        primary: "",
        disabled: $data.buttonDisabled,
        onClick: _cache[0] || (_cache[0] = ($event) => $options.createPayment())
      }, null, 8, ["label", "disabled"])) : createCommentVNode("", true)
    ], 2)) : createCommentVNode("", true);
  }
  var FreeMOCheckPayment = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
  var paymentSvg = "/paymentIcon.svg";
  const _sfc_main$2 = {
    name: "Payment",
    props: {
      width: {
        type: String
      },
      height: {
        type: String
      },
      fill: {
        type: String
      },
      role: {
        type: String
      },
      ariaLabel: {
        type: String
      }
    },
    computed: {
      paymentSvgIcon() {
        return `${getStaticUrl(paymentSvg)}`;
      }
    },
    setup(props) {
      const reactiveProps = reactive(props);
      return {
        style: computed(() => ({
          width: reactiveProps.width,
          height: reactiveProps.height,
          fill: reactiveProps.fill
        }))
      };
    }
  };
  const _hoisted_1$2 = ["src", "alt"];
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("img", {
      src: $options.paymentSvgIcon,
      alt: $options.paymentSvgIcon
    }, null, 8, _hoisted_1$2);
  }
  var Payment = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
  var getPaymentNonce = (publicHash) => {
    const url = `/braintree/payment/getnonce?${new URLSearchParams({
      cvv: "",
      public_hash: publicHash
    })}`;
    return fetch(url).then((res) => res.json()).then(({
      paymentMethodNonce: nonce,
      details: { bin } = { bin: "" },
      message
    }) => {
      if (!nonce) {
        throw new Error(message);
      }
      return { nonce, bin };
    });
  };
  var updatePayment = (response, publicHash) => {
    const url = `/braintree/payment/updatepaymentmethod?${new URLSearchParams({
      nonce: response.nonce,
      public_hash: publicHash
    })}`;
    return fetch(url).then((res) => res.json());
  };
  const _sfc_main$1 = {
    name: "BrainteeVaultMethods",
    components: {
      Agreements,
      ErrorMessage,
      MyButton,
      PrivacyPolicy,
      Recaptcha,
      Tick,
      TextField
    },
    data() {
      return {
        hostedFieldsInstance: null,
        loading: false,
        paymentStepText: ""
      };
    },
    computed: {
      ...mapState(useBraintreeStore, [
        "vaultActive",
        "clientToken",
        "clientInstance",
        "threeDSecureInstance",
        "vaultedMethods",
        "selectedVaultMethod",
        "vaultVerifyCvv",
        "threeDSEnabled",
        "threeDSThresholdAmount",
        "alwaysRequestThreeDS",
        "errorMessage"
      ]),
      ...mapState(useConfigStore, ["currencyCode", "websiteName"]),
      ...mapState(useCartStore, ["cart", "cartGrandTotal"]),
      ...mapState(useCustomerStore, ["customer", "getSelectedBillingAddress", "isLoggedIn"]),
      ...mapState(usePaymentStore, ["paymentEmitter", "availableMethods"]),
      ...mapState(useRecaptchaStore, ["isRecaptchaVisible"])
    },
    async created() {
      var _a;
      await this.getInitialConfig();
      this.paymentStepText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a["bluefinch-checkout-paymentstep-text-stored"]) || this.$t("paymentStep.titleStored");
      this.paymentEmitter.on("braintreePaymentStart", () => {
        this.loading = true;
      });
      this.paymentEmitter.on("braintreePaymentError", () => {
        this.loading = false;
      });
    },
    methods: {
      ...mapActions(useAgreementStore, ["validateAgreements"]),
      ...mapActions(useBraintreeStore, [
        "createClientToken",
        "selectVaultedMethod",
        "setErrorMessage",
        "clearErrorMessage",
        "escapeNonAsciiCharacters",
        "mapCartTypes"
      ]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useRecaptchaStore, ["validateToken"]),
      async selectPaymentCard(vaultedMethod) {
        if (this.selectedVaultMethod && vaultedMethod.publicHash === this.selectedVaultMethod.publicHash) {
          return;
        }
        this.paymentEmitter.emit("paymentMethodSelected", { id: "braintree-vaulted" });
        if (this.hostedFieldsInstance) {
          this.hostedFieldsInstance.teardown();
        }
        this.clearErrorMessage();
        this.selectVaultedMethod(vaultedMethod);
        this.paymentEmitter.emit("braintreeStoredPaymentCardSelected", { publicHash: vaultedMethod.publicHash });
        if (this.vaultVerifyCvv) {
          const options = {
            client: this.clientInstance,
            fields: {
              cvv: {
                selector: `#cid_${vaultedMethod.publicHash}`,
                placeholder: "123"
              }
            }
          };
          this.hostedFieldsInstance = await markRaw(braintree.hostedFields.create(options));
        }
      },
      startPayment() {
        this.clearErrorMessage();
        if (!this.validateAgreements() || !this.validateToken("placeOrder")) {
          return;
        }
        this.paymentEmitter.emit("braintreePaymentStart");
        const { publicHash } = this.selectedVaultMethod;
        const getNonce = !this.hostedFieldsInstance ? getPaymentNonce(publicHash) : this.hostedFieldsInstance.tokenize().then(async (response) => {
          await updatePayment(response, publicHash);
          return getPaymentNonce(publicHash);
        });
        getNonce.then(({ nonce, bin }) => new Promise((resolve2, reject) => {
          const price = this.cartGrandTotal / 100;
          const threshold = this.threeDSThresholdAmount;
          if (!this.threeDSEnabled || !this.alwaysRequestThreeDS && this.vaultVerifyCvv && price < threshold) {
            resolve2({
              nonce
            });
            return;
          }
          const billingAddress = this.cart.billing_address;
          const firstName = this.escapeNonAsciiCharacters(billingAddress.firstname);
          const lastName = this.escapeNonAsciiCharacters(billingAddress.lastname);
          const formattedBillingAddress = {
            givenName: firstName,
            surname: lastName,
            phoneNumber: billingAddress.telephone,
            streetAddress: billingAddress.street[0],
            extendedAddress: billingAddress.street[1],
            locality: billingAddress.city,
            region: billingAddress.region_code,
            postalCode: billingAddress.postcode,
            countryCodeAlpha2: billingAddress.country_code
          };
          const threeDSecureParameters = {
            amount: parseFloat(price).toFixed(2),
            email: this.customer.email,
            nonce,
            bin,
            billingAddress: formattedBillingAddress,
            challengeRequested: this.alwaysRequestThreeDS
          };
          this.threeDSecureInstance.on("lookup-complete", (data2, next) => {
            next();
          });
          this.threeDSecureInstance.verifyCard(threeDSecureParameters, (err, response) => {
            if (err) {
              if (err.code === "THREEDS_LOOKUP_VALIDATION_ERROR") {
                const errorMessage = err.details.originalError.details.originalError.error.message;
                const pleaseTryAgain = "Please update the address and try again.";
                if (errorMessage === "Billing line1 format is invalid." && billingAddress.street.length > 50) {
                  return reject(new Error(`Billing line1 must be string and less than 50 characters. ${pleaseTryAgain}`));
                }
                if (errorMessage === "Billing line2 format is invalid." && billingAddress.street.length.length > 50) {
                  return reject(new Error(`Billing line2 must be string and less than 50 characters. ${pleaseTryAgain}`));
                }
                return reject(new Error(errorMessage));
              }
              return reject(new Error("Please try again with another form of payment."));
            }
            const liability = {
              shifted: response.liabilityShifted,
              shiftPossible: response.liabilityShiftPossible
            };
            if (liability.shifted || !liability.shifted && !liability.shiftPossible) {
              resolve2(response);
            } else {
              reject(new Error("Please try again with another form of payment."));
            }
            return true;
          });
        })).then((response) => {
          const paymentData = this.getPaymentData(response);
          return createPayment$1(paymentData).then(() => refreshCustomerData(["cart"])).then(this.redirectToSuccess);
        }).catch((paymentError) => {
          var _a, _b;
          if (paymentError.name !== "DropinError") {
            this.setErrorMessage(((_b = (_a = paymentError == null ? void 0 : paymentError.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message) || paymentError.message);
          }
          this.loading = false;
          this.paymentEmitter.emit("braintreePaymentError");
        });
      },
      getPaymentData(response) {
        const { publicHash } = this.selectedVaultMethod;
        return {
          paymentMethod: {
            method: "braintree_cc_vault",
            additional_data: {
              payment_method_nonce: response.nonce,
              public_hash: publicHash
            },
            extension_attributes: getPaymentExtensionAttributes()
          }
        };
      },
      redirectToSuccess() {
        window.location.href = getSuccessPageUrl();
      }
    }
  };
  const _hoisted_1$1 = {
    key: 0,
    class: "braintree-vault"
  };
  const _hoisted_2$1 = ["aria-label", "onClick"];
  const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("span", {
    class: "braintree-payment__payment-method__radio",
    "aria-hidden": "true"
  }, null, -1);
  const _hoisted_4$1 = { class: "braintree-payment__payment-method__image__wrapper braintree-payment__payment-method__image__wrapper--outline" };
  const _hoisted_5$1 = ["xlink:href"];
  const _hoisted_6$1 = { class: "braintree-payment__payment-method__card-number" };
  const _hoisted_7$1 = { class: "braintree-payment__payment-method__name" };
  const _hoisted_8$1 = { class: "braintree-payment__payment-method__expiry-label" };
  const _hoisted_9 = { class: "braintree-payment__payment-method__expiry" };
  const _hoisted_10 = ["id"];
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Tick = resolveComponent("Tick");
    const _component_TextField = resolveComponent("TextField");
    const _component_ErrorMessage = resolveComponent("ErrorMessage");
    const _component_Agreements = resolveComponent("Agreements");
    const _component_PrivacyPolicy = resolveComponent("PrivacyPolicy");
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_MyButton = resolveComponent("MyButton");
    return Object.values(_ctx.vaultedMethods).length ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
      withDirectives(createBaseVNode("div", {
        class: normalizeClass(["braintree-vaulted-methods-container", `braintree-vaulted-methods-container-${Object.values(_ctx.vaultedMethods).length}`])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(Object.values(_ctx.vaultedMethods), (vaultedMethod) => {
          return openBlock(), createElementBlock("div", {
            key: vaultedMethod.publicHash
          }, [
            createBaseVNode("button", {
              class: normalizeClass(["braintree-payment__payment-method__header__title button", { "braintree-payment__payment-method-disabled": !vaultedMethod.selected }]),
              "aria-label": _ctx.$t("paymentCard.storedPaymentLabel", { lastFour: vaultedMethod.details.maskedCC }),
              type: "button",
              onClick: ($event) => $options.selectPaymentCard(vaultedMethod)
            }, [
              vaultedMethod.selected ? (openBlock(), createBlock(_component_Tick, {
                key: 0,
                class: "braintree-payment__payment-method-tick"
              })) : (openBlock(), createBlock(_component_TextField, {
                key: 1,
                class: "braintree-payment__payment-method-select",
                text: _ctx.$t("paymentCard.select")
              }, null, 8, ["text"])),
              _hoisted_3$1,
              createBaseVNode("span", _hoisted_4$1, [
                (openBlock(), createElementBlock("svg", null, [
                  createBaseVNode("use", {
                    "data-braintree-id": "card-number-icon-svg",
                    "xlink:href": `#icon-${_ctx.mapCartTypes(vaultedMethod.details.type)}`
                  }, null, 8, _hoisted_5$1)
                ]))
              ]),
              createBaseVNode("span", _hoisted_6$1, toDisplayString$1(_ctx.$t("paymentCard.cardNumber")), 1),
              createBaseVNode("span", _hoisted_7$1, " **** **** **** " + toDisplayString$1(vaultedMethod.details.maskedCC), 1),
              createBaseVNode("span", _hoisted_8$1, toDisplayString$1(_ctx.$t("paymentCard.expiry")), 1),
              createBaseVNode("span", _hoisted_9, toDisplayString$1(vaultedMethod.details.expirationDate), 1)
            ], 10, _hoisted_2$1)
          ]);
        }), 128))
      ], 2), [
        [vShow, !$data.loading && _ctx.clientInstance]
      ]),
      _ctx.vaultVerifyCvv && _ctx.selectedVaultMethod ? withDirectives((openBlock(), createElementBlock("div", {
        key: 0,
        id: "cid_" + _ctx.selectedVaultMethod.publicHash
      }, null, 8, _hoisted_10)), [
        [vShow, !$data.loading]
      ]) : createCommentVNode("", true),
      _ctx.selectedVaultMethod && !$data.loading ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.errorMessage ? (openBlock(), createBlock(_component_ErrorMessage, {
          key: 0,
          message: _ctx.errorMessage,
          attached: false
        }, null, 8, ["message"])) : createCommentVNode("", true),
        createVNode(_component_Agreements, { id: "braintreeVault" }),
        createVNode(_component_PrivacyPolicy),
        _ctx.isRecaptchaVisible("placeOrder") ? (openBlock(), createBlock(_component_Recaptcha, {
          key: 1,
          id: "placeOrder",
          location: "braintreeVaultedMethods"
        })) : createCommentVNode("", true),
        createVNode(_component_MyButton, {
          class: "braintree-vaulted-methods-pay-button",
          label: "Pay",
          primary: "",
          onClick: _cache[0] || (_cache[0] = ($event) => $options.startPayment())
        })
      ], 64)) : createCommentVNode("", true)
    ])) : createCommentVNode("", true);
  }
  var VaultedMethods = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
  var paymentMethods = () => {
    var _a;
    const paymentMethods2 = {};
    if ((_a = window.bluefinchCheckout) == null ? void 0 : _a.paymentMethods) {
      Object.keys(window.bluefinchCheckout.paymentMethods).forEach((paymentMethod) => {
        paymentMethods2[paymentMethod] = defineAsyncComponent(() => __vitePreload(() => import(
          /* @vite-ignore */
          window.bluefinchCheckout.paymentMethods[paymentMethod]
        ), true ? [] : void 0));
      });
    }
    return paymentMethods2;
  };
  const _sfc_main = {
    name: "PaymentPage",
    components: {
      SavedDeliveryAddress,
      SavedShippingMethod,
      Rewards,
      FreeMOCheckPayment,
      ErrorMessage,
      BraintreeDropIn,
      StoreCredit,
      Recaptcha,
      Payment,
      ProgressBar,
      TextField,
      VaultedMethods,
      ...paymentMethods()
    },
    data() {
      return {
        additionalPaymentMethods: [],
        storedStepText: "",
        paymentStepText: "",
        paymentKey: 0,
        paymentStepTextStoredId: "bluefinch-checkout-paymentstep-text-stored",
        paymentStepTextNewId: "bluefinch-checkout-paymentstep-text-new",
        paymentStepTextGuestId: "bluefinch-checkout-paymentstep-text-guest"
      };
    },
    computed: {
      ...mapState(useConfigStore, [
        "currencyCode",
        "storeCode",
        "rewardsEnabled"
      ]),
      ...mapState(useCustomerStore, ["isLoggedIn"]),
      ...mapState(useBraintreeStore, ["isBraintreeEnabled", "showMagentoPayments"]),
      ...mapState(usePaymentStore, [
        "paymentEmitter",
        "hasVaultedMethods",
        "isPaymentMethodAvailable",
        "getPaymentMethodTitle"
      ]),
      ...mapState(useCartStore, ["cart", "cartEmitter", "cartGrandTotal"]),
      ...mapState(useRecaptchaStore, ["isRecaptchaVisible"])
    },
    async created() {
      var _a, _b, _c;
      this.storedStepText = ((_a = window.bluefinchCheckout) == null ? void 0 : _a["bluefinch-checkout-paymentstep-text-stored"]) || this.$t("paymentStep.titleStored");
      if (this.hasVaultedMethods) {
        this.paymentStepText = ((_b = window.bluefinchCheckout) == null ? void 0 : _b["bluefinch-checkout-paymentstep-text-new"]) || this.$t("paymentStep.titleNew");
      } else {
        this.paymentStepText = ((_c = window.bluefinchCheckout) == null ? void 0 : _c["bluefinch-checkout-paymentstep-text-guest"]) || this.$t("paymentStep.titleGuest");
      }
      document.addEventListener(this.paymentStepTextStoredId, this.setPaymentStepText);
      document.addEventListener(this.paymentStepTextNewId, this.setPaymentStepText);
      document.addEventListener(this.paymentStepTextGuestId, this.setPaymentStepText);
      this.additionalPaymentMethods = Object.keys(paymentMethods());
    },
    methods: {
      ...mapActions(useBraintreeStore, ["getVaultedMethods"]),
      ...mapActions(useCartStore, ["getCart"]),
      ...mapActions(useConfigStore, ["getInitialConfig"]),
      ...mapActions(useGtmStore, ["trackStep"]),
      setPaymentStepText(event) {
        var _a;
        if ((_a = event == null ? void 0 : event.detail) == null ? void 0 : _a.value) {
          if (event.detail.customEventId === this.paymentStepTextStoredId) {
            this.storedStepText = event.detail.value;
          } else {
            this.paymentStepText = event.detail.value;
          }
          return;
        }
        if (this.hasVaultedMethods) {
          this.storedStepText = this.$t("paymentStep.titleStored");
          this.paymentStepText = this.$t("paymentStep.titleNew");
        } else {
          this.paymentStepText = this.$t("paymentStep.titleGuest");
        }
      },
      setDetailsStepActive() {
        const element = document.getElementById("progress-bar");
        element.classList.add("details-active");
      }
    }
  };
  const _hoisted_1 = { class: "payment-step" };
  const _hoisted_2 = { class: "payment-page" };
  const _hoisted_3 = { class: "payment-form" };
  const _hoisted_4 = { class: "braintree-payment__title" };
  const _hoisted_5 = /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1);
  const _hoisted_6 = { class: "braintree-payment__title" };
  const _hoisted_7 = /* @__PURE__ */ createBaseVNode("div", { class: "divider-line" }, null, -1);
  const _hoisted_8 = { key: 1 };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Recaptcha = resolveComponent("Recaptcha");
    const _component_SavedDeliveryAddress = resolveComponent("SavedDeliveryAddress");
    const _component_SavedShippingMethod = resolveComponent("SavedShippingMethod");
    const _component_Rewards = resolveComponent("Rewards");
    const _component_StoreCredit = resolveComponent("StoreCredit");
    const _component_ProgressBar = resolveComponent("ProgressBar");
    const _component_Payment = resolveComponent("Payment");
    const _component_TextField = resolveComponent("TextField");
    const _component_VaultedMethods = resolveComponent("VaultedMethods");
    const _component_BraintreeDropIn = resolveComponent("BraintreeDropIn");
    const _component_FreeMOCheckPayment = resolveComponent("FreeMOCheckPayment");
    return openBlock(), createElementBlock("div", _hoisted_1, [
      !_ctx.isRecaptchaVisible("placeOrder") ? (openBlock(), createBlock(_component_Recaptcha, {
        key: 0,
        id: "placeOrder",
        location: "braintreeNewMethods"
      })) : createCommentVNode("", true),
      createVNode(_component_SavedDeliveryAddress),
      !_ctx.cart.is_virtual ? (openBlock(), createBlock(_component_SavedShippingMethod, { key: 1 })) : createCommentVNode("", true),
      _ctx.rewardsEnabled ? (openBlock(), createBlock(_component_Rewards, { key: 2 })) : createCommentVNode("", true),
      createVNode(_component_StoreCredit),
      createBaseVNode("div", _hoisted_2, [
        createBaseVNode("div", _hoisted_3, [
          createVNode(_component_ProgressBar),
          _ctx.cartGrandTotal ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _ctx.isLoggedIn && _ctx.hasVaultedMethods ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_4, [
                createVNode(_component_Payment, {
                  class: "braintree-payment__icon",
                  fill: "black"
                }),
                createVNode(_component_TextField, {
                  class: "braintree-payment__header",
                  text: $data.storedStepText
                }, null, 8, ["text"]),
                _hoisted_5
              ]),
              _ctx.isPaymentMethodAvailable("braintree_cc_vault") ? (openBlock(), createBlock(_component_VaultedMethods, {
                key: `braintreeStoredMethods-${$data.paymentKey}`
              })) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_6, [
              createVNode(_component_Payment, {
                class: "braintree-payment__icon",
                fill: "black"
              }),
              createVNode(_component_TextField, {
                class: "braintree-payment__header",
                text: $data.paymentStepText
              }, null, 8, ["text"]),
              _hoisted_7
            ]),
            (openBlock(), createBlock(_component_BraintreeDropIn, {
              key: `braintreeNewMethods-${$data.paymentKey}`
            })),
            _ctx.isPaymentMethodAvailable("checkmo") ? (openBlock(), createElementBlock("div", _hoisted_8, [
              createVNode(_component_FreeMOCheckPayment, {
                "v-if": _ctx.showMagentoPayments || _ctx.isBraintreeEnabled !== "0",
                "payment-type": "checkmo",
                title: _ctx.getPaymentMethodTitle("checkmo")
              }, null, 8, ["v-if", "title"])
            ])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.additionalPaymentMethods, (additionalPaymentMethod) => {
              return openBlock(), createBlock(resolveDynamicComponent(additionalPaymentMethod), { key: additionalPaymentMethod });
            }), 128))
          ], 64)) : (openBlock(), createBlock(_component_FreeMOCheckPayment, {
            key: 1,
            "payment-type": "free",
            title: _ctx.getPaymentMethodTitle("free") ? _ctx.getPaymentMethodTitle("free") : _ctx.$t("paymentStep.freePaymentLabel")
          }, null, 8, ["title"]))
        ])
      ])
    ]);
  }
  var PaymentPage = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
  const routes = [
    {
      path: "/",
      alias: [
        "/checkout"
      ],
      name: "SignInPage",
      component: SignInPage,
      meta: {
        depth: 0
      }
    },
    {
      path: "/details",
      name: "DetailsPage",
      component: DetailsPage,
      meta: {
        depth: 1
      }
    },
    {
      path: "/shipping",
      name: "ShippingPage",
      component: ShippingPage,
      meta: {
        depth: 2
      }
    },
    {
      path: "/payments",
      name: "PaymentPage",
      component: PaymentPage,
      meta: {
        depth: 3
      }
    },
    {
      path: "/*",
      redirect: "/",
      meta: {
        depth: 0
      }
    }
  ];
  const router = createRouter({
    history: createWebHashHistory(),
    routes,
    scrollBehavior() {
      return {
        el: "#vue-checkout-root",
        behavior: "smooth"
      };
    }
  });
  var enTranslations = {
    header: {
      text: "Secure Checkout"
    },
    dividerText: "Or checkout below with credit/debit card",
    signInDividerText: "or",
    payNoExpressWithBlockTitle: "Enter your email address to pay by credit or debit card",
    payWithBlockTitle: "Pay With",
    orderSummary: {
      applyBtn: "Apply",
      removeBtn: "Remove",
      modalHeader: "Order Summary",
      mobileDiscountText: "Add gift card or promo code",
      backBtn: "Back",
      grandTotalTitle: "Total to Pay",
      inclTaxTitle: "Tax",
      exclTaxTitle: "Tax",
      discountTitle: "Discount",
      subtotalTitle: "Subtotal",
      removeItemButton: "remove item",
      removeItemButtonLabel: "remove item",
      minusOneItem: "minus one item",
      plusOneItem: "plus one item",
      couponDiscountTitle: "Add promo code",
      couponDiscount: {
        title: "Coupon",
        errorMessage: "Please enter a valid code.",
        placeholder: "Enter promo code",
        successMessage: 'Successfully applied code "{code}".'
      },
      giftDiscountTitle: "Add gift card code",
      giftCardDiscount: {
        title: "Gift card {code}",
        errorMessage: "Please enter a valid code.",
        placeholder: "Enter Gift Card Code",
        successMessage: 'Successfully applied code "{code}".'
      },
      crossSellsTitle: "You may also like these items...",
      freeShippingAvailable: "Good news: your order will be delivered for Free.",
      couponCodeTitle: "For another",
      couponCodeTitleBottom: "you can get a",
      couponCodeTitleFreeShipping: "free standard delivery",
      couponCode: {
        placeholder: "Enter promotional code"
      },
      addToCart: "Add to Basket",
      promoTitle: "Complete your order with",
      rewardsTitle: "Reward Points",
      storeCreditTitle: "Store Credit",
      giftWrappingTitle: "Gift Wrapping"
    },
    progressBar: {
      detailStepTitle: "Details",
      shippingStepTitle: "Shipping",
      paymentStepTitle: "Payment"
    },
    yourDetailsSection: {
      title: "Your details",
      selectPlaceholder: "Please select your country",
      showPassLabel: "Show or hide password",
      phoneField: {
        infoMessage: "We will use this for delivery questions",
        placeholder: "Enter your phone number",
        label: "Phone number"
      },
      emailAddress: {
        placeholder: "Enter your email address",
        label: "Email address",
        span: "Email"
      },
      passwordField: {
        placeholder: "Enter your password",
        label: "Your Password"
      },
      firstName: {
        placeholder: "First name",
        label: "First name"
      },
      lastName: {
        placeholder: "Last name",
        label: "Last name"
      },
      deliverySection: {
        toShippingButton: "Choose your shipping method",
        title: "Where should we deliver it to?",
        savedAddressesTitle: "Select a saved {addressType} address",
        shipHere: "Ship here",
        deliveryAddressTitle: "Delivery Address",
        billingAddressTitle: "Select a billing address",
        selectedBillingAddressTitle: "Billing address",
        newAddressTitle: "Add new address",
        shippingButton: "Home Delivery",
        clickandCollectButton: "Click & Collect",
        clickandCollectOpeningTimes: "Opening Times",
        clickandCollectThresholdHigh: "Unfortunately, your basket value is too high for Click and Collect. If you want to collect from a store near you, your basket must be less than {price}.",
        clickandCollectThresholdLow: "Unfortunately, your basket value is too low for Click and Collect. If you want to collect from a store near you, your basket must be more than {price}.",
        addressFinder: {
          title: "Address Finder",
          placeholder: "Search by street name or postcode",
          label: "Street name/postcode"
        },
        addressForm: {
          saveAddressButton: "Use this address",
          linkText: "Enter your address manually",
          useMyLocation: "Use My Location",
          collectLocations: "Where would you like to collect it?",
          closestLocations: "Nearest Collection Locations",
          noLocations: "No locations found for current search.",
          collectionName: "Who is collecting the order?",
          collectionBillingTitle: "Billing Details",
          submitCollectionDetails: "Submit collection details",
          collectionDistance: "{distance} miles",
          viewMapAndHours: "View map and opening hours",
          selectLocation: "SELECT LOCATION",
          addressField: {
            placeholder: "Address (line 1)",
            unrequired: "Address (line 2)",
            label: "Address (line 1)",
            unrequiredLabel: "Address (line 2)"
          },
          cityField: {
            label: "City",
            placeholder: "City"
          },
          countryField: {
            label: "Country",
            placeholder: "Country"
          },
          postCodeField: {
            label: "Postcode",
            placeholder: "Postcode"
          },
          regionField: {
            label: "County",
            placeholder: "County"
          }
        }
      },
      editButton: "Edit",
      editDetailsButtonLabel: "Edit Your Details",
      editShippingButtonLabel: "Edit Your Shipping Details"
    },
    errorMessages: {
      addressWrongError: "Please check your address format.",
      sanitiseError: "Invalid character entered",
      firstNameErrorMessage: "Please enter a valid first name",
      lastNameErrorMessage: "Please enter a valid last name",
      emailErrorMessage: "Please enter a valid email address",
      phoneErrorMessage: "Not a valid Phone Number",
      passwordHelpText: "Minimum 8 characters and must include at least three character classes (lowercase letter, uppercase letter, number or special characters).",
      passwordErrorMessage: "Please enter a valid password",
      addressFormErrorMessage: "Please make sure that all required fields are filled",
      postCodeErrorMessage: "Please enter a valid postcode for",
      countryErrorMessage: "Please choose your country",
      streetErrorMessage: "Please enter a valid address",
      streetCharacterLimit: "Please use a maximum of 75 characters for your street address",
      cityErrorMessage: "Please enter a valid city",
      regionErrorMessage: "Please enter a valid county",
      googlePayShippingError: "The shipping method is missing. Please select the shipping method and try again.",
      googlePayNominatedDayError: "Unfortunately we cannot offer Express Payment on orders with Nominated Day Delivery.",
      noShippingMethods: "No shipping methods found for the selected address.",
      googlePayNoShippingMethods: "No shipping methods found for the selected address.",
      unexpectedPaymentError: "An unexpected error occurred",
      applePayNoShippingMethods: "No shipping methods found for the selected address.",
      postcodeLookup: "Unable to get your location."
    },
    welcomeMessages: {
      accountBody: "Sign in to your account to checkout or continue as a guest.",
      accountTitle: "Welcome back!",
      getStarted: "Enter your email to get started.",
      guestBody: "Looks like you're new here! Continue to checkout as a guest with the option to create an account once you've placed your order.",
      guestTitle: "Hello"
    },
    signInButton: "Sign In",
    noAccountGuestButton: "Continue as a Guest",
    accountGuestButton: "Continue as a Guest",
    continueButton: "Continue",
    forgotPass: "Forgot your Password",
    updateButton: "Update",
    billingForm: {
      notSameAddress: "My billing and shipping address are the same"
    },
    shippingStep: {
      proceedToPay: "Proceed to payment",
      stepTitle: "Select a shipping method",
      stepCompleteTitle: "Shipping",
      nominatedDelivery: "Choose a day that suits you.",
      nominatedDeliveryCalendar: "Please select a date",
      tbc: "Calculated at next step"
    },
    addNewAddressBtn: "+ Add new address",
    saveNewAddress: "Save in address book",
    paymentStep: {
      titleGuest: "Select a payment method",
      titleStored: "Your saved payment methods",
      titleNew: "Select new payment method",
      freePaymentLabel: "No Payment Information Required",
      checkMOLabel: "Check / Money Order",
      payNow: "Pay Now",
      storedPayments: "Your Saved Payments",
      creditDebitCard: "Credit or debit card"
    },
    productOptionsTrigger: "Product options",
    instantCheckout: "Instant Checkout",
    adyen: {
      applePayTotal: "Grand Total",
      applePayNoShippingMethods: "There are no shipping methods available for you right now. Please try again or use an alternative payment method.",
      paymentSuccessful: "Payment Successful"
    },
    paymentCard: {
      cardNumber: "Card Number",
      expiry: "Expiry",
      select: "Select",
      storedPaymentLabel: "{name} Stored card ends in {lastFour}"
    },
    braintree: {
      payingWith: "Paying with {paymentTitle}",
      ach: {
        accountNumber: "Account Number",
        accountType: "Account Type",
        businessName: "Business Name",
        firstname: "First Name",
        lastname: "Last Name",
        ownershipType: "Ownership Type",
        payment: "ACH Payment",
        proof: "Proof of Authorization",
        routingNumber: "Routing Number",
        terms: 'By clicking "Pay with ACH", I authorize Braintree, a service of PayPal on behalf of {websiteName} (i) to verify my bank account information using bank information and consumer reports and (ii) to debit my bank account.'
      },
      lpm: {
        noMethods: "There are currently no available payment methods. Please update your Billing Address."
      },
      storePayment: "Save for later use."
    },
    agreements: {
      acceptBtn: "Accept",
      title: "Terms & Conditions",
      label: "I confirm that I have read and accept the",
      errorMessage: "This is a required field.",
      paymentErrorMessage: "Agreements have not been accepted. Please check the agreements and try again."
    },
    privacyPolicy: {
      content: "Your data will be handled as set out in our ",
      link: "Privacy Policy"
    },
    termsServices: {
      content: 'By clicking on the "order now" button, you hereby agree to our ',
      generalLink: "General Terms & Conditions, ",
      privacyLink: " our Privacy Policy",
      withdrawLink: "and our Withdrawal Policy."
    },
    newsletter: {
      label: "Subscribe to the newsletter"
    },
    rewards: {
      applied: "Reward points have been applied.",
      applyButton: "Apply Points",
      available: " available ",
      removeButton: "Remove Points",
      rewardPoints: "{points} Reward Points",
      youHave: "You have "
    },
    storeCredit: {
      applyStoreCredit: "You have {value} in store credit available.",
      applyButton: "Use store credit",
      removeStoreCredit: "Store credit has been used.",
      removeButton: "Remove store credit"
    },
    payWith: {
      masterCard: "pay with master card",
      visa: "pay with visa",
      americanExpress: "pay with american express",
      clearPay: "pay with clear pay",
      klarna: "pay with klarna"
    },
    giftMessage: {
      to: "To",
      from: "From",
      message: "Message"
    },
    days: {
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday",
      sunday: "Sunday"
    }
  };
  var usTranslations = {
    header: {
      text: "Secure Checkout"
    },
    dividerText: "Or checkout below with credit/debit card",
    signInDividerText: "or",
    payNoExpressWithBlockTitle: "Enter your email address to pay by credit or debit card",
    payWithBlockTitle: "Pay With",
    orderSummary: {
      applyBtn: "Apply",
      removeBtn: "Remove",
      modalHeader: "Order Summary",
      mobileDiscountText: "Add gift card or promo code",
      backBtn: "Back",
      grandTotalTitle: "Total to Pay",
      inclTaxTitle: "Tax",
      exclTaxTitle: "Tax",
      discountTitle: "Discount",
      subtotalTitle: "Subtotal",
      removeItemButton: "remove item",
      removeItemButtonLabel: "remove item",
      minusOneItem: "minus one item",
      plusOneItem: "plus one item",
      couponDiscountTitle: "Add promo code",
      couponDiscount: {
        title: "Coupon",
        errorMessage: "Please enter a valid code.",
        placeholder: "Enter promo code",
        successMessage: 'Successfully applied code "{code}".'
      },
      giftDiscountTitle: "Add gift card code",
      giftCardDiscount: {
        title: "Gift card {code}",
        errorMessage: "Please enter a valid code.",
        placeholder: "Enter gift card code",
        successMessage: 'Successfully applied code "{code}".'
      },
      crossSellsTitle: "You may also like these items...",
      freeShippingAvailable: "Good news: your order will be delivered for Free.",
      couponCodeTitle: "For another",
      couponCodeTitleBottom: "you can get a",
      couponCodeTitleFreeShipping: "free standard delivery",
      couponCode: {
        placeholder: "Enter promotional code"
      },
      addToCart: "Add to Basket",
      promoTitle: "Complete your order with",
      rewardsTitle: "Reward Points",
      storeCreditTitle: "Store Credit",
      giftWrappingTitle: "Gift Wrapping"
    },
    progressBar: {
      detailStepTitle: "Details",
      shippingStepTitle: "Shipping",
      paymentStepTitle: "Payment"
    },
    yourDetailsSection: {
      title: "Your details",
      selectPlaceholder: "Please select your country",
      showPassLabel: "Show or hide password",
      phoneField: {
        infoMessage: "We will use this for delivery questions",
        placeholder: "Enter your phone number",
        label: "Phone number"
      },
      emailAddress: {
        placeholder: "Enter your email address",
        label: "Email address",
        span: "Email"
      },
      passwordField: {
        placeholder: "Enter your password",
        label: "Your Password"
      },
      firstName: {
        placeholder: "First name",
        label: "First name"
      },
      lastName: {
        placeholder: "Last name",
        label: "Last name"
      },
      deliverySection: {
        toShippingButton: "Choose your shipping method",
        title: "Where should we deliver it to?",
        savedAddressesTitle: "Select a saved {addressType} address",
        shipHere: "Ship here",
        deliveryAddressTitle: "Delivery Address",
        billingAddressTitle: "Select a billing address",
        selectedBillingAddressTitle: "Billing address",
        newAddressTitle: "Add new address",
        shippingButton: "Home Delivery",
        clickandCollectButton: "Click & Collect",
        clickandCollectOpeningTimes: "Opening Times",
        clickandCollectThresholdHigh: "Unfortunately, your basket value is too high for Click and Collect. If you want to collect from a store near you, your basket must be less than {price}.",
        clickandCollectThresholdLow: "Unfortunately, your basket value is too low for Click and Collect. If you want to collect from a store near you, your basket must be more than {price}.",
        addressFinder: {
          title: "Address Finder",
          placeholder: "Search by street name or postcode",
          label: "Street name/postcode"
        },
        addressForm: {
          saveAddressButton: "Use this address",
          linkText: "Enter your address manually",
          addressField: {
            placeholder: "Address (line 1)",
            unrequired: "Address (line 2)",
            label: "Address (line 1)",
            unrequiredLabel: "Address (line 2)"
          },
          cityField: {
            label: "City",
            placeholder: "City"
          },
          countryField: {
            label: "Country",
            placeholder: "Country"
          },
          postCodeField: {
            label: "Postcode",
            placeholder: "Postcode"
          },
          regionField: {
            label: "State",
            placeholder: "State"
          }
        }
      },
      editButton: "Edit",
      editDetailsButtonLabel: "Edit Your Details",
      editShippingButtonLabel: "Edit Your Shipping Details"
    },
    errorMessages: {
      addressWrongError: "Please check your address format.",
      sanitiseError: "Invalid character entered",
      firstNameErrorMessage: "Please enter a valid first name",
      lastNameErrorMessage: "Please enter a valid last name",
      emailErrorMessage: "Please enter a valid email address",
      phoneErrorMessage: "Not a valid Phone Number",
      passwordHelpText: "Minimum 8 characters and must include at least three character classes (lowercase letter, uppercase letter, number or special characters).",
      passwordErrorMessage: "Please enter a valid password",
      addressFormErrorMessage: "Please make sure that all required fields are filled",
      postCodeErrorMessage: "Please enter a valid postcode for",
      countryErrorMessage: "Please choose your country",
      streetErrorMessage: "Please enter a valid address",
      streetCharacterLimit: "Please use a maximum of 75 characters for your street address",
      cityErrorMessage: "Please enter a valid city",
      googlePayShippingError: "The shipping method is missing. Please select the shipping method and try again.",
      googlePayNominatedDayError: "Unfortunately we cannot offer Express Payment on orders with Nominated Day Delivery.",
      noShippingMethods: "No shipping methods found for the selected address.",
      googlePayNoShippingMethods: "No shipping methods found for the selected address.",
      unexpectedPaymentError: "An unexpected error occurred",
      applePayNoShippingMethods: "No shipping methods found for the selected address."
    },
    welcomeMessages: {
      accountBody: "Sign in to your account to checkout or continue as a guest.",
      accountTitle: "Welcome back!",
      getStarted: "Enter your email to get started.",
      guestBody: "Looks like you're new here! Continue to checkout as a guest with the option to create an account once you've placed your order.",
      guestTitle: "Hello"
    },
    signInButton: "Sign In",
    noAccountGuestButton: "Continue as a Guest",
    accountGuestButton: "Or Continue as a Guest",
    continueButton: "Continue",
    forgotPass: "Forgot your Password",
    updateButton: "Update",
    billingForm: {
      notSameAddress: "My billing and shipping address are the same"
    },
    shippingStep: {
      proceedToPay: "Proceed to payment",
      stepTitle: "Select a shipping method",
      stepCompleteTitle: "Shipping",
      nominatedDelivery: "Choose a day that suits you.",
      nominatedDeliveryCalendar: "Please select a date",
      tbc: "Calculated at next step"
    },
    addNewAddressBtn: "+ Add new address",
    saveNewAddress: "Save in address book",
    paymentStep: {
      titleGuest: "Select a payment method",
      titleStored: "Your saved payment methods",
      titleNew: "Select new payment method",
      payNow: "Pay Now",
      storedPayments: "Your Saved Payments",
      creditDebitCard: "Credit or debit card"
    },
    productOptionsTrigger: "Product options",
    instantCheckout: "Instant Checkout",
    adyen: {
      applePayTotal: "Grand Total",
      applePayNoShippingMethods: "There are no shipping methods available for you right now. Please try again or use an alternative payment method.",
      paymentSuccessful: "Payment Successful"
    },
    paymentCard: {
      cardNumber: "Card Number",
      expiry: "Expiry",
      select: "Select",
      storedPaymentLabel: "{name} Stored card ends in {lastFour}"
    },
    braintree: {
      payingWith: "Paying with {paymentTitle}",
      ach: {
        accountNumber: "Account Number",
        accountType: "Account Type",
        businessName: "Business Name",
        firstname: "First Name",
        lastname: "Last Name",
        ownershipType: "Ownership Type",
        payment: "ACH Payment",
        proof: "Proof of Authorization",
        routingNumber: "Routing Number",
        terms: 'By clicking "Pay with ACH", I authorize Braintree, a service of PayPal on behalf of {websiteName} (i) to verify my bank account information using bank information and consumer reports and (ii) to debit my bank account.'
      },
      lpm: {
        noMethods: "There are currently no available payment methods. Please update your Billing Address."
      },
      storePayment: "Save for later use."
    },
    agreements: {
      acceptBtn: "Accept",
      title: "Terms & Conditions",
      label: "I confirm that I have read and accept the",
      errorMessage: "This is a required field.",
      paymentErrorMessage: "Agreements have not been accepted. Please check the agreements and try again."
    },
    privacyPolicy: {
      content: "Your data will be handled as set out in our ",
      link: "Privacy Policy"
    },
    termsServices: {
      content: 'By clicking on the "order now" button, you hereby agree to our ',
      generalLink: "General Terms & Conditions, ",
      privacyLink: " our Privacy Policy",
      withdrawLink: "and our Withdrawal Policy."
    },
    newsletter: {
      label: "Subscribe to the newsletter"
    },
    rewards: {
      applied: "Reward points have been applied.",
      applyButton: "Apply Points",
      available: " available ",
      removeButton: "Remove Points",
      rewardPoints: "{points} Reward Points",
      youHave: "You have "
    },
    storeCredit: {
      applyStoreCredit: "You have {value} in store credit available.",
      applyButton: "Use store credit",
      removeStoreCredit: "Store credit has been used.",
      removeButton: "Remove store credit"
    },
    payWith: {
      masterCard: "pay with master card",
      visa: "pay with visa",
      americanExpress: "pay with american express",
      clearPay: "pay with clear pay",
      klarna: "pay with klarna"
    },
    giftMessage: {
      to: "To",
      from: "From",
      message: "Message"
    }
  };
  var blankTranslations = {
    header: {
      text: " "
    },
    payWithBlockTitle: " ",
    orderSummary: {
      applyBtn: " ",
      removeBtn: " ",
      modalHeader: " ",
      mobileDiscountText: " ",
      backBtn: " ",
      grandTotalTitle: " ",
      inclTaxTitle: " ",
      exclTaxTitle: " ",
      discountTitle: " ",
      subtotalTitle: " ",
      removeItemButton: " ",
      couponDiscountTitle: " ",
      couponDiscount: {
        title: " ",
        errorMessage: "",
        placeholder: " ",
        successMessage: " "
      },
      giftDiscountTitle: " ",
      giftCardDiscount: {
        title: " ",
        errorMessage: " ",
        placeholder: " ",
        successMessage: " "
      },
      crossSellsTitle: " ",
      freeShippingAvailable: " ",
      couponCodeTitle: " ",
      couponCodeTitleBottom: " ",
      couponCodeTitleFreeShipping: " ",
      addToCart: " ",
      promoTitle: " ",
      rewardsTitle: " ",
      storeCreditTitle: " ",
      giftWrappingTitle: " "
    },
    progressBar: {
      detailStepTitle: " ",
      shippingStepTitle: " ",
      paymentStepTitle: " "
    },
    yourDetailsSection: {
      title: " ",
      selectPlaceholder: " ",
      phoneField: {
        infoMessage: " ",
        placeholder: " ",
        label: " "
      },
      emailAddress: {
        placeholder: " ",
        label: " "
      },
      passwordField: {
        placeholder: " ",
        label: " "
      },
      firstName: {
        placeholder: " ",
        label: " "
      },
      lastName: {
        placeholder: " ",
        label: " "
      },
      deliverySection: {
        toShippingButton: " ",
        title: " ",
        savedAddressesTitle: " ",
        shipHere: " ",
        deliveryAddressTitle: " ",
        billingAddressTitle: " ",
        selectedBillingAddressTitle: " ",
        newAddressTitle: " ",
        addressFinder: {
          title: " ",
          placeholder: " ",
          label: " "
        },
        addressForm: {
          saveAddressButton: " ",
          linkText: " ",
          addressField: {
            placeholder: " ",
            unrequired: " ",
            label: " ",
            unrequiredLabel: " "
          },
          cityField: {
            placeholder: " "
          },
          countryField: {
            placeholder: " "
          },
          postCodeField: {
            placeholder: " "
          },
          regionField: {
            placeholder: " "
          }
        }
      },
      editButton: " "
    },
    errorMessages: {
      addressWrongError: " ",
      sanitiseError: " ",
      firstNameErrorMessage: " ",
      lastNameErrorMessage: " ",
      emailErrorMessage: " ",
      phoneErrorMessage: " ",
      passwordHelpText: " ",
      passwordErrorMessage: " ",
      addressFormErrorMessage: " ",
      postCodeErrorMessage: " ",
      countryErrorMessage: " ",
      streetErrorMessage: " ",
      cityErrorMessage: " ",
      regionErrorMessage: " ",
      googlePayNoShippingMethods: " ",
      unexpectedPaymentError: " ",
      applePayNoShippingMethods: " ",
      noShippingMethods: " ",
      postcodeLookup: " "
    },
    welcomeMessages: {
      accountBody: "",
      accountTitle: "",
      getStarted: "",
      guestBody: "",
      guestTitle: ""
    },
    signInButton: " ",
    guestButton: " ",
    continueButton: " ",
    forgotPass: " ",
    updateButton: " ",
    billingForm: {
      notSameAddress: " "
    },
    shippingStep: {
      proceedToPay: " ",
      stepTitle: " ",
      stepCompleteTitle: " ",
      nominatedDelivery: " ",
      nominatedDeliveryCalendar: " ",
      tbc: " "
    },
    addNewAddressBtn: " ",
    saveNewAddress: " ",
    paymentStep: {
      titleGuest: " ",
      titleStored: " ",
      freePayment: " ",
      payNow: " "
    },
    productOptionsTrigger: " ",
    instantCheckout: " ",
    adyen: {
      applePayTotal: " ",
      applePayNoShippingMethods: " ",
      paymentSuccessful: " "
    },
    paymentCard: {
      cardNumber: " ",
      expiry: " ",
      select: " ",
      storedPaymentLabel: " "
    },
    braintree: {
      payingWith: " ",
      ach: {
        accountNumber: " ",
        accountType: " ",
        businessName: " ",
        firstname: " ",
        lastname: " ",
        ownershipType: " ",
        payment: " ",
        proof: " ",
        routingNumber: " ",
        terms: " "
      },
      lpm: {
        noMethods: " "
      },
      storePayment: " "
    },
    agreements: {
      acceptBtn: " ",
      title: " ",
      label: " ",
      errorMessage: " ",
      paymentErrorMessage: " "
    },
    privacyPolicy: {
      content: " ",
      link: " "
    },
    newsletter: {
      label: " "
    },
    rewards: {
      applied: " ",
      applyButton: " ",
      available: " ",
      removeButton: " ",
      rewardPoints: " ",
      youHave: " "
    },
    storeCredit: {
      applyStoreCredit: " ",
      applyButton: " ",
      removeStoreCredit: " ",
      removeButton: " "
    },
    giftMessage: {
      to: " ",
      from: " ",
      message: " "
    },
    days: {
      monday: " ",
      tuesday: " ",
      wednesday: " ",
      thursday: " ",
      friday: " ",
      saturday: " ",
      sunday: " "
    }
  };
  var messages = {
    "en-GB": {
      ...enTranslations
    },
    "en-US": {
      ...usTranslations
    },
    blank: {
      ...blankTranslations
    }
  };
  const i18n = createI18n({
    locale: "blank",
    fallbackLocale: "en",
    messages
  });
  const pinia = createPinia();
  pinia.use(({ store }) => {
    store.$router = markRaw(router);
    store.$i18n = markRaw(i18n);
  });
  const app = createApp(App);
  app.use(i18n);
  app.use(pinia);
  app.use(router);
  app.mount("#bluefinch-checkout-container");
})();
